<Type Name="VBufferUtils" FullName="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils">
  <TypeSignature Language="C#" Value="public static class VBufferUtils" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit VBufferUtils extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils" />
  <TypeSignature Language="VB.NET" Value="Public Class VBufferUtils" />
  <TypeSignature Language="F#" Value="type VBufferUtils = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.ML.Core</AssemblyName>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
            Convenience utilities for vector operations on <see cref="T:Microsoft.ML.Runtime.Data.VBuffer`1" />.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Apply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Apply&lt;T&gt; (ref Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt; dst, Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.SlotValueManipulator&lt;T&gt; manip);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Apply&lt;T&gt;(valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!T&gt;&amp; dst, class Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils/SlotValueManipulator`1&lt;!!T&gt; manip) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.Apply``1(Microsoft.ML.Runtime.Data.VBuffer{``0}@,Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.SlotValueManipulator{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Apply(Of T) (ByRef dst As VBuffer(Of T), manip As VBufferUtils.SlotValueManipulator(Of T))" />
      <MemberSignature Language="F#" Value="static member Apply :  * Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.SlotValueManipulator&lt;'T&gt; -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.Apply (dst, manip)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.Core</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="dst" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt;&amp;" RefType="ref" />
        <Parameter Name="manip" Type="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils+SlotValueManipulator&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="dst">To be added.</param>
        <param name="manip">To be added.</param>
        <summary>
            Applies the <paramref name="manip" /> to every explicitly defined
            element of the vector.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ApplyAt&lt;T&gt; (ref Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt; dst, int slot, Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.SlotValueManipulator&lt;T&gt; manip, Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ValuePredicate&lt;T&gt; pred = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ApplyAt&lt;T&gt;(valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!T&gt;&amp; dst, int32 slot, class Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils/SlotValueManipulator`1&lt;!!T&gt; manip, class Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils/ValuePredicate`1&lt;!!T&gt; pred) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ApplyAt``1(Microsoft.ML.Runtime.Data.VBuffer{``0}@,System.Int32,Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.SlotValueManipulator{``0},Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ValuePredicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ApplyAt(Of T) (ByRef dst As VBuffer(Of T), slot As Integer, manip As VBufferUtils.SlotValueManipulator(Of T), Optional pred As VBufferUtils.ValuePredicate(Of T) = null)" />
      <MemberSignature Language="F#" Value="static member ApplyAt :  * int * Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.SlotValueManipulator&lt;'T&gt; * Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ValuePredicate&lt;'T&gt; -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ApplyAt (dst, slot, manip, pred)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.Core</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="dst" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt;&amp;" RefType="ref" />
        <Parameter Name="slot" Type="System.Int32" />
        <Parameter Name="manip" Type="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils+SlotValueManipulator&lt;T&gt;" />
        <Parameter Name="pred" Type="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils+ValuePredicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="dst">The vector to modify</param>
        <param name="slot">The slot of the vector to modify</param>
        <param name="manip">The manipulation function</param>
        <param name="pred">A predicate that returns true if we should skip insertion of a value into 
            sparse vector if it was default. If the predicate is null, we insert any non-default.</param>
        <summary>
            Applies some function on a value at a particular slot value, changing that slot value.
            This function will, wherever possible, not change the structure of <paramref name="dst" />.
            If the vector is sparse, and the corresponding slot is not explicitly represented,
            then this can involve memory copying and possibly memory reallocation on <paramref name="dst" />.
            However, if the item is explicitly represented, even if the item is set to the default
            value of <typeparamref name="T" /> it will not change the structure of <paramref name="dst" />,
            in terms of sparsifying a dense array, or dropping indices.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyInto&lt;TSrc1,TSrc2,TDst&gt;">
      <MemberSignature Language="C#" Value="public static void ApplyInto&lt;TSrc1,TSrc2,TDst&gt; (ref Microsoft.ML.Runtime.Data.VBuffer&lt;TSrc1&gt; a, ref Microsoft.ML.Runtime.Data.VBuffer&lt;TSrc2&gt; b, ref Microsoft.ML.Runtime.Data.VBuffer&lt;TDst&gt; dst, Func&lt;int,TSrc1,TSrc2,TDst&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ApplyInto&lt;TSrc1, TSrc2, TDst&gt;(valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!TSrc1&gt;&amp; a, valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!TSrc2&gt;&amp; b, valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!TDst&gt;&amp; dst, class System.Func`4&lt;int32, !!TSrc1, !!TSrc2, !!TDst&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ApplyInto``3(Microsoft.ML.Runtime.Data.VBuffer{``0}@,Microsoft.ML.Runtime.Data.VBuffer{``1}@,Microsoft.ML.Runtime.Data.VBuffer{``2}@,System.Func{System.Int32,``0,``1,``2})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ApplyInto(Of TSrc1, TSrc2, TDst) (ByRef a As VBuffer(Of TSrc1), ByRef b As VBuffer(Of TSrc2), ByRef dst As VBuffer(Of TDst), func As Func(Of Integer, TSrc1, TSrc2, TDst))" />
      <MemberSignature Language="F#" Value="static member ApplyInto :  *  *  * Func&lt;int, 'TSrc1, 'TSrc2, 'Dst&gt; -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ApplyInto (a, b, dst, func)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.Core</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSrc1" />
        <TypeParameter Name="TSrc2" />
        <TypeParameter Name="TDst" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="a" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;TSrc1&gt;&amp;" RefType="ref" />
        <Parameter Name="b" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;TSrc2&gt;&amp;" RefType="ref" />
        <Parameter Name="dst" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;TDst&gt;&amp;" RefType="ref" />
        <Parameter Name="func" Type="System.Func&lt;System.Int32,TSrc1,TSrc2,TDst&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSrc1">To be added.</typeparam>
        <typeparam name="TSrc2">To be added.</typeparam>
        <typeparam name="TDst">To be added.</typeparam>
        <param name="a">To be added.</param>
        <param name="b">To be added.</param>
        <param name="dst">To be added.</param>
        <param name="func">To be added.</param>
        <summary>
            Applies a function <paramref name="func" /> to two vectors, storing the result in
            <paramref name="dst" />, whose existing contents are discarded and overwritten. The
            function is called for every index value that appears in either <paramref name="a" />
            or <paramref name="b" />. If either of the two inputs is dense, the output will
            necessarily be dense. Otherwise, if both are sparse, the output will be sparse iff
            there is any slot that is not explicitly represented in either vector.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyIntoEitherDefined&lt;TSrc,TDst&gt;">
      <MemberSignature Language="C#" Value="public static void ApplyIntoEitherDefined&lt;TSrc,TDst&gt; (ref Microsoft.ML.Runtime.Data.VBuffer&lt;TSrc&gt; src, ref Microsoft.ML.Runtime.Data.VBuffer&lt;TDst&gt; dst, Func&lt;int,TSrc,TDst&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ApplyIntoEitherDefined&lt;TSrc, TDst&gt;(valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!TSrc&gt;&amp; src, valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!TDst&gt;&amp; dst, class System.Func`3&lt;int32, !!TSrc, !!TDst&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ApplyIntoEitherDefined``2(Microsoft.ML.Runtime.Data.VBuffer{``0}@,Microsoft.ML.Runtime.Data.VBuffer{``1}@,System.Func{System.Int32,``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ApplyIntoEitherDefined(Of TSrc, TDst) (ByRef src As VBuffer(Of TSrc), ByRef dst As VBuffer(Of TDst), func As Func(Of Integer, TSrc, TDst))" />
      <MemberSignature Language="F#" Value="static member ApplyIntoEitherDefined :  *  * Func&lt;int, 'Src, 'Dst&gt; -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ApplyIntoEitherDefined (src, dst, func)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.Core</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSrc" />
        <TypeParameter Name="TDst" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="src" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;TSrc&gt;&amp;" RefType="ref" />
        <Parameter Name="dst" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;TDst&gt;&amp;" RefType="ref" />
        <Parameter Name="func" Type="System.Func&lt;System.Int32,TSrc,TDst&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSrc">To be added.</typeparam>
        <typeparam name="TDst">To be added.</typeparam>
        <param name="src">To be added.</param>
        <param name="dst">To be added.</param>
        <param name="func">To be added.</param>
        <summary>
            Applies a function to explicitly defined elements in a vector <paramref name="src" />,
            storing the result in <paramref name="dst" />, overwriting any of its existing contents.
            The contents of <paramref name="dst" /> do not affect calculation. If you instead wish
            to calculate a function that reads and writes <paramref name="dst" />, see
            <see cref="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ApplyWith``2(Microsoft.ML.Runtime.Data.VBuffer{``0}@,Microsoft.ML.Runtime.Data.VBuffer{``1}@,Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.PairManipulator{``0,``1})" /> and <see cref="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ApplyWithEitherDefined``2(Microsoft.ML.Runtime.Data.VBuffer{``0}@,Microsoft.ML.Runtime.Data.VBuffer{``1}@,Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.PairManipulator{``0,``1})" />. Post-operation,
            <paramref name="dst" /> will be dense iff <paramref name="src" /> is dense.
            </summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ApplyWith``2(Microsoft.ML.Runtime.Data.VBuffer{``0}@,Microsoft.ML.Runtime.Data.VBuffer{``1}@,Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.PairManipulator{``0,``1})" />
        <altmember cref="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ApplyWithEitherDefined``2(Microsoft.ML.Runtime.Data.VBuffer{``0}@,Microsoft.ML.Runtime.Data.VBuffer{``1}@,Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.PairManipulator{``0,``1})" />
      </Docs>
    </Member>
    <Member MemberName="ApplyWith&lt;TSrc,TDst&gt;">
      <MemberSignature Language="C#" Value="public static void ApplyWith&lt;TSrc,TDst&gt; (ref Microsoft.ML.Runtime.Data.VBuffer&lt;TSrc&gt; src, ref Microsoft.ML.Runtime.Data.VBuffer&lt;TDst&gt; dst, Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.PairManipulator&lt;TSrc,TDst&gt; manip);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ApplyWith&lt;TSrc, TDst&gt;(valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!TSrc&gt;&amp; src, valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!TDst&gt;&amp; dst, class Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils/PairManipulator`2&lt;!!TSrc, !!TDst&gt; manip) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ApplyWith``2(Microsoft.ML.Runtime.Data.VBuffer{``0}@,Microsoft.ML.Runtime.Data.VBuffer{``1}@,Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.PairManipulator{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ApplyWith(Of TSrc, TDst) (ByRef src As VBuffer(Of TSrc), ByRef dst As VBuffer(Of TDst), manip As VBufferUtils.PairManipulator(Of TSrc, TDst))" />
      <MemberSignature Language="F#" Value="static member ApplyWith :  *  * Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.PairManipulator&lt;'Src, 'Dst&gt; -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ApplyWith (src, dst, manip)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.Core</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSrc" />
        <TypeParameter Name="TDst" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="src" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;TSrc&gt;&amp;" RefType="ref" />
        <Parameter Name="dst" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;TDst&gt;&amp;" RefType="ref" />
        <Parameter Name="manip" Type="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils+PairManipulator&lt;TSrc,TDst&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSrc">To be added.</typeparam>
        <typeparam name="TDst">To be added.</typeparam>
        <param name="src">Argument vector, whose elements are only read</param>
        <param name="dst">Argument vector, that could change</param>
        <param name="manip">Function to apply to each pair of elements</param>
        <summary>
            Applies the <see cref="T:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.PairManipulator`2" /> to each pair of elements
            where <paramref name="src" /> is defined, in order of index. If there is
            some value at an index in <paramref name="dst" /> that is not defined in
            <paramref name="src" />, that item remains without any further modification.
            If either of the vectors are dense, the resulting <paramref name="dst" />
            will be dense. Otherwise, if both are sparse, the output will be sparse iff
            there is any slot that is not explicitly represented in either vector.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyWithCopy&lt;TSrc,TDst&gt;">
      <MemberSignature Language="C#" Value="public static void ApplyWithCopy&lt;TSrc,TDst&gt; (ref Microsoft.ML.Runtime.Data.VBuffer&lt;TSrc&gt; src, ref Microsoft.ML.Runtime.Data.VBuffer&lt;TDst&gt; dst, ref Microsoft.ML.Runtime.Data.VBuffer&lt;TDst&gt; res, Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.PairManipulatorCopy&lt;TSrc,TDst&gt; manip);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ApplyWithCopy&lt;TSrc, TDst&gt;(valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!TSrc&gt;&amp; src, valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!TDst&gt;&amp; dst, valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!TDst&gt;&amp; res, class Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils/PairManipulatorCopy`2&lt;!!TSrc, !!TDst&gt; manip) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ApplyWithCopy``2(Microsoft.ML.Runtime.Data.VBuffer{``0}@,Microsoft.ML.Runtime.Data.VBuffer{``1}@,Microsoft.ML.Runtime.Data.VBuffer{``1}@,Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.PairManipulatorCopy{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ApplyWithCopy(Of TSrc, TDst) (ByRef src As VBuffer(Of TSrc), ByRef dst As VBuffer(Of TDst), ByRef res As VBuffer(Of TDst), manip As VBufferUtils.PairManipulatorCopy(Of TSrc, TDst))" />
      <MemberSignature Language="F#" Value="static member ApplyWithCopy :  *  *  * Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.PairManipulatorCopy&lt;'Src, 'Dst&gt; -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ApplyWithCopy (src, dst, res, manip)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.Core</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSrc" />
        <TypeParameter Name="TDst" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="src" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;TSrc&gt;&amp;" RefType="ref" />
        <Parameter Name="dst" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;TDst&gt;&amp;" RefType="ref" />
        <Parameter Name="res" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;TDst&gt;&amp;" RefType="ref" />
        <Parameter Name="manip" Type="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils+PairManipulatorCopy&lt;TSrc,TDst&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSrc">To be added.</typeparam>
        <typeparam name="TDst">To be added.</typeparam>
        <param name="src">Argument vector, whose elements are only read</param>
        <param name="dst">Argument vector, whose elements are only read</param>
        <param name="res">Result vector</param>
        <param name="manip">Function to apply to each pair of elements</param>
        <summary>
            Applies the <see cref="T:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.PairManipulator`2" /> to each pair of elements
            where <paramref name="src" /> is defined, in order of index. It stores the result 
            in another vector. If there is some value at an index in <paramref name="dst" /> 
            that is not defined in <paramref name="src" />, that slot value is copied to the 
            corresponding slot in the result vector without any further modification.
            If either of the vectors are dense, the resulting <paramref name="res" />
            will be dense. Otherwise, if both are sparse, the output will be sparse iff
            there is any slot that is not explicitly represented in either vector.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyWithEitherDefined&lt;TSrc,TDst&gt;">
      <MemberSignature Language="C#" Value="public static void ApplyWithEitherDefined&lt;TSrc,TDst&gt; (ref Microsoft.ML.Runtime.Data.VBuffer&lt;TSrc&gt; src, ref Microsoft.ML.Runtime.Data.VBuffer&lt;TDst&gt; dst, Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.PairManipulator&lt;TSrc,TDst&gt; manip);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ApplyWithEitherDefined&lt;TSrc, TDst&gt;(valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!TSrc&gt;&amp; src, valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!TDst&gt;&amp; dst, class Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils/PairManipulator`2&lt;!!TSrc, !!TDst&gt; manip) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ApplyWithEitherDefined``2(Microsoft.ML.Runtime.Data.VBuffer{``0}@,Microsoft.ML.Runtime.Data.VBuffer{``1}@,Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.PairManipulator{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ApplyWithEitherDefined(Of TSrc, TDst) (ByRef src As VBuffer(Of TSrc), ByRef dst As VBuffer(Of TDst), manip As VBufferUtils.PairManipulator(Of TSrc, TDst))" />
      <MemberSignature Language="F#" Value="static member ApplyWithEitherDefined :  *  * Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.PairManipulator&lt;'Src, 'Dst&gt; -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ApplyWithEitherDefined (src, dst, manip)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.Core</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSrc" />
        <TypeParameter Name="TDst" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="src" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;TSrc&gt;&amp;" RefType="ref" />
        <Parameter Name="dst" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;TDst&gt;&amp;" RefType="ref" />
        <Parameter Name="manip" Type="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils+PairManipulator&lt;TSrc,TDst&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSrc">To be added.</typeparam>
        <typeparam name="TDst">To be added.</typeparam>
        <param name="src">Argument vector, whose elements are only read</param>
        <param name="dst">Argument vector, that could change</param>
        <param name="manip">Function to apply to each pair of elements</param>
        <summary>
            Applies the <see cref="T:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.PairManipulator`2" /> to each pair of elements
            where either <paramref name="src" /> or <paramref name="dst" />, has an element
            defined at that index. If either of the vectors are dense, the resulting
            <paramref name="dst" /> will be dense. Otherwise, if both are sparse, the output
            will be sparse iff there is any slot that is not explicitly represented in
            either vector.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyWithEitherDefinedCopy&lt;TSrc,TDst&gt;">
      <MemberSignature Language="C#" Value="public static void ApplyWithEitherDefinedCopy&lt;TSrc,TDst&gt; (ref Microsoft.ML.Runtime.Data.VBuffer&lt;TSrc&gt; src, ref Microsoft.ML.Runtime.Data.VBuffer&lt;TDst&gt; dst, ref Microsoft.ML.Runtime.Data.VBuffer&lt;TDst&gt; res, Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.PairManipulatorCopy&lt;TSrc,TDst&gt; manip);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ApplyWithEitherDefinedCopy&lt;TSrc, TDst&gt;(valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!TSrc&gt;&amp; src, valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!TDst&gt;&amp; dst, valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!TDst&gt;&amp; res, class Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils/PairManipulatorCopy`2&lt;!!TSrc, !!TDst&gt; manip) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ApplyWithEitherDefinedCopy``2(Microsoft.ML.Runtime.Data.VBuffer{``0}@,Microsoft.ML.Runtime.Data.VBuffer{``1}@,Microsoft.ML.Runtime.Data.VBuffer{``1}@,Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.PairManipulatorCopy{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ApplyWithEitherDefinedCopy(Of TSrc, TDst) (ByRef src As VBuffer(Of TSrc), ByRef dst As VBuffer(Of TDst), ByRef res As VBuffer(Of TDst), manip As VBufferUtils.PairManipulatorCopy(Of TSrc, TDst))" />
      <MemberSignature Language="F#" Value="static member ApplyWithEitherDefinedCopy :  *  *  * Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.PairManipulatorCopy&lt;'Src, 'Dst&gt; -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ApplyWithEitherDefinedCopy (src, dst, res, manip)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.Core</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSrc" />
        <TypeParameter Name="TDst" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="src" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;TSrc&gt;&amp;" RefType="ref" />
        <Parameter Name="dst" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;TDst&gt;&amp;" RefType="ref" />
        <Parameter Name="res" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;TDst&gt;&amp;" RefType="ref" />
        <Parameter Name="manip" Type="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils+PairManipulatorCopy&lt;TSrc,TDst&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSrc">To be added.</typeparam>
        <typeparam name="TDst">To be added.</typeparam>
        <param name="src">Argument vector, whose elements are only read</param>
        <param name="dst">Argument vector, whose elements are only read</param>
        <param name="res">Result vector</param>
        <param name="manip">Function to apply to each pair of elements</param>
        <summary>
            Applies the <see cref="T:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.PairManipulator`2" /> to each pair of elements
            where either <paramref name="src" /> or <paramref name="dst" />, has an element
            defined at that index. It stores the result in another vector <paramref name="res" />. 
            If either of the vectors are dense, the resulting <paramref name="res" />
            will be dense. Otherwise, if both are sparse, the output will be sparse iff
            there is any slot that is not explicitly represented in either vector.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Clear&lt;T&gt; (ref Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt; dst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear&lt;T&gt;(valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!T&gt;&amp; dst) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.Clear``1(Microsoft.ML.Runtime.Data.VBuffer{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Clear(Of T) (ByRef dst As VBuffer(Of T))" />
      <MemberSignature Language="F#" Value="static member Clear :  -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.Clear dst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.Core</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="dst" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt;&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="dst">To be added.</param>
        <summary>
            Sets all values in the vector to the default value for the type, without changing the
            density or index structure of the input array. That is to say, the count of the input
            vector will be the same afterwards as it was before.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Copy&lt;T&gt; (System.Collections.Generic.List&lt;T&gt; src, ref Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt; dst, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy&lt;T&gt;(class System.Collections.Generic.List`1&lt;!!T&gt; src, valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!T&gt;&amp; dst, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.Copy``1(System.Collections.Generic.List{``0},Microsoft.ML.Runtime.Data.VBuffer{``0}@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy(Of T) (src As List(Of T), ByRef dst As VBuffer(Of T), length As Integer)" />
      <MemberSignature Language="F#" Value="static member Copy : System.Collections.Generic.List&lt;'T&gt; *  * int -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.Copy (src, dst, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.Core</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="src" Type="System.Collections.Generic.List&lt;T&gt;" />
        <Parameter Name="dst" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt;&amp;" RefType="ref" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="src">To be added.</param>
        <param name="dst">To be added.</param>
        <param name="length">To be added.</param>
        <summary>
            Copy from a source list to the given VBuffer destination.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDense&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt; CreateDense&lt;T&gt; (int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!T&gt; CreateDense&lt;T&gt;(int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.CreateDense``1(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDense(Of T) (length As Integer) As VBuffer(Of T)" />
      <MemberSignature Language="F#" Value="static member CreateDense : int -&gt; Microsoft.ML.Runtime.Data.VBuffer&lt;'T&gt;" Usage="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.CreateDense length" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.Core</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateEmpty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt; CreateEmpty&lt;T&gt; (int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!T&gt; CreateEmpty&lt;T&gt;(int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.CreateEmpty``1(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateEmpty(Of T) (length As Integer) As VBuffer(Of T)" />
      <MemberSignature Language="F#" Value="static member CreateEmpty : int -&gt; Microsoft.ML.Runtime.Data.VBuffer&lt;'T&gt;" Usage="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.CreateEmpty length" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.Core</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMaybeSparseCopy&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void CreateMaybeSparseCopy&lt;T&gt; (ref Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt; src, ref Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt; dst, Microsoft.ML.Runtime.Data.RefPredicate&lt;T&gt; isDefaultPredicate, float sparsityThreshold = 0.25);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateMaybeSparseCopy&lt;T&gt;(valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!T&gt;&amp; src, valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!T&gt;&amp; dst, class Microsoft.ML.Runtime.Data.RefPredicate`1&lt;!!T&gt; isDefaultPredicate, float32 sparsityThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.CreateMaybeSparseCopy``1(Microsoft.ML.Runtime.Data.VBuffer{``0}@,Microsoft.ML.Runtime.Data.VBuffer{``0}@,Microsoft.ML.Runtime.Data.RefPredicate{``0},System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateMaybeSparseCopy(Of T) (ByRef src As VBuffer(Of T), ByRef dst As VBuffer(Of T), isDefaultPredicate As RefPredicate(Of T), Optional sparsityThreshold As Single = 0.25)" />
      <MemberSignature Language="F#" Value="static member CreateMaybeSparseCopy :  *  * Microsoft.ML.Runtime.Data.RefPredicate&lt;'T&gt; * single -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.CreateMaybeSparseCopy (src, dst, isDefaultPredicate, sparsityThreshold)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.Core</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="src" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt;&amp;" RefType="ref" />
        <Parameter Name="dst" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt;&amp;" RefType="ref" />
        <Parameter Name="isDefaultPredicate" Type="Microsoft.ML.Runtime.Data.RefPredicate&lt;T&gt;" />
        <Parameter Name="sparsityThreshold" Type="System.Single" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="src">To be added.</param>
        <param name="dst">To be added.</param>
        <param name="isDefaultPredicate">To be added.</param>
        <param name="sparsityThreshold">To be added.</param>
        <summary>
            Creates a maybe sparse copy of a VBuffer. 
            Whether the created copy is sparse or not is determined by the proportion of non-default entries compared to the sparsity parameter.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Densify&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Densify&lt;T&gt; (ref Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt; dst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Densify&lt;T&gt;(valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!T&gt;&amp; dst) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.Densify``1(Microsoft.ML.Runtime.Data.VBuffer{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Densify(Of T) (ByRef dst As VBuffer(Of T))" />
      <MemberSignature Language="F#" Value="static member Densify :  -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.Densify dst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.Core</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="dst" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt;&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="dst">To be added.</param>
        <summary>
            Given a vector, turns it into an equivalent dense representation.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DensifyFirst&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void DensifyFirst&lt;T&gt; (ref Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt; dst, int denseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DensifyFirst&lt;T&gt;(valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!T&gt;&amp; dst, int32 denseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.DensifyFirst``1(Microsoft.ML.Runtime.Data.VBuffer{``0}@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DensifyFirst(Of T) (ByRef dst As VBuffer(Of T), denseCount As Integer)" />
      <MemberSignature Language="F#" Value="static member DensifyFirst :  * int -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.DensifyFirst (dst, denseCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.Core</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="dst" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt;&amp;" RefType="ref" />
        <Parameter Name="denseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="dst">To be added.</param>
        <param name="denseCount">To be added.</param>
        <summary>
            Given a vector, ensure that the first <paramref name="denseCount" /> slots are explicitly
            represented.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForEachBothDefined&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEachBothDefined&lt;T&gt; (ref Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt; a, ref Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt; b, Action&lt;int,T,T&gt; visitor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEachBothDefined&lt;T&gt;(valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!T&gt;&amp; a, valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!T&gt;&amp; b, class System.Action`3&lt;int32, !!T, !!T&gt; visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ForEachBothDefined``1(Microsoft.ML.Runtime.Data.VBuffer{``0}@,Microsoft.ML.Runtime.Data.VBuffer{``0}@,System.Action{System.Int32,``0,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEachBothDefined(Of T) (ByRef a As VBuffer(Of T), ByRef b As VBuffer(Of T), visitor As Action(Of Integer, T, T))" />
      <MemberSignature Language="F#" Value="static member ForEachBothDefined :  *  * Action&lt;int, 'T, 'T&gt; -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ForEachBothDefined (a, b, visitor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.Core</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="a" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt;&amp;" RefType="ref" />
        <Parameter Name="b" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt;&amp;" RefType="ref" />
        <Parameter Name="visitor" Type="System.Action&lt;System.Int32,T,T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="a">The first vector</param>
        <param name="b">The second vector</param>
        <param name="visitor">Delegate to apply to each pair of non-zero values.
            This is passed the index, and two values</param>
        <summary>
            Applies the <paramref name="visitor " />to each corresponding pair of elements
            where the item is emplicitly defined in the vector. By explicitly defined,
            we mean that for a given index <c>i</c>, both vectors have an entry in
            <see cref="F:Microsoft.ML.Runtime.Data.VBuffer`1.Values" /> corresponding to that index.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForEachDefined&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEachDefined&lt;T&gt; (ref Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt; a, Action&lt;int,T&gt; visitor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEachDefined&lt;T&gt;(valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!T&gt;&amp; a, class System.Action`2&lt;int32, !!T&gt; visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ForEachDefined``1(Microsoft.ML.Runtime.Data.VBuffer{``0}@,System.Action{System.Int32,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEachDefined(Of T) (ByRef a As VBuffer(Of T), visitor As Action(Of Integer, T))" />
      <MemberSignature Language="F#" Value="static member ForEachDefined :  * Action&lt;int, 'T&gt; -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ForEachDefined (a, visitor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.Core</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="a" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt;&amp;" RefType="ref" />
        <Parameter Name="visitor" Type="System.Action&lt;System.Int32,T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="a">To be added.</param>
        <param name="visitor">To be added.</param>
        <summary>
            Applies <paramref name="visitor" /> to every explicitly defined element of the vector,
            in order of index.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForEachEitherDefined&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEachEitherDefined&lt;T&gt; (ref Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt; a, ref Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt; b, Action&lt;int,T,T&gt; visitor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEachEitherDefined&lt;T&gt;(valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!T&gt;&amp; a, valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!T&gt;&amp; b, class System.Action`3&lt;int32, !!T, !!T&gt; visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ForEachEitherDefined``1(Microsoft.ML.Runtime.Data.VBuffer{``0}@,Microsoft.ML.Runtime.Data.VBuffer{``0}@,System.Action{System.Int32,``0,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEachEitherDefined(Of T) (ByRef a As VBuffer(Of T), ByRef b As VBuffer(Of T), visitor As Action(Of Integer, T, T))" />
      <MemberSignature Language="F#" Value="static member ForEachEitherDefined :  *  * Action&lt;int, 'T, 'T&gt; -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ForEachEitherDefined (a, b, visitor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.Core</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="a" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt;&amp;" RefType="ref" />
        <Parameter Name="b" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt;&amp;" RefType="ref" />
        <Parameter Name="visitor" Type="System.Action&lt;System.Int32,T,T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="a">a vector</param>
        <param name="b">another vector</param>
        <param name="visitor">Function to apply to each pair of non-zero values - passed the index, and two values</param>
        <summary>
            Applies the ParallelVisitor to each corresponding pair of elements where at least one is non-zero, in order of index.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasNaNs">
      <MemberSignature Language="C#" Value="public static bool HasNaNs (ref Microsoft.ML.Runtime.Data.VBuffer&lt;double&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasNaNs(valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;float64&gt;&amp; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.HasNaNs(Microsoft.ML.Runtime.Data.VBuffer{System.Double}@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasNaNs (ByRef buffer As VBuffer(Of Double)) As Boolean" />
      <MemberSignature Language="F#" Value="static member HasNaNs :  -&gt; bool" Usage="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.HasNaNs buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.Core</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;System.Double&gt;&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasNaNs">
      <MemberSignature Language="C#" Value="public static bool HasNaNs (ref Microsoft.ML.Runtime.Data.VBuffer&lt;float&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasNaNs(valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;float32&gt;&amp; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.HasNaNs(Microsoft.ML.Runtime.Data.VBuffer{System.Single}@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasNaNs (ByRef buffer As VBuffer(Of Single)) As Boolean" />
      <MemberSignature Language="F#" Value="static member HasNaNs :  -&gt; bool" Usage="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.HasNaNs buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.Core</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;System.Single&gt;&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasNonFinite">
      <MemberSignature Language="C#" Value="public static bool HasNonFinite (ref Microsoft.ML.Runtime.Data.VBuffer&lt;double&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasNonFinite(valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;float64&gt;&amp; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.HasNonFinite(Microsoft.ML.Runtime.Data.VBuffer{System.Double}@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasNonFinite (ByRef buffer As VBuffer(Of Double)) As Boolean" />
      <MemberSignature Language="F#" Value="static member HasNonFinite :  -&gt; bool" Usage="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.HasNonFinite buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.Core</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;System.Double&gt;&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasNonFinite">
      <MemberSignature Language="C#" Value="public static bool HasNonFinite (ref Microsoft.ML.Runtime.Data.VBuffer&lt;float&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasNonFinite(valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;float32&gt;&amp; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.HasNonFinite(Microsoft.ML.Runtime.Data.VBuffer{System.Single}@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasNonFinite (ByRef buffer As VBuffer(Of Single)) As Boolean" />
      <MemberSignature Language="F#" Value="static member HasNonFinite :  -&gt; bool" Usage="Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.HasNonFinite buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.Core</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;System.Single&gt;&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>