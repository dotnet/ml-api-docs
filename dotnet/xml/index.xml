<Overview>
  <Assemblies>
    <Assembly Name="Microsoft.ML.Core" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.Core")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyFileVersion("1.0.27602.11")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyInformationalVersion("1.0.27602.11 @BuiltBy: dlab14-DDVSOWINAGE082 @Branch: release/1.0 @SrcCode: https://github.com/dotnet/machinelearning/tree/62a5b3440a728908864b9cc30d416f1b16492010+62a5b3440a728908864b9cc30d416f1b16492010")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Core")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.Core")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TestFramework, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Core.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Predictor.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Sweeper.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.InferenceTesting, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StaticPipelineTesting, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.OnnxTransformerTest, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.EntryPoints, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Maml, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.ResultProcessor, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.CpuMath, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Data, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Api, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Ensemble, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.FastTree, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Mkl.Components, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.KMeansClustering, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.LightGbm, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.OnnxConverter, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.OnnxTransformer, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Parquet, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.PCA, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.PipelineInference, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Recommender, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.ImageAnalytics, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Scoring, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StandardTrainers, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Sweeper, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TensorFlow, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TimeSeries, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Transforms, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TensorFlow.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Mkl.Components.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.OnnxTransformer.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.LightGbm.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TimeSeries.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Internal.MetaLinearLearner, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("TreeVisualizer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("TMSNlearnPrediction, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.CntkWrapper, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.DssmFeaturizer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.DssmTrigram, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.EdgeML, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("ExperimentVisualization, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Internal.FastTree, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.Garage, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.HelperCommands, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.Internal.ImageAnalytics, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("ImageNetClientSample, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.InferNetWrapper, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TlcTesting.Inference, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Internal.RecipeInference, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.LDSVM, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("LibSvmWrapper, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("maml, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("TLCTelemetry, PublicKey=0024000004800000940000000602000000240000525341310004000001000100edfd1aca74f2e8d6d7fd53d6f0bf77982ea38a5d2dc462f2f9f01f0734d87a8480279e02c42df82024ea146bf9721a86c50740b9809e4f379a848e1c5168bbfc2b3969aacec1822b3a29db0a23dce5502d764bc0d6ca68f5e4a53ad5212c427567545ec7027402b908460476bcc690a730d25532399e9ce5de32bfdc2211f7e0")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Internal.Api, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.PyTrainer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("ParameterMixer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.OcrTransform, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.RServerScoring.TextAnalytics, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.TextAnalytics, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("StratoLearner, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.SequencePrediction, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.Internal.Opencv, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.Sar, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.NeuralNetworks, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.PowerShellIntegration, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.RServerScoring.NeuralNetworks, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("TMSNStreams, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.TlcAzurePublish, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.VowpalWabbit, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.XGBoost, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.SLib, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTestsMore, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.RServerScoring, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.Sweeper, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.TlcCustomModule, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.SweeperHpc, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.Scope, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("NeuralNetworksTest, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunEndToEnd, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTestsAzurePublish, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("SseTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("TLC, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("DotNetBridge, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.ML.CpuMath" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.CpuMath")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyFileVersion("1.0.27602.11")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyInformationalVersion("1.0.27602.11 @BuiltBy: dlab14-DDVSOWINAGE082 @Branch: release/1.0 @SrcCode: https://github.com/dotnet/machinelearning/tree/62a5b3440a728908864b9cc30d416f1b16492010+62a5b3440a728908864b9cc30d416f1b16492010")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Core")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.CpuMath")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.CpuMath.UnitTests.netstandard, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.CpuMath.UnitTests.netcoreapp, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Data, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.FastTree, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Mkl.Components, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.KMeansClustering, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.PCA, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StandardTrainers, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Sweeper, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TimeSeries, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Transforms, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Benchmarks.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.CpuMath.PerformanceTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Internal.CpuMath, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.Internal.MklMath, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("LibSvmWrapper, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.NeuralNetworks, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.RServerScoring.NeuralNetworks, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("SseTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.ML.Data" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.EntryPoints.SelectRows))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.EntryPoints.SummarizePredictor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Calibrators.FixedPlattCalibratorTrainer/Arguments))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Calibrators.NaiveCalibratorTrainerFactory))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Calibrators.PavCalibratorTrainerFactory))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Calibrators.PlattCalibratorTrainerFactory))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.BootstrapSample))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.RandomNumberGenerator))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.TypeConversion))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.ExpLoss/Options))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.LogLossFactory))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.HingeLoss/Options))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.PoissonLossFactory))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.SmoothedHingeLoss/Options))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.SquaredLossFactory))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.TweedieLoss/Options))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.CrossValidationCommand), typeof(Microsoft.ML.Data.CrossValidationCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Cross Validation", new System.String[] { "CV" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Runs a previously trained predictor on the data.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Data.EvaluateTransform), typeof(Microsoft.ML.Data.EvaluateTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Evaluate Predictor", new System.String[] { "Evaluate" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Evaluates the metrics for a scored data file.", typeof(Microsoft.ML.Data.EvaluateCommand), typeof(Microsoft.ML.Data.EvaluateCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Evaluate Predictor", new System.String[] { "Evaluate" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Given input data, a loader, and possibly transforms, save the data to a new file as parameterized by a saver.", typeof(Microsoft.ML.Data.SaveDataCommand), typeof(Microsoft.ML.Data.SaveDataCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Save Data", new System.String[] { "SaveData", "save" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Given input data, a loader, and possibly transforms, display a sample of the data file.", typeof(Microsoft.ML.Data.ShowDataCommand), typeof(Microsoft.ML.Data.ShowDataCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Show Data", new System.String[] { "ShowData", "show" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Given a TLC model file with a predictor, we can output this same predictor in multiple export formats.", typeof(Microsoft.ML.Tools.SavePredictorCommand), typeof(Microsoft.ML.Tools.SavePredictorCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Save Predictor As", new System.String[] { "SavePredictorAs", "SavePredictor", "SaveAs", "SaveModel" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Scores a data file.", typeof(Microsoft.ML.Data.ScoreCommand), typeof(Microsoft.ML.Data.ScoreCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Score Predictor", new System.String[] { "Score" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Given input data, a loader, and possibly transforms, display the schema.", typeof(Microsoft.ML.Data.ShowSchemaCommand), typeof(Microsoft.ML.Data.ShowSchemaCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Show Schema", new System.String[] { "ShowSchema", "schema" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Scores and evaluates a data file.", typeof(Microsoft.ML.Data.TestCommand), typeof(Microsoft.ML.Data.TestCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Test Predictor", new System.String[] { "Test" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Trains a predictor.", typeof(Microsoft.ML.Data.TrainCommand), typeof(Microsoft.ML.Data.TrainCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Train Predictor", new System.String[] { "Train" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Trains a predictor using the train file and then scores and evaluates the predictor using the test file.", typeof(Microsoft.ML.Data.TrainTestCommand), typeof(Microsoft.ML.Data.TrainTestCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Train Test", new System.String[] { "TrainTest" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.Commands.TypeInfoCommand), typeof(Microsoft.ML.Data.Commands.TypeInfoCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "", new System.String[] { "TypeInfo" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Loads native Binary IDV data file.", typeof(Microsoft.ML.Data.IO.BinaryLoader), typeof(Microsoft.ML.Data.IO.BinaryLoader/Arguments), typeof(Microsoft.ML.Data.SignatureDataLoader), "Binary Loader", new System.String[] { "BinaryLoader", "Binary", "Bin" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Loads native Binary IDV data file.", typeof(Microsoft.ML.Data.IO.BinaryLoader), null, typeof(Microsoft.ML.Data.SignatureLoadDataLoader), "Binary Data View Loader", new System.String[] { "BinaryLoader" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IO.BinaryLoader/InfoCommand), typeof(Microsoft.ML.Data.IO.BinaryLoader/InfoCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "", new System.String[] { "IdvInfo", "idv" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Writes data into a native binary IDV file.", typeof(Microsoft.ML.Data.IO.BinarySaver), typeof(Microsoft.ML.Data.IO.BinarySaver/Arguments), typeof(Microsoft.ML.Data.SignatureDataSaver), "Binary Saver", new System.String[] { "BinarySaver", "Binary" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("A model loader that encapsulates a data loader and a transformer chain.", typeof(Microsoft.ML.Data.CompositeDataLoader`2&lt;Microsoft.ML.Data.IMultiStreamSource,Microsoft.ML.ITransformer&gt;), null, typeof(Microsoft.ML.SignatureLoadModel), "Composite Loader", new System.String[] { "CompositeLoader" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ILegacyDataLoader), typeof(Microsoft.ML.Data.LegacyCompositeDataLoader), typeof(Microsoft.ML.Data.LegacyCompositeDataLoader/Arguments), typeof(Microsoft.ML.Data.SignatureDataLoader), "Composite Data Loader", new System.String[] { "CompositeDataLoader", "Composite", "PipeData", "Pipe", "PipeDataLoader" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ILegacyDataLoader), typeof(Microsoft.ML.Data.LegacyCompositeDataLoader), null, typeof(Microsoft.ML.Data.SignatureLoadDataLoader), "Pipe DataL Loader", new System.String[] { "PipeDataLoader" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Loads text data file.", typeof(Microsoft.ML.Data.ILegacyDataLoader), typeof(Microsoft.ML.Data.TextLoader), typeof(Microsoft.ML.Data.TextLoader/Options), typeof(Microsoft.ML.Data.SignatureDataLoader), "Text Loader", new System.String[] { "TextLoader", "Text" }, DocName="loader/TextLoader.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Loads text data file.", typeof(Microsoft.ML.Data.ILegacyDataLoader), typeof(Microsoft.ML.Data.TextLoader), null, typeof(Microsoft.ML.Data.SignatureLoadDataLoader), "Text Loader", new System.String[] { "TextLoader" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Loads text data file.", typeof(Microsoft.ML.Data.TextLoader), null, typeof(Microsoft.ML.SignatureLoadModel), "Text Loader", new System.String[] { "TextLoader" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Writes data into a text file.", typeof(Microsoft.ML.Data.IO.TextSaver), typeof(Microsoft.ML.Data.IO.TextSaver/Arguments), typeof(Microsoft.ML.Data.SignatureDataSaver), "Text Saver", new System.String[] { "TextSaver", "Text" }, DocName="saver/TextSaver.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.TransformerChain`1&lt;Microsoft.ML.ITransformer&gt;), typeof(Microsoft.ML.Data.TransformerChain), null, typeof(Microsoft.ML.SignatureLoadModel), "Transformer chain", new System.String[] { "TransformerChain" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.TransformWrapper), null, typeof(Microsoft.ML.SignatureLoadModel), "Transform wrapper", new System.String[] { "TransformWrapper" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Loads a binary transposed data file.", typeof(Microsoft.ML.Data.IO.TransposeLoader), typeof(Microsoft.ML.Data.IO.TransposeLoader/Arguments), typeof(Microsoft.ML.Data.SignatureDataLoader), "Transpose Loader", new System.String[] { "TransposeLoader", "Transpose", "trans" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Loads a binary transposed data file.", typeof(Microsoft.ML.Data.IO.TransposeLoader), null, typeof(Microsoft.ML.Data.SignatureLoadDataLoader), "Transpose Data View Loader", new System.String[] { "TransposeLoader" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Writes data into a transposed binary TDV file.", typeof(Microsoft.ML.Data.IO.TransposeSaver), typeof(Microsoft.ML.Data.IO.TransposeSaver/Arguments), typeof(Microsoft.ML.Data.SignatureDataSaver), "Transpose Saver", new System.String[] { "TransposeSaver", "TransposedSaver", "Transpose", "Transposed", "trans" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.RowToRowMapperTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "", new System.String[] { "RowToRowMapper" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ChooseColumnsByIndexTransform), typeof(Microsoft.ML.Data.ChooseColumnsByIndexTransform/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "", new System.String[] { "ChooseColumnsByIndexTransform", "ChooseColumnsByIndex" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ChooseColumnsByIndexTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "", new System.String[] { "ChooseColumnsIdxTrans", "ChooseColumnsIdxFunc" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.EntryPoints.SchemaManipulation), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "SchemaManipulation", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.AnomalyDetectionEvaluator), typeof(Microsoft.ML.Data.AnomalyDetectionEvaluator), typeof(Microsoft.ML.Data.AnomalyDetectionEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureEvaluator), "Anomaly Detection Evaluator", new System.String[] { "AnomalyDetectionEvaluator", "AnomalyDetection", "Anomaly" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.AnomalyDetectionMamlEvaluator), typeof(Microsoft.ML.Data.AnomalyDetectionMamlEvaluator), typeof(Microsoft.ML.Data.AnomalyDetectionMamlEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureMamlEvaluator), "Anomaly Detection Evaluator", new System.String[] { "AnomalyDetectionEvaluator", "AnomalyDetection", "Anomaly" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.BinaryClassifierEvaluator), typeof(Microsoft.ML.Data.BinaryClassifierEvaluator), typeof(Microsoft.ML.Data.BinaryClassifierEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureEvaluator), "Binary Classifier Evaluator", new System.String[] { "BinaryClassifierEvaluator", "BinaryClassifier", "Binary", "bin" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.BinaryClassifierMamlEvaluator), typeof(Microsoft.ML.Data.BinaryClassifierMamlEvaluator), typeof(Microsoft.ML.Data.BinaryClassifierMamlEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureMamlEvaluator), "Binary Classifier Evaluator", new System.String[] { "BinaryClassifierEvaluator", "BinaryClassifier", "Binary", "bin" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.BinaryPerInstanceEvaluator), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "", new System.String[] { "BinaryPerInstance" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Data.Evaluate), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "Evaluators", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ClusteringEvaluator), typeof(Microsoft.ML.Data.ClusteringEvaluator), typeof(Microsoft.ML.Data.ClusteringEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureEvaluator), "Clustering Evaluator", new System.String[] { "ClusteringEvaluator", "Clustering" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ClusteringMamlEvaluator), typeof(Microsoft.ML.Data.ClusteringMamlEvaluator), typeof(Microsoft.ML.Data.ClusteringMamlEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureMamlEvaluator), "Clustering Evaluator", new System.String[] { "ClusteringEvaluator", "Clustering" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ClusteringPerInstanceEvaluator), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "", new System.String[] { "ClusteringPerInstance" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.MulticlassClassificationEvaluator), typeof(Microsoft.ML.Data.MulticlassClassificationEvaluator), typeof(Microsoft.ML.Data.MulticlassClassificationEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureEvaluator), "Multi-Class Classifier Evaluator", new System.String[] { "MultiClassClassifierEvaluator", "MultiClassClassifier", "MultiClass" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.MulticlassClassificationMamlEvaluator), typeof(Microsoft.ML.Data.MulticlassClassificationMamlEvaluator), typeof(Microsoft.ML.Data.MulticlassClassificationMamlEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureMamlEvaluator), "Multi-Class Classifier Evaluator", new System.String[] { "MultiClassClassifierEvaluator", "MultiClassClassifier", "MultiClass" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.MulticlassPerInstanceEvaluator), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "", new System.String[] { "MulticlassPerInstance" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.MultiOutputRegressionEvaluator), typeof(Microsoft.ML.Data.MultiOutputRegressionEvaluator), typeof(Microsoft.ML.Data.MultiOutputRegressionEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureEvaluator), "Multi Output Regression Evaluator", new System.String[] { "MultiRegressionEvaluator", "MultiOutputRegression", "MRE" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.MultiOutputRegressionMamlEvaluator), typeof(Microsoft.ML.Data.MultiOutputRegressionMamlEvaluator), typeof(Microsoft.ML.Data.MultiOutputRegressionMamlEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureMamlEvaluator), "Multi Output Regression Evaluator", new System.String[] { "MultiRegressionEvaluator", "MultiOutputRegression", "MRE" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.MultiOutputRegressionPerInstanceEvaluator), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "", new System.String[] { "MultiRegPerInstance" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.QuantileRegressionEvaluator), typeof(Microsoft.ML.Data.QuantileRegressionEvaluator), typeof(Microsoft.ML.Data.QuantileRegressionEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureEvaluator), "Quantile Regression Evaluator", new System.String[] { "QuantileRegressionEvaluator", "QuantileRegression" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.QuantileRegressionMamlEvaluator), typeof(Microsoft.ML.Data.QuantileRegressionMamlEvaluator), typeof(Microsoft.ML.Data.QuantileRegressionMamlEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureMamlEvaluator), "Quantile Regression Evaluator", new System.String[] { "QuantileRegressionEvaluator", "QuantileRegression" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.QuantileRegressionPerInstanceEvaluator), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "", new System.String[] { "QuantileRegPerInstance" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.RankingEvaluator), typeof(Microsoft.ML.Data.RankingEvaluator), typeof(Microsoft.ML.Data.RankingEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureEvaluator), "Ranking Evaluator", new System.String[] { "RankingEvaluator", "Ranking", "rank" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.RankingMamlEvaluator), typeof(Microsoft.ML.Data.RankingMamlEvaluator), typeof(Microsoft.ML.Data.RankingMamlEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureMamlEvaluator), "Ranking Evaluator", new System.String[] { "RankingEvaluator", "Ranking", "rank" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.RankingPerInstanceTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "", new System.String[] { "RankerPerInstTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.RegressionEvaluator), typeof(Microsoft.ML.Data.RegressionEvaluator), typeof(Microsoft.ML.Data.RegressionEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureEvaluator), "Regression Evaluator", new System.String[] { "RegressionEvaluator", "Regression" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.RegressionMamlEvaluator), typeof(Microsoft.ML.Data.RegressionMamlEvaluator), typeof(Microsoft.ML.Data.RegressionMamlEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureMamlEvaluator), "Regression Evaluator", new System.String[] { "RegressionEvaluator", "Regression" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.RegressionPerInstanceEvaluator), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "", new System.String[] { "RegressionPerInstance" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Given a data model, write out the corresponding PFA.", typeof(Microsoft.ML.Model.Pfa.SavePfaCommand), typeof(Microsoft.ML.Model.Pfa.SavePfaCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Save PFA", new System.String[] { "SavePfa" }, DocName="command/SavePfa.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("This model was introduced by Platt in the paper Probabilistic Outputs for Support Vector Machines and Comparisons to Regularized Likelihood Methods", typeof(Microsoft.ML.Calibrators.PlattCalibratorTrainer), null, typeof(Microsoft.ML.Calibrators.SignatureCalibrator), "Sigmoid Calibration", new System.String[] { "PlattCalibration", "SigmoidCalibration" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Sigmoid calibrator with configurable slope and offset.", typeof(Microsoft.ML.Calibrators.FixedPlattCalibratorTrainer), typeof(Microsoft.ML.Calibrators.FixedPlattCalibratorTrainer/Arguments), typeof(Microsoft.ML.Calibrators.SignatureCalibrator), "Fixed Sigmoid Calibration", new System.String[] { "FixedPlattCalibration", "FixedSigmoidCalibration" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Piecewise linear calibrator.", typeof(Microsoft.ML.Calibrators.PavCalibratorTrainer), null, typeof(Microsoft.ML.Calibrators.SignatureCalibrator), "PAV Calibration", new System.String[] { "PAVCalibration", "PAV" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Naive calibrator divides the range of the outputs into equally sized bins. In each bin, the probability of belonging to class 1 is the number of class 1 instances in the bin, divided by the total number of instances in the bin.", typeof(Microsoft.ML.Calibrators.NaiveCalibratorTrainer), null, typeof(Microsoft.ML.Calibrators.SignatureCalibrator), "Naive Calibrator", new System.String[] { "NaiveCalibrator", "Naive", "NaiveCalibration" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Calibrators.PlattCalibrator), null, typeof(Microsoft.ML.SignatureLoadModel), "Platt Calibration Executor", new System.String[] { "PlattCaliExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Calibrators.IsotonicCalibrator), null, typeof(Microsoft.ML.SignatureLoadModel), "PAV Calibration Executor", new System.String[] { "PAVCaliExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Calibrators.NaiveCalibrator), null, typeof(Microsoft.ML.SignatureLoadModel), "Naive Calibration Executor", new System.String[] { "NaiveCaliExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Calibrators.CalibratedModelParametersBase), typeof(Microsoft.ML.Calibrators.ValueMapperCalibratedModelParameters`2&lt;Microsoft.ML.IPredictorProducing`1&lt;System.Single&gt;,Microsoft.ML.Calibrators.ICalibrator&gt;), null, typeof(Microsoft.ML.SignatureLoadModel), "Calibrated Predictor Executor", new System.String[] { "CaliPredExec", "BulkCaliPredExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Calibrators.CalibratedModelParametersBase), typeof(Microsoft.ML.Calibrators.FeatureWeightsCalibratedModelParameters`2&lt;Microsoft.ML.IPredictorProducing`1&lt;System.Single&gt;,Microsoft.ML.Calibrators.ICalibrator&gt;), null, typeof(Microsoft.ML.SignatureLoadModel), "Feature Weights Calibrated Predictor Executor", new System.String[] { "FeatWCaliPredExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Calibrators.CalibratedModelParametersBase), typeof(Microsoft.ML.Calibrators.ParameterMixingCalibratedModelParameters`2&lt;Microsoft.ML.IPredictorProducing`1&lt;System.Single&gt;,Microsoft.ML.Calibrators.ICalibrator&gt;), null, typeof(Microsoft.ML.SignatureLoadModel), "Parameter Mixing Calibrated Predictor Executor", new System.String[] { "PMixCaliPredExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Calibrators.CalibratedModelParametersBase), typeof(Microsoft.ML.Calibrators.SchemaBindableCalibratedModelParameters`2&lt;Microsoft.ML.IPredictorProducing`1&lt;System.Single&gt;,Microsoft.ML.Calibrators.ICalibrator&gt;), null, typeof(Microsoft.ML.SignatureLoadModel), "Schema Bindable Calibrated Predictor", new System.String[] { "SchemaBindableCalibrated" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Calibrators.Calibrate), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "Calibrate", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Calibrators.CalibratorTransformer`1&lt;Microsoft.ML.Calibrators.PlattCalibrator&gt;), typeof(Microsoft.ML.Calibrators.PlattCalibratorTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "", new System.String[] { "PlattCalibratTransf" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Calibrators.CalibratorTransformer`1&lt;Microsoft.ML.Calibrators.NaiveCalibrator&gt;), typeof(Microsoft.ML.Calibrators.NaiveCalibratorTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "", new System.String[] { "NaiveCalibratTransf" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Calibrators.CalibratorTransformer`1&lt;Microsoft.ML.Calibrators.IsotonicCalibrator&gt;), typeof(Microsoft.ML.Calibrators.IsotonicCalibratorTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "", new System.String[] { "PavCalibratTransf" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.BinaryClassifierScorer), typeof(Microsoft.ML.Data.BinaryClassifierScorer/Arguments), typeof(Microsoft.ML.Data.SignatureDataScorer), "Binary Classifier Scorer", new System.String[] { "BinaryClassifierScorer", "BinaryClassifier", "Binary", "bin", "BinaryClassification" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.BinaryClassifierScorer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Binary Classifier Scorer", new System.String[] { "BinClassScoreTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ClusteringScorer), typeof(Microsoft.ML.Data.ClusteringScorer/Arguments), typeof(Microsoft.ML.Data.SignatureDataScorer), "Clustering Scorer", new System.String[] { "ClusteringScorer", "Clustering" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ClusteringScorer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Clustering Scorer", new System.String[] { "ClusteringScoreTrans" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IDataScorerTransform), typeof(Microsoft.ML.Data.FeatureContributionScorer), typeof(Microsoft.ML.Data.FeatureContributionScorer/Arguments), typeof(Microsoft.ML.Data.SignatureDataScorer), "Feature Contribution Scorer", new System.String[] { "fcc", "wtf", "fct", "FeatureContributionCalculationScorer", "FeatureContribution" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ISchemaBindableMapper), typeof(Microsoft.ML.Data.FeatureContributionScorer), typeof(Microsoft.ML.Data.FeatureContributionScorer/Arguments), typeof(Microsoft.ML.Data.SignatureBindableMapper), "Feature Contribution Mapper", new System.String[] { "fcc", "wtf", "fct", "FeatureContribution" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ISchemaBindableMapper), typeof(Microsoft.ML.Data.FeatureContributionScorer), null, typeof(Microsoft.ML.SignatureLoadModel), "Feature Contribution Mapper", new System.String[] { "WTFBindable" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.GenericScorer), typeof(Microsoft.ML.Data.GenericScorer/Arguments), typeof(Microsoft.ML.Data.SignatureDataScorer), "Generic Scorer", new System.String[] { "GenericScorer", "Generic" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.GenericScorer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Generic Scorer", new System.String[] { "GenericScoreTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.MulticlassClassificationScorer), typeof(Microsoft.ML.Data.MulticlassClassificationScorer/Arguments), typeof(Microsoft.ML.Data.SignatureDataScorer), "Multi-Class Classifier Scorer", new System.String[] { "MultiClassClassifierScorer", "MultiClassClassifier", "MultiClass", "MulticlassClassification" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.MulticlassClassificationScorer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Multi-Class Classifier Scorer", new System.String[] { "MultiClassScoreTrans" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ISchemaBindableMapper), typeof(Microsoft.ML.Data.MulticlassClassificationScorer/LabelNameBindableMapper), null, typeof(Microsoft.ML.SignatureLoadModel), "Multi-Class Label-Name Mapper", new System.String[] { "LabelSlotNameMapper" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.BinaryPredictionTransformer`1&lt;Microsoft.ML.IPredictorProducing`1&lt;System.Single&gt;&gt;), typeof(Microsoft.ML.Data.BinaryPredictionTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "", new System.String[] { "BinaryPredXfer" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.MulticlassPredictionTransformer`1&lt;Microsoft.ML.IPredictorProducing`1&lt;Microsoft.ML.Data.VBuffer`1&lt;System.Single&gt;&gt;&gt;), typeof(Microsoft.ML.Data.MulticlassPredictionTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "", new System.String[] { "MulticlassPredXfer" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.RegressionPredictionTransformer`1&lt;Microsoft.ML.IPredictorProducing`1&lt;System.Single&gt;&gt;), typeof(Microsoft.ML.Data.RegressionPredictionTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "", new System.String[] { "RegressionPredXfer" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.RankingPredictionTransformer`1&lt;Microsoft.ML.IPredictorProducing`1&lt;System.Single&gt;&gt;), typeof(Microsoft.ML.Data.RankingPredictionTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "", new System.String[] { "RankingPredXfer" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.AnomalyPredictionTransformer`1&lt;Microsoft.ML.IPredictorProducing`1&lt;System.Single&gt;&gt;), typeof(Microsoft.ML.Data.AnomalyPredictionTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "", new System.String[] { "AnomalyPredXfer" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ClusteringPredictionTransformer`1&lt;Microsoft.ML.IPredictorProducing`1&lt;Microsoft.ML.Data.VBuffer`1&lt;System.Single&gt;&gt;&gt;), typeof(Microsoft.ML.Data.ClusteringPredictionTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "", new System.String[] { "ClusteringPredXfer" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IDataScorerTransform), typeof(Microsoft.ML.Data.QuantileRegressionScorerTransform), typeof(Microsoft.ML.Data.QuantileRegressionScorerTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataScorer), "Quantile Regression Scorer", new System.String[] { "QuantileRegressionScorer", "QuantileRegression" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ISchemaBindableMapper), typeof(Microsoft.ML.Data.QuantileRegressionScorerTransform), typeof(Microsoft.ML.Data.QuantileRegressionScorerTransform/Arguments), typeof(Microsoft.ML.Data.SignatureBindableMapper), "Quantile Regression Mapper", new System.String[] { "QuantileRegressionScorer", "QuantileRegression" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.SchemaBindablePredictorWrapper), null, typeof(Microsoft.ML.SignatureLoadModel), "Bindable Mapper", new System.String[] { "SchemaBindableWrapper" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.SchemaBindableQuantileRegressionPredictor), null, typeof(Microsoft.ML.SignatureLoadModel), "Regression Bindable Mapper", new System.String[] { "QuantileSchemaBindable" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.SchemaBindableBinaryPredictorWrapper), null, typeof(Microsoft.ML.SignatureLoadModel), "Binary Classification Bindable Mapper", new System.String[] { "BinarySchemaBindable" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Approximate bootstrap sampling.", typeof(Microsoft.ML.Transforms.BootstrapSamplingTransformer), typeof(Microsoft.ML.Transforms.BootstrapSamplingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Bootstrap Sample Transform", new System.String[] { "BootstrapSampleTransform", "BootstrapSample" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Approximate bootstrap sampling.", typeof(Microsoft.ML.Transforms.BootstrapSamplingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Bootstrap Sample Transform", new System.String[] { "BootstrapSampleTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Concatenates one or more columns of the same item type.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Data.ColumnConcatenatingTransformer), typeof(Microsoft.ML.Data.ColumnConcatenatingTransformer/TaggedOptions), typeof(Microsoft.ML.Data.SignatureDataTransform), "Concat Transform", new System.String[] { "Concat", "ConcatTransform" }, DocName="transform/ConcatTransform.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Concatenates one or more columns of the same item type.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Data.ColumnConcatenatingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Concat Transform", new System.String[] { "ConcatTransform", "ConcatFunction" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ColumnConcatenatingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Concat Transform", new System.String[] { "ConcatTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Data.ColumnConcatenatingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Concat Transform", new System.String[] { "ConcatTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Copy a source column to a new column.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.ColumnCopyingTransformer), typeof(Microsoft.ML.Transforms.ColumnCopyingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Copy Columns Transform", new System.String[] { "CopyColumns", "CopyColumnsTransform", "Copy" }, DocName="transform/CopyColumnsTransformer.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Copy a source column to a new column.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.ColumnCopyingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Copy Columns Transform", new System.String[] { "CopyTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Copy a source column to a new column.", typeof(Microsoft.ML.Transforms.ColumnCopyingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Copy Columns Transform", new System.String[] { "CopyTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.ColumnCopyingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Copy Columns Transform", new System.String[] { "CopyTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Selects which columns from the dataset to keep.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.ColumnSelectingTransformer), typeof(Microsoft.ML.Transforms.ColumnSelectingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Select Columns Transform", new System.String[] { "SelectColumns", "SelectColumnsTransform", "Select" }, DocName="transform/SelectTransforms.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Selects which columns from the dataset to keep.", typeof(Microsoft.ML.IDataView), typeof(Microsoft.ML.Transforms.ColumnSelectingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Select Columns Transform", new System.String[] { "SelectColumnsTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Selects which columns from the dataset to keep.", typeof(Microsoft.ML.Transforms.ColumnSelectingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Select Columns Transform", new System.String[] { "SelectColumnsTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("", typeof(Microsoft.ML.IDataView), typeof(Microsoft.ML.Transforms.ColumnSelectingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "", new System.String[] { "DropColumnsTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("", typeof(Microsoft.ML.IDataView), typeof(Microsoft.ML.Transforms.ColumnSelectingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "", new System.String[] { "ChooseColumnsTransform", "ChooseColumnsFunction" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("For each data point, calculates the contribution of individual features to the model prediction.", typeof(Microsoft.ML.Transforms.FeatureContributionCalculatingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Feature Contribution Calculation", new System.String[] { "FeatureContribution" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.FeatureContributionCalculatingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Feature Contribution Calculation", new System.String[] { "FeatureContribution" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Transforms.FeatureContributionEntryPoint), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "FeatureContribution", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Adds a column with a generated number sequence.", typeof(Microsoft.ML.Transforms.GenerateNumberTransform), typeof(Microsoft.ML.Transforms.GenerateNumberTransform/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Generate Number Transform", new System.String[] { "GenerateNumberTransform", "GenerateNumber", "Generate" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Adds a column with a generated number sequence.", typeof(Microsoft.ML.Transforms.GenerateNumberTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Generate Number Transform", new System.String[] { "GenNumTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Converts column values into hashes. This transform accepts text and keys as inputs. It works on single- and vector-valued columns, and hashes each slot in a vector separately.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.HashingTransformer), typeof(Microsoft.ML.Transforms.HashingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Hash Transform", new System.String[] { "HashTransform", "Hash" }, DocName="transform/HashTransform.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Converts column values into hashes. This transform accepts text and keys as inputs. It works on single- and vector-valued columns, and hashes each slot in a vector separately.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.HashingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Hash Transform", new System.String[] { "HashTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Converts column values into hashes. This transform accepts text and keys as inputs. It works on single- and vector-valued columns, and hashes each slot in a vector separately.", typeof(Microsoft.ML.Transforms.HashingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Hash Transform", new System.String[] { "HashTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.HashingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Hash Transform", new System.String[] { "HashTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.KeyToValueMappingTransformer), typeof(Microsoft.ML.Transforms.KeyToValueMappingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Key To Value Transform", new System.String[] { "KeyToValueTransform", "KeyToValue", "KeyToVal", "Unterm" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.KeyToValueMappingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Key To Value Transform", new System.String[] { "KeyToValueTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.KeyToValueMappingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Key To Value Transform", new System.String[] { "KeyToValueTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.KeyToValueMappingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Key To Value Transform", new System.String[] { "KeyToValueTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Converts a key column to an indicator vector.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.KeyToVectorMappingTransformer), typeof(Microsoft.ML.Transforms.KeyToVectorMappingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Key To Vector Transform", new System.String[] { "KeyToVectorTransform", "KeyToVector", "ToVector" }, DocName="transform/KeyToVectorTransform.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Converts a key column to an indicator vector.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.KeyToVectorMappingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Key To Vector Transform", new System.String[] { "KeyToVectorTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Converts a key column to an indicator vector.", typeof(Microsoft.ML.Transforms.KeyToVectorMappingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "KeyToVectorTransform", new System.String[] { "KeyToVectorTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.KeyToVectorMappingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "KeyToVectorTransform", new System.String[] { "KeyToVectorTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Convert a label column into a standard floating point representation.", typeof(Microsoft.ML.Transforms.LabelConvertTransform), typeof(Microsoft.ML.Transforms.LabelConvertTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "", new System.String[] { "LabelConvert", "LabelConvertTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Convert a label column into a standard floating point representation.", typeof(Microsoft.ML.Transforms.LabelConvertTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Label Convert Transform", new System.String[] { "LabelConvertTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.LabelIndicatorTransform), typeof(Microsoft.ML.Transforms.LabelIndicatorTransform/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Label Indicator Transform", new System.String[] { "LabelIndicatorTransform", "LabelIndicator" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.LabelIndicatorTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Label Indicator Transform", new System.String[] { "LabelIndicatorTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Transforms.LabelIndicatorTransform), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "LabelIndicatorTransform", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Filters out rows that contain missing values.", typeof(Microsoft.ML.Transforms.NAFilter), typeof(Microsoft.ML.Transforms.NAFilter/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "NA Filter", new System.String[] { "NAFilter", "MissingValueFilter", "MissingFilter" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Filters out rows that contain missing values.", typeof(Microsoft.ML.Transforms.NAFilter), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "NA Filter", new System.String[] { "MissingValueFilter", "MissingFeatureFilter" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Does nothing.", typeof(Microsoft.ML.Data.NopTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "", new System.String[] { "NopTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Data.NopTransform), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "NopTransform", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Normalizes the data based on the observed minimum and maximum values of the data.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.NormalizeTransform), typeof(Microsoft.ML.Transforms.NormalizeTransform/MinMaxArguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Min-Max Normalizer", new System.String[] { "MinMaxNormalizer", "MinMax" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Normalizes the data based on the computed mean and variance of the data.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.NormalizeTransform), typeof(Microsoft.ML.Transforms.NormalizeTransform/MeanVarArguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "MeanVar Normalizer", new System.String[] { "MeanVarNormalizer", "MeanVar", "ZScoreNormalizer", "ZScore", "GaussianNormalizer", "Gaussian" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Normalizes the data based on the computed mean and variance of the logarithm of the data.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.NormalizeTransform), typeof(Microsoft.ML.Transforms.NormalizeTransform/LogMeanVarArguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "LogMeanVar Normalizer", new System.String[] { "LogMeanVarNormalizer", "LogMeanVar", "LogNormalNormalizer", "LogNormal" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("The values are assigned into equidensity bins and a value is mapped to its bin_number/number_of_bins.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.NormalizeTransform), typeof(Microsoft.ML.Transforms.NormalizeTransform/BinArguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Binning Normalizer", new System.String[] { "BinNormalizer", "Bin" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.NormalizeTransform/AffineColumnFunction), null, typeof(Microsoft.ML.Data.SignatureLoadColumnFunction), "Affine Normalizer", new System.String[] { "AffineNormExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.NormalizeTransform/CdfColumnFunction), null, typeof(Microsoft.ML.Data.SignatureLoadColumnFunction), "CDF Normalizer", new System.String[] { "CdfNormalizeFunction" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("The values are assigned into equidensity bins and a value is mapped to its bin_number/number_of_bins.", typeof(Microsoft.ML.Transforms.NormalizeTransform/BinColumnFunction), null, typeof(Microsoft.ML.Data.SignatureLoadColumnFunction), "Bin Normalizer", new System.String[] { "BinNormalizeFunction" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.NormalizingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "", new System.String[] { "Normalizer" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.NormalizingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "", new System.String[] { "Normalizer" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.NormalizingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "", new System.String[] { "Normalizer", "NormalizeTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Data.Normalize), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "Normalize", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Filters a dataview on a column of type Single, Double or Key (contiguous). Keeps the values that are in the specified min/max range. NaNs are always filtered out. If the input is a Key type, the min/max are considered percentages of the number of values.", typeof(Microsoft.ML.Transforms.RangeFilter), typeof(Microsoft.ML.Transforms.RangeFilter/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Range Filter", new System.String[] { "RangeFilter" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Filters a dataview on a column of type Single, Double or Key (contiguous). Keeps the values that are in the specified min/max range. NaNs are always filtered out. If the input is a Key type, the min/max are considered percentages of the number of values.", typeof(Microsoft.ML.Transforms.RangeFilter), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Range Filter", new System.String[] { "RangeFilter" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Reorders rows in the dataset by pseudo-random shuffling.", typeof(Microsoft.ML.Transforms.RowShufflingTransformer), typeof(Microsoft.ML.Transforms.RowShufflingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Shuffle Transform", new System.String[] { "ShuffleTransform", "Shuffle", "shuf" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Reorders rows in the dataset by pseudo-random shuffling.", typeof(Microsoft.ML.Transforms.RowShufflingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Shuffle Transform", new System.String[] { "ShuffleTrans" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Allows limiting input to a subset of rows at an optional offset.  Can be used to implement data paging.", typeof(Microsoft.ML.Transforms.SkipTakeFilter), typeof(Microsoft.ML.Transforms.SkipTakeFilter/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Skip and Take Filter", new System.String[] { "SkipTakeFilter", "SkipTake" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Allows limiting input to a subset of rows by skipping a number of rows.", typeof(Microsoft.ML.Transforms.SkipTakeFilter), typeof(Microsoft.ML.Transforms.SkipTakeFilter/SkipOptions), typeof(Microsoft.ML.Data.SignatureDataTransform), "Skip Filter", new System.String[] { "SkipFilter", "Skip" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Allows limiting input to a subset of rows by taking N first rows.", typeof(Microsoft.ML.Transforms.SkipTakeFilter), typeof(Microsoft.ML.Transforms.SkipTakeFilter/TakeOptions), typeof(Microsoft.ML.Data.SignatureDataTransform), "Take Filter", new System.String[] { "TakeFilter", "Take" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Allows limiting input to a subset of rows at an optional offset.  Can be used to implement data paging.", typeof(Microsoft.ML.Transforms.SkipTakeFilter), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Skip and Take Filter", new System.String[] { "SkipTakeFilter" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Removes the selected slots from the column.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.SlotsDroppingTransformer), typeof(Microsoft.ML.Transforms.SlotsDroppingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Drop Slots Transform", new System.String[] { "DropSlotsTransform", "DropSlots" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Removes the selected slots from the column.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.SlotsDroppingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Drop Slots Transform", new System.String[] { "DropSlotsTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Removes the selected slots from the column.", typeof(Microsoft.ML.Transforms.SlotsDroppingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Drop Slots Transform", new System.String[] { "DropSlotsTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.SlotsDroppingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Drop Slots Transform", new System.String[] { "DropSlotsTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Runs a previously trained predictor on the data.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.ScoringTransformer), typeof(Microsoft.ML.Transforms.ScoringTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Score Predictor", new System.String[] { "Score" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Trains a predictor, or loads it from a file, and runs it on the data.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.TrainAndScoreTransformer), typeof(Microsoft.ML.Transforms.TrainAndScoreTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Train and Score Predictor", new System.String[] { "TrainScore" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Converts a column to a different type, using standard conversions.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.TypeConvertingTransformer), typeof(Microsoft.ML.Transforms.TypeConvertingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Convert Transform", new System.String[] { "Convert", "ConvertTransform" }, DocName="transform/ConvertTransform.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Converts a column to a different type, using standard conversions.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.TypeConvertingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Convert Transform", new System.String[] { "ConvertTransform", "ConvertFunction" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Converts a column to a different type, using standard conversions.", typeof(Microsoft.ML.Transforms.TypeConvertingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Convert Transform", new System.String[] { "ConvertTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Converts a column to a different type, using standard conversions.", typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.TypeConvertingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Convert Transform", new System.String[] { "ConvertTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Maps text values columns to new columns using a map dataset.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.ValueMappingTransformer), typeof(Microsoft.ML.Transforms.ValueMappingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Value Mapping Transform", new System.String[] { "ValueMapping", "ValueMappingTransformer", "ValueMap", "TermLookup", "Lookup", "LookupTransform" }, DocName="transform/ValueMappingTransformer.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Maps text values columns to new columns using a map dataset.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.ValueMappingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Value Mapping Transform", new System.String[] { "ValueMappingTransformer", "TermLookupTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Maps text values columns to new columns using a map dataset.", typeof(Microsoft.ML.Transforms.ValueMappingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Value Mapping Transform", new System.String[] { "ValueMappingTransformer" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.ValueMappingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Value Mapping Transform", new System.String[] { "ValueMappingTransformer" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Converts input values (words, numbers, etc.) to index in a dictionary.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.ValueToKeyMappingTransformer), typeof(Microsoft.ML.Transforms.ValueToKeyMappingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Term Transform", new System.String[] { "Term", "AutoLabel", "TermTransform", "AutoLabelTransform" }, DocName="transform/TermTransform.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Converts input values (words, numbers, etc.) to index in a dictionary.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.ValueToKeyMappingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Term Transform", new System.String[] { "TermTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Converts input values (words, numbers, etc.) to index in a dictionary.", typeof(Microsoft.ML.Transforms.ValueToKeyMappingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Term Transform", new System.String[] { "TermTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.ValueToKeyMappingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Term Transform", new System.String[] { "TermTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("The log loss function for classification. Supported by SDCA.", typeof(Microsoft.ML.Trainers.LogLoss), null, typeof(Microsoft.ML.Trainers.SignatureClassificationLoss), "Log Loss", new System.String[] { "LogLoss", "Logistic", "CrossEntropy" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("The Hinge loss function for classification. Supported by SDCA.", typeof(Microsoft.ML.Trainers.HingeLoss), typeof(Microsoft.ML.Trainers.HingeLoss/Options), typeof(Microsoft.ML.Trainers.SignatureClassificationLoss), "Hinge Loss", new System.String[] { "HingeLoss", "Hinge" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("The smooth Hinge loss function for classification. Supported by SDCA.", typeof(Microsoft.ML.Trainers.SmoothedHingeLoss), typeof(Microsoft.ML.Trainers.SmoothedHingeLoss/Options), typeof(Microsoft.ML.Trainers.SignatureClassificationLoss), "Smoothed Hinge Loss", new System.String[] { "SmoothedHingeLoss", "SmoothedHinge" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("The exponential loss function for classification.", typeof(Microsoft.ML.Trainers.ExpLoss), typeof(Microsoft.ML.Trainers.ExpLoss/Options), typeof(Microsoft.ML.Trainers.SignatureClassificationLoss), "Exponential Loss", new System.String[] { "ExpLoss", "Exp" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("The squared loss function for regression.", typeof(Microsoft.ML.Trainers.SquaredLoss), null, typeof(Microsoft.ML.Trainers.SignatureRegressionLoss), "Squared Loss", new System.String[] { "SquaredLoss", "L2" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("The Poisson loss function for regression.", typeof(Microsoft.ML.Trainers.PoissonLoss), null, typeof(Microsoft.ML.Trainers.SignatureRegressionLoss), "Poisson Loss", new System.String[] { "PoissonLoss", "Poisson" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("The Tweedie loss function for regression.", typeof(Microsoft.ML.Trainers.TweedieLoss), typeof(Microsoft.ML.Trainers.TweedieLoss/Options), typeof(Microsoft.ML.Trainers.SignatureRegressionLoss), "Tweedie Loss", new System.String[] { "TweedieLoss", "Tweedie", "Tw" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.WantsToBeBestFriends</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.Data")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyFileVersion("1.0.27602.11")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyInformationalVersion("1.0.27602.11 @BuiltBy: dlab14-DDVSOWINAGE082 @Branch: release/1.0 @SrcCode: https://github.com/dotnet/machinelearning/tree/62a5b3440a728908864b9cc30d416f1b16492010+62a5b3440a728908864b9cc30d416f1b16492010")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Core")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.Data")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TestFramework, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Core.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.InferenceTesting, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.OnnxTransformerTest, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Predictor.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TimeSeries.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Benchmarks, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StaticPipelineTesting, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.EntryPoints, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Maml, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.ResultProcessor, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Api, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Ensemble, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.FastTree, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Mkl.Components, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.KMeansClustering, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.LightGbm, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.OnnxConverter, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.OnnxTransformer, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Parquet, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.PCA, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.PipelineInference, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Recommender, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.ImageAnalytics, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Scoring, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StandardTrainers, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Sweeper, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TensorFlow, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TimeSeries, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Transforms, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.DnnImageFeaturizer.AlexNet, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.DnnImageFeaturizer.ResNet101, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.DnnImageFeaturizer.ResNet18, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.DnnImageFeaturizer.ResNet50, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Experimental, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Internal.MetaLinearLearner, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("TMSNlearnPrediction, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.CntkWrapper, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.DssmFeaturizer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.DssmTrigram, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.EdgeML, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Internal.FastTree, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.Garage, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.HelperCommands, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.Internal.ImageAnalytics, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.InferNetWrapper, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.LDSVM, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("LibSvmWrapper, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Internal.RecipeInference, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.PyTrainer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("ParameterMixer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Internal.Api, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.TextAnalytics, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("StratoLearner, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.SequencePrediction, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.RServerScoring.TextAnalytics, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.NeuralNetworks, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.RServerScoring.NeuralNetworks, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.Sar, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.OcrTransform, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("TreeVisualizer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.TlcAzurePublish, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.XGBoost, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.SLib, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.VowpalWabbit, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.RServerScoring, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.TlcCustomModule, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.Scope, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("TLC, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTestsMore, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("DotNetBridge, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("NeuralNetworksTest, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTestsAzurePublish, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.ML.DataView" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.DataView")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyFileVersion("1.0.27602.11")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyInformationalVersion("1.0.27602.11 @BuiltBy: dlab14-DDVSOWINAGE082 @Branch: release/1.0 @SrcCode: https://github.com/dotnet/machinelearning/tree/62a5b3440a728908864b9cc30d416f1b16492010+62a5b3440a728908864b9cc30d416f1b16492010")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Core")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.DataView")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.ML.FastTree" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer/Options))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer/Options))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer/Options))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer/Options))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.FastTree.TolerantEarlyStoppingRule))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.FastTree.GeneralityLossRule))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.FastTree.LowProgressRule))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.FastTree.GeneralityToProgressRatioRule))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.FastTree.ConsecutiveGeneralityLossRule))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.FastTree.TolerantEarlyStoppingRule/Options))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.FastTree.GeneralityLossRule/Options))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.FastTree.LowProgressRule/Options))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.FastTree.GeneralityToProgressRatioRule/Options))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.FastTree.ConsecutiveGeneralityLossRule/Options))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.FastTree.SingleTrainerFactory))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Uses a logit-boost boosted tree learner to perform binary classification.", typeof(Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer), typeof(Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Trainers.FastTree.SignatureTreeEnsembleTrainer), typeof(Microsoft.ML.Model.SignatureFeatureScorerTrainer) }, "FastTree (Boosted Trees) Classification", new System.String[] { "FastTreeBinaryClassification", "FastTreeClassification", "FastTree", "ft", "ftc", "FastRankBinaryClassification", "FastRankBinaryClassificationWrapper", "FastRankClassification", "fr", "btc", "frc", "fastrank", "fastrankwrapper" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.IPredictorProducing`1&lt;System.Single&gt;), typeof(Microsoft.ML.Trainers.FastTree.FastTreeBinaryModelParameters), null, typeof(Microsoft.ML.SignatureLoadModel), "FastTree Binary Executor", new System.String[] { "FastTreeBinaryExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Trains gradient boosted decision trees to the LambdaRank quasi-gradient.", typeof(Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer), typeof(Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureRankerTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Trainers.FastTree.SignatureTreeEnsembleTrainer), typeof(Microsoft.ML.Model.SignatureFeatureScorerTrainer) }, "FastTree (Boosted Trees) Ranking", new System.String[] { "FastTreeRanking", "ftrank", "FastRankRanking", "FastRankRankingWrapper", "rank", "frrank", "btrank" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.FastTree.FastTreeRankingModelParameters), null, typeof(Microsoft.ML.SignatureLoadModel), "FastTree Ranking Executor", new System.String[] { "FastTreeRankerExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.FastTree.FastTree), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "FastTree", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Trains gradient boosted decision trees to fit target values using least-squares.", typeof(Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer), typeof(Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureRegressorTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Trainers.FastTree.SignatureTreeEnsembleTrainer), typeof(Microsoft.ML.Model.SignatureFeatureScorerTrainer) }, "FastTree (Boosted Trees) Regression", new System.String[] { "FastTreeRegression", "ftr", "FastRankRegression", "FastRankRegressionWrapper", "frr", "btr" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.FastTree.FastTreeRegressionModelParameters), null, typeof(Microsoft.ML.SignatureLoadModel), "FastTree Regression Executor", new System.String[] { "FastTreeRegressionExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Trains gradient boosted decision trees to fit target values using a Tweedie loss function. This learner is a generalization of Poisson, compound Poisson, and gamma regression.", typeof(Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer), typeof(Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureRegressorTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Trainers.FastTree.SignatureTreeEnsembleTrainer), typeof(Microsoft.ML.Model.SignatureFeatureScorerTrainer) }, "FastTree (Boosted Trees) Tweedie Regression", new System.String[] { "FastTreeTweedieRegression", "fttweedie" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.FastTree.FastTreeTweedieModelParameters), null, typeof(Microsoft.ML.SignatureLoadModel), "FastTree Tweedie Regression Executor", new System.String[] { "FastTreeTweedieExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Trains a gradient boosted stump per feature, on all features simultaneously, to fit target values using least-squares. It mantains no interactions between features.", typeof(Microsoft.ML.Trainers.FastTree.GamBinaryTrainer), typeof(Microsoft.ML.Trainers.FastTree.GamBinaryTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Model.SignatureFeatureScorerTrainer) }, "Generalized Additive Model for Binary Classification", new System.String[] { "BinaryClassificationGamTrainer", "gam" }, DocName="trainer/GAM.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.IPredictorProducing`1&lt;System.Single&gt;), typeof(Microsoft.ML.Trainers.FastTree.GamBinaryModelParameters), null, typeof(Microsoft.ML.SignatureLoadModel), "GAM Binary Class Predictor", new System.String[] { "BinaryClassGamPredictor" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.FastTree.GamModelParametersBase/VisualizationCommand), typeof(Microsoft.ML.Trainers.FastTree.GamModelParametersBase/VisualizationCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "GAM Vizualization Command", new System.String[] { "GamVisualization", "gamviz" }, DocName="command/GamViz.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Trains a gradient boosted stump per feature, on all features simultaneously, to fit target values using least-squares. It mantains no interactions between features.", typeof(Microsoft.ML.Trainers.FastTree.GamRegressionTrainer), typeof(Microsoft.ML.Trainers.FastTree.GamRegressionTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureRegressorTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Model.SignatureFeatureScorerTrainer) }, "Generalized Additive Model for Regression", new System.String[] { "RegressionGamTrainer", "gamr" }, DocName="trainer/GAM.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.FastTree.GamRegressionModelParameters), null, typeof(Microsoft.ML.SignatureLoadModel), "GAM Regression Predictor", new System.String[] { "RegressionGamPredictor" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.FastTree.Gam), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "GAM", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Uses a random forest learner to perform binary classification.", typeof(Microsoft.ML.Trainers.FastTree.FastForestBinaryTrainer), typeof(Microsoft.ML.Trainers.FastTree.FastForestBinaryTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Trainers.FastTree.SignatureTreeEnsembleTrainer), typeof(Microsoft.ML.Model.SignatureFeatureScorerTrainer) }, "Fast Forest Classification", new System.String[] { "FastForestClassification", "FastForest", "ff", "ffc" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.IPredictorProducing`1&lt;System.Single&gt;), typeof(Microsoft.ML.Trainers.FastTree.FastForestBinaryModelParameters), null, typeof(Microsoft.ML.SignatureLoadModel), "FastForest Binary Executor", new System.String[] { "FastForestBinaryExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.FastTree.FastForest), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "FastForest", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Trains a random forest to fit target values using least-squares.", typeof(Microsoft.ML.Trainers.FastTree.FastForestRegressionTrainer), typeof(Microsoft.ML.Trainers.FastTree.FastForestRegressionTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureRegressorTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Trainers.FastTree.SignatureTreeEnsembleTrainer), typeof(Microsoft.ML.Model.SignatureFeatureScorerTrainer) }, "Fast Forest Regression", new System.String[] { "FastForestRegression", "ffr" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.FastTree.FastForestRegressionModelParameters), null, typeof(Microsoft.ML.SignatureLoadModel), "FastForest Regression Executor", new System.String[] { "FastForestRegressionExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.FastTree.SumupPerformanceCommand), typeof(Microsoft.ML.Trainers.FastTree.SumupPerformanceCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "", new System.String[] { "FastTreeSumupPerformance", "ftsumup" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.FastTree.TolerantEarlyStoppingRule), typeof(Microsoft.ML.Trainers.FastTree.TolerantEarlyStoppingRule/Options), typeof(Microsoft.ML.Trainers.FastTree.SignatureEarlyStoppingCriterion), "Tolerant (TR)", new System.String[] { "tr" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.FastTree.GeneralityLossRule), typeof(Microsoft.ML.Trainers.FastTree.GeneralityLossRule/Options), typeof(Microsoft.ML.Trainers.FastTree.SignatureEarlyStoppingCriterion), "Loss of Generality (GL)", new System.String[] { "gl" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.FastTree.LowProgressRule), typeof(Microsoft.ML.Trainers.FastTree.LowProgressRule/Options), typeof(Microsoft.ML.Trainers.FastTree.SignatureEarlyStoppingCriterion), "Low Progress (LP)", new System.String[] { "lp" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.FastTree.GeneralityToProgressRatioRule), typeof(Microsoft.ML.Trainers.FastTree.GeneralityToProgressRatioRule/Options), typeof(Microsoft.ML.Trainers.FastTree.SignatureEarlyStoppingCriterion), "Generality to Progress Ratio (PQ)", new System.String[] { "pq" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.FastTree.ConsecutiveGeneralityLossRule), typeof(Microsoft.ML.Trainers.FastTree.ConsecutiveGeneralityLossRule/Options), typeof(Microsoft.ML.Trainers.FastTree.SignatureEarlyStoppingCriterion), "Consecutive Loss in Generality (UP)", new System.String[] { "up" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.FastTree.SingleTrainer), null, typeof(Microsoft.ML.Trainers.FastTree.SignatureParallelTrainer), "single", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ISchemaBindableMapper), typeof(Microsoft.ML.Data.TreeEnsembleFeaturizerTransform), typeof(Microsoft.ML.Data.TreeEnsembleFeaturizerBindableMapper/Arguments), typeof(Microsoft.ML.Data.SignatureBindableMapper), "Tree Ensemble Featurizer Mapper", new System.String[] { "TreeFeat" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IDataScorerTransform), typeof(Microsoft.ML.Data.TreeEnsembleFeaturizerTransform), typeof(Microsoft.ML.Data.TreeEnsembleFeaturizerBindableMapper/Arguments), typeof(Microsoft.ML.Data.SignatureDataScorer), "Tree Ensemble Featurizer Scorer", new System.String[] { "TreeFeat" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ISchemaBindableMapper), typeof(Microsoft.ML.Data.TreeEnsembleFeaturizerTransform), null, typeof(Microsoft.ML.SignatureLoadModel), "Tree Ensemble Featurizer Mapper", new System.String[] { "TreeEnsembleMapper" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Trains a tree ensemble, or loads it from a file, then maps a numeric feature vector to three outputs: 1. A vector containing the individual tree outputs of the tree ensemble. 2. A vector indicating the leaves that the feature vector falls on in the tree ensemble. 3. A vector indicating the paths that the feature vector falls on in the tree ensemble. If a both a model file and a trainer are specified - will use the model file. If neither are specified, will train a default FastTree model. This can handle key labels by training a regression model towards their optionally permuted indices.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Data.TreeEnsembleFeaturizerTransform), typeof(Microsoft.ML.Data.TreeEnsembleFeaturizerTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Tree Ensemble Featurization Transform", new System.String[] { "TreeFeat", "TreeFeaturizationTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Data.TreeFeaturize), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "TreeFeaturize", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.FastTree.TreeEnsembleCombiner), null, typeof(Microsoft.ML.Data.SignatureModelCombiner), "Fast Tree Model Combiner", new System.String[] { "FastTreeCombiner" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.WantsToBeBestFriends</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.FastTree")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyFileVersion("1.0.27602.11")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyInformationalVersion("1.0.27602.11 @BuiltBy: dlab14-DDVSOWINAGE082 @Branch: release/1.0 @SrcCode: https://github.com/dotnet/machinelearning/tree/62a5b3440a728908864b9cc30d416f1b16492010+62a5b3440a728908864b9cc30d416f1b16492010")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Core")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.FastTree")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Core.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Predictor.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.LightGbm, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Sweeper, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Internal.FastTree, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.ML.ImageAnalytics" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Transforms.Image.ImageAnalyticsEntryPoints), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "ImageAnalytics", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Convert image into grayscale.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Image.ImageGrayscalingTransformer), typeof(Microsoft.ML.Transforms.Image.ImageGrayscalingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Image Greyscale Transform", new System.String[] { "ImageGrayscaleTransform", "ImageGrayscale" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Convert image into grayscale.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Image.ImageGrayscalingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Image Greyscale Transform", new System.String[] { "ImageGrayscaleTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.Image.ImageGrayscalingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Image Greyscale Transform", new System.String[] { "ImageGrayscaleTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Image.ImageGrayscalingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Image Greyscale Transform", new System.String[] { "ImageGrayscaleTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Load images from files.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Data.ImageLoadingTransformer), typeof(Microsoft.ML.Data.ImageLoadingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Image Loader Transform", new System.String[] { "ImageLoaderTransform", "ImageLoader" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Load images from files.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Data.ImageLoadingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Image Loader Transform", new System.String[] { "ImageLoaderTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ImageLoadingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "", new System.String[] { "ImageLoaderTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Data.ImageLoadingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "", new System.String[] { "ImageLoaderTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Extract color plane(s) from an image. Options include scaling, offset and conversion to floating point.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Image.ImagePixelExtractingTransformer), typeof(Microsoft.ML.Transforms.Image.ImagePixelExtractingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Image Pixel Extractor Transform", new System.String[] { "ImagePixelExtractorTransform", "ImagePixelExtractor" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Extract color plane(s) from an image. Options include scaling, offset and conversion to floating point.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Image.ImagePixelExtractingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Image Pixel Extractor Transform", new System.String[] { "ImagePixelExtractor" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.Image.ImagePixelExtractingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Image Pixel Extractor Transform", new System.String[] { "ImagePixelExtractor" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Image.ImagePixelExtractingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Image Pixel Extractor Transform", new System.String[] { "ImagePixelExtractor" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Scales an image to specified dimensions using one of the three scale types: isotropic with padding, isotropic with cropping or anisotropic. In case of isotropic padding, transparent color is used to pad resulting image.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Image.ImageResizingTransformer), typeof(Microsoft.ML.Transforms.Image.ImageResizingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Image Resizer Transform", new System.String[] { "ImageResizerTransform", "ImageResizer" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Scales an image to specified dimensions using one of the three scale types: isotropic with padding, isotropic with cropping or anisotropic. In case of isotropic padding, transparent color is used to pad resulting image.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Image.ImageResizingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Image Resizer Transform", new System.String[] { "ImageScalerTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.Image.ImageResizingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Image Resizer Transform", new System.String[] { "ImageScalerTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Image.ImageResizingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Image Resizer Transform", new System.String[] { "ImageScalerTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Converts vector array into image type.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Image.VectorToImageConvertingTransformer), typeof(Microsoft.ML.Transforms.Image.VectorToImageConvertingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Image Pixel Extractor Transform", new System.String[] { "VectorToImageTransform", "VectorToImage" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Converts vector array into image type.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Image.VectorToImageConvertingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Vector To Image Transform", new System.String[] { "VectorToImageConverter" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.Image.VectorToImageConvertingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Vector To Image Transform", new System.String[] { "VectorToImageConverter" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Image.VectorToImageConvertingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Vector To Image Transform", new System.String[] { "VectorToImageConverter" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.WantsToBeBestFriends</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.ImageAnalytics")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyFileVersion("1.0.27602.11")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyInformationalVersion("1.0.27602.11 @BuiltBy: dlab14-DDVSOWINAGE082 @Branch: release/1.0 @SrcCode: https://github.com/dotnet/machinelearning/tree/62a5b3440a728908864b9cc30d416f1b16492010+62a5b3440a728908864b9cc30d416f1b16492010")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Core")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.ImageAnalytics")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.ML.KMeansClustering" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.KMeansModelParameters), null, typeof(Microsoft.ML.SignatureLoadModel), "KMeans predictor", new System.String[] { "KMeansPredictor" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("K-means is a popular clustering algorithm. With K-means, the data is clustered into a specified number of clusters in order to minimize the within-cluster sum of squares. K-means++ improves upon K-means by using a better method for choosing the initial cluster centers.", typeof(Microsoft.ML.Trainers.KMeansTrainer), typeof(Microsoft.ML.Trainers.KMeansTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureClusteringTrainer), typeof(Microsoft.ML.SignatureTrainer) }, "KMeans++ Clustering", new System.String[] { "KMeansPlusPlus", "KM", "KMeans" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.KMeansTrainer), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "KMeans", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.WantsToBeBestFriends</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.KMeansClustering")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyFileVersion("1.0.27602.11")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyInformationalVersion("1.0.27602.11 @BuiltBy: dlab14-DDVSOWINAGE082 @Branch: release/1.0 @SrcCode: https://github.com/dotnet/machinelearning/tree/62a5b3440a728908864b9cc30d416f1b16492010+62a5b3440a728908864b9cc30d416f1b16492010")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Core")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.KMeansClustering")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.ML.LightGbm" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.LightGbm.GradientBooster/Options))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.LightGbm.DartBooster/Options))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.LightGbm.GossBooster/Options))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.LightGbm.SingleTrainerFactory))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.LightGbm.GradientBooster), typeof(Microsoft.ML.Trainers.LightGbm.GradientBooster/Options), typeof(Microsoft.ML.Trainers.LightGbm.SignatureLightGBMBooster), "Tree Booster", new System.String[] { "gbdt" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.LightGbm.DartBooster), typeof(Microsoft.ML.Trainers.LightGbm.DartBooster/Options), typeof(Microsoft.ML.Trainers.LightGbm.SignatureLightGBMBooster), "Tree Dropout Tree Booster", new System.String[] { "dart" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.LightGbm.GossBooster), typeof(Microsoft.ML.Trainers.LightGbm.GossBooster/Options), typeof(Microsoft.ML.Trainers.LightGbm.SignatureLightGBMBooster), "Gradient-based One-Size Sampling", new System.String[] { "goss" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Train a LightGBM binary classification model.", typeof(Microsoft.ML.Trainers.LightGbm.LightGbmBinaryTrainer), typeof(Microsoft.ML.Trainers.LightGbm.LightGbmBinaryTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Trainers.FastTree.SignatureTreeEnsembleTrainer) }, "LightGBM Binary Classifier", new System.String[] { "LightGBMBinary", "LightGBM" }, DocName="trainer/LightGBM.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.IPredictorProducing`1&lt;System.Single&gt;), typeof(Microsoft.ML.Trainers.LightGbm.LightGbmBinaryModelParameters), null, typeof(Microsoft.ML.SignatureLoadModel), "LightGBM Binary Executor", new System.String[] { "LightGBMBinaryExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.LightGbm.LightGbm), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "LightGBM", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("LightGBM Multi Class Classifier", typeof(Microsoft.ML.Trainers.LightGbm.LightGbmMulticlassTrainer), typeof(Microsoft.ML.Trainers.LightGbm.LightGbmMulticlassTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureMulticlassClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer) }, "LightGBM Multi-class Classifier", new System.String[] { "LightGBMMulticlass", "LightGBMMC" }, DocName="trainer/LightGBM.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("LightGBM Ranking", typeof(Microsoft.ML.Trainers.LightGbm.LightGbmRankingTrainer), typeof(Microsoft.ML.Trainers.LightGbm.LightGbmRankingTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureRankerTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Trainers.FastTree.SignatureTreeEnsembleTrainer) }, "LightGBM Ranking", new System.String[] { "LightGBMRanking", "LightGBMRank" }, DocName="trainer/LightGBM.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.LightGbm.LightGbmRankingModelParameters), null, typeof(Microsoft.ML.SignatureLoadModel), "LightGBM Ranking Executor", new System.String[] { "LightGBMRankerExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("LightGBM Regression", typeof(Microsoft.ML.Trainers.LightGbm.LightGbmRegressionTrainer), typeof(Microsoft.ML.Trainers.LightGbm.LightGbmRegressionTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureRegressorTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Trainers.FastTree.SignatureTreeEnsembleTrainer) }, "LightGBM Regressor", new System.String[] { "LightGBMRegression", "LightGBMR" }, DocName="trainer/LightGBM.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.LightGbm.LightGbmRegressionModelParameters), null, typeof(Microsoft.ML.SignatureLoadModel), "LightGBM Regression Executor", new System.String[] { "LightGBMRegressionExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.LightGbm.SingleTrainer), null, typeof(Microsoft.ML.Trainers.LightGbm.SignatureParallelTrainer), "single", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.WantsToBeBestFriends</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.LightGbm")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyFileVersion("1.0.27602.11")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyInformationalVersion("1.0.27602.11 @BuiltBy: dlab14-DDVSOWINAGE082 @Branch: release/1.0 @SrcCode: https://github.com/dotnet/machinelearning/tree/62a5b3440a728908864b9cc30d416f1b16492010+62a5b3440a728908864b9cc30d416f1b16492010")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Core")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.LightGbm")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.LightGbm.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Predictor.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.ML.Mkl.Components" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("The ordinary least square regression fits the target function as a linear function of the numerical features that minimizes the square loss function.", typeof(Microsoft.ML.Trainers.OlsTrainer), typeof(Microsoft.ML.Trainers.OlsTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureRegressorTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Model.SignatureFeatureScorerTrainer) }, "Ordinary Least Squares (Regression)", new System.String[] { "OLSLinearRegression", "ols" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.OlsModelParameters), null, typeof(Microsoft.ML.SignatureLoadModel), "OLS Linear Regression Executor", new System.String[] { "OlsLinearRegressionExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.OlsTrainer), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "OLSLinearRegression", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.SymbolicSgdLogisticRegressionBinaryTrainer), typeof(Microsoft.ML.Trainers.SymbolicSgdLogisticRegressionBinaryTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Model.SignatureFeatureScorerTrainer) }, "Symbolic SGD (binary)", new System.String[] { "SymbolicSGD", "SymSGD" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.SymbolicSgdLogisticRegressionBinaryTrainer), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "SymbolicSGD", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Apply PCA or ZCA whitening algorithm to the input.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.VectorWhiteningTransformer), typeof(Microsoft.ML.Transforms.VectorWhiteningTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Whitening Transform", new System.String[] { "WhiteningTransform", "Whitening" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Apply PCA or ZCA whitening algorithm to the input.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.VectorWhiteningTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Whitening Transform", new System.String[] { "WhiteningTransform", "WhiteningFunction" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Apply PCA or ZCA whitening algorithm to the input.", typeof(Microsoft.ML.Transforms.VectorWhiteningTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Whitening Transform", new System.String[] { "WhiteningTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.VectorWhiteningTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Whitening Transform", new System.String[] { "WhiteningTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.WantsToBeBestFriends</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.Mkl.Components")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyFileVersion("1.0.27602.11")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyInformationalVersion("1.0.27602.11 @BuiltBy: dlab14-DDVSOWINAGE082 @Branch: release/1.0 @SrcCode: https://github.com/dotnet/machinelearning/tree/62a5b3440a728908864b9cc30d416f1b16492010+62a5b3440a728908864b9cc30d416f1b16492010")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Core")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.Mkl.Components")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Mkl.Components.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Internal.MetaLinearLearner, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.ML.PCA" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("This algorithm trains an approximate PCA using Randomized SVD algorithm. This PCA can be made into Kernel PCA by using Random Fourier Features transform.", typeof(Microsoft.ML.Trainers.RandomizedPcaTrainer), typeof(Microsoft.ML.Trainers.RandomizedPcaTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureAnomalyDetectorTrainer), typeof(Microsoft.ML.SignatureTrainer) }, "PCA Anomaly Detector", new System.String[] { "pcaAnomaly", "pcaAnom" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.PcaModelParameters), null, typeof(Microsoft.ML.SignatureLoadModel), "PCA Anomaly Executor", new System.String[] { "pcaAnomExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.RandomizedPcaTrainer), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "pcaAnomaly", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("PCA is a dimensionality-reduction transform which computes the projection of a numeric vector onto a low-rank subspace.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.PrincipalComponentAnalysisTransformer), typeof(Microsoft.ML.Transforms.PrincipalComponentAnalysisTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Principal Component Analysis Transform", new System.String[] { "PcaTransform", "Pca" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("PCA is a dimensionality-reduction transform which computes the projection of a numeric vector onto a low-rank subspace.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.PrincipalComponentAnalysisTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Principal Component Analysis Transform", new System.String[] { "PcaTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("PCA is a dimensionality-reduction transform which computes the projection of a numeric vector onto a low-rank subspace.", typeof(Microsoft.ML.Transforms.PrincipalComponentAnalysisTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Principal Component Analysis Transform", new System.String[] { "PcaTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.PrincipalComponentAnalysisTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Principal Component Analysis Transform", new System.String[] { "PcaTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Transforms.PrincipalComponentAnalysisTransformer), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "PcaTransform", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.WantsToBeBestFriends</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.PCA")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyFileVersion("1.0.27602.11")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyInformationalVersion("1.0.27602.11 @BuiltBy: dlab14-DDVSOWINAGE082 @Branch: release/1.0 @SrcCode: https://github.com/dotnet/machinelearning/tree/62a5b3440a728908864b9cc30d416f1b16492010+62a5b3440a728908864b9cc30d416f1b16492010")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Core")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.PCA")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Core.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.ML.StandardTrainers" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.OneVersusAllModelParameters))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Train a field-aware factorization machine for binary classification", typeof(Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer), typeof(Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer) }, "Field-aware Factorization Machine", new System.String[] { "FieldAwareFactorizationMachine", "ffm" }, DocName="trainer/FactorizationMachine.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "FieldAwareFactorizationMachine", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.FieldAwareFactorizationMachineModelParameters), null, typeof(Microsoft.ML.SignatureLoadModel), "Field Aware Factorization Machine", new System.String[] { "FieldAwareFactMacPredict" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.FieldAwareFactorizationMachinePredictionTransformer), typeof(Microsoft.ML.Trainers.FieldAwareFactorizationMachinePredictionTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "", new System.String[] { "FAFMPredXfer" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.IPredictorProducing`1&lt;System.Single&gt;), typeof(Microsoft.ML.Trainers.LinearBinaryModelParameters), null, typeof(Microsoft.ML.SignatureLoadModel), "Linear Binary Executor", new System.String[] { "Linear2CExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.LinearRegressionModelParameters), null, typeof(Microsoft.ML.SignatureLoadModel), "Linear Regression Executor", new System.String[] { "LinearRegressionExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.PoissonRegressionModelParameters), null, typeof(Microsoft.ML.SignatureLoadModel), "Poisson Regression Executor", new System.String[] { "PoissonRegressionExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Logistic Regression is a method in statistics used to predict the probability of occurrence of an event and can be used as a classification algorithm. The algorithm predicts the probability of occurrence of an event by fitting data to a logistical function.", typeof(Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer), typeof(Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Model.SignatureFeatureScorerTrainer) }, "Logistic Regression", new System.String[] { "LogisticRegression", "lr", "logisticregressionwrapper" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "LogisticRegression", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer), typeof(Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureMulticlassClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer) }, "Multi-class Logistic Regression", new System.String[] { "MultiClassLogisticRegression", "MulticlassLogisticRegressionPredictorNew", "mlr", "multilr" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.MaximumEntropyModelParameters), null, typeof(Microsoft.ML.SignatureLoadModel), "Multiclass LR Executor", new System.String[] { "MultiClassLRExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "MultiClassLogisticRegression", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.ModelStatisticsBase), typeof(Microsoft.ML.Trainers.LinearModelParameterStatistics), null, typeof(Microsoft.ML.SignatureLoadModel), "Linear Model Statistics", new System.String[] { "LinearModelStats" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.ModelStatisticsBase), typeof(Microsoft.ML.Trainers.ModelStatisticsBase), null, typeof(Microsoft.ML.SignatureLoadModel), "Model Statistics", new System.String[] { "ModelStats" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Trains a multiclass Naive Bayes predictor that supports binary feature values.", typeof(Microsoft.ML.Trainers.NaiveBayesMulticlassTrainer), typeof(Microsoft.ML.Trainers.NaiveBayesMulticlassTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureMulticlassClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer) }, "Multiclass Naive Bayes", new System.String[] { "MultiClassNaiveBayes", "MNB" }, DocName="trainer/NaiveBayes.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.NaiveBayesMulticlassModelParameters), null, typeof(Microsoft.ML.SignatureLoadModel), "Multi Class Naive Bayes predictor", new System.String[] { "MultiClassNaiveBayesPred" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.NaiveBayesMulticlassTrainer), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "MultiClassNaiveBayes", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("In this strategy, a binary classification algorithm is used to train one classifier for each class, which distinguishes that class from all other classes. Prediction is then performed by running these binary classifiers, and choosing the prediction with the highest confidence score.", typeof(Microsoft.ML.Trainers.OneVersusAllTrainer), typeof(Microsoft.ML.Trainers.OneVersusAllTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureMulticlassClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer) }, "One-vs-All", new System.String[] { "OVA" }, DocName="trainer/OvaPkpd.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.OneVersusAllModelParameters), null, typeof(Microsoft.ML.SignatureLoadModel), "OVA Executor", new System.String[] { "OVAExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("In this strategy, a binary classification algorithm is used to train one classifier for each pair of classes. Prediction is then performed by running these binary classifiers, and computing a score for each class by counting how many of the binary classifiers predicted it. The prediction is the class with the highest score.", typeof(Microsoft.ML.Trainers.PairwiseCouplingTrainer), typeof(Microsoft.ML.Trainers.PairwiseCouplingTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureMulticlassClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer) }, "Pairwise coupling (PKPD)", new System.String[] { "PKPD" }, DocName="trainer/OvaPkpd.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.PairwiseCouplingModelParameters), null, typeof(Microsoft.ML.SignatureLoadModel), "PKPD Executor", new System.String[] { "PKPDExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Averaged Perceptron Binary Classifier.", typeof(Microsoft.ML.Trainers.AveragedPerceptronTrainer), typeof(Microsoft.ML.Trainers.AveragedPerceptronTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Model.SignatureFeatureScorerTrainer) }, "Averaged Perceptron", new System.String[] { "AveragedPerceptron", "avgper", "ap" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.AveragedPerceptronTrainer), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "AP", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("The idea behind support vector machines, is to map the instances into a high dimensional space in which instances of the two classes are linearly separable, i.e., there exists a hyperplane such that all the positive examples are on one side of it, and all the negative examples are on the other. After this mapping, quadratic programming is used to find the separating hyperplane that maximizes the margin, i.e., the minimal distance between it and the instances.", typeof(Microsoft.ML.Trainers.LinearSvmTrainer), typeof(Microsoft.ML.Trainers.LinearSvmTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Model.SignatureFeatureScorerTrainer) }, "SVM (Pegasos-Linear)", new System.String[] { "LinearSVM", "svm" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.LinearSvmTrainer), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "LinearSvm", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Stochastic gradient descent is an optimization method used to train a wide range of models in machine learning. In the TLC implementation of OGD, it is for linear regression.", typeof(Microsoft.ML.Trainers.OnlineGradientDescentTrainer), typeof(Microsoft.ML.Trainers.OnlineGradientDescentTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureRegressorTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Model.SignatureFeatureScorerTrainer) }, "Stochastic Gradient Descent (Regression)", new System.String[] { "OnlineGradientDescent", "ogd", "sgdr", "stochasticgradientdescentregression" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.OnlineGradientDescentTrainer), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "OGD", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Poisson Regression assumes the unknown function, denoted Y has a Poisson distribution.", typeof(Microsoft.ML.Trainers.LbfgsPoissonRegressionTrainer), typeof(Microsoft.ML.Trainers.LbfgsPoissonRegressionTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureRegressorTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Model.SignatureFeatureScorerTrainer) }, "Poisson Regression", new System.String[] { "PoissonRegression", "PoissonRegressionNew", "Poisson", "PR" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.LbfgsPoissonRegressionTrainer), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "PoissonRegression", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.LegacySdcaBinaryTrainer), typeof(Microsoft.ML.Trainers.LegacySdcaBinaryTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Model.SignatureFeatureScorerTrainer) }, "Fast Linear (SA-SDCA)", new System.String[] { "SDCA", "LinearClassifier", "lc", "sasdca" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.LegacySgdBinaryTrainer), typeof(Microsoft.ML.Trainers.LegacySgdBinaryTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Model.SignatureFeatureScorerTrainer) }, "Hogwild SGD (binary)", new System.String[] { "BinarySGD", "sgd" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.Sdca), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "SDCA", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.LegacySgdBinaryTrainer), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "HogwildSGD", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("The SDCA linear multi-class classification trainer.", typeof(Microsoft.ML.Trainers.SdcaMaximumEntropyMulticlassTrainer), typeof(Microsoft.ML.Trainers.SdcaMaximumEntropyMulticlassTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureMulticlassClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Model.SignatureFeatureScorerTrainer) }, "Fast Linear Multi-class Classification (SA-SDCA)", new System.String[] { "SDCAMC", "sasdcamc" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("The SDCA linear regression trainer.", typeof(Microsoft.ML.Trainers.SdcaRegressionTrainer), typeof(Microsoft.ML.Trainers.SdcaRegressionTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureRegressorTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Model.SignatureFeatureScorerTrainer) }, "Fast Linear Regression (SA-SDCA)", new System.String[] { "SDCAR", "sasdcar" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("A trivial model for producing the prior based on the number of positive and negative examples.", typeof(Microsoft.ML.Trainers.PriorTrainer), typeof(Microsoft.ML.Trainers.PriorTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer) }, "Prior Predictor", new System.String[] { "PriorPredictor", "prior", "constant" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.RandomModelParameters), null, typeof(Microsoft.ML.SignatureLoadModel), "Random predictor", new System.String[] { "RandomPredictor" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.PriorModelParameters), null, typeof(Microsoft.ML.SignatureLoadModel), "Prior predictor", new System.String[] { "PriorPredictor" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.WantsToBeBestFriends</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.StandardTrainers")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyFileVersion("1.0.27602.11")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyInformationalVersion("1.0.27602.11 @BuiltBy: dlab14-DDVSOWINAGE082 @Branch: release/1.0 @SrcCode: https://github.com/dotnet/machinelearning/tree/62a5b3440a728908864b9cc30d416f1b16492010+62a5b3440a728908864b9cc30d416f1b16492010")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Core")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.StandardTrainers")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.EntryPoints, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.LightGbm, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Mkl.Components, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Ensemble, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Core.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Predictor.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTestsMore, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Internal.MetaLinearLearner, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("ParameterMixer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.Sar, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.ML.Transforms" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.LpNormNormalization))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.GroupingOperations))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.HashJoin))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.NAHandling))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.OptionalColumnTransform))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.Text.PredefinedStopWordsRemoverFactory))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.Text.CustomStopWordsRemovingTransformer/LoaderArguments))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.Text.NgramExtractorTransform/NgramExtractorArguments))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.Text.NgramHashExtractingTransformer/NgramHashExtractorArguments))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.CompositeTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Composite Transform", new System.String[] { "CompositeRowFunction" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Selects the slots for which the count of non-default values is greater than or equal to a threshold.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.CountFeatureSelectingEstimator), typeof(Microsoft.ML.Transforms.CountFeatureSelectingEstimator/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Count Feature Selection Transform", new System.String[] { "CountFeatureSelectionTransform", "CountFeatureSelection" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Transforms.SelectFeatures), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "SelectFeatures", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Transforms.Text.TextAnalytics), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "TextAnalytics", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.GaussianKernel), typeof(Microsoft.ML.Transforms.GaussianKernel/Options), typeof(Microsoft.ML.Transforms.SignatureKernelBase), "Gaussian Kernel", new System.String[] { "GaussianRandom", "Gaussian" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.LaplacianKernel), typeof(Microsoft.ML.Transforms.LaplacianKernel/Options), typeof(Microsoft.ML.Transforms.SignatureKernelBase), "Laplacian Kernel", new System.String[] { "LaplacianRandom", "Laplacian" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.GaussianKernel/RandomNumberGenerator), null, typeof(Microsoft.ML.SignatureLoadModel), "Gaussian Fourier Sampler Executor", new System.String[] { "GaussianSamplerExecutor", "RandGaussFourierExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.LaplacianKernel/RandomNumberGenerator), null, typeof(Microsoft.ML.SignatureLoadModel), "Laplacian Fourier Sampler Executor", new System.String[] { "LaplacianSamplerExecutor", "RandLaplacianFourierExec" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Performs a global contrast normalization on input values: Y = (s * X - M) / D, where s is a scale, M is mean and D is either L2 norm or standard deviation.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.LpNormNormalizingTransformer), typeof(Microsoft.ML.Transforms.LpNormNormalizingTransformer/GcnOptions), typeof(Microsoft.ML.Data.SignatureDataTransform), "Global Contrast Normalization Transform", new System.String[] { "GcnTransform", "Gcn" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Performs a global contrast normalization on input values: Y = (s * X - M) / D, where s is a scale, M is mean and D is either L2 norm or standard deviation.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.LpNormNormalizingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Global Contrast Normalization Transform", new System.String[] { "GcnTransform", "GcnFunction" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Normalize vectors (rows) individually by rescaling them to unit norm (L2, L1 or LInf). Performs the following operation on a vector X: Y = (X - M) / D, where M is mean and D is either L2 norm, L1 norm or LInf norm.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.LpNormNormalizingTransformer), typeof(Microsoft.ML.Transforms.LpNormNormalizingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Lp-Norm Normalizer", new System.String[] { "LpNormNormalizer", "lpnorm" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Normalize vectors (rows) individually by rescaling them to unit norm (L2, L1 or LInf). Performs the following operation on a vector X: Y = (X - M) / D, where M is mean and D is either L2 norm, L1 norm or LInf norm.", typeof(Microsoft.ML.Transforms.LpNormNormalizingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Global Contrast Normalization Transform", new System.String[] { "GcnTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.LpNormNormalizingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Global Contrast Normalization Transform", new System.String[] { "GcnTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Groups values of a scalar column into a vector, by a contiguous group ID", typeof(Microsoft.ML.Transforms.GroupTransform), typeof(Microsoft.ML.Transforms.GroupTransform/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Group Transform", new System.String[] { "Group" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Groups values of a scalar column into a vector, by a contiguous group ID", typeof(Microsoft.ML.Transforms.GroupTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Group Transform", new System.String[] { "GroupTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Converts column values into hashes. This transform accepts both numeric and text inputs, both single and vector-valued columns. ", typeof(Microsoft.ML.Transforms.HashJoiningTransform), typeof(Microsoft.ML.Transforms.HashJoiningTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Hash Join Transform", new System.String[] { "HashJoinTransform", "HashJoin" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Converts column values into hashes. This transform accepts both numeric and text inputs, both single and vector-valued columns. ", typeof(Microsoft.ML.Transforms.HashJoiningTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Hash Join Transform", new System.String[] { "HashJoinTransform", "HashJoinFunction" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Converts a key column to a binary encoded vector.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.KeyToBinaryVectorMappingTransformer), typeof(Microsoft.ML.Transforms.KeyToBinaryVectorMappingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Key To Binary Vector Transform", new System.String[] { "KeyToBinaryVectorTransform", "KeyToBinary", "ToBinaryVector" }, DocName="transform/KeyToBinaryVectorTransform.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Converts a key column to a binary encoded vector.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.KeyToBinaryVectorMappingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Key To Binary Vector Transform", new System.String[] { "KeyToBinaryTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Converts a key column to a binary encoded vector.", typeof(Microsoft.ML.Transforms.KeyToBinaryVectorMappingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "KeyToBinaryVectorTransform", new System.String[] { "KeyToBinaryTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.KeyToBinaryVectorMappingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "KeyToBinaryVectorTransform", new System.String[] { "KeyToBinaryTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.ITransformer), typeof(Microsoft.ML.Transforms.LambdaTransform), null, typeof(Microsoft.ML.SignatureLoadModel), "", new System.String[] { "CustomTransformer" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Selects the slots for which the absolute value of the corresponding weight in a linear learner is greater than a threshold.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.LearnerFeatureSelectionTransform), typeof(Microsoft.ML.Transforms.LearnerFeatureSelectionTransform/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Learner Feature Selection Transform", new System.String[] { "LearnerFeatureSelectionTransform", "LearnerFeatureSelection" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Loads specified transforms from the model file and applies them to current data.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.LoadTransform), typeof(Microsoft.ML.Transforms.LoadTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Load Transform", new System.String[] { "LoadTransform", "Load" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Removes NAs from vector columns.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.MissingValueDroppingTransformer), typeof(Microsoft.ML.Transforms.MissingValueDroppingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "NA Drop Transform", new System.String[] { "NADrop", "NADropTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Removes NAs from vector columns.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.MissingValueDroppingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "NA Drop Transform", new System.String[] { "NADropTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Removes NAs from vector columns.", typeof(Microsoft.ML.Transforms.MissingValueDroppingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "NA Drop Transform", new System.String[] { "NADropTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.MissingValueDroppingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "NA Drop Transform", new System.String[] { "NADropTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Handle missing values by replacing them with either the default value or the mean/min/max value (for non-text columns only). An indicator column can optionally be concatenated, if theinput column type is numeric.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.MissingValueHandlingTransformer), typeof(Microsoft.ML.Transforms.MissingValueHandlingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "NA Handle Transform", new System.String[] { "NAHandleTransform", "NAHandle", "NA" }, DocName="transform/NAHandle.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.MissingValueIndicatorTransform), typeof(Microsoft.ML.Transforms.MissingValueIndicatorTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "", new System.String[] { "MissingValueIndicatorTransform", "MissingValueTransform", "MissingTransform", "Missing" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.MissingValueIndicatorTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Missing Value Indicator Transform", new System.String[] { "MissingIndicatorFunction", "MissingFeatureFunction" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Create a boolean output column with the same number of slots as the input column, where the output value is true if the value in the input column is missing.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.MissingValueIndicatorTransformer), typeof(Microsoft.ML.Transforms.MissingValueIndicatorTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "NA Indicator Transform", new System.String[] { "NaIndicatorTransform", "NAIndicator", "NAInd" }, DocName="transform/NAHandle.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Create a boolean output column with the same number of slots as the input column, where the output value is true if the value in the input column is missing.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.MissingValueIndicatorTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "NA Indicator Transform", new System.String[] { "NaIndicatorTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Create a boolean output column with the same number of slots as the input column, where the output value is true if the value in the input column is missing.", typeof(Microsoft.ML.Transforms.MissingValueIndicatorTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "NA Indicator Transform", new System.String[] { "NaIndicatorTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.MissingValueIndicatorTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "NA Indicator Transform", new System.String[] { "NaIndicatorTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Create an output column of the same type and size of the input column, where missing values are replaced with either the default value or the mean/min/max value (for non-text columns only).", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.MissingValueReplacingTransformer), typeof(Microsoft.ML.Transforms.MissingValueReplacingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "NA Replace Transform", new System.String[] { "NAReplaceTransform", "NAReplace", "NARep" }, DocName="transform/NAHandle.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Create an output column of the same type and size of the input column, where missing values are replaced with either the default value or the mean/min/max value (for non-text columns only).", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.MissingValueReplacingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "NA Replace Transform", new System.String[] { "NAReplaceTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Create an output column of the same type and size of the input column, where missing values are replaced with either the default value or the mean/min/max value (for non-text columns only).", typeof(Microsoft.ML.Transforms.MissingValueReplacingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "NA Replace Transform", new System.String[] { "NAReplaceTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.MissingValueReplacingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "NA Replace Transform", new System.String[] { "NAReplaceTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Selects the top k slots across all specified columns ordered by their mutual information with the label column.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.MutualInformationFeatureSelectingEstimator), typeof(Microsoft.ML.Transforms.MutualInformationFeatureSelectingEstimator/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Mutual Information Feature Selection Transform", new System.String[] { "MutualInformationFeatureSelection", "MutualInformationFeatureSelectionTransform", "MIFeatureSelection" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Converts the categorical value into an indicator array by building a dictionary of categories based on the data and using the id in the dictionary as the index in the array.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.OneHotEncodingTransformer), typeof(Microsoft.ML.Transforms.OneHotEncodingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Categorical Transform", new System.String[] { "CategoricalTransform", "CatTransform", "Categorical", "Cat" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Transforms.Categorical), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "Categorical", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Converts the categorical value into an indicator array by hashing the value and using the hash as an index in the bag. If the input column is a vector, a single indicator bag is returned for it.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.OneHotHashEncodingTransformer), typeof(Microsoft.ML.Transforms.OneHotHashEncodingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Categorical Hash Transform", new System.String[] { "CategoricalHashTransform", "CatHashTransform", "CategoricalHash", "CatHash" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("If the source column does not exist after deserialization, create a column with the right type and default values.", typeof(Microsoft.ML.Transforms.OptionalColumnTransform), typeof(Microsoft.ML.Transforms.OptionalColumnTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Optional Column Transform", new System.String[] { "OptColTransform", "optional" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.OptionalColumnTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Optional Column Transform", new System.String[] { "OptColTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Produces a new column with the row ID.", typeof(Microsoft.ML.Transforms.ProduceIdTransform), typeof(Microsoft.ML.Transforms.ProduceIdTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "", new System.String[] { "ProduceIdTransform", "ProduceId" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Produces a new column with the row ID.", typeof(Microsoft.ML.Transforms.ProduceIdTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Produce ID Transform", new System.String[] { "ProduceIdTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("This transform maps numeric vectors to a random low-dimensional feature space. It is useful when data has non-linear features, since the transform is designed so that the inner products of the transformed data are approximately equal to those in the feature space of a user specified shift-invariant kernel.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.ApproximatedKernelTransformer), typeof(Microsoft.ML.Transforms.ApproximatedKernelTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Random Fourier Features Transform", new System.String[] { "RffTransform", "Rff" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("This transform maps numeric vectors to a random low-dimensional feature space. It is useful when data has non-linear features, since the transform is designed so that the inner products of the transformed data are approximately equal to those in the feature space of a user specified shift-invariant kernel.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.ApproximatedKernelTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Random Fourier Features Transform", new System.String[] { "RffTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("This transform maps numeric vectors to a random low-dimensional feature space. It is useful when data has non-linear features, since the transform is designed so that the inner products of the transformed data are approximately equal to those in the feature space of a user specified shift-invariant kernel.", typeof(Microsoft.ML.Transforms.ApproximatedKernelTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Random Fourier Features Transform", new System.String[] { "RffTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.ApproximatedKernelTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Random Fourier Features Transform", new System.String[] { "RffTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Allows the definition of convenient user defined transforms", typeof(Microsoft.ML.Data.ITransformTemplate), typeof(Microsoft.ML.Transforms.SerializableLambdaTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "", new System.String[] { "UserLambdaMapTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("The LDA transform implements LightLDA, a state-of-the-art implementation of Latent Dirichlet Allocation.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.LatentDirichletAllocationTransformer), typeof(Microsoft.ML.Transforms.Text.LatentDirichletAllocationTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Latent Dirichlet Allocation Transform", new System.String[] { "LdaTransform", "Lda" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("The LDA transform implements LightLDA, a state-of-the-art implementation of Latent Dirichlet Allocation.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.LatentDirichletAllocationTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Latent Dirichlet Allocation Transform", new System.String[] { "LdaTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("The LDA transform implements LightLDA, a state-of-the-art implementation of Latent Dirichlet Allocation.", typeof(Microsoft.ML.Transforms.Text.LatentDirichletAllocationTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Latent Dirichlet Allocation Transform", new System.String[] { "LdaTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Text.LatentDirichletAllocationTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Latent Dirichlet Allocation Transform", new System.String[] { "LdaTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Produces a bag of counts of ngrams (sequences of consecutive values of length 1-n) in a given vector of keys. It does so by hashing each ngram and using the hash value as the index in the bag.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.NgramHashingTransformer), typeof(Microsoft.ML.Transforms.Text.NgramHashingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Ngram Hash Transform", new System.String[] { "NgramHashTransform", "NgramHash" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Produces a bag of counts of ngrams (sequences of consecutive values of length 1-n) in a given vector of keys. It does so by hashing each ngram and using the hash value as the index in the bag.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.NgramHashingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Ngram Hash Transform", new System.String[] { "NgramHashTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Produces a bag of counts of ngrams (sequences of consecutive values of length 1-n) in a given vector of keys. It does so by hashing each ngram and using the hash value as the index in the bag.", typeof(Microsoft.ML.Transforms.Text.NgramHashingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Ngram Hash Transform", new System.String[] { "NgramHashTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Text.NgramHashingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Ngram Hash Transform", new System.String[] { "NgramHashTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Produces a bag of counts of ngrams (sequences of consecutive values of length 1-n) in a given vector of keys. It does so by building a dictionary of ngrams and using the id in the dictionary as the index in the bag.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.NgramExtractingTransformer), typeof(Microsoft.ML.Transforms.Text.NgramExtractingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Ngram Transform", new System.String[] { "NgramTransform", "Ngram" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Produces a bag of counts of ngrams (sequences of consecutive values of length 1-n) in a given vector of keys. It does so by building a dictionary of ngrams and using the id in the dictionary as the index in the bag.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.NgramExtractingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Ngram Transform", new System.String[] { "NgramTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Produces a bag of counts of ngrams (sequences of consecutive values of length 1-n) in a given vector of keys. It does so by building a dictionary of ngrams and using the id in the dictionary as the index in the bag.", typeof(Microsoft.ML.Transforms.Text.NgramExtractingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Ngram Transform", new System.String[] { "NgramTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Text.NgramExtractingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Ngram Transform", new System.String[] { "NgramTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("A transform that turns a collection of text documents into numerical feature vectors. The feature vectors are normalized counts of (word and/or character) ngrams in a given tokenized text.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.SentimentAnalyzingTransformer), typeof(Microsoft.ML.Transforms.Text.SentimentAnalyzingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Sentiment Analyzing Transform", new System.String[] { "SentimentAnalyzingTransform", "SentimentAnalyzer", "Senti" }, DocName="transform/SentimentAnalyzingTransform.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("A Stopword remover transform based on language-specific lists of stop words (most common words) from Office Named Entity Recognition project. The transform is usually applied after tokenizing text, so it compares individual tokens (case-insensitive comparison) to the stopwords.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.StopWordsRemovingTransformer), typeof(Microsoft.ML.Transforms.Text.StopWordsRemovingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Stopwords Remover Transform", new System.String[] { "StopWordsRemoverTransform", "StopWordsRemover", "StopWords" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("A Stopword remover transform based on language-specific lists of stop words (most common words) from Office Named Entity Recognition project. The transform is usually applied after tokenizing text, so it compares individual tokens (case-insensitive comparison) to the stopwords.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.StopWordsRemovingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Stopwords Remover Transform", new System.String[] { "StopWordsTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("A Stopword remover transform based on language-specific lists of stop words (most common words) from Office Named Entity Recognition project. The transform is usually applied after tokenizing text, so it compares individual tokens (case-insensitive comparison) to the stopwords.", typeof(Microsoft.ML.Transforms.Text.StopWordsRemovingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Stopwords Remover Transform", new System.String[] { "StopWordsTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Text.StopWordsRemovingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Stopwords Remover Transform", new System.String[] { "StopWordsTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("A Stopword remover transform based on a user-defined list of stopwords. The transform is usually applied after tokenizing text, so it compares individual tokens (case-insensitive comparison) to the stopwords.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.CustomStopWordsRemovingTransformer), typeof(Microsoft.ML.Transforms.Text.CustomStopWordsRemovingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Custom Stopwords Remover Transform", new System.String[] { "CustomStopWordsRemoverTransform", "CustomStopWords" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("A Stopword remover transform based on a user-defined list of stopwords. The transform is usually applied after tokenizing text, so it compares individual tokens (case-insensitive comparison) to the stopwords.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.CustomStopWordsRemovingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Custom Stopwords Remover Transform", new System.String[] { "CustomStopWords" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("A Stopword remover transform based on a user-defined list of stopwords. The transform is usually applied after tokenizing text, so it compares individual tokens (case-insensitive comparison) to the stopwords.", typeof(Microsoft.ML.Transforms.Text.CustomStopWordsRemovingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Custom Stopwords Remover Transform", new System.String[] { "CustomStopWords" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Text.CustomStopWordsRemovingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Custom Stopwords Remover Transform", new System.String[] { "CustomStopWords" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("A transform that turns a collection of text documents into numerical feature vectors. The feature vectors are normalized counts of (word and/or character) ngrams in a given tokenized text.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.TextFeaturizingEstimator), typeof(Microsoft.ML.Transforms.Text.TextFeaturizingEstimator/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Text Transform", new System.String[] { "TextTransform", "Text" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("A transform that turns a collection of text documents into numerical feature vectors. The feature vectors are normalized counts of (word and/or character) ngrams in a given tokenized text.", typeof(Microsoft.ML.ITransformer), typeof(Microsoft.ML.Transforms.Text.TextFeaturizingEstimator), null, typeof(Microsoft.ML.SignatureLoadModel), "Text Transform", new System.String[] { "TextTransform", "Text" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("A text normalization transform that allows normalizing text case, removing diacritical marks, punctuation marks and/or numbers. The transform operates on text input as well as vector of tokens/text (vector of ReadOnlyMemory).", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.TextNormalizingTransformer), typeof(Microsoft.ML.Transforms.Text.TextNormalizingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Text Normalizer Transform", new System.String[] { "TextNormalizerTransform", "TextNormalizer", "TextNorm" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("A text normalization transform that allows normalizing text case, removing diacritical marks, punctuation marks and/or numbers. The transform operates on text input as well as vector of tokens/text (vector of ReadOnlyMemory).", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.TextNormalizingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Text Normalizer Transform", new System.String[] { "TextNormalizerTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("A text normalization transform that allows normalizing text case, removing diacritical marks, punctuation marks and/or numbers. The transform operates on text input as well as vector of tokens/text (vector of ReadOnlyMemory).", typeof(Microsoft.ML.Transforms.Text.TextNormalizingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Text Normalizer Transform", new System.String[] { "TextNormalizerTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Text.TextNormalizingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Text Normalizer Transform", new System.String[] { "TextNormalizerTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Character-oriented tokenizer where text is considered a sequence of characters.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.TokenizingByCharactersTransformer), typeof(Microsoft.ML.Transforms.Text.TokenizingByCharactersTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Character Tokenizer Transform", new System.String[] { "CharTokenize", "CharToken" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.TokenizingByCharactersTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Character Tokenizer Transform", new System.String[] { "CharToken" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Character-oriented tokenizer where text is considered a sequence of characters.", typeof(Microsoft.ML.Transforms.Text.TokenizingByCharactersTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Character Tokenizer Transform", new System.String[] { "CharToken" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Text.TokenizingByCharactersTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Character Tokenizer Transform", new System.String[] { "CharToken" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Produces a bag of counts of ngrams (sequences of consecutive words of length 1-n) in a given text. It does so by building a dictionary of ngrams and using the id in the dictionary as the index in the bag.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.WordBagBuildingTransformer), typeof(Microsoft.ML.Transforms.Text.WordBagBuildingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Word Bag Transform", new System.String[] { "WordBagTransform", "WordBag" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("A transform that turns a collection of tokenized text ReadOnlyMemory, or vectors of keys into numerical feature vectors. The feature vectors are counts of ngrams (sequences of consecutive *tokens* -words or keys- of length 1-n).", typeof(Microsoft.ML.Transforms.Text.INgramExtractorFactory), typeof(Microsoft.ML.Transforms.Text.NgramExtractorTransform), typeof(Microsoft.ML.Transforms.Text.NgramExtractorTransform/NgramExtractorArguments), typeof(Microsoft.ML.Transforms.Text.SignatureNgramExtractorFactory), "Ngram Extractor Transform", new System.String[] { "NgramExtractorTransform", "Ngram", "NgramExtractor" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Word Embeddings transform is a text featurizer which converts vectors of text tokens into sentence vectors using a pre-trained model", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.WordEmbeddingTransformer), typeof(Microsoft.ML.Transforms.Text.WordEmbeddingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Word Embeddings Transform", new System.String[] { "WordEmbeddingsTransform", "WordEmbeddings" }, DocName="transform/WordEmbeddingsTransform.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Word Embeddings transform is a text featurizer which converts vectors of text tokens into sentence vectors using a pre-trained model", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.WordEmbeddingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Word Embeddings Transform", new System.String[] { "WordEmbeddingsTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.Text.WordEmbeddingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Word Embeddings Transform", new System.String[] { "WordEmbeddingsTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Text.WordEmbeddingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Word Embeddings Transform", new System.String[] { "WordEmbeddingsTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Produces a bag of counts of ngrams (sequences of consecutive words of length 1-n) in a given text. It does so by hashing each ngram and using the hash value as the index in the bag.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.WordHashBagProducingTransformer), typeof(Microsoft.ML.Transforms.Text.WordHashBagProducingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Word Hash Bag Transform", new System.String[] { "WordHashBagTransform", "WordHashBag" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("A transform that turns a collection of tokenized text (vector of ReadOnlyMemory) into numerical feature vectors using the hashing trick.", typeof(Microsoft.ML.Transforms.Text.INgramExtractorFactory), typeof(Microsoft.ML.Transforms.Text.NgramHashExtractingTransformer), typeof(Microsoft.ML.Transforms.Text.NgramHashExtractingTransformer/NgramHashExtractorArguments), typeof(Microsoft.ML.Transforms.Text.SignatureNgramExtractorFactory), "Ngram Hash Extractor Transform", new System.String[] { "NgramHashExtractorTransform", "NgramHash", "NgramHashExtractor" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("The input to this transform is text, and the output is a vector of text containing the words (tokens) in the original text. The separator is space, but can be specified as any other character (or multiple characters) if needed.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.WordTokenizingTransformer), typeof(Microsoft.ML.Transforms.Text.WordTokenizingTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Word Tokenizer Transform", new System.String[] { "WordTokenizeTransform", "DelimitedTokenizeTransform", "WordToken", "DelimitedTokenize", "Token" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("The input to this transform is text, and the output is a vector of text containing the words (tokens) in the original text. The separator is space, but can be specified as any other character (or multiple characters) if needed.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.WordTokenizingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Word Tokenizer Transform", new System.String[] { "TokenizeTextTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("The input to this transform is text, and the output is a vector of text containing the words (tokens) in the original text. The separator is space, but can be specified as any other character (or multiple characters) if needed.", typeof(Microsoft.ML.Transforms.Text.WordTokenizingTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "Word Tokenizer Transform", new System.String[] { "TokenizeTextTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Text.WordTokenizingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Word Tokenizer Transform", new System.String[] { "TokenizeTextTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Un-groups vector columns into sequences of rows, inverse of Group transform", typeof(Microsoft.ML.Transforms.UngroupTransform), typeof(Microsoft.ML.Transforms.UngroupTransform/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "Un-group Transform", new System.String[] { "Ungroup" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.LoadableClass("Un-groups vector columns into sequences of rows, inverse of Group transform", typeof(Microsoft.ML.Transforms.UngroupTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Un-group Transform", new System.String[] { "UngroupTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>Microsoft.ML.WantsToBeBestFriends</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.Transforms")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyFileVersion("1.0.27602.11")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyInformationalVersion("1.0.27602.11 @BuiltBy: dlab14-DDVSOWINAGE082 @Branch: release/1.0 @SrcCode: https://github.com/dotnet/machinelearning/tree/62a5b3440a728908864b9cc30d416f1b16492010+62a5b3440a728908864b9cc30d416f1b16492010")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Core")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.Transforms")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Ensemble, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Core.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.EntryPoints, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.NeuralNetworks, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.RServerScoring.NeuralNetworks, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.TextAnalytics, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.RServerScoring.TextAnalytics, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TimeSeries, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TestFramework, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet">
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.ML.DnnImageFeaturizer.AlexNet" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.DnnImageFeaturizer.AlexNet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyFileVersion("0.12.27602.11")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.12.27602.11 @BuiltBy: dlab14-DDVSOWINAGE082 @Branch: release/1.0 @SrcCode: https://github.com/dotnet/machinelearning/tree/62a5b3440a728908864b9cc30d416f1b16492010+62a5b3440a728908864b9cc30d416f1b16492010")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Core")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.DnnImageFeaturizer.AlexNet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.ML.DnnImageFeaturizer.ResNet101" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.DnnImageFeaturizer.ResNet101")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyFileVersion("0.12.27602.11")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.12.27602.11 @BuiltBy: dlab14-DDVSOWINAGE082 @Branch: release/1.0 @SrcCode: https://github.com/dotnet/machinelearning/tree/62a5b3440a728908864b9cc30d416f1b16492010+62a5b3440a728908864b9cc30d416f1b16492010")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Core")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.DnnImageFeaturizer.ResNet101")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.ML.DnnImageFeaturizer.ResNet18" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.DnnImageFeaturizer.ResNet18")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyFileVersion("0.12.27602.11")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.12.27602.11 @BuiltBy: dlab14-DDVSOWINAGE082 @Branch: release/1.0 @SrcCode: https://github.com/dotnet/machinelearning/tree/62a5b3440a728908864b9cc30d416f1b16492010+62a5b3440a728908864b9cc30d416f1b16492010")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Core")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.DnnImageFeaturizer.ResNet18")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.ML.DnnImageFeaturizer.ResNet50" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.DnnImageFeaturizer.ResNet50")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyFileVersion("0.12.27602.11")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.12.27602.11 @BuiltBy: dlab14-DDVSOWINAGE082 @Branch: release/1.0 @SrcCode: https://github.com/dotnet/machinelearning/tree/62a5b3440a728908864b9cc30d416f1b16492010+62a5b3440a728908864b9cc30d416f1b16492010")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Core")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.DnnImageFeaturizer.ResNet50")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.ML.OnnxConverter" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("Given a data model, write out the corresponding ONNX.", typeof(Microsoft.ML.Model.OnnxConverter.SaveOnnxCommand), typeof(Microsoft.ML.Model.OnnxConverter.SaveOnnxCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Save ONNX", new System.String[] { "SaveOnnx" }, DocName="command/SaveOnnx.md")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Model.OnnxConverter.SaveOnnxCommand), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "SaveOnnx", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.OnnxConverter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyFileVersion("0.12.27602.11")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.12.27602.11 @BuiltBy: dlab14-DDVSOWINAGE082 @Branch: release/1.0 @SrcCode: https://github.com/dotnet/machinelearning/tree/62a5b3440a728908864b9cc30d416f1b16492010+62a5b3440a728908864b9cc30d416f1b16492010")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Core")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.OnnxConverter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Core.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.ML.OnnxTransformer" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.Onnx.OnnxTransformer))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("Transforms the data using the Onnx model.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Onnx.OnnxTransformer), typeof(Microsoft.ML.Transforms.Onnx.OnnxTransformer/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "ONNX Scoring Transform", new System.String[] { "Onnx", "OnnxTransform", "OnnxScorer" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("Transforms the data using the Onnx model.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Onnx.OnnxTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "ONNX Scoring Transform", new System.String[] { "OnnxTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.Onnx.OnnxTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "ONNX Scoring Transform", new System.String[] { "OnnxTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Onnx.OnnxTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "ONNX Scoring Transform", new System.String[] { "OnnxTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.OnnxTransformer")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyFileVersion("0.12.27602.11")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.12.27602.11 @BuiltBy: dlab14-DDVSOWINAGE082 @Branch: release/1.0 @SrcCode: https://github.com/dotnet/machinelearning/tree/62a5b3440a728908864b9cc30d416f1b16492010+62a5b3440a728908864b9cc30d416f1b16492010")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Core")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.OnnxTransformer")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.DnnImageFeaturizer.AlexNet, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.DnnImageFeaturizer.ResNet101, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.DnnImageFeaturizer.ResNet18, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.DnnImageFeaturizer.ResNet50, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.OnnxTransformer.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.OnnxTransformerTest, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.ML.Recommender" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.Recommender.MatrixFactorizationModelParameters), null, typeof(Microsoft.ML.SignatureLoadModel), "Matrix Factorization Predictor Executor", new System.String[] { "MFPredictor" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.Recommender.MatrixFactorizationPredictionTransformer), typeof(Microsoft.ML.Trainers.Recommender.MatrixFactorizationPredictionTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "", new System.String[] { "MaFactPredXf" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("From pairs of row/column indices and a value of a matrix, this trains a predictor capable of filling in unknown entries of the matrix, using a low-rank matrix factorization. This technique is often used in recommender system, where the row and column indices indicate users and items, and the values of the matrix are ratings. ", typeof(Microsoft.ML.Trainers.MatrixFactorizationTrainer), typeof(Microsoft.ML.Trainers.MatrixFactorizationTrainer/Options), new System.Type[] { typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.SignatureMatrixRecommendingTrainer) }, "Matrix Factorization", new System.String[] { "MatrixFactorization", "libmf", "mf" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.WantsToBeBestFriends</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.Recommender")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyFileVersion("0.12.27602.11")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.12.27602.11 @BuiltBy: dlab14-DDVSOWINAGE082 @Branch: release/1.0 @SrcCode: https://github.com/dotnet/machinelearning/tree/62a5b3440a728908864b9cc30d416f1b16492010+62a5b3440a728908864b9cc30d416f1b16492010")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Core")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.Recommender")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.ML.SamplesUtils" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.SamplesUtils")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyFileVersion("0.12.27602.11")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.12.27602.11 @BuiltBy: dlab14-DDVSOWINAGE082 @Branch: release/1.0 @SrcCode: https://github.com/dotnet/machinelearning/tree/62a5b3440a728908864b9cc30d416f1b16492010+62a5b3440a728908864b9cc30d416f1b16492010")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Core")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.SamplesUtils")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.ML.StaticPipe" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.StaticPipe")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyFileVersion("0.12.27602.11")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.12.27602.11 @BuiltBy: dlab14-DDVSOWINAGE082 @Branch: release/1.0 @SrcCode: https://github.com/dotnet/machinelearning/tree/62a5b3440a728908864b9cc30d416f1b16492010+62a5b3440a728908864b9cc30d416f1b16492010")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Core")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.StaticPipe")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.ML.TensorFlow" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.TensorFlowTransformer))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("Transforms the data using the TensorFlow model.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.TensorFlowTransformer), typeof(Microsoft.ML.Transforms.TensorFlowEstimator/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "TensorFlowTransform", new System.String[] { "TFTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("Transforms the data using the TensorFlow model.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.TensorFlowTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "TensorFlowTransform", new System.String[] { "TensorFlowTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.TensorFlowTransformer), null, typeof(Microsoft.ML.SignatureLoadModel), "TensorFlowTransform", new System.String[] { "TensorFlowTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.TensorFlowTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "TensorFlowTransform", new System.String[] { "TensorFlowTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.TensorFlow")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyFileVersion("0.12.27602.11")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.12.27602.11 @BuiltBy: dlab14-DDVSOWINAGE082 @Branch: release/1.0 @SrcCode: https://github.com/dotnet/machinelearning/tree/62a5b3440a728908864b9cc30d416f1b16492010+62a5b3440a728908864b9cc30d416f1b16492010")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Core")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.TensorFlow")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TensorFlow.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.ML.TimeSeries" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.TimeSeries.TimeSeriesProcessingEntryPoints))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.TimeSeries.AdaptiveSingularSpectrumSequenceModeler), typeof(Microsoft.ML.Transforms.TimeSeries.AdaptiveSingularSpectrumSequenceModeler), null, typeof(Microsoft.ML.SignatureLoadModel), "SSA Sequence Modeler", new System.String[] { "SSAModel" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("Applies a Exponential average on a time series.", typeof(Microsoft.ML.Transforms.TimeSeries.ExponentialAverageTransform), typeof(Microsoft.ML.Transforms.TimeSeries.ExponentialAverageTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Exponential Average Transform", new System.String[] { "ExpAverageTransform", "ExpAvg" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("Applies a Exponential average on a time series.", typeof(Microsoft.ML.Transforms.TimeSeries.ExponentialAverageTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Exponential Average Transform", new System.String[] { "ExpAverageTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("This transform detects the change-points in an i.i.d. sequence using adaptive kernel density estimation and martingales.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.TimeSeries.IidChangePointDetector), typeof(Microsoft.ML.Transforms.TimeSeries.IidChangePointDetector/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "IID Change Point Detection", new System.String[] { "IidChangePointDetector", "ichgpnt" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("This transform detects the change-points in an i.i.d. sequence using adaptive kernel density estimation and martingales.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.TimeSeries.IidChangePointDetector), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "IID Change Point Detection", new System.String[] { "IidChangePointDetector" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("This transform detects the change-points in an i.i.d. sequence using adaptive kernel density estimation and martingales.", typeof(Microsoft.ML.Transforms.TimeSeries.IidChangePointDetector), null, typeof(Microsoft.ML.SignatureLoadModel), "IID Change Point Detection", new System.String[] { "IidChangePointDetector" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.TimeSeries.IidChangePointDetector), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "IID Change Point Detection", new System.String[] { "IidChangePointDetector" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("This transform detects the spikes in a i.i.d. sequence using adaptive kernel density estimation.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.TimeSeries.IidSpikeDetector), typeof(Microsoft.ML.Transforms.TimeSeries.IidSpikeDetector/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "IID Spike Detection", new System.String[] { "IidSpikeDetector", "ispike" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("This transform detects the spikes in a i.i.d. sequence using adaptive kernel density estimation.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.TimeSeries.IidSpikeDetector), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "IID Spike Detection", new System.String[] { "IidSpikeDetector" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("This transform detects the spikes in a i.i.d. sequence using adaptive kernel density estimation.", typeof(Microsoft.ML.Transforms.TimeSeries.IidSpikeDetector), null, typeof(Microsoft.ML.SignatureLoadModel), "IID Spike Detection", new System.String[] { "IidSpikeDetector" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.TimeSeries.IidSpikeDetector), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "IID Spike Detection", new System.String[] { "IidSpikeDetector" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("Applies a moving average on a time series. Only finite values are taken into account.", typeof(Microsoft.ML.Transforms.TimeSeries.MovingAverageTransform), typeof(Microsoft.ML.Transforms.TimeSeries.MovingAverageTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Moving Average Transform", new System.String[] { "MovingAverageTransform", "MoAv" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("Applies a moving average on a time series. Only finite values are taken into account.", typeof(Microsoft.ML.Transforms.TimeSeries.MovingAverageTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Moving Average Transform", new System.String[] { "MovingAverageTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("Detects the values of time-series that are in the top percentile of the sliding window.", typeof(Microsoft.ML.Transforms.TimeSeries.PercentileThresholdTransform), typeof(Microsoft.ML.Transforms.TimeSeries.PercentileThresholdTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Percentile Threshold Transform", new System.String[] { "PercentThrTransform", "TopPcnt" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("Detects the values of time-series that are in the top percentile of the sliding window.", typeof(Microsoft.ML.Transforms.TimeSeries.PercentileThresholdTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Percentile Threshold Transform", new System.String[] { "PercentThrTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("This P-Value transform calculates the p-value of the current input in the sequence with regard to the values in the sliding window.", typeof(Microsoft.ML.Transforms.TimeSeries.PValueTransform), typeof(Microsoft.ML.Transforms.TimeSeries.PValueTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "p-Value Transform", new System.String[] { "PValueTransform", "PVal" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("This P-Value transform calculates the p-value of the current input in the sequence with regard to the values in the sliding window.", typeof(Microsoft.ML.Transforms.TimeSeries.PValueTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "p-Value Transform", new System.String[] { "PValueTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("Returns the last values for a time series [y(t-d-l+1), y(t-d-l+2), ..., y(t-l-1), y(t-l)] where d is the size of the window, l the lag and y is a Float.", typeof(Microsoft.ML.Transforms.TimeSeries.SlidingWindowTransform), typeof(Microsoft.ML.Transforms.TimeSeries.SlidingWindowTransformBase`1/Arguments&lt;System.Single&gt;), typeof(Microsoft.ML.Data.SignatureDataTransform), "Sliding Window Transform", new System.String[] { "SlideWinTransform", "SlideWin" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("Returns the last values for a time series [y(t-d-l+1), y(t-d-l+2), ..., y(t-l-1), y(t-l)] where d is the size of the window, l the lag and y is a Float.", typeof(Microsoft.ML.Transforms.TimeSeries.SlidingWindowTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Sliding Window Transform", new System.String[] { "SlideWinTransform" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("This transform detects the change-points in a seasonal time-series using Singular Spectrum Analysis (SSA).", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.TimeSeries.SsaChangePointDetector), typeof(Microsoft.ML.Transforms.TimeSeries.SsaChangePointDetector/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "SSA Change Point Detection", new System.String[] { "SsaChangePointDetector", "chgpnt" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("This transform detects the change-points in a seasonal time-series using Singular Spectrum Analysis (SSA).", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.TimeSeries.SsaChangePointDetector), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "SSA Change Point Detection", new System.String[] { "SsaChangePointDetector" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("This transform detects the change-points in a seasonal time-series using Singular Spectrum Analysis (SSA).", typeof(Microsoft.ML.Transforms.TimeSeries.SsaChangePointDetector), null, typeof(Microsoft.ML.SignatureLoadModel), "SSA Change Point Detection", new System.String[] { "SsaChangePointDetector" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.TimeSeries.SsaChangePointDetector), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "SSA Change Point Detection", new System.String[] { "SsaChangePointDetector" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("This transform detects the spikes in a seasonal time-series using Singular Spectrum Analysis (SSA).", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.TimeSeries.SsaSpikeDetector), typeof(Microsoft.ML.Transforms.TimeSeries.SsaSpikeDetector/Options), typeof(Microsoft.ML.Data.SignatureDataTransform), "SSA Spike Detection", new System.String[] { "SsaSpikeDetector", "spike" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("This transform detects the spikes in a seasonal time-series using Singular Spectrum Analysis (SSA).", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.TimeSeries.SsaSpikeDetector), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "SSA Spike Detection", new System.String[] { "SsaSpikeDetector" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass("This transform detects the spikes in a seasonal time-series using Singular Spectrum Analysis (SSA).", typeof(Microsoft.ML.Transforms.TimeSeries.SsaSpikeDetector), null, typeof(Microsoft.ML.SignatureLoadModel), "SSA Spike Detection", new System.String[] { "SsaSpikeDetector" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.TimeSeries.SsaSpikeDetector), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "SSA Spike Detection", new System.String[] { "SsaSpikeDetector" })</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>Microsoft.ML.WantsToBeBestFriends</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.TimeSeries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyFileVersion("0.12.27602.11")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.12.27602.11 @BuiltBy: dlab14-DDVSOWINAGE082 @Branch: release/1.0 @SrcCode: https://github.com/dotnet/machinelearning/tree/62a5b3440a728908864b9cc30d416f1b16492010+62a5b3440a728908864b9cc30d416f1b16492010")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Core")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.TimeSeries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TimeSeries.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Core.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="ml-dotnet-preview">
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
  </Assemblies>
  <Remarks>To be added.</Remarks>
  <Copyright>To be added.</Copyright>
  <Types>
    <Namespace Name="Microsoft.ML">
      <Type Name="AlexNetExtension" Kind="Class" />
      <Type Name="AnomalyDetectionCatalog" Kind="Class" />
      <Type Name="AnomalyDetectionCatalog+AnomalyDetectionTrainers" Kind="Class" />
      <Type Name="BinaryClassificationCatalog" Kind="Class" />
      <Type Name="BinaryClassificationCatalog+BinaryClassificationTrainers" Kind="Class" />
      <Type Name="BinaryClassificationCatalog+CalibratorsCatalog" Kind="Class" />
      <Type Name="BinaryLoaderSaverCatalog" Kind="Class" />
      <Type Name="CategoricalCatalog" Kind="Class" />
      <Type Name="ClusteringCatalog" Kind="Class" />
      <Type Name="ClusteringCatalog+ClusteringTrainers" Kind="Class" />
      <Type Name="ConversionsCatalog" Kind="Class" />
      <Type Name="ConversionsExtensionsCatalog" Kind="Class" />
      <Type Name="CustomMappingCatalog" Kind="Class" />
      <Type Name="DataLoaderExtensions" Kind="Class" />
      <Type Name="DataOperationsCatalog" Kind="Class" />
      <Type Name="DataOperationsCatalog+TrainTestData" Kind="Structure" />
      <Type Name="DataViewRow" Kind="Class" />
      <Type Name="DataViewRowCursor" Kind="Class" />
      <Type Name="DataViewSchema" Kind="Class" />
      <Type Name="DataViewSchema+Annotations" Kind="Class" />
      <Type Name="DataViewSchema+Annotations+Builder" Kind="Class" />
      <Type Name="DataViewSchema+Builder" Kind="Class" />
      <Type Name="DataViewSchema+Column" Kind="Structure" />
      <Type Name="DataViewSchema+DetachedColumn" Kind="Structure" />
      <Type Name="DebuggerExtensions" Kind="Class" />
      <Type Name="ExplainabilityCatalog" Kind="Class" />
      <Type Name="ExtensionBaseAttribute" Kind="Class" />
      <Type Name="ExtensionsCatalog" Kind="Class" />
      <Type Name="FactorizationMachineExtensions" Kind="Class" />
      <Type Name="FeatureSelectionCatalog" Kind="Class" />
      <Type Name="ICanSaveModel" Kind="Interface" />
      <Type Name="IDataLoader`1" DisplayName="IDataLoader&lt;TSource&gt;" Kind="Interface" />
      <Type Name="IDataLoaderEstimator`2" DisplayName="IDataLoaderEstimator&lt;TSource,TLoader&gt;" Kind="Interface" />
      <Type Name="IDataView" Kind="Interface" />
      <Type Name="IEstimator`1" DisplayName="IEstimator&lt;TTransformer&gt;" Kind="Interface" />
      <Type Name="ImageEstimatorsCatalog" Kind="Class" />
      <Type Name="InputOutputColumnPair" Kind="Class" />
      <Type Name="IPredictionTransformer`1" DisplayName="IPredictionTransformer&lt;TModel&gt;" Kind="Interface" />
      <Type Name="ISingleFeaturePredictionTransformer`1" DisplayName="ISingleFeaturePredictionTransformer&lt;TModel&gt;" Kind="Interface" />
      <Type Name="ITransformer" Kind="Interface" />
      <Type Name="KernelExpansionCatalog" Kind="Class" />
      <Type Name="KMeansClusteringExtensions" Kind="Class" />
      <Type Name="LearningPipelineExtensions" Kind="Class" />
      <Type Name="LightGbmExtensions" Kind="Class" />
      <Type Name="LoggingEventArgs" Kind="Class" />
      <Type Name="MklComponentsCatalog" Kind="Class" />
      <Type Name="MLContext" Kind="Class" />
      <Type Name="ModelOperationsCatalog" Kind="Class" />
      <Type Name="ModelSaveContext" Kind="Class" />
      <Type Name="MulticlassClassificationCatalog" Kind="Class" />
      <Type Name="MulticlassClassificationCatalog+MulticlassClassificationTrainers" Kind="Class" />
      <Type Name="NormalizationCatalog" Kind="Class" />
      <Type Name="OnnxCatalog" Kind="Class" />
      <Type Name="OnnxExportExtensions" Kind="Class" />
      <Type Name="PcaCatalog" Kind="Class" />
      <Type Name="PermutationFeatureImportanceExtensions" Kind="Class" />
      <Type Name="PredictionEngine`2" DisplayName="PredictionEngine&lt;TSrc,TDst&gt;" Kind="Class" />
      <Type Name="PredictionEngineBase`2" DisplayName="PredictionEngineBase&lt;TSrc,TDst&gt;" Kind="Class" />
      <Type Name="RankingCatalog" Kind="Class" />
      <Type Name="RankingCatalog+RankingTrainers" Kind="Class" />
      <Type Name="RecommendationCatalog" Kind="Class" />
      <Type Name="RecommendationCatalog+RecommendationTrainers" Kind="Class" />
      <Type Name="RecommenderCatalog" Kind="Class" />
      <Type Name="RegressionCatalog" Kind="Class" />
      <Type Name="RegressionCatalog+RegressionTrainers" Kind="Class" />
      <Type Name="ResNet101Extension" Kind="Class" />
      <Type Name="ResNet18Extension" Kind="Class" />
      <Type Name="ResNet50Extension" Kind="Class" />
      <Type Name="SchemaShape" Kind="Class" />
      <Type Name="SchemaShape+Column" Kind="Structure" />
      <Type Name="SchemaShape+Column+VectorKind" Kind="Enumeration" />
      <Type Name="StandardTrainersCatalog" Kind="Class" />
      <Type Name="TensorflowCatalog" Kind="Class" />
      <Type Name="TextCatalog" Kind="Class" />
      <Type Name="TextLoaderSaverCatalog" Kind="Class" />
      <Type Name="TimeSeriesCatalog" Kind="Class" />
      <Type Name="TrainCatalogBase" Kind="Class" />
      <Type Name="TrainCatalogBase+CatalogInstantiatorBase" Kind="Class" />
      <Type Name="TrainCatalogBase+CrossValidationResult`1" DisplayName="TrainCatalogBase+CrossValidationResult&lt;T&gt;" Kind="Class" />
      <Type Name="TrainerInfo" Kind="Class" />
      <Type Name="TransformExtensionsCatalog" Kind="Class" />
      <Type Name="TransformsCatalog" Kind="Class" />
      <Type Name="TransformsCatalog+CategoricalTransforms" Kind="Class" />
      <Type Name="TransformsCatalog+ConversionTransforms" Kind="Class" />
      <Type Name="TransformsCatalog+FeatureSelectionTransforms" Kind="Class" />
      <Type Name="TransformsCatalog+TextTransforms" Kind="Class" />
      <Type Name="TreeExtensions" Kind="Class" />
      <Type Name="ValueGetter`1" DisplayName="ValueGetter&lt;TValue&gt;" Kind="Delegate" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Calibrators">
      <Type Name="CalibratedModelParametersBase" Kind="Class" />
      <Type Name="CalibratedModelParametersBase`2" DisplayName="CalibratedModelParametersBase&lt;TSubModel,TCalibrator&gt;" Kind="Class" />
      <Type Name="CalibratorEstimatorBase`1" DisplayName="CalibratorEstimatorBase&lt;TICalibrator&gt;" Kind="Class" />
      <Type Name="CalibratorTransformer`1" DisplayName="CalibratorTransformer&lt;TICalibrator&gt;" Kind="Class" />
      <Type Name="FixedPlattCalibratorEstimator" Kind="Class" />
      <Type Name="ICalibrator" Kind="Interface" />
      <Type Name="IsotonicCalibrator" Kind="Class" />
      <Type Name="IsotonicCalibratorEstimator" Kind="Class" />
      <Type Name="IsotonicCalibratorTransformer" Kind="Class" />
      <Type Name="NaiveCalibrator" Kind="Class" />
      <Type Name="NaiveCalibratorEstimator" Kind="Class" />
      <Type Name="NaiveCalibratorTransformer" Kind="Class" />
      <Type Name="PlattCalibrator" Kind="Class" />
      <Type Name="PlattCalibratorEstimator" Kind="Class" />
      <Type Name="PlattCalibratorTransformer" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Data">
      <Type Name="AnomalyDetectionMetrics" Kind="Class" />
      <Type Name="AnomalyPredictionTransformer`1" DisplayName="AnomalyPredictionTransformer&lt;TModel&gt;" Kind="Class" />
      <Type Name="BinaryClassificationMetrics" Kind="Class" />
      <Type Name="BinaryClassificationMetricsStatistics" Kind="Class" />
      <Type Name="BinaryPrecisionRecallDataPoint" Kind="Class" />
      <Type Name="BinaryPredictionTransformer`1" DisplayName="BinaryPredictionTransformer&lt;TModel&gt;" Kind="Class" />
      <Type Name="BooleanDataViewType" Kind="Class" />
      <Type Name="CalibratedBinaryClassificationMetrics" Kind="Class" />
      <Type Name="ClusteringMetrics" Kind="Class" />
      <Type Name="ClusteringPredictionTransformer`1" DisplayName="ClusteringPredictionTransformer&lt;TModel&gt;" Kind="Class" />
      <Type Name="ColumnConcatenatingTransformer" Kind="Class" />
      <Type Name="ColumnCursorExtensions" Kind="Class" />
      <Type Name="ColumnNameAttribute" Kind="Class" />
      <Type Name="CompositeDataLoader`2" DisplayName="CompositeDataLoader&lt;TSource,TLastTransformer&gt;" Kind="Class" />
      <Type Name="CompositeLoaderEstimator`2" DisplayName="CompositeLoaderEstimator&lt;TSource,TLastTransformer&gt;" Kind="Class" />
      <Type Name="DataDebuggerPreview" Kind="Class" />
      <Type Name="DataDebuggerPreview+ColumnInfo" Kind="Class" />
      <Type Name="DataDebuggerPreview+RowInfo" Kind="Class" />
      <Type Name="DataKind" Kind="Enumeration" />
      <Type Name="DataViewRowId" Kind="Structure" />
      <Type Name="DataViewType" Kind="Class" />
      <Type Name="DateTimeDataViewType" Kind="Class" />
      <Type Name="DateTimeOffsetDataViewType" Kind="Class" />
      <Type Name="EstimatorChain`1" DisplayName="EstimatorChain&lt;TLastTransformer&gt;" Kind="Class" />
      <Type Name="FileHandleSource" Kind="Class" />
      <Type Name="IFileHandle" Kind="Interface" />
      <Type Name="ImageLoadingEstimator" Kind="Class" />
      <Type Name="ImageLoadingTransformer" Kind="Class" />
      <Type Name="IMultiStreamSource" Kind="Interface" />
      <Type Name="IRowToRowMapper" Kind="Interface" />
      <Type Name="KeyCount" Kind="Class" />
      <Type Name="KeyDataViewType" Kind="Class" />
      <Type Name="KeyTypeAttribute" Kind="Class" />
      <Type Name="LoadColumnAttribute" Kind="Class" />
      <Type Name="MetricStatistics" Kind="Class" />
      <Type Name="MulticlassClassificationMetrics" Kind="Class" />
      <Type Name="MulticlassClassificationMetricsStatistics" Kind="Class" />
      <Type Name="MulticlassPredictionTransformer`1" DisplayName="MulticlassPredictionTransformer&lt;TModel&gt;" Kind="Class" />
      <Type Name="MultiFileSource" Kind="Class" />
      <Type Name="NoColumnAttribute" Kind="Class" />
      <Type Name="NumberDataViewType" Kind="Class" />
      <Type Name="OneToOneTransformerBase" Kind="Class" />
      <Type Name="PredictionTransformerBase`1" DisplayName="PredictionTransformerBase&lt;TModel&gt;" Kind="Class" />
      <Type Name="PrimitiveDataViewType" Kind="Class" />
      <Type Name="RankingMetrics" Kind="Class" />
      <Type Name="RankingMetricsStatistics" Kind="Class" />
      <Type Name="RankingPredictionTransformer`1" DisplayName="RankingPredictionTransformer&lt;TModel&gt;" Kind="Class" />
      <Type Name="RegressionMetrics" Kind="Class" />
      <Type Name="RegressionMetricsStatistics" Kind="Class" />
      <Type Name="RegressionPredictionTransformer`1" DisplayName="RegressionPredictionTransformer&lt;TModel&gt;" Kind="Class" />
      <Type Name="RowIdDataViewType" Kind="Class" />
      <Type Name="RowToRowTransformerBase" Kind="Class" />
      <Type Name="SchemaAnnotationsExtensions" Kind="Class" />
      <Type Name="SchemaDefinition" Kind="Class" />
      <Type Name="SchemaDefinition+Column" Kind="Class" />
      <Type Name="SchemaDefinition+Direction" Kind="Enumeration" />
      <Type Name="SimpleFileHandle" Kind="Class" />
      <Type Name="SingleFeaturePredictionTransformerBase`1" DisplayName="SingleFeaturePredictionTransformerBase&lt;TModel&gt;" Kind="Class" />
      <Type Name="StructuredDataViewType" Kind="Class" />
      <Type Name="TextDataViewType" Kind="Class" />
      <Type Name="TextLoader" Kind="Class" />
      <Type Name="TextLoader+Column" Kind="Class" />
      <Type Name="TextLoader+Options" Kind="Class" />
      <Type Name="TextLoader+Range" Kind="Class" />
      <Type Name="TimeSpanDataViewType" Kind="Class" />
      <Type Name="TransformerChain`1" DisplayName="TransformerChain&lt;TLastTransformer&gt;" Kind="Class" />
      <Type Name="TransformerScope" Kind="Enumeration" />
      <Type Name="TrivialEstimator`1" DisplayName="TrivialEstimator&lt;TTransformer&gt;" Kind="Class" />
      <Type Name="VBuffer`1" DisplayName="VBuffer&lt;T&gt;" Kind="Structure" />
      <Type Name="VBufferEditor" Kind="Class" />
      <Type Name="VBufferEditor`1" DisplayName="VBufferEditor&lt;T&gt;" Kind="Structure" />
      <Type Name="VectorDataViewType" Kind="Class" />
      <Type Name="VectorTypeAttribute" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime">
      <Type Name="ChannelMessage" Kind="Structure" />
      <Type Name="ChannelMessageKind" Kind="Enumeration" />
      <Type Name="ComponentCatalog" Kind="Class" />
      <Type Name="IChannel" Kind="Interface" />
      <Type Name="IChannelProvider" Kind="Interface" />
      <Type Name="IComponentFactory" Kind="Interface" />
      <Type Name="IComponentFactory`1" DisplayName="IComponentFactory&lt;TComponent&gt;" Kind="Interface" />
      <Type Name="IComponentFactory`2" DisplayName="IComponentFactory&lt;TArg1,TComponent&gt;" Kind="Interface" />
      <Type Name="IComponentFactory`3" DisplayName="IComponentFactory&lt;TArg1,TArg2,TComponent&gt;" Kind="Interface" />
      <Type Name="IComponentFactory`4" DisplayName="IComponentFactory&lt;TArg1,TArg2,TArg3,TComponent&gt;" Kind="Interface" />
      <Type Name="IExceptionContext" Kind="Interface" />
      <Type Name="IHost" Kind="Interface" />
      <Type Name="IHostEnvironment" Kind="Interface" />
      <Type Name="IPipe`1" DisplayName="IPipe&lt;TMessage&gt;" Kind="Interface" />
      <Type Name="IProgressChannel" Kind="Interface" />
      <Type Name="IProgressChannelProvider" Kind="Interface" />
      <Type Name="IProgressEntry" Kind="Interface" />
      <Type Name="MessageSensitivity" Kind="Enumeration" />
      <Type Name="ProgressHeader" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.SamplesUtils">
      <Type Name="ConsoleUtils" Kind="Class" />
      <Type Name="DatasetUtils" Kind="Class" />
      <Type Name="DatasetUtils+BinaryLabelFloatFeatureVectorFloatWeightSample" Kind="Class" />
      <Type Name="DatasetUtils+CalibratedBinaryClassifierOutput" Kind="Class" />
      <Type Name="DatasetUtils+FfmExample" Kind="Class" />
      <Type Name="DatasetUtils+FloatLabelFloatFeatureVectorSample" Kind="Class" />
      <Type Name="DatasetUtils+HousingRegression" Kind="Class" />
      <Type Name="DatasetUtils+MatrixElement" Kind="Class" />
      <Type Name="DatasetUtils+MatrixElementForScore" Kind="Class" />
      <Type Name="DatasetUtils+MulticlassClassificationExample" Kind="Class" />
      <Type Name="DatasetUtils+NonCalibratedBinaryClassifierOutput" Kind="Class" />
      <Type Name="DatasetUtils+SampleInfertData" Kind="Class" />
      <Type Name="DatasetUtils+SampleInput" Kind="Class" />
      <Type Name="DatasetUtils+SampleSentimentData" Kind="Class" />
      <Type Name="DatasetUtils+SampleTemperatureData" Kind="Class" />
      <Type Name="DatasetUtils+SampleTemperatureDataWithLatitude" Kind="Class" />
      <Type Name="DatasetUtils+SampleTopicsData" Kind="Class" />
      <Type Name="DatasetUtils+SampleVectorOfNumbersData" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.StaticPipe">
      <Type Name="ApproximatedKernelMappingStaticExtenensions" Kind="Class" />
      <Type Name="AveragedPerceptronStaticExtensions" Kind="Class" />
      <Type Name="CategoricalHashStaticExtensions" Kind="Class" />
      <Type Name="CategoricalHashStaticExtensions+OneHotHashScalarOutputKind" Kind="Enumeration" />
      <Type Name="CategoricalHashStaticExtensions+OneHotHashVectorOutputKind" Kind="Enumeration" />
      <Type Name="CategoricalStaticExtensions" Kind="Class" />
      <Type Name="CategoricalStaticExtensions+OneHotScalarOutputKind" Kind="Enumeration" />
      <Type Name="CategoricalStaticExtensions+OneHotVectorOutputKind" Kind="Enumeration" />
      <Type Name="CharacterTokenizerStaticExtensions" Kind="Class" />
      <Type Name="ConcatStaticExtensions" Kind="Class" />
      <Type Name="ConcatStaticExtensions+ScalarOrVector`1" DisplayName="ConcatStaticExtensions+ScalarOrVector&lt;T&gt;" Kind="Class" />
      <Type Name="ConcatStaticExtensions+ScalarOrVectorOrVarVector`1" DisplayName="ConcatStaticExtensions+ScalarOrVectorOrVarVector&lt;T&gt;" Kind="Class" />
      <Type Name="ConvertStaticExtensions" Kind="Class" />
      <Type Name="CountFeatureSelectorStaticExtensions" Kind="Class" />
      <Type Name="Custom`1" DisplayName="Custom&lt;T&gt;" Kind="Class" />
      <Type Name="DataLoader`2" DisplayName="DataLoader&lt;TIn,TShape&gt;" Kind="Class" />
      <Type Name="DataLoaderEstimator`3" DisplayName="DataLoaderEstimator&lt;TIn,TShape,TDataLoader&gt;" Kind="Class" />
      <Type Name="DataLoadSaveOperationsExtensions" Kind="Class" />
      <Type Name="DataView`1" DisplayName="DataView&lt;TShape&gt;" Kind="Class" />
      <Type Name="DataViewExtensions" Kind="Class" />
      <Type Name="Estimator`3" DisplayName="Estimator&lt;TInShape,TOutShape,TTransformer&gt;" Kind="Class" />
      <Type Name="EstimatorReconciler" Kind="Class" />
      <Type Name="EvaluatorStaticExtensions" Kind="Class" />
      <Type Name="FactorizationMachineExtensions" Kind="Class" />
      <Type Name="GlobalContrastNormalizerStaticExtensions" Kind="Class" />
      <Type Name="ImageGreyScalingStaticExtensions" Kind="Class" />
      <Type Name="ImageLoadingStaticExtensions" Kind="Class" />
      <Type Name="ImagePixelExtractingStaticExtensions" Kind="Class" />
      <Type Name="ImageResizingStaticExtensions" Kind="Class" />
      <Type Name="ImageStaticPipe" Kind="Class" />
      <Type Name="IsShapeAttribute" Kind="Class" />
      <Type Name="Key`1" DisplayName="Key&lt;T&gt;" Kind="Class" />
      <Type Name="Key`2" DisplayName="Key&lt;T,TVal&gt;" Kind="Class" />
      <Type Name="KeyOrdinality" Kind="Enumeration" />
      <Type Name="KeyToBinaryVectorStaticExtensions" Kind="Class" />
      <Type Name="KeyToValueStaticExtensions" Kind="Class" />
      <Type Name="KeyToVectorStaticExtensions" Kind="Class" />
      <Type Name="KMeansClusteringExtensions" Kind="Class" />
      <Type Name="LatentDirichletAllocationFitResult" Kind="Class" />
      <Type Name="LatentDirichletAllocationFitResult+OnFit" Kind="Delegate" />
      <Type Name="LatentDirichletAllocationStaticExtensions" Kind="Class" />
      <Type Name="LbfgsBinaryStaticExtensions" Kind="Class" />
      <Type Name="LbfgsMulticlassStaticExtensions" Kind="Class" />
      <Type Name="LbfgsRegressionStaticExtensions" Kind="Class" />
      <Type Name="LoaderReconciler`1" DisplayName="LoaderReconciler&lt;TIn&gt;" Kind="Class" />
      <Type Name="LocalPathReader" Kind="Class" />
      <Type Name="LpNormNormalizerStaticExtensions" Kind="Class" />
      <Type Name="MatrixFactorizationExtensions" Kind="Class" />
      <Type Name="MulticlassClassificationStaticExtensions" Kind="Class" />
      <Type Name="MutualInformationFeatureSelectorStaticExtensions" Kind="Class" />
      <Type Name="NAIndicatorStaticExtensions" Kind="Class" />
      <Type Name="NAReplacerStaticExtensions" Kind="Class" />
      <Type Name="NgramEstimatorStaticExtensions" Kind="Class" />
      <Type Name="NgramHashEstimatorStaticExtensions" Kind="Class" />
      <Type Name="NormalizerStaticExtensions" Kind="Class" />
      <Type Name="NormalizerStaticExtensions+OnFitAffine`1" DisplayName="NormalizerStaticExtensions+OnFitAffine&lt;TData&gt;" Kind="Delegate" />
      <Type Name="NormalizerStaticExtensions+OnFitBinned`1" DisplayName="NormalizerStaticExtensions+OnFitBinned&lt;TData&gt;" Kind="Delegate" />
      <Type Name="NormalizerStaticExtensions+OnFitCumulativeDistribution`1" DisplayName="NormalizerStaticExtensions+OnFitCumulativeDistribution&lt;TData&gt;" Kind="Delegate" />
      <Type Name="NormVector`1" DisplayName="NormVector&lt;T&gt;" Kind="Class" />
      <Type Name="OnlineGradientDescentExtensions" Kind="Class" />
      <Type Name="PcaStaticExtensions" Kind="Class" />
      <Type Name="PipelineColumn" Kind="Class" />
      <Type Name="Reconciler" Kind="Class" />
      <Type Name="Scalar`1" DisplayName="Scalar&lt;T&gt;" Kind="Class" />
      <Type Name="SchemaAssertionContext" Kind="Class" />
      <Type Name="SchemaAssertionContext+KeyTypeSelectorAssertions`1" DisplayName="SchemaAssertionContext+KeyTypeSelectorAssertions&lt;T&gt;" Kind="Structure" />
      <Type Name="SchemaAssertionContext+KeyTypeVectorAssertions`1" DisplayName="SchemaAssertionContext+KeyTypeVectorAssertions&lt;T&gt;" Kind="Structure" />
      <Type Name="SchemaAssertionContext+NormalizableTypeAssertions`1" DisplayName="SchemaAssertionContext+NormalizableTypeAssertions&lt;T&gt;" Kind="Structure" />
      <Type Name="SchemaAssertionContext+PrimitiveTypeAssertions`1" DisplayName="SchemaAssertionContext+PrimitiveTypeAssertions&lt;T&gt;" Kind="Structure" />
      <Type Name="SchemaBearing`1" DisplayName="SchemaBearing&lt;TShape&gt;" Kind="Class" />
      <Type Name="SdcaStaticExtensions" Kind="Class" />
      <Type Name="SgdStaticExtensions" Kind="Class" />
      <Type Name="StaticPipeExtensions" Kind="Class" />
      <Type Name="StaticPipeUtils" Kind="Class" />
      <Type Name="StaticPipeUtils+IndexHelper`1" DisplayName="StaticPipeUtils+IndexHelper&lt;T&gt;" Kind="Class" />
      <Type Name="StopwordRemoverStaticExtensions" Kind="Class" />
      <Type Name="TermStaticExtensions" Kind="Class" />
      <Type Name="TermStaticExtensions+ToKeyFitResult`1" DisplayName="TermStaticExtensions+ToKeyFitResult&lt;T&gt;" Kind="Class" />
      <Type Name="TermStaticExtensions+ToKeyFitResult`1+OnFit" DisplayName="TermStaticExtensions+ToKeyFitResult&lt;T&gt;+OnFit" Kind="Delegate" />
      <Type Name="TextFeaturizerStaticExtensions" Kind="Class" />
      <Type Name="TextLoaderStatic" Kind="Class" />
      <Type Name="TextLoaderStatic+Context" Kind="Class" />
      <Type Name="TextNormalizerStaticExtensions" Kind="Class" />
      <Type Name="TrainerEstimatorReconciler" Kind="Class" />
      <Type Name="TrainerEstimatorReconciler+BinaryClassifier" Kind="Class" />
      <Type Name="TrainerEstimatorReconciler+BinaryClassifier+EstimatorFactory" Kind="Delegate" />
      <Type Name="TrainerEstimatorReconciler+BinaryClassifierNoCalibration" Kind="Class" />
      <Type Name="TrainerEstimatorReconciler+BinaryClassifierNoCalibration+EstimatorFactory" Kind="Delegate" />
      <Type Name="TrainerEstimatorReconciler+Clustering" Kind="Class" />
      <Type Name="TrainerEstimatorReconciler+Clustering+EstimatorFactory" Kind="Delegate" />
      <Type Name="TrainerEstimatorReconciler+MulticlassClassificationReconciler`1" DisplayName="TrainerEstimatorReconciler+MulticlassClassificationReconciler&lt;TVal&gt;" Kind="Class" />
      <Type Name="TrainerEstimatorReconciler+MulticlassClassificationReconciler`1+EstimatorFactory" DisplayName="TrainerEstimatorReconciler+MulticlassClassificationReconciler&lt;TVal&gt;+EstimatorFactory" Kind="Delegate" />
      <Type Name="TrainerEstimatorReconciler+Ranker`1" DisplayName="TrainerEstimatorReconciler+Ranker&lt;TVal&gt;" Kind="Class" />
      <Type Name="TrainerEstimatorReconciler+Ranker`1+EstimatorFactory" DisplayName="TrainerEstimatorReconciler+Ranker&lt;TVal&gt;+EstimatorFactory" Kind="Delegate" />
      <Type Name="TrainerEstimatorReconciler+Regression" Kind="Class" />
      <Type Name="TrainerEstimatorReconciler+Regression+EstimatorFactory" Kind="Delegate" />
      <Type Name="TrainingStaticExtensions" Kind="Class" />
      <Type Name="Transformer`3" DisplayName="Transformer&lt;TInShape,TOutShape,TTransformer&gt;" Kind="Class" />
      <Type Name="TreeRegressionExtensions" Kind="Class" />
      <Type Name="UnknownSizeBitmap" Kind="Class" />
      <Type Name="VarKey`1" DisplayName="VarKey&lt;T&gt;" Kind="Class" />
      <Type Name="VarVector`1" DisplayName="VarVector&lt;T&gt;" Kind="Class" />
      <Type Name="Vector`1" DisplayName="Vector&lt;T&gt;" Kind="Class" />
      <Type Name="WordBagEstimatorStaticExtensions" Kind="Class" />
      <Type Name="WordEmbeddingsStaticExtensions" Kind="Class" />
      <Type Name="WordHashBagEstimatorStaticExtensions" Kind="Class" />
      <Type Name="WordTokenizerStaticExtensions" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Trainers">
      <Type Name="AveragedLinearOptions" Kind="Class" />
      <Type Name="AveragedLinearTrainer`2" DisplayName="AveragedLinearTrainer&lt;TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="AveragedPerceptronTrainer" Kind="Class" />
      <Type Name="AveragedPerceptronTrainer+Options" Kind="Class" />
      <Type Name="CoefficientStatistics" Kind="Class" />
      <Type Name="ComputeLogisticRegressionStandardDeviation" Kind="Class" />
      <Type Name="ComputeLRTrainingStdThroughMkl" Kind="Class" />
      <Type Name="ExpLoss" Kind="Class" />
      <Type Name="FeatureContributionCalculator" Kind="Class" />
      <Type Name="FieldAwareFactorizationMachineModelParameters" Kind="Class" />
      <Type Name="FieldAwareFactorizationMachinePredictionTransformer" Kind="Class" />
      <Type Name="FieldAwareFactorizationMachineTrainer" Kind="Class" />
      <Type Name="FieldAwareFactorizationMachineTrainer+Options" Kind="Class" />
      <Type Name="HingeLoss" Kind="Class" />
      <Type Name="ICalculateFeatureContribution" Kind="Interface" />
      <Type Name="IClassificationLoss" Kind="Interface" />
      <Type Name="ILossFunction`2" DisplayName="ILossFunction&lt;TOutput,TLabel&gt;" Kind="Interface" />
      <Type Name="IRegressionLoss" Kind="Interface" />
      <Type Name="IScalarLoss" Kind="Interface" />
      <Type Name="ISupportSdcaClassificationLoss" Kind="Interface" />
      <Type Name="ISupportSdcaLoss" Kind="Interface" />
      <Type Name="ISupportSdcaRegressionLoss" Kind="Interface" />
      <Type Name="ITrainerEstimator`2" DisplayName="ITrainerEstimator&lt;TTransformer,TModel&gt;" Kind="Interface" />
      <Type Name="KMeansModelParameters" Kind="Class" />
      <Type Name="KMeansTrainer" Kind="Class" />
      <Type Name="KMeansTrainer+InitializationAlgorithm" Kind="Enumeration" />
      <Type Name="KMeansTrainer+Options" Kind="Class" />
      <Type Name="LbfgsLogisticRegressionBinaryTrainer" Kind="Class" />
      <Type Name="LbfgsLogisticRegressionBinaryTrainer+Options" Kind="Class" />
      <Type Name="LbfgsMaximumEntropyMulticlassTrainer" Kind="Class" />
      <Type Name="LbfgsMaximumEntropyMulticlassTrainer+Options" Kind="Class" />
      <Type Name="LbfgsPoissonRegressionTrainer" Kind="Class" />
      <Type Name="LbfgsPoissonRegressionTrainer+Options" Kind="Class" />
      <Type Name="LbfgsTrainerBase`3" DisplayName="LbfgsTrainerBase&lt;TOptions,TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="LbfgsTrainerBase`3+OptionsBase" DisplayName="LbfgsTrainerBase&lt;TOptions,TTransformer,TModel&gt;+OptionsBase" Kind="Class" />
      <Type Name="LinearBinaryModelParameters" Kind="Class" />
      <Type Name="LinearModelParameters" Kind="Class" />
      <Type Name="LinearModelParameterStatistics" Kind="Class" />
      <Type Name="LinearMulticlassModelParameters" Kind="Class" />
      <Type Name="LinearMulticlassModelParametersBase" Kind="Class" />
      <Type Name="LinearRegressionModelParameters" Kind="Class" />
      <Type Name="LinearSvmTrainer" Kind="Class" />
      <Type Name="LinearSvmTrainer+Options" Kind="Class" />
      <Type Name="LinearTrainerBase`2" DisplayName="LinearTrainerBase&lt;TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="LogLoss" Kind="Class" />
      <Type Name="MatrixFactorizationTrainer" Kind="Class" />
      <Type Name="MatrixFactorizationTrainer+LossFunctionType" Kind="Enumeration" />
      <Type Name="MatrixFactorizationTrainer+Options" Kind="Class" />
      <Type Name="MaximumEntropyModelParameters" Kind="Class" />
      <Type Name="MetaMulticlassTrainer`2" DisplayName="MetaMulticlassTrainer&lt;TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="ModelParametersBase`1" DisplayName="ModelParametersBase&lt;TOutput&gt;" Kind="Class" />
      <Type Name="ModelStatisticsBase" Kind="Class" />
      <Type Name="NaiveBayesMulticlassModelParameters" Kind="Class" />
      <Type Name="NaiveBayesMulticlassTrainer" Kind="Class" />
      <Type Name="OlsModelParameters" Kind="Class" />
      <Type Name="OlsTrainer" Kind="Class" />
      <Type Name="OlsTrainer+Options" Kind="Class" />
      <Type Name="OneVersusAllModelParameters" Kind="Class" />
      <Type Name="OneVersusAllTrainer" Kind="Class" />
      <Type Name="OnlineGradientDescentTrainer" Kind="Class" />
      <Type Name="OnlineGradientDescentTrainer+Options" Kind="Class" />
      <Type Name="OnlineLinearOptions" Kind="Class" />
      <Type Name="OnlineLinearTrainer`2" DisplayName="OnlineLinearTrainer&lt;TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="PairwiseCouplingModelParameters" Kind="Class" />
      <Type Name="PairwiseCouplingTrainer" Kind="Class" />
      <Type Name="PcaModelParameters" Kind="Class" />
      <Type Name="PoissonLoss" Kind="Class" />
      <Type Name="PoissonRegressionModelParameters" Kind="Class" />
      <Type Name="PriorModelParameters" Kind="Class" />
      <Type Name="PriorTrainer" Kind="Class" />
      <Type Name="RandomizedPcaTrainer" Kind="Class" />
      <Type Name="RandomizedPcaTrainer+Options" Kind="Class" />
      <Type Name="RegressionModelParameters" Kind="Class" />
      <Type Name="SdcaBinaryTrainerBase`1" DisplayName="SdcaBinaryTrainerBase&lt;TModelParameters&gt;" Kind="Class" />
      <Type Name="SdcaBinaryTrainerBase`1+BinaryOptionsBase" DisplayName="SdcaBinaryTrainerBase&lt;TModelParameters&gt;+BinaryOptionsBase" Kind="Class" />
      <Type Name="SdcaLogisticRegressionBinaryTrainer" Kind="Class" />
      <Type Name="SdcaLogisticRegressionBinaryTrainer+Options" Kind="Class" />
      <Type Name="SdcaMaximumEntropyMulticlassTrainer" Kind="Class" />
      <Type Name="SdcaMaximumEntropyMulticlassTrainer+Options" Kind="Class" />
      <Type Name="SdcaMulticlassTrainerBase`1" DisplayName="SdcaMulticlassTrainerBase&lt;TModel&gt;" Kind="Class" />
      <Type Name="SdcaMulticlassTrainerBase`1+MulticlassOptions" DisplayName="SdcaMulticlassTrainerBase&lt;TModel&gt;+MulticlassOptions" Kind="Class" />
      <Type Name="SdcaNonCalibratedBinaryTrainer" Kind="Class" />
      <Type Name="SdcaNonCalibratedBinaryTrainer+Options" Kind="Class" />
      <Type Name="SdcaNonCalibratedMulticlassTrainer" Kind="Class" />
      <Type Name="SdcaNonCalibratedMulticlassTrainer+Options" Kind="Class" />
      <Type Name="SdcaRegressionTrainer" Kind="Class" />
      <Type Name="SdcaRegressionTrainer+Options" Kind="Class" />
      <Type Name="SdcaTrainerBase`3" DisplayName="SdcaTrainerBase&lt;TOptions,TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="SdcaTrainerBase`3+OptionsBase" DisplayName="SdcaTrainerBase&lt;TOptions,TTransformer,TModel&gt;+OptionsBase" Kind="Class" />
      <Type Name="SgdBinaryTrainerBase`1" DisplayName="SgdBinaryTrainerBase&lt;TModel&gt;" Kind="Class" />
      <Type Name="SgdBinaryTrainerBase`1+OptionsBase" DisplayName="SgdBinaryTrainerBase&lt;TModel&gt;+OptionsBase" Kind="Class" />
      <Type Name="SgdCalibratedTrainer" Kind="Class" />
      <Type Name="SgdCalibratedTrainer+Options" Kind="Class" />
      <Type Name="SgdNonCalibratedTrainer" Kind="Class" />
      <Type Name="SgdNonCalibratedTrainer+Options" Kind="Class" />
      <Type Name="SmoothedHingeLoss" Kind="Class" />
      <Type Name="SquaredLoss" Kind="Class" />
      <Type Name="StochasticTrainerBase`2" DisplayName="StochasticTrainerBase&lt;TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="SymbolicSgdLogisticRegressionBinaryTrainer" Kind="Class" />
      <Type Name="SymbolicSgdLogisticRegressionBinaryTrainer+Options" Kind="Class" />
      <Type Name="TrainerEstimatorBase`2" DisplayName="TrainerEstimatorBase&lt;TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="TrainerEstimatorBaseWithGroupId`2" DisplayName="TrainerEstimatorBaseWithGroupId&lt;TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="TrainerInputBase" Kind="Class" />
      <Type Name="TrainerInputBaseWithGroupId" Kind="Class" />
      <Type Name="TrainerInputBaseWithLabel" Kind="Class" />
      <Type Name="TrainerInputBaseWithWeight" Kind="Class" />
      <Type Name="TweedieLoss" Kind="Class" />
      <Type Name="UnsupervisedTrainerInputBaseWithWeight" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Trainers.FastTree">
      <Type Name="BoostedTreeOptions" Kind="Class" />
      <Type Name="BoostedTreeOptions+OptimizationAlgorithmType" Kind="Enumeration" />
      <Type Name="BoostingFastTreeTrainerBase`3" DisplayName="BoostingFastTreeTrainerBase&lt;TOptions,TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="Bundle" Kind="Enumeration" />
      <Type Name="ConsecutiveGeneralityLossRule" Kind="Class" />
      <Type Name="EarlyStoppingMetric" Kind="Enumeration" />
      <Type Name="EarlyStoppingRankingMetric" Kind="Enumeration" />
      <Type Name="EarlyStoppingRule" Kind="Class" />
      <Type Name="EarlyStoppingRuleBase" Kind="Class" />
      <Type Name="FastForestBinaryModelParameters" Kind="Class" />
      <Type Name="FastForestBinaryTrainer" Kind="Class" />
      <Type Name="FastForestBinaryTrainer+Options" Kind="Class" />
      <Type Name="FastForestOptionsBase" Kind="Class" />
      <Type Name="FastForestRegressionModelParameters" Kind="Class" />
      <Type Name="FastForestRegressionTrainer" Kind="Class" />
      <Type Name="FastForestRegressionTrainer+Options" Kind="Class" />
      <Type Name="FastTreeBinaryModelParameters" Kind="Class" />
      <Type Name="FastTreeBinaryTrainer" Kind="Class" />
      <Type Name="FastTreeBinaryTrainer+Options" Kind="Class" />
      <Type Name="FastTreeRankingModelParameters" Kind="Class" />
      <Type Name="FastTreeRankingTrainer" Kind="Class" />
      <Type Name="FastTreeRankingTrainer+Options" Kind="Class" />
      <Type Name="FastTreeRegressionModelParameters" Kind="Class" />
      <Type Name="FastTreeRegressionTrainer" Kind="Class" />
      <Type Name="FastTreeRegressionTrainer+Options" Kind="Class" />
      <Type Name="FastTreeTrainerBase`3" DisplayName="FastTreeTrainerBase&lt;TOptions,TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="FastTreeTweedieModelParameters" Kind="Class" />
      <Type Name="FastTreeTweedieTrainer" Kind="Class" />
      <Type Name="FastTreeTweedieTrainer+Options" Kind="Class" />
      <Type Name="GamBinaryModelParameters" Kind="Class" />
      <Type Name="GamBinaryTrainer" Kind="Class" />
      <Type Name="GamBinaryTrainer+Options" Kind="Class" />
      <Type Name="GamModelParametersBase" Kind="Class" />
      <Type Name="GamRegressionModelParameters" Kind="Class" />
      <Type Name="GamRegressionTrainer" Kind="Class" />
      <Type Name="GamRegressionTrainer+Options" Kind="Class" />
      <Type Name="GamTrainerBase`3" DisplayName="GamTrainerBase&lt;TOptions,TTransformer,TPredictor&gt;" Kind="Class" />
      <Type Name="GamTrainerBase`3+OptionsBase" DisplayName="GamTrainerBase&lt;TOptions,TTransformer,TPredictor&gt;+OptionsBase" Kind="Class" />
      <Type Name="GeneralityLossRule" Kind="Class" />
      <Type Name="GeneralityToProgressRatioRule" Kind="Class" />
      <Type Name="LowProgressRule" Kind="Class" />
      <Type Name="MovingWindowRule" Kind="Class" />
      <Type Name="QuantileRegressionTree" Kind="Class" />
      <Type Name="QuantileRegressionTreeEnsemble" Kind="Class" />
      <Type Name="RandomForestTrainerBase`3" DisplayName="RandomForestTrainerBase&lt;TOptions,TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="RegressionTree" Kind="Class" />
      <Type Name="RegressionTreeBase" Kind="Class" />
      <Type Name="RegressionTreeEnsemble" Kind="Class" />
      <Type Name="TolerantEarlyStoppingRule" Kind="Class" />
      <Type Name="TreeEnsemble`1" DisplayName="TreeEnsemble&lt;T&gt;" Kind="Class" />
      <Type Name="TreeEnsembleModelParameters" Kind="Class" />
      <Type Name="TreeEnsembleModelParametersBasedOnQuantileRegressionTree" Kind="Class" />
      <Type Name="TreeEnsembleModelParametersBasedOnRegressionTree" Kind="Class" />
      <Type Name="TreeOptions" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Trainers.LightGbm">
      <Type Name="BoosterParameterBase" Kind="Class" />
      <Type Name="BoosterParameterBase+OptionsBase" Kind="Class" />
      <Type Name="DartBooster" Kind="Class" />
      <Type Name="DartBooster+Options" Kind="Class" />
      <Type Name="GossBooster" Kind="Class" />
      <Type Name="GossBooster+Options" Kind="Class" />
      <Type Name="GradientBooster" Kind="Class" />
      <Type Name="GradientBooster+Options" Kind="Class" />
      <Type Name="LightGbmBinaryModelParameters" Kind="Class" />
      <Type Name="LightGbmBinaryTrainer" Kind="Class" />
      <Type Name="LightGbmBinaryTrainer+Options" Kind="Class" />
      <Type Name="LightGbmBinaryTrainer+Options+EvaluateMetricType" Kind="Enumeration" />
      <Type Name="LightGbmMulticlassTrainer" Kind="Class" />
      <Type Name="LightGbmMulticlassTrainer+Options" Kind="Class" />
      <Type Name="LightGbmMulticlassTrainer+Options+EvaluateMetricType" Kind="Enumeration" />
      <Type Name="LightGbmRankingModelParameters" Kind="Class" />
      <Type Name="LightGbmRankingTrainer" Kind="Class" />
      <Type Name="LightGbmRankingTrainer+Options" Kind="Class" />
      <Type Name="LightGbmRankingTrainer+Options+EvaluateMetricType" Kind="Enumeration" />
      <Type Name="LightGbmRegressionModelParameters" Kind="Class" />
      <Type Name="LightGbmRegressionTrainer" Kind="Class" />
      <Type Name="LightGbmRegressionTrainer+Options" Kind="Class" />
      <Type Name="LightGbmRegressionTrainer+Options+EvaluateMetricType" Kind="Enumeration" />
      <Type Name="LightGbmTrainerBase`4" DisplayName="LightGbmTrainerBase&lt;TOptions,TOutput,TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="LightGbmTrainerBase`4+OptionsBase" DisplayName="LightGbmTrainerBase&lt;TOptions,TOutput,TTransformer,TModel&gt;+OptionsBase" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Trainers.Recommender">
      <Type Name="MatrixFactorizationModelParameters" Kind="Class" />
      <Type Name="MatrixFactorizationPredictionTransformer" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Transforms">
      <Type Name="ApproximatedKernelMappingEstimator" Kind="Class" />
      <Type Name="ApproximatedKernelTransformer" Kind="Class" />
      <Type Name="ColumnConcatenatingEstimator" Kind="Class" />
      <Type Name="ColumnCopyingEstimator" Kind="Class" />
      <Type Name="ColumnCopyingTransformer" Kind="Class" />
      <Type Name="ColumnSelectingEstimator" Kind="Class" />
      <Type Name="ColumnSelectingTransformer" Kind="Class" />
      <Type Name="CountFeatureSelectingEstimator" Kind="Class" />
      <Type Name="CustomMappingEstimator`2" DisplayName="CustomMappingEstimator&lt;TSrc,TDst&gt;" Kind="Class" />
      <Type Name="CustomMappingFactory`2" DisplayName="CustomMappingFactory&lt;TSrc,TDst&gt;" Kind="Class" />
      <Type Name="CustomMappingFactoryAttributeAttribute" Kind="Class" />
      <Type Name="CustomMappingTransformer`2" DisplayName="CustomMappingTransformer&lt;TSrc,TDst&gt;" Kind="Class" />
      <Type Name="FeatureContributionCalculatingEstimator" Kind="Class" />
      <Type Name="FeatureContributionCalculatingTransformer" Kind="Class" />
      <Type Name="GaussianKernel" Kind="Class" />
      <Type Name="GlobalContrastNormalizingEstimator" Kind="Class" />
      <Type Name="HashingEstimator" Kind="Class" />
      <Type Name="HashingTransformer" Kind="Class" />
      <Type Name="KernelBase" Kind="Class" />
      <Type Name="KeyToBinaryVectorMappingEstimator" Kind="Class" />
      <Type Name="KeyToBinaryVectorMappingTransformer" Kind="Class" />
      <Type Name="KeyToValueMappingEstimator" Kind="Class" />
      <Type Name="KeyToValueMappingTransformer" Kind="Class" />
      <Type Name="KeyToVectorMappingEstimator" Kind="Class" />
      <Type Name="KeyToVectorMappingTransformer" Kind="Class" />
      <Type Name="LaplacianKernel" Kind="Class" />
      <Type Name="LpNormNormalizingEstimator" Kind="Class" />
      <Type Name="LpNormNormalizingEstimatorBase" Kind="Class" />
      <Type Name="LpNormNormalizingEstimatorBase+NormFunction" Kind="Enumeration" />
      <Type Name="LpNormNormalizingTransformer" Kind="Class" />
      <Type Name="MissingValueIndicatorEstimator" Kind="Class" />
      <Type Name="MissingValueIndicatorTransformer" Kind="Class" />
      <Type Name="MissingValueReplacingEstimator" Kind="Class" />
      <Type Name="MissingValueReplacingEstimator+ReplacementMode" Kind="Enumeration" />
      <Type Name="MissingValueReplacingTransformer" Kind="Class" />
      <Type Name="MutualInformationFeatureSelectingEstimator" Kind="Class" />
      <Type Name="NormalizingEstimator" Kind="Class" />
      <Type Name="NormalizingTransformer" Kind="Class" />
      <Type Name="NormalizingTransformer+AffineNormalizerModelParameters`1" DisplayName="NormalizingTransformer+AffineNormalizerModelParameters&lt;TData&gt;" Kind="Class" />
      <Type Name="NormalizingTransformer+BinNormalizerModelParameters`1" DisplayName="NormalizingTransformer+BinNormalizerModelParameters&lt;TData&gt;" Kind="Class" />
      <Type Name="NormalizingTransformer+CdfNormalizerModelParameters`1" DisplayName="NormalizingTransformer+CdfNormalizerModelParameters&lt;TData&gt;" Kind="Class" />
      <Type Name="NormalizingTransformer+NormalizerModelParametersBase" Kind="Class" />
      <Type Name="OneHotEncodingEstimator" Kind="Class" />
      <Type Name="OneHotEncodingEstimator+OutputKind" Kind="Enumeration" />
      <Type Name="OneHotEncodingTransformer" Kind="Class" />
      <Type Name="OneHotHashEncodingEstimator" Kind="Class" />
      <Type Name="OneHotHashEncodingTransformer" Kind="Class" />
      <Type Name="PrincipalComponentAnalysisTransformer" Kind="Class" />
      <Type Name="PrincipalComponentAnalyzer" Kind="Class" />
      <Type Name="TensorFlowEstimator" Kind="Class" />
      <Type Name="TensorFlowModel" Kind="Class" />
      <Type Name="TensorFlowTransformer" Kind="Class" />
      <Type Name="TransformInputBase" Kind="Class" />
      <Type Name="TypeConvertingEstimator" Kind="Class" />
      <Type Name="TypeConvertingTransformer" Kind="Class" />
      <Type Name="ValueMappingEstimator" Kind="Class" />
      <Type Name="ValueMappingEstimator`2" DisplayName="ValueMappingEstimator&lt;TKey,TValue&gt;" Kind="Class" />
      <Type Name="ValueMappingTransformer" Kind="Class" />
      <Type Name="ValueToKeyMappingEstimator" Kind="Class" />
      <Type Name="ValueToKeyMappingEstimator+KeyOrdinality" Kind="Enumeration" />
      <Type Name="ValueToKeyMappingTransformer" Kind="Class" />
      <Type Name="VectorWhiteningEstimator" Kind="Class" />
      <Type Name="VectorWhiteningTransformer" Kind="Class" />
      <Type Name="WhiteningKind" Kind="Enumeration" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Transforms.Image">
      <Type Name="ImageDataViewType" Kind="Class" />
      <Type Name="ImageGrayscalingEstimator" Kind="Class" />
      <Type Name="ImageGrayscalingTransformer" Kind="Class" />
      <Type Name="ImagePixelExtractingEstimator" Kind="Class" />
      <Type Name="ImagePixelExtractingEstimator+ColorBits" Kind="Enumeration" />
      <Type Name="ImagePixelExtractingEstimator+ColorsOrder" Kind="Enumeration" />
      <Type Name="ImagePixelExtractingTransformer" Kind="Class" />
      <Type Name="ImageResizingEstimator" Kind="Class" />
      <Type Name="ImageResizingEstimator+Anchor" Kind="Enumeration" />
      <Type Name="ImageResizingEstimator+ResizingKind" Kind="Enumeration" />
      <Type Name="ImageResizingTransformer" Kind="Class" />
      <Type Name="VectorToImageConvertingEstimator" Kind="Class" />
      <Type Name="VectorToImageConvertingTransformer" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Transforms.Onnx">
      <Type Name="DnnImageFeaturizerEstimator" Kind="Class" />
      <Type Name="DnnImageFeaturizerInput" Kind="Class" />
      <Type Name="DnnImageModelSelector" Kind="Class" />
      <Type Name="OnnxScoringEstimator" Kind="Class" />
      <Type Name="OnnxTransformer" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Transforms.TensorFlow">
      <Type Name="TensorFlowUtils" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Transforms.Text">
      <Type Name="CustomStopWordsRemovingEstimator" Kind="Class" />
      <Type Name="CustomStopWordsRemovingEstimator+Options" Kind="Class" />
      <Type Name="CustomStopWordsRemovingTransformer" Kind="Class" />
      <Type Name="IStopWordsRemoverOptions" Kind="Interface" />
      <Type Name="LatentDirichletAllocationEstimator" Kind="Class" />
      <Type Name="LatentDirichletAllocationTransformer" Kind="Class" />
      <Type Name="LatentDirichletAllocationTransformer+ModelParameters" Kind="Class" />
      <Type Name="LatentDirichletAllocationTransformer+ModelParameters+ItemScore" Kind="Structure" />
      <Type Name="LatentDirichletAllocationTransformer+ModelParameters+WordItemScore" Kind="Structure" />
      <Type Name="NgramExtractingEstimator" Kind="Class" />
      <Type Name="NgramExtractingEstimator+WeightingCriteria" Kind="Enumeration" />
      <Type Name="NgramExtractingTransformer" Kind="Class" />
      <Type Name="NgramHashingEstimator" Kind="Class" />
      <Type Name="NgramHashingTransformer" Kind="Class" />
      <Type Name="StopWordsRemovingEstimator" Kind="Class" />
      <Type Name="StopWordsRemovingEstimator+Language" Kind="Enumeration" />
      <Type Name="StopWordsRemovingEstimator+Options" Kind="Class" />
      <Type Name="StopWordsRemovingTransformer" Kind="Class" />
      <Type Name="TextFeaturizingEstimator" Kind="Class" />
      <Type Name="TextFeaturizingEstimator+Language" Kind="Enumeration" />
      <Type Name="TextFeaturizingEstimator+NormFunction" Kind="Enumeration" />
      <Type Name="TextFeaturizingEstimator+Options" Kind="Class" />
      <Type Name="TextNormalizingEstimator" Kind="Class" />
      <Type Name="TextNormalizingEstimator+CaseMode" Kind="Enumeration" />
      <Type Name="TextNormalizingTransformer" Kind="Class" />
      <Type Name="TokenizingByCharactersEstimator" Kind="Class" />
      <Type Name="TokenizingByCharactersTransformer" Kind="Class" />
      <Type Name="WordBagEstimator" Kind="Class" />
      <Type Name="WordBagEstimator+Options" Kind="Class" />
      <Type Name="WordEmbeddingEstimator" Kind="Class" />
      <Type Name="WordEmbeddingEstimator+PretrainedModelKind" Kind="Enumeration" />
      <Type Name="WordEmbeddingTransformer" Kind="Class" />
      <Type Name="WordHashBagEstimator" Kind="Class" />
      <Type Name="WordTokenizingEstimator" Kind="Class" />
      <Type Name="WordTokenizingTransformer" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Transforms.TimeSeries">
      <Type Name="AnomalySide" Kind="Enumeration" />
      <Type Name="ErrorFunction" Kind="Enumeration" />
      <Type Name="IidAnomalyDetectionBaseWrapper" Kind="Class" />
      <Type Name="IidChangePointDetector" Kind="Class" />
      <Type Name="IidChangePointEstimator" Kind="Class" />
      <Type Name="IidSpikeDetector" Kind="Class" />
      <Type Name="IidSpikeEstimator" Kind="Class" />
      <Type Name="MartingaleType" Kind="Enumeration" />
      <Type Name="PredictionFunctionExtensions" Kind="Class" />
      <Type Name="SsaAnomalyDetectionBaseWrapper" Kind="Class" />
      <Type Name="SsaChangePointDetector" Kind="Class" />
      <Type Name="SsaChangePointEstimator" Kind="Class" />
      <Type Name="SsaSpikeDetector" Kind="Class" />
      <Type Name="SsaSpikeEstimator" Kind="Class" />
      <Type Name="TimeSeriesPredictionFunction`2" DisplayName="TimeSeriesPredictionFunction&lt;TSrc,TDst&gt;" Kind="Class" />
    </Namespace>
  </Types>
  <Title>Untitled</Title>
  <ExtensionMethods>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Transforms.Onnx.DnnImageModelSelector" />
      </Targets>
      <Member MemberName="AlexNet">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; AlexNet (this Microsoft.ML.Transforms.Onnx.DnnImageModelSelector dnnModelContext, Microsoft.ML.Runtime.IHostEnvironment env, string outputColumnName, string inputColumnName);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.EstimatorChain`1&lt;class Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; AlexNet(class Microsoft.ML.Transforms.Onnx.DnnImageModelSelector dnnModelContext, class Microsoft.ML.Runtime.IHostEnvironment env, string outputColumnName, string inputColumnName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.AlexNetExtension.AlexNet(Microsoft.ML.Transforms.Onnx.DnnImageModelSelector,Microsoft.ML.Runtime.IHostEnvironment,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AlexNet (dnnModelContext As DnnImageModelSelector, env As IHostEnvironment, outputColumnName As String, inputColumnName As String) As EstimatorChain(Of ColumnCopyingTransformer)" />
        <MemberSignature Language="F#" Value="static member AlexNet : Microsoft.ML.Transforms.Onnx.DnnImageModelSelector * Microsoft.ML.Runtime.IHostEnvironment * string * string -&gt; Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;" Usage="Microsoft.ML.AlexNetExtension.AlexNet (dnnModelContext, env, outputColumnName, inputColumnName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="dnnModelContext" Type="Microsoft.ML.Transforms.Onnx.DnnImageModelSelector" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="dnnModelContext">To be added.</param>
          <param name="env">To be added.</param>
          <param name="outputColumnName">To be added.</param>
          <param name="inputColumnName">To be added.</param>
          <summary>
            Returns an estimator chain with the two corresponding models (a preprocessing one and a main one) required for the AlexNet pipeline.
            Also includes the renaming ColumnsCopyingTransforms required to be able to use arbitrary input and output column names.
            This assumes both of the models are in the same location as the file containing this method, which they will be if used through the NuGet.
            This should be the default way to use AlexNet if importing the model from a NuGet.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.AlexNetExtension" Member="M:Microsoft.ML.AlexNetExtension.AlexNet(Microsoft.ML.Transforms.Onnx.DnnImageModelSelector,Microsoft.ML.Runtime.IHostEnvironment,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Transforms.Onnx.DnnImageModelSelector" />
      </Targets>
      <Member MemberName="AlexNet">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; AlexNet (this Microsoft.ML.Transforms.Onnx.DnnImageModelSelector dnnModelContext, Microsoft.ML.Runtime.IHostEnvironment env, string outputColumnName, string inputColumnName, string modelDir);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.EstimatorChain`1&lt;class Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; AlexNet(class Microsoft.ML.Transforms.Onnx.DnnImageModelSelector dnnModelContext, class Microsoft.ML.Runtime.IHostEnvironment env, string outputColumnName, string inputColumnName, string modelDir) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.AlexNetExtension.AlexNet(Microsoft.ML.Transforms.Onnx.DnnImageModelSelector,Microsoft.ML.Runtime.IHostEnvironment,System.String,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AlexNet (dnnModelContext As DnnImageModelSelector, env As IHostEnvironment, outputColumnName As String, inputColumnName As String, modelDir As String) As EstimatorChain(Of ColumnCopyingTransformer)" />
        <MemberSignature Language="F#" Value="static member AlexNet : Microsoft.ML.Transforms.Onnx.DnnImageModelSelector * Microsoft.ML.Runtime.IHostEnvironment * string * string * string -&gt; Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;" Usage="Microsoft.ML.AlexNetExtension.AlexNet (dnnModelContext, env, outputColumnName, inputColumnName, modelDir)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="dnnModelContext" Type="Microsoft.ML.Transforms.Onnx.DnnImageModelSelector" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="modelDir" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="dnnModelContext">To be added.</param>
          <param name="env">To be added.</param>
          <param name="outputColumnName">To be added.</param>
          <param name="inputColumnName">To be added.</param>
          <param name="modelDir">To be added.</param>
          <summary>
            This allows a custom model location to be specified. This is useful is a custom model is specified,
            or if the model is desired to be placed or shipped separately in a different folder from the main application. Note that because Onnx models
            must be in a directory all by themsleves for the OnnxTransformer to work, this method appends a AlexNetOnnx/AlexNetPrepOnnx subdirectory
            to the passed in directory to prevent having to make that directory manually each time.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.AlexNetExtension" Member="M:Microsoft.ML.AlexNetExtension.AlexNet(Microsoft.ML.Transforms.Onnx.DnnImageModelSelector,Microsoft.ML.Runtime.IHostEnvironment,System.String,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataOperationsCatalog" />
      </Targets>
      <Member MemberName="LoadFromBinary">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.IDataView LoadFromBinary (this Microsoft.ML.DataOperationsCatalog catalog, Microsoft.ML.Data.IMultiStreamSource fileSource);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.IDataView LoadFromBinary(class Microsoft.ML.DataOperationsCatalog catalog, class Microsoft.ML.Data.IMultiStreamSource fileSource) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.BinaryLoaderSaverCatalog.LoadFromBinary(Microsoft.ML.DataOperationsCatalog,Microsoft.ML.Data.IMultiStreamSource)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LoadFromBinary (catalog As DataOperationsCatalog, fileSource As IMultiStreamSource) As IDataView" />
        <MemberSignature Language="F#" Value="static member LoadFromBinary : Microsoft.ML.DataOperationsCatalog * Microsoft.ML.Data.IMultiStreamSource -&gt; Microsoft.ML.IDataView" Usage="Microsoft.ML.BinaryLoaderSaverCatalog.LoadFromBinary (catalog, fileSource)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.IDataView</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.DataOperationsCatalog" RefType="this" />
          <Parameter Name="fileSource" Type="Microsoft.ML.Data.IMultiStreamSource" />
        </Parameters>
        <Docs>
          <param name="catalog">The catalog.</param>
          <param name="fileSource">The file source to load from. This can be a <see cref="T:Microsoft.ML.Data.MultiFileSource" />, for example.</param>
          <summary>
            Load a <see cref="T:Microsoft.ML.IDataView" /> from an <see cref="T:Microsoft.ML.Data.IMultiStreamSource" /> on a binary file.
            Note that <see cref="T:Microsoft.ML.IDataView" />'s are lazy, so no actual loading happens here, just schema validation.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.BinaryLoaderSaverCatalog" Member="M:Microsoft.ML.BinaryLoaderSaverCatalog.LoadFromBinary(Microsoft.ML.DataOperationsCatalog,Microsoft.ML.Data.IMultiStreamSource)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataOperationsCatalog" />
      </Targets>
      <Member MemberName="LoadFromBinary">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.IDataView LoadFromBinary (this Microsoft.ML.DataOperationsCatalog catalog, string path);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.IDataView LoadFromBinary(class Microsoft.ML.DataOperationsCatalog catalog, string path) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.BinaryLoaderSaverCatalog.LoadFromBinary(Microsoft.ML.DataOperationsCatalog,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LoadFromBinary (catalog As DataOperationsCatalog, path As String) As IDataView" />
        <MemberSignature Language="F#" Value="static member LoadFromBinary : Microsoft.ML.DataOperationsCatalog * string -&gt; Microsoft.ML.IDataView" Usage="Microsoft.ML.BinaryLoaderSaverCatalog.LoadFromBinary (catalog, path)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.IDataView</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.DataOperationsCatalog" RefType="this" />
          <Parameter Name="path" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="catalog">The catalog.</param>
          <param name="path">The path to the file to load from.</param>
          <summary>
            Load a <see cref="T:Microsoft.ML.IDataView" /> from a binary file.
            Note that <see cref="T:Microsoft.ML.IDataView" />'s are lazy, so no actual loading happens here, just schema validation.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.BinaryLoaderSaverCatalog" Member="M:Microsoft.ML.BinaryLoaderSaverCatalog.LoadFromBinary(Microsoft.ML.DataOperationsCatalog,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataOperationsCatalog" />
      </Targets>
      <Member MemberName="SaveAsBinary">
        <MemberSignature Language="C#" Value="public static void SaveAsBinary (this Microsoft.ML.DataOperationsCatalog catalog, Microsoft.ML.IDataView data, System.IO.Stream stream, bool keepHidden = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SaveAsBinary(class Microsoft.ML.DataOperationsCatalog catalog, class Microsoft.ML.IDataView data, class System.IO.Stream stream, bool keepHidden) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.BinaryLoaderSaverCatalog.SaveAsBinary(Microsoft.ML.DataOperationsCatalog,Microsoft.ML.IDataView,System.IO.Stream,System.Boolean)" />
        <MemberSignature Language="F#" Value="static member SaveAsBinary : Microsoft.ML.DataOperationsCatalog * Microsoft.ML.IDataView * System.IO.Stream * bool -&gt; unit" Usage="Microsoft.ML.BinaryLoaderSaverCatalog.SaveAsBinary (catalog, data, stream, keepHidden)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.DataOperationsCatalog" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.IDataView" />
          <Parameter Name="stream" Type="System.IO.Stream" />
          <Parameter Name="keepHidden" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The catalog.</param>
          <param name="data">The data view to save.</param>
          <param name="stream">The stream to write to.</param>
          <param name="keepHidden">Whether to keep hidden columns in the dataset.</param>
          <summary>
            Save the <see cref="T:Microsoft.ML.IDataView" /> into a binary stream.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.BinaryLoaderSaverCatalog" Member="M:Microsoft.ML.BinaryLoaderSaverCatalog.SaveAsBinary(Microsoft.ML.DataOperationsCatalog,Microsoft.ML.IDataView,System.IO.Stream,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.CategoricalTransforms" />
      </Targets>
      <Member MemberName="OneHotEncoding">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.OneHotEncodingEstimator OneHotEncoding (this Microsoft.ML.TransformsCatalog.CategoricalTransforms catalog, Microsoft.ML.InputOutputColumnPair[] columns, Microsoft.ML.Transforms.OneHotEncodingEstimator.OutputKind outputKind = Microsoft.ML.Transforms.OneHotEncodingEstimator+OutputKind.Indicator, int maximumNumberOfKeys = 1000000, Microsoft.ML.Transforms.ValueToKeyMappingEstimator.KeyOrdinality keyOrdinality = Microsoft.ML.Transforms.ValueToKeyMappingEstimator+KeyOrdinality.ByOccurrence, Microsoft.ML.IDataView keyData = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.OneHotEncodingEstimator OneHotEncoding(class Microsoft.ML.TransformsCatalog/CategoricalTransforms catalog, class Microsoft.ML.InputOutputColumnPair[] columns, valuetype Microsoft.ML.Transforms.OneHotEncodingEstimator/OutputKind outputKind, int32 maximumNumberOfKeys, valuetype Microsoft.ML.Transforms.ValueToKeyMappingEstimator/KeyOrdinality keyOrdinality, class Microsoft.ML.IDataView keyData) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.CategoricalCatalog.OneHotEncoding(Microsoft.ML.TransformsCatalog.CategoricalTransforms,Microsoft.ML.InputOutputColumnPair[],Microsoft.ML.Transforms.OneHotEncodingEstimator.OutputKind,System.Int32,Microsoft.ML.Transforms.ValueToKeyMappingEstimator.KeyOrdinality,Microsoft.ML.IDataView)" />
        <MemberSignature Language="F#" Value="static member OneHotEncoding : Microsoft.ML.TransformsCatalog.CategoricalTransforms * Microsoft.ML.InputOutputColumnPair[] * Microsoft.ML.Transforms.OneHotEncodingEstimator.OutputKind * int * Microsoft.ML.Transforms.ValueToKeyMappingEstimator.KeyOrdinality * Microsoft.ML.IDataView -&gt; Microsoft.ML.Transforms.OneHotEncodingEstimator" Usage="Microsoft.ML.CategoricalCatalog.OneHotEncoding (catalog, columns, outputKind, maximumNumberOfKeys, keyOrdinality, keyData)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.OneHotEncodingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+CategoricalTransforms" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.InputOutputColumnPair[]" />
          <Parameter Name="outputKind" Type="Microsoft.ML.Transforms.OneHotEncodingEstimator+OutputKind" />
          <Parameter Name="maximumNumberOfKeys" Type="System.Int32" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.Transforms.ValueToKeyMappingEstimator+KeyOrdinality" />
          <Parameter Name="keyData" Type="Microsoft.ML.IDataView" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform catalog</param>
          <param name="columns">Specifies the names of the columns on which to apply the transformation.</param>
          <param name="outputKind">Output kind: Bag (multi-set vector), Ind (indicator vector), Key (index), or Binary encoded indicator vector.</param>
          <param name="maximumNumberOfKeys">Maximum number of terms to keep per column when auto-training.</param>
          <param name="keyOrdinality">How items should be ordered when vectorized. If <see cref="F:Microsoft.ML.Transforms.ValueToKeyMappingEstimator.KeyOrdinality.ByOccurrence" /> choosen they will be in the order encountered.
            If <see cref="F:Microsoft.ML.Transforms.ValueToKeyMappingEstimator.KeyOrdinality.ByValue" />, items are sorted according to their default comparison, for example, text sorting will be case sensitive (for example, 'A' then 'Z' then 'a').</param>
          <param name="keyData">Specifies an ordering for the encoding. If specified, this should be a single column data view,
            and the key-values will be taken from that column. If unspecified, the ordering will be determined from the input data upon fitting.</param>
          <summary>
            Convert text columns into one-hot encoded vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.CategoricalCatalog" Member="M:Microsoft.ML.CategoricalCatalog.OneHotEncoding(Microsoft.ML.TransformsCatalog.CategoricalTransforms,Microsoft.ML.InputOutputColumnPair[],Microsoft.ML.Transforms.OneHotEncodingEstimator.OutputKind,System.Int32,Microsoft.ML.Transforms.ValueToKeyMappingEstimator.KeyOrdinality,Microsoft.ML.IDataView)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.CategoricalTransforms" />
      </Targets>
      <Member MemberName="OneHotEncoding">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.OneHotEncodingEstimator OneHotEncoding (this Microsoft.ML.TransformsCatalog.CategoricalTransforms catalog, string outputColumnName, string inputColumnName = null, Microsoft.ML.Transforms.OneHotEncodingEstimator.OutputKind outputKind = Microsoft.ML.Transforms.OneHotEncodingEstimator+OutputKind.Indicator, int maximumNumberOfKeys = 1000000, Microsoft.ML.Transforms.ValueToKeyMappingEstimator.KeyOrdinality keyOrdinality = Microsoft.ML.Transforms.ValueToKeyMappingEstimator+KeyOrdinality.ByOccurrence, Microsoft.ML.IDataView keyData = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.OneHotEncodingEstimator OneHotEncoding(class Microsoft.ML.TransformsCatalog/CategoricalTransforms catalog, string outputColumnName, string inputColumnName, valuetype Microsoft.ML.Transforms.OneHotEncodingEstimator/OutputKind outputKind, int32 maximumNumberOfKeys, valuetype Microsoft.ML.Transforms.ValueToKeyMappingEstimator/KeyOrdinality keyOrdinality, class Microsoft.ML.IDataView keyData) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.CategoricalCatalog.OneHotEncoding(Microsoft.ML.TransformsCatalog.CategoricalTransforms,System.String,System.String,Microsoft.ML.Transforms.OneHotEncodingEstimator.OutputKind,System.Int32,Microsoft.ML.Transforms.ValueToKeyMappingEstimator.KeyOrdinality,Microsoft.ML.IDataView)" />
        <MemberSignature Language="F#" Value="static member OneHotEncoding : Microsoft.ML.TransformsCatalog.CategoricalTransforms * string * string * Microsoft.ML.Transforms.OneHotEncodingEstimator.OutputKind * int * Microsoft.ML.Transforms.ValueToKeyMappingEstimator.KeyOrdinality * Microsoft.ML.IDataView -&gt; Microsoft.ML.Transforms.OneHotEncodingEstimator" Usage="Microsoft.ML.CategoricalCatalog.OneHotEncoding (catalog, outputColumnName, inputColumnName, outputKind, maximumNumberOfKeys, keyOrdinality, keyData)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.OneHotEncodingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+CategoricalTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="outputKind" Type="Microsoft.ML.Transforms.OneHotEncodingEstimator+OutputKind" />
          <Parameter Name="maximumNumberOfKeys" Type="System.Int32" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.Transforms.ValueToKeyMappingEstimator+KeyOrdinality" />
          <Parameter Name="keyData" Type="Microsoft.ML.IDataView" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform catalog</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="outputKind">Output kind: Bag (multi-set vector), Ind (indicator vector), Key (index), or Binary encoded indicator vector.</param>
          <param name="maximumNumberOfKeys">Maximum number of terms to keep per column when auto-training.</param>
          <param name="keyOrdinality">How items should be ordered when vectorized. If <see cref="F:Microsoft.ML.Transforms.ValueToKeyMappingEstimator.KeyOrdinality.ByOccurrence" /> choosen they will be in the order encountered.
            If <see cref="F:Microsoft.ML.Transforms.ValueToKeyMappingEstimator.KeyOrdinality.ByValue" />, items are sorted according to their default comparison, for example, text sorting will be case sensitive (for example, 'A' then 'Z' then 'a').</param>
          <param name="keyData">Specifies an ordering for the encoding. If specified, this should be a single column data view,
            and the key-values will be taken from that column. If unspecified, the ordering will be determined from the input data upon fitting.</param>
          <summary>
            Convert text columns into one-hot encoded vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.CategoricalCatalog" Member="M:Microsoft.ML.CategoricalCatalog.OneHotEncoding(Microsoft.ML.TransformsCatalog.CategoricalTransforms,System.String,System.String,Microsoft.ML.Transforms.OneHotEncodingEstimator.OutputKind,System.Int32,Microsoft.ML.Transforms.ValueToKeyMappingEstimator.KeyOrdinality,Microsoft.ML.IDataView)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.CategoricalTransforms" />
      </Targets>
      <Member MemberName="OneHotHashEncoding">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.OneHotHashEncodingEstimator OneHotHashEncoding (this Microsoft.ML.TransformsCatalog.CategoricalTransforms catalog, Microsoft.ML.InputOutputColumnPair[] columns, Microsoft.ML.Transforms.OneHotEncodingEstimator.OutputKind outputKind = Microsoft.ML.Transforms.OneHotEncodingEstimator+OutputKind.Indicator, int numberOfBits = 16, uint seed = 314489979, bool useOrderedHashing = true, int maximumNumberOfInverts = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.OneHotHashEncodingEstimator OneHotHashEncoding(class Microsoft.ML.TransformsCatalog/CategoricalTransforms catalog, class Microsoft.ML.InputOutputColumnPair[] columns, valuetype Microsoft.ML.Transforms.OneHotEncodingEstimator/OutputKind outputKind, int32 numberOfBits, unsigned int32 seed, bool useOrderedHashing, int32 maximumNumberOfInverts) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.CategoricalCatalog.OneHotHashEncoding(Microsoft.ML.TransformsCatalog.CategoricalTransforms,Microsoft.ML.InputOutputColumnPair[],Microsoft.ML.Transforms.OneHotEncodingEstimator.OutputKind,System.Int32,System.UInt32,System.Boolean,System.Int32)" />
        <MemberSignature Language="F#" Value="static member OneHotHashEncoding : Microsoft.ML.TransformsCatalog.CategoricalTransforms * Microsoft.ML.InputOutputColumnPair[] * Microsoft.ML.Transforms.OneHotEncodingEstimator.OutputKind * int * uint32 * bool * int -&gt; Microsoft.ML.Transforms.OneHotHashEncodingEstimator" Usage="Microsoft.ML.CategoricalCatalog.OneHotHashEncoding (catalog, columns, outputKind, numberOfBits, seed, useOrderedHashing, maximumNumberOfInverts)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.OneHotHashEncodingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+CategoricalTransforms" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.InputOutputColumnPair[]" />
          <Parameter Name="outputKind" Type="Microsoft.ML.Transforms.OneHotEncodingEstimator+OutputKind" />
          <Parameter Name="numberOfBits" Type="System.Int32" />
          <Parameter Name="seed" Type="System.UInt32" />
          <Parameter Name="useOrderedHashing" Type="System.Boolean" />
          <Parameter Name="maximumNumberOfInverts" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform catalog</param>
          <param name="columns">Specifies the names of the columns on which to apply the transformation.</param>
          <param name="outputKind">The conversion mode.</param>
          <param name="numberOfBits">Number of bits to hash into. Must be between 1 and 30, inclusive.</param>
          <param name="seed">Hashing seed.</param>
          <param name="useOrderedHashing">Whether the position of each term should be included in the hash.</param>
          <param name="maximumNumberOfInverts">During hashing we constuct mappings between original values and the produced hash values.
            Text representation of original values are stored in the slot names of the  metadata for the new column.Hashing, as such, can map many initial values to one.
            <paramref name="maximumNumberOfInverts" /> specifies the upper bound of the number of distinct input values mapping to a hash that should be retained.
            <value>0</value> does not retain any input values. <value>-1</value> retains all input values mapping to each hash.</param>
          <summary>
            Convert text columns into hash-based one-hot encoded vector columns.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.CategoricalCatalog" Member="M:Microsoft.ML.CategoricalCatalog.OneHotHashEncoding(Microsoft.ML.TransformsCatalog.CategoricalTransforms,Microsoft.ML.InputOutputColumnPair[],Microsoft.ML.Transforms.OneHotEncodingEstimator.OutputKind,System.Int32,System.UInt32,System.Boolean,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.CategoricalTransforms" />
      </Targets>
      <Member MemberName="OneHotHashEncoding">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.OneHotHashEncodingEstimator OneHotHashEncoding (this Microsoft.ML.TransformsCatalog.CategoricalTransforms catalog, string outputColumnName, string inputColumnName = null, Microsoft.ML.Transforms.OneHotEncodingEstimator.OutputKind outputKind = Microsoft.ML.Transforms.OneHotEncodingEstimator+OutputKind.Indicator, int numberOfBits = 16, uint seed = 314489979, bool useOrderedHashing = true, int maximumNumberOfInverts = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.OneHotHashEncodingEstimator OneHotHashEncoding(class Microsoft.ML.TransformsCatalog/CategoricalTransforms catalog, string outputColumnName, string inputColumnName, valuetype Microsoft.ML.Transforms.OneHotEncodingEstimator/OutputKind outputKind, int32 numberOfBits, unsigned int32 seed, bool useOrderedHashing, int32 maximumNumberOfInverts) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.CategoricalCatalog.OneHotHashEncoding(Microsoft.ML.TransformsCatalog.CategoricalTransforms,System.String,System.String,Microsoft.ML.Transforms.OneHotEncodingEstimator.OutputKind,System.Int32,System.UInt32,System.Boolean,System.Int32)" />
        <MemberSignature Language="F#" Value="static member OneHotHashEncoding : Microsoft.ML.TransformsCatalog.CategoricalTransforms * string * string * Microsoft.ML.Transforms.OneHotEncodingEstimator.OutputKind * int * uint32 * bool * int -&gt; Microsoft.ML.Transforms.OneHotHashEncodingEstimator" Usage="Microsoft.ML.CategoricalCatalog.OneHotHashEncoding (catalog, outputColumnName, inputColumnName, outputKind, numberOfBits, seed, useOrderedHashing, maximumNumberOfInverts)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.OneHotHashEncodingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+CategoricalTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="outputKind" Type="Microsoft.ML.Transforms.OneHotEncodingEstimator+OutputKind" />
          <Parameter Name="numberOfBits" Type="System.Int32" />
          <Parameter Name="seed" Type="System.UInt32" />
          <Parameter Name="useOrderedHashing" Type="System.Boolean" />
          <Parameter Name="maximumNumberOfInverts" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform catalog</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="outputKind">The conversion mode.</param>
          <param name="numberOfBits">Number of bits to hash into. Must be between 1 and 30, inclusive.</param>
          <param name="seed">Hashing seed.</param>
          <param name="useOrderedHashing">Whether the position of each term should be included in the hash.</param>
          <param name="maximumNumberOfInverts">During hashing we constuct mappings between original values and the produced hash values.
            Text representation of original values are stored in the slot names of the  metadata for the new column.Hashing, as such, can map many initial values to one.
            <paramref name="maximumNumberOfInverts" /> specifies the upper bound of the number of distinct input values mapping to a hash that should be retained.
            <value>0</value> does not retain any input values. <value>-1</value> retains all input values mapping to each hash.</param>
          <summary>
            Convert a text column into hash-based one-hot encoded vector.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.CategoricalCatalog" Member="M:Microsoft.ML.CategoricalCatalog.OneHotHashEncoding(Microsoft.ML.TransformsCatalog.CategoricalTransforms,System.String,System.String,Microsoft.ML.Transforms.OneHotEncodingEstimator.OutputKind,System.Int32,System.UInt32,System.Boolean,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="MapKeyToBinaryVector">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.KeyToBinaryVectorMappingEstimator MapKeyToBinaryVector (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, string outputColumnName, string inputColumnName = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.KeyToBinaryVectorMappingEstimator MapKeyToBinaryVector(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, string outputColumnName, string inputColumnName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsCatalog.MapKeyToBinaryVector(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function MapKeyToBinaryVector (catalog As TransformsCatalog.ConversionTransforms, outputColumnName As String, Optional inputColumnName As String = null) As KeyToBinaryVectorMappingEstimator" />
        <MemberSignature Language="F#" Value="static member MapKeyToBinaryVector : Microsoft.ML.TransformsCatalog.ConversionTransforms * string * string -&gt; Microsoft.ML.Transforms.KeyToBinaryVectorMappingEstimator" Usage="Microsoft.ML.ConversionsCatalog.MapKeyToBinaryVector (catalog, outputColumnName, inputColumnName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.KeyToBinaryVectorMappingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="catalog">The categorical transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <summary>
             Convert the key types back to binary vector.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsCatalog" Member="M:Microsoft.ML.ConversionsCatalog.MapKeyToBinaryVector(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="ConvertType">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.TypeConvertingEstimator ConvertType (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, Microsoft.ML.InputOutputColumnPair[] columns, Microsoft.ML.Data.DataKind outputKind = Microsoft.ML.Data.DataKind.Single);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.TypeConvertingEstimator ConvertType(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, class Microsoft.ML.InputOutputColumnPair[] columns, valuetype Microsoft.ML.Data.DataKind outputKind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsExtensionsCatalog.ConvertType(Microsoft.ML.TransformsCatalog.ConversionTransforms,Microsoft.ML.InputOutputColumnPair[],Microsoft.ML.Data.DataKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConvertType (catalog As TransformsCatalog.ConversionTransforms, columns As InputOutputColumnPair(), Optional outputKind As DataKind = Microsoft.ML.Data.DataKind.Single) As TypeConvertingEstimator" />
        <MemberSignature Language="F#" Value="static member ConvertType : Microsoft.ML.TransformsCatalog.ConversionTransforms * Microsoft.ML.InputOutputColumnPair[] * Microsoft.ML.Data.DataKind -&gt; Microsoft.ML.Transforms.TypeConvertingEstimator" Usage="Microsoft.ML.ConversionsExtensionsCatalog.ConvertType (catalog, columns, outputKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.TypeConvertingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.InputOutputColumnPair[]" />
          <Parameter Name="outputKind" Type="Microsoft.ML.Data.DataKind" />
        </Parameters>
        <Docs>
          <param name="catalog">The conversion transform's catalog.</param>
          <param name="columns">Specifies the names of the columns on which to apply the transformation.</param>
          <param name="outputKind">The expected kind of the output column.</param>
          <summary>
            Changes column type of the input columns.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsExtensionsCatalog" Member="M:Microsoft.ML.ConversionsExtensionsCatalog.ConvertType(Microsoft.ML.TransformsCatalog.ConversionTransforms,Microsoft.ML.InputOutputColumnPair[],Microsoft.ML.Data.DataKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="ConvertType">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.TypeConvertingEstimator ConvertType (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, string outputColumnName, string inputColumnName = null, Microsoft.ML.Data.DataKind outputKind = Microsoft.ML.Data.DataKind.Single);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.TypeConvertingEstimator ConvertType(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, string outputColumnName, string inputColumnName, valuetype Microsoft.ML.Data.DataKind outputKind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsExtensionsCatalog.ConvertType(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.String,Microsoft.ML.Data.DataKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConvertType (catalog As TransformsCatalog.ConversionTransforms, outputColumnName As String, Optional inputColumnName As String = null, Optional outputKind As DataKind = Microsoft.ML.Data.DataKind.Single) As TypeConvertingEstimator" />
        <MemberSignature Language="F#" Value="static member ConvertType : Microsoft.ML.TransformsCatalog.ConversionTransforms * string * string * Microsoft.ML.Data.DataKind -&gt; Microsoft.ML.Transforms.TypeConvertingEstimator" Usage="Microsoft.ML.ConversionsExtensionsCatalog.ConvertType (catalog, outputColumnName, inputColumnName, outputKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.TypeConvertingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="outputKind" Type="Microsoft.ML.Data.DataKind" />
        </Parameters>
        <Docs>
          <param name="catalog">The conversion transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="outputKind">The expected kind of the output column.</param>
          <summary>
            Changes column type of the input column.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsExtensionsCatalog" Member="M:Microsoft.ML.ConversionsExtensionsCatalog.ConvertType(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.String,Microsoft.ML.Data.DataKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="Hash">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.HashingEstimator Hash (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, string outputColumnName, string inputColumnName = null, int numberOfBits = 31, int maximumNumberOfInverts = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.HashingEstimator Hash(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, string outputColumnName, string inputColumnName, int32 numberOfBits, int32 maximumNumberOfInverts) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsExtensionsCatalog.Hash(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.String,System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Hash (catalog As TransformsCatalog.ConversionTransforms, outputColumnName As String, Optional inputColumnName As String = null, Optional numberOfBits As Integer = 31, Optional maximumNumberOfInverts As Integer = 0) As HashingEstimator" />
        <MemberSignature Language="F#" Value="static member Hash : Microsoft.ML.TransformsCatalog.ConversionTransforms * string * string * int * int -&gt; Microsoft.ML.Transforms.HashingEstimator" Usage="Microsoft.ML.ConversionsExtensionsCatalog.Hash (catalog, outputColumnName, inputColumnName, numberOfBits, maximumNumberOfInverts)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.HashingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="numberOfBits" Type="System.Int32" />
          <Parameter Name="maximumNumberOfInverts" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The conversion transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="numberOfBits">Number of bits to hash into. Must be between 1 and 31, inclusive.</param>
          <param name="maximumNumberOfInverts">During hashing we constuct mappings between original values and the produced hash values.
            Text representation of original values are stored in the slot names of the  metadata for the new column.Hashing, as such, can map many initial values to one.
            <paramref name="maximumNumberOfInverts" />Specifies the upper bound of the number of distinct input values mapping to a hash that should be retained.
            <value>0</value> does not retain any input values. <value>-1</value> retains all input values mapping to each hash.</param>
          <summary>
            Hashes the values in the input column.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsExtensionsCatalog" Member="M:Microsoft.ML.ConversionsExtensionsCatalog.Hash(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.String,System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="MapKeyToValue">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.KeyToValueMappingEstimator MapKeyToValue (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, Microsoft.ML.InputOutputColumnPair[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.KeyToValueMappingEstimator MapKeyToValue(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, class Microsoft.ML.InputOutputColumnPair[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsExtensionsCatalog.MapKeyToValue(Microsoft.ML.TransformsCatalog.ConversionTransforms,Microsoft.ML.InputOutputColumnPair[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function MapKeyToValue (catalog As TransformsCatalog.ConversionTransforms, columns As InputOutputColumnPair()) As KeyToValueMappingEstimator" />
        <MemberSignature Language="F#" Value="static member MapKeyToValue : Microsoft.ML.TransformsCatalog.ConversionTransforms * Microsoft.ML.InputOutputColumnPair[] -&gt; Microsoft.ML.Transforms.KeyToValueMappingEstimator" Usage="Microsoft.ML.ConversionsExtensionsCatalog.MapKeyToValue (catalog, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.KeyToValueMappingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.InputOutputColumnPair[]" />
        </Parameters>
        <Docs>
          <param name="catalog">The conversion transform's catalog.</param>
          <param name="columns">Specifies the names of the columns on which to apply the transformation.</param>
          <summary>
            Convert the key types back to their original values.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsExtensionsCatalog" Member="M:Microsoft.ML.ConversionsExtensionsCatalog.MapKeyToValue(Microsoft.ML.TransformsCatalog.ConversionTransforms,Microsoft.ML.InputOutputColumnPair[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="MapKeyToValue">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.KeyToValueMappingEstimator MapKeyToValue (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, string outputColumnName, string inputColumnName = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.KeyToValueMappingEstimator MapKeyToValue(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, string outputColumnName, string inputColumnName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsExtensionsCatalog.MapKeyToValue(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function MapKeyToValue (catalog As TransformsCatalog.ConversionTransforms, outputColumnName As String, Optional inputColumnName As String = null) As KeyToValueMappingEstimator" />
        <MemberSignature Language="F#" Value="static member MapKeyToValue : Microsoft.ML.TransformsCatalog.ConversionTransforms * string * string -&gt; Microsoft.ML.Transforms.KeyToValueMappingEstimator" Usage="Microsoft.ML.ConversionsExtensionsCatalog.MapKeyToValue (catalog, outputColumnName, inputColumnName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.KeyToValueMappingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="catalog">The conversion transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <summary>
            Convert the key types back to their original values.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsExtensionsCatalog" Member="M:Microsoft.ML.ConversionsExtensionsCatalog.MapKeyToValue(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="MapKeyToVector">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.KeyToVectorMappingEstimator MapKeyToVector (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, Microsoft.ML.InputOutputColumnPair[] columns, bool outputCountVector = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.KeyToVectorMappingEstimator MapKeyToVector(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, class Microsoft.ML.InputOutputColumnPair[] columns, bool outputCountVector) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsExtensionsCatalog.MapKeyToVector(Microsoft.ML.TransformsCatalog.ConversionTransforms,Microsoft.ML.InputOutputColumnPair[],System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function MapKeyToVector (catalog As TransformsCatalog.ConversionTransforms, columns As InputOutputColumnPair(), Optional outputCountVector As Boolean = false) As KeyToVectorMappingEstimator" />
        <MemberSignature Language="F#" Value="static member MapKeyToVector : Microsoft.ML.TransformsCatalog.ConversionTransforms * Microsoft.ML.InputOutputColumnPair[] * bool -&gt; Microsoft.ML.Transforms.KeyToVectorMappingEstimator" Usage="Microsoft.ML.ConversionsExtensionsCatalog.MapKeyToVector (catalog, columns, outputCountVector)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.KeyToVectorMappingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.InputOutputColumnPair[]" />
          <Parameter Name="outputCountVector" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The conversion transform's catalog.</param>
          <param name="columns">Specifies the names of the columns on which to apply the transformation.</param>
          <param name="outputCountVector">Whether to combine multiple indicator vectors into a single vector of counts instead of concatenating them.
            This is only relevant when the input column is a vector of keys.</param>
          <summary>
            Maps columns of key types or key values into columns of floating point vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsExtensionsCatalog" Member="M:Microsoft.ML.ConversionsExtensionsCatalog.MapKeyToVector(Microsoft.ML.TransformsCatalog.ConversionTransforms,Microsoft.ML.InputOutputColumnPair[],System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="MapKeyToVector">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.KeyToVectorMappingEstimator MapKeyToVector (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, string outputColumnName, string inputColumnName = null, bool outputCountVector = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.KeyToVectorMappingEstimator MapKeyToVector(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, string outputColumnName, string inputColumnName, bool outputCountVector) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsExtensionsCatalog.MapKeyToVector(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.String,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function MapKeyToVector (catalog As TransformsCatalog.ConversionTransforms, outputColumnName As String, Optional inputColumnName As String = null, Optional outputCountVector As Boolean = false) As KeyToVectorMappingEstimator" />
        <MemberSignature Language="F#" Value="static member MapKeyToVector : Microsoft.ML.TransformsCatalog.ConversionTransforms * string * string * bool -&gt; Microsoft.ML.Transforms.KeyToVectorMappingEstimator" Usage="Microsoft.ML.ConversionsExtensionsCatalog.MapKeyToVector (catalog, outputColumnName, inputColumnName, outputCountVector)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.KeyToVectorMappingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="outputCountVector" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The conversion transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="outputCountVector">Whether to combine multiple indicator vectors into a single vector of counts instead of concatenating them.
            This is only relevant when the input column is a vector of keys.</param>
          <summary>
            Maps key types or key values into a floating point vector.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsExtensionsCatalog" Member="M:Microsoft.ML.ConversionsExtensionsCatalog.MapKeyToVector(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.String,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="MapValue">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.ValueMappingEstimator MapValue (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, string outputColumnName, Microsoft.ML.IDataView lookupMap, Microsoft.ML.DataViewSchema.Column keyColumn, Microsoft.ML.DataViewSchema.Column valueColumn, string inputColumnName = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.ValueMappingEstimator MapValue(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, string outputColumnName, class Microsoft.ML.IDataView lookupMap, valuetype Microsoft.ML.DataViewSchema/Column keyColumn, valuetype Microsoft.ML.DataViewSchema/Column valueColumn, string inputColumnName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsExtensionsCatalog.MapValue(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,Microsoft.ML.IDataView,Microsoft.ML.DataViewSchema.Column,Microsoft.ML.DataViewSchema.Column,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function MapValue (catalog As TransformsCatalog.ConversionTransforms, outputColumnName As String, lookupMap As IDataView, keyColumn As DataViewSchema.Column, valueColumn As DataViewSchema.Column, Optional inputColumnName As String = null) As ValueMappingEstimator" />
        <MemberSignature Language="F#" Value="static member MapValue : Microsoft.ML.TransformsCatalog.ConversionTransforms * string * Microsoft.ML.IDataView * Microsoft.ML.DataViewSchema.Column * Microsoft.ML.DataViewSchema.Column * string -&gt; Microsoft.ML.Transforms.ValueMappingEstimator" Usage="Microsoft.ML.ConversionsExtensionsCatalog.MapValue (catalog, outputColumnName, lookupMap, keyColumn, valueColumn, inputColumnName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.ValueMappingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="lookupMap" Type="Microsoft.ML.IDataView" />
          <Parameter Name="keyColumn" Type="Microsoft.ML.DataViewSchema+Column" />
          <Parameter Name="valueColumn" Type="Microsoft.ML.DataViewSchema+Column" />
          <Parameter Name="inputColumnName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="catalog">The conversion transform's catalog</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="lookupMap">An instance of <see cref="T:Microsoft.ML.IDataView" /> that contains the <paramref name="keyColumn" /> and <paramref name="valueColumn" /> columns.</param>
          <param name="keyColumn">The key column in <paramref name="lookupMap" />.</param>
          <param name="valueColumn">The value column in <paramref name="lookupMap" />.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <summary>
            <see cref="T:Microsoft.ML.Transforms.ValueMappingEstimator" />
          </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsExtensionsCatalog" Member="M:Microsoft.ML.ConversionsExtensionsCatalog.MapValue(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,Microsoft.ML.IDataView,Microsoft.ML.DataViewSchema.Column,Microsoft.ML.DataViewSchema.Column,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="MapValue&lt;TInputType,TOutputType&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.ValueMappingEstimator&lt;TInputType,TOutputType&gt; MapValue&lt;TInputType,TOutputType&gt; (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, string outputColumnName, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TInputType,TOutputType[]&gt;&gt; keyValuePairs, string inputColumnName = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.ValueMappingEstimator`2&lt;!!TInputType, !!TOutputType&gt; MapValue&lt;TInputType, TOutputType&gt;(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, string outputColumnName, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!!TInputType, !!TOutputType[]&gt;&gt; keyValuePairs, string inputColumnName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsExtensionsCatalog.MapValue``2(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1[]}},System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function MapValue(Of TInputType, TOutputType) (catalog As TransformsCatalog.ConversionTransforms, outputColumnName As String, keyValuePairs As IEnumerable(Of KeyValuePair(Of TInputType, TOutputType())), Optional inputColumnName As String = null) As ValueMappingEstimator(Of TInputType, TOutputType)" />
        <MemberSignature Language="F#" Value="static member MapValue : Microsoft.ML.TransformsCatalog.ConversionTransforms * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;'InputType, 'OutputType[]&gt;&gt; * string -&gt; Microsoft.ML.Transforms.ValueMappingEstimator&lt;'InputType, 'OutputType&gt;" Usage="Microsoft.ML.ConversionsExtensionsCatalog.MapValue (catalog, outputColumnName, keyValuePairs, inputColumnName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.ValueMappingEstimator&lt;TInputType,TOutputType&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TInputType" />
          <TypeParameter Name="TOutputType" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="keyValuePairs" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TInputType,TOutputType[]&gt;&gt;" />
          <Parameter Name="inputColumnName" Type="System.String" />
        </Parameters>
        <Docs>
          <typeparam name="TInputType">The key type.</typeparam>
          <typeparam name="TOutputType">The value type.</typeparam>
          <param name="catalog">The conversion transform's catalog</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="keyValuePairs">Specifies the mapping that will be perfomed. The keys will be mapped to the values as specified in the <paramref name="keyValuePairs" />.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <summary>
            <see cref="T:Microsoft.ML.Transforms.ValueMappingEstimator" />
          </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsExtensionsCatalog" Member="M:Microsoft.ML.ConversionsExtensionsCatalog.MapValue``2(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1[]}},System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="MapValue&lt;TInputType,TOutputType&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.ValueMappingEstimator&lt;TInputType,TOutputType&gt; MapValue&lt;TInputType,TOutputType&gt; (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, string outputColumnName, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TInputType,TOutputType&gt;&gt; keyValuePairs, string inputColumnName = null, bool treatValuesAsKeyType = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.ValueMappingEstimator`2&lt;!!TInputType, !!TOutputType&gt; MapValue&lt;TInputType, TOutputType&gt;(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, string outputColumnName, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!!TInputType, !!TOutputType&gt;&gt; keyValuePairs, string inputColumnName, bool treatValuesAsKeyType) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsExtensionsCatalog.MapValue``2(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}},System.String,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function MapValue(Of TInputType, TOutputType) (catalog As TransformsCatalog.ConversionTransforms, outputColumnName As String, keyValuePairs As IEnumerable(Of KeyValuePair(Of TInputType, TOutputType)), Optional inputColumnName As String = null, Optional treatValuesAsKeyType As Boolean = false) As ValueMappingEstimator(Of TInputType, TOutputType)" />
        <MemberSignature Language="F#" Value="static member MapValue : Microsoft.ML.TransformsCatalog.ConversionTransforms * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;'InputType, 'OutputType&gt;&gt; * string * bool -&gt; Microsoft.ML.Transforms.ValueMappingEstimator&lt;'InputType, 'OutputType&gt;" Usage="Microsoft.ML.ConversionsExtensionsCatalog.MapValue (catalog, outputColumnName, keyValuePairs, inputColumnName, treatValuesAsKeyType)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.ValueMappingEstimator&lt;TInputType,TOutputType&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TInputType" />
          <TypeParameter Name="TOutputType" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="keyValuePairs" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TInputType,TOutputType&gt;&gt;" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="treatValuesAsKeyType" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <typeparam name="TInputType">The key type.</typeparam>
          <typeparam name="TOutputType">The value type.</typeparam>
          <param name="catalog">The conversion transform's catalog</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="keyValuePairs">Specifies the mapping that will be perfomed. The keys will be mapped to the values as specified in the <paramref name="keyValuePairs" />.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="treatValuesAsKeyType">Whether to treat the values as a <see cref="T:Microsoft.ML.Data.KeyDataViewType" />.</param>
          <summary>
            <see cref="T:Microsoft.ML.Transforms.ValueMappingEstimator" />
          </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsExtensionsCatalog" Member="M:Microsoft.ML.ConversionsExtensionsCatalog.MapValue``2(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}},System.String,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="MapValueToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.ValueToKeyMappingEstimator MapValueToKey (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, Microsoft.ML.InputOutputColumnPair[] columns, int maximumNumberOfKeys = 1000000, Microsoft.ML.Transforms.ValueToKeyMappingEstimator.KeyOrdinality keyOrdinality = Microsoft.ML.Transforms.ValueToKeyMappingEstimator+KeyOrdinality.ByOccurrence, bool addKeyValueAnnotationsAsText = false, Microsoft.ML.IDataView keyData = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.ValueToKeyMappingEstimator MapValueToKey(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, class Microsoft.ML.InputOutputColumnPair[] columns, int32 maximumNumberOfKeys, valuetype Microsoft.ML.Transforms.ValueToKeyMappingEstimator/KeyOrdinality keyOrdinality, bool addKeyValueAnnotationsAsText, class Microsoft.ML.IDataView keyData) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsExtensionsCatalog.MapValueToKey(Microsoft.ML.TransformsCatalog.ConversionTransforms,Microsoft.ML.InputOutputColumnPair[],System.Int32,Microsoft.ML.Transforms.ValueToKeyMappingEstimator.KeyOrdinality,System.Boolean,Microsoft.ML.IDataView)" />
        <MemberSignature Language="F#" Value="static member MapValueToKey : Microsoft.ML.TransformsCatalog.ConversionTransforms * Microsoft.ML.InputOutputColumnPair[] * int * Microsoft.ML.Transforms.ValueToKeyMappingEstimator.KeyOrdinality * bool * Microsoft.ML.IDataView -&gt; Microsoft.ML.Transforms.ValueToKeyMappingEstimator" Usage="Microsoft.ML.ConversionsExtensionsCatalog.MapValueToKey (catalog, columns, maximumNumberOfKeys, keyOrdinality, addKeyValueAnnotationsAsText, keyData)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.ValueToKeyMappingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.InputOutputColumnPair[]" />
          <Parameter Name="maximumNumberOfKeys" Type="System.Int32" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.Transforms.ValueToKeyMappingEstimator+KeyOrdinality" />
          <Parameter Name="addKeyValueAnnotationsAsText" Type="System.Boolean" />
          <Parameter Name="keyData" Type="Microsoft.ML.IDataView" />
        </Parameters>
        <Docs>
          <param name="catalog">The conversion transform's catalog.</param>
          <param name="columns">Specifies the names of the columns on which to apply the transformation.</param>
          <param name="maximumNumberOfKeys">Maximum number of keys to keep per column when auto-training.</param>
          <param name="keyOrdinality">How items should be ordered when vectorized. If <see cref="F:Microsoft.ML.Transforms.ValueToKeyMappingEstimator.KeyOrdinality.ByOccurrence" /> choosen they will be in the order encountered.
            If <see cref="F:Microsoft.ML.Transforms.ValueToKeyMappingEstimator.KeyOrdinality.ByValue" />, items are sorted according to their default comparison, for example, text sorting will be case sensitive (for example, 'A' then 'Z' then 'a').</param>
          <param name="addKeyValueAnnotationsAsText">Whether key value annotations should be text, regardless of the actual input type.</param>
          <param name="keyData">The data view containing the terms. If specified, this should be a single column data
            view, and the key-values will be taken from that column. If unspecified, the key-values will be determined
            from the input data upon fitting.</param>
          <summary>
            Converts value types into <see cref="T:Microsoft.ML.Data.KeyDataViewType" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsExtensionsCatalog" Member="M:Microsoft.ML.ConversionsExtensionsCatalog.MapValueToKey(Microsoft.ML.TransformsCatalog.ConversionTransforms,Microsoft.ML.InputOutputColumnPair[],System.Int32,Microsoft.ML.Transforms.ValueToKeyMappingEstimator.KeyOrdinality,System.Boolean,Microsoft.ML.IDataView)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="MapValueToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.ValueToKeyMappingEstimator MapValueToKey (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, string outputColumnName, string inputColumnName = null, int maximumNumberOfKeys = 1000000, Microsoft.ML.Transforms.ValueToKeyMappingEstimator.KeyOrdinality keyOrdinality = Microsoft.ML.Transforms.ValueToKeyMappingEstimator+KeyOrdinality.ByOccurrence, bool addKeyValueAnnotationsAsText = false, Microsoft.ML.IDataView keyData = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.ValueToKeyMappingEstimator MapValueToKey(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, string outputColumnName, string inputColumnName, int32 maximumNumberOfKeys, valuetype Microsoft.ML.Transforms.ValueToKeyMappingEstimator/KeyOrdinality keyOrdinality, bool addKeyValueAnnotationsAsText, class Microsoft.ML.IDataView keyData) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsExtensionsCatalog.MapValueToKey(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.String,System.Int32,Microsoft.ML.Transforms.ValueToKeyMappingEstimator.KeyOrdinality,System.Boolean,Microsoft.ML.IDataView)" />
        <MemberSignature Language="F#" Value="static member MapValueToKey : Microsoft.ML.TransformsCatalog.ConversionTransforms * string * string * int * Microsoft.ML.Transforms.ValueToKeyMappingEstimator.KeyOrdinality * bool * Microsoft.ML.IDataView -&gt; Microsoft.ML.Transforms.ValueToKeyMappingEstimator" Usage="Microsoft.ML.ConversionsExtensionsCatalog.MapValueToKey (catalog, outputColumnName, inputColumnName, maximumNumberOfKeys, keyOrdinality, addKeyValueAnnotationsAsText, keyData)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.ValueToKeyMappingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="maximumNumberOfKeys" Type="System.Int32" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.Transforms.ValueToKeyMappingEstimator+KeyOrdinality" />
          <Parameter Name="addKeyValueAnnotationsAsText" Type="System.Boolean" />
          <Parameter Name="keyData" Type="Microsoft.ML.IDataView" />
        </Parameters>
        <Docs>
          <param name="catalog">The conversion transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="maximumNumberOfKeys">Maximum number of keys to keep per column when auto-training.</param>
          <param name="keyOrdinality">How items should be ordered when vectorized. If <see cref="F:Microsoft.ML.Transforms.ValueToKeyMappingEstimator.KeyOrdinality.ByOccurrence" /> choosen they will be in the order encountered.
            If <see cref="F:Microsoft.ML.Transforms.ValueToKeyMappingEstimator.KeyOrdinality.ByValue" />, items are sorted according to their default comparison, for example, text sorting will be case sensitive (for example, 'A' then 'Z' then 'a').</param>
          <param name="addKeyValueAnnotationsAsText">Whether key value annotations should be text, regardless of the actual input type.</param>
          <param name="keyData">The data view containing the terms. If specified, this should be a single column data
            view, and the key-values will be taken from that column. If unspecified, the key-values will be determined
            from the input data upon fitting.</param>
          <summary>
            Converts value types into <see cref="T:Microsoft.ML.Data.KeyDataViewType" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsExtensionsCatalog" Member="M:Microsoft.ML.ConversionsExtensionsCatalog.MapValueToKey(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.String,System.Int32,Microsoft.ML.Transforms.ValueToKeyMappingEstimator.KeyOrdinality,System.Boolean,Microsoft.ML.IDataView)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="CustomMapping&lt;TSrc,TDst&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.CustomMappingEstimator&lt;TSrc,TDst&gt; CustomMapping&lt;TSrc,TDst&gt; (this Microsoft.ML.TransformsCatalog catalog, Action&lt;TSrc,TDst&gt; mapAction, string contractName, Microsoft.ML.Data.SchemaDefinition inputSchemaDefinition = null, Microsoft.ML.Data.SchemaDefinition outputSchemaDefinition = null) where TSrc : class, new() where TDst : class, new();" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.CustomMappingEstimator`2&lt;!!TSrc, !!TDst&gt; CustomMapping&lt;class .ctor TSrc, class .ctor TDst&gt;(class Microsoft.ML.TransformsCatalog catalog, class System.Action`2&lt;!!TSrc, !!TDst&gt; mapAction, string contractName, class Microsoft.ML.Data.SchemaDefinition inputSchemaDefinition, class Microsoft.ML.Data.SchemaDefinition outputSchemaDefinition) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.CustomMappingCatalog.CustomMapping``2(Microsoft.ML.TransformsCatalog,System.Action{``0,``1},System.String,Microsoft.ML.Data.SchemaDefinition,Microsoft.ML.Data.SchemaDefinition)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CustomMapping(Of TSrc As {Class, New}, TDst As {Class, New}) (catalog As TransformsCatalog, mapAction As Action(Of TSrc, TDst), contractName As String, Optional inputSchemaDefinition As SchemaDefinition = null, Optional outputSchemaDefinition As SchemaDefinition = null) As CustomMappingEstimator(Of TSrc, TDst)" />
        <MemberSignature Language="F#" Value="static member CustomMapping : Microsoft.ML.TransformsCatalog * Action&lt;'Src, 'Dst (requires 'Src : null and 'Src : (new : unit -&gt; 'Src) and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))&gt; * string * Microsoft.ML.Data.SchemaDefinition * Microsoft.ML.Data.SchemaDefinition -&gt; Microsoft.ML.Transforms.CustomMappingEstimator&lt;'Src, 'Dst (requires 'Src : null and 'Src : (new : unit -&gt; 'Src) and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))&gt; (requires 'Src : null and 'Src : (new : unit -&gt; 'Src) and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))" Usage="Microsoft.ML.CustomMappingCatalog.CustomMapping (catalog, mapAction, contractName, inputSchemaDefinition, outputSchemaDefinition)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.CustomMappingEstimator&lt;TSrc,TDst&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSrc">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
          <TypeParameter Name="TDst">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="mapAction" Type="System.Action&lt;TSrc,TDst&gt;" />
          <Parameter Name="contractName" Type="System.String" />
          <Parameter Name="inputSchemaDefinition" Type="Microsoft.ML.Data.SchemaDefinition" />
          <Parameter Name="outputSchemaDefinition" Type="Microsoft.ML.Data.SchemaDefinition" />
        </Parameters>
        <Docs>
          <typeparam name="TSrc">The class defining which columns to take from the incoming data.</typeparam>
          <typeparam name="TDst">The class defining which new columns are added to the data.</typeparam>
          <param name="catalog">The transform catalog</param>
          <param name="mapAction">The mapping action. This must be thread-safe and free from side effects.</param>
          <param name="contractName">The contract name, used by ML.NET for loading the model. If <c>null</c> is specified, such a trained model would not be save-able.</param>
          <param name="inputSchemaDefinition">Additional parameters for schema mapping between <typeparamref name="TSrc" /> and input data.</param>
          <param name="outputSchemaDefinition">Additional parameters for schema mapping between <typeparamref name="TDst" /> and output data.</param>
          <summary>
            Create a custom mapping of input columns to output columns.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.CustomMappingCatalog" Member="M:Microsoft.ML.CustomMappingCatalog.CustomMapping``2(Microsoft.ML.TransformsCatalog,System.Action{``0,``1},System.String,Microsoft.ML.Data.SchemaDefinition,Microsoft.ML.Data.SchemaDefinition)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IDataView" />
      </Targets>
      <Member MemberName="GetColumn&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; GetColumn&lt;T&gt; (this Microsoft.ML.IDataView data, Microsoft.ML.DataViewSchema.Column column);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; GetColumn&lt;T&gt;(class Microsoft.ML.IDataView data, valuetype Microsoft.ML.DataViewSchema/Column column) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.ColumnCursorExtensions.GetColumn``1(Microsoft.ML.IDataView,Microsoft.ML.DataViewSchema.Column)" />
        <MemberSignature Language="F#" Value="static member GetColumn : Microsoft.ML.IDataView * Microsoft.ML.DataViewSchema.Column -&gt; seq&lt;'T&gt;" Usage="Microsoft.ML.Data.ColumnCursorExtensions.GetColumn (data, column)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.IDataView" RefType="this" />
          <Parameter Name="column" Type="Microsoft.ML.DataViewSchema+Column" />
        </Parameters>
        <Docs>
          <typeparam name="T">The type of the values. This must match the actual column type.</typeparam>
          <param name="data">The data view to get the column from.</param>
          <param name="column">The column to be extracted.</param>
          <summary>
            Extract all values of one column of the data view in a form of an <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.ColumnCursorExtensions" Member="M:Microsoft.ML.Data.ColumnCursorExtensions.GetColumn``1(Microsoft.ML.IDataView,Microsoft.ML.DataViewSchema.Column)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IDataView" />
      </Targets>
      <Member MemberName="GetColumn&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; GetColumn&lt;T&gt; (this Microsoft.ML.IDataView data, string columnName);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; GetColumn&lt;T&gt;(class Microsoft.ML.IDataView data, string columnName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.ColumnCursorExtensions.GetColumn``1(Microsoft.ML.IDataView,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetColumn(Of T) (data As IDataView, columnName As String) As IEnumerable(Of T)" />
        <MemberSignature Language="F#" Value="static member GetColumn : Microsoft.ML.IDataView * string -&gt; seq&lt;'T&gt;" Usage="Microsoft.ML.Data.ColumnCursorExtensions.GetColumn (data, columnName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.IDataView" RefType="this" />
          <Parameter Name="columnName" Type="System.String" />
        </Parameters>
        <Docs>
          <typeparam name="T">The type of the values. This must match the actual column type.</typeparam>
          <param name="data">The data view to get the column from.</param>
          <param name="columnName">The name of the column to be extracted.</param>
          <summary>
            Extract all values of one column of the data view in a form of an <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.ColumnCursorExtensions" Member="M:Microsoft.ML.Data.ColumnCursorExtensions.GetColumn``1(Microsoft.ML.IDataView,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataViewSchema.Column" />
      </Targets>
      <Member MemberName="GetKeyValues&lt;TValue&gt;">
        <MemberSignature Language="C#" Value="public static void GetKeyValues&lt;TValue&gt; (this Microsoft.ML.DataViewSchema.Column column, ref Microsoft.ML.Data.VBuffer&lt;TValue&gt; keyValues);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetKeyValues&lt;TValue&gt;(valuetype Microsoft.ML.DataViewSchema/Column column, valuetype Microsoft.ML.Data.VBuffer`1&lt;!!TValue&gt;&amp; keyValues) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.SchemaAnnotationsExtensions.GetKeyValues``1(Microsoft.ML.DataViewSchema.Column,Microsoft.ML.Data.VBuffer{``0}@)" />
        <MemberSignature Language="F#" Value="static member GetKeyValues : Microsoft.ML.DataViewSchema.Column *  -&gt; unit" Usage="Microsoft.ML.Data.SchemaAnnotationsExtensions.GetKeyValues (column, keyValues)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="column" Type="Microsoft.ML.DataViewSchema+Column" RefType="this" />
          <Parameter Name="keyValues" Type="Microsoft.ML.Data.VBuffer&lt;TValue&gt;" RefType="ref" />
        </Parameters>
        <Docs>
          <typeparam name="TValue">The type of the key values.</typeparam>
          <param name="column">The column whose <see cref="P:Microsoft.ML.DataViewSchema.Column.Annotations" /> will be queried.</param>
          <param name="keyValues">The <see cref="T:Microsoft.ML.Data.VBuffer`1" /> into which the key values will be stored.</param>
          <summary>
            Stores the key values of the input colum into the provided buffer, if this is of key type and whose
            key values are of <see cref="P:Microsoft.ML.Data.VectorDataViewType.ItemType" /> whose <see cref="P:Microsoft.ML.Data.DataViewType.RawType" /> matches
            <typeparamref name="TValue" />. If there is no matching key valued annotation this will throw an exception.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.SchemaAnnotationsExtensions" Member="M:Microsoft.ML.Data.SchemaAnnotationsExtensions.GetKeyValues``1(Microsoft.ML.DataViewSchema.Column,Microsoft.ML.Data.VBuffer{``0}@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataViewSchema.Column" />
      </Targets>
      <Member MemberName="GetSlotNames">
        <MemberSignature Language="C#" Value="public static void GetSlotNames (this Microsoft.ML.DataViewSchema.Column column, ref Microsoft.ML.Data.VBuffer&lt;ReadOnlyMemory&lt;char&gt;&gt; slotNames);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetSlotNames(valuetype Microsoft.ML.DataViewSchema/Column column, valuetype Microsoft.ML.Data.VBuffer`1&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt;&amp; slotNames) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.SchemaAnnotationsExtensions.GetSlotNames(Microsoft.ML.DataViewSchema.Column,Microsoft.ML.Data.VBuffer{System.ReadOnlyMemory{System.Char}}@)" />
        <MemberSignature Language="F#" Value="static member GetSlotNames : Microsoft.ML.DataViewSchema.Column *  -&gt; unit" Usage="Microsoft.ML.Data.SchemaAnnotationsExtensions.GetSlotNames (column, slotNames)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="column" Type="Microsoft.ML.DataViewSchema+Column" RefType="this" />
          <Parameter Name="slotNames" Type="Microsoft.ML.Data.VBuffer&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="column">The column whose <see cref="P:Microsoft.ML.DataViewSchema.Column.Annotations" /> will be queried.</param>
          <param name="slotNames">The <see cref="T:Microsoft.ML.Data.VBuffer`1" /> into which the slot names will be stored.</param>
          <summary>
            Stores the slots names of the input column into the provided buffer, if there are slot names.
            Otherwise it will throw an exception.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.SchemaAnnotationsExtensions" Member="M:Microsoft.ML.Data.SchemaAnnotationsExtensions.GetSlotNames(Microsoft.ML.DataViewSchema.Column,Microsoft.ML.Data.VBuffer{System.ReadOnlyMemory{System.Char}}@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataViewSchema.Column" />
      </Targets>
      <Member MemberName="HasKeyValues">
        <MemberSignature Language="C#" Value="public static bool HasKeyValues (this Microsoft.ML.DataViewSchema.Column column, Microsoft.ML.Data.PrimitiveDataViewType keyValueItemType = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasKeyValues(valuetype Microsoft.ML.DataViewSchema/Column column, class Microsoft.ML.Data.PrimitiveDataViewType keyValueItemType) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.SchemaAnnotationsExtensions.HasKeyValues(Microsoft.ML.DataViewSchema.Column,Microsoft.ML.Data.PrimitiveDataViewType)" />
        <MemberSignature Language="F#" Value="static member HasKeyValues : Microsoft.ML.DataViewSchema.Column * Microsoft.ML.Data.PrimitiveDataViewType -&gt; bool" Usage="Microsoft.ML.Data.SchemaAnnotationsExtensions.HasKeyValues (column, keyValueItemType)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="column" Type="Microsoft.ML.DataViewSchema+Column" RefType="this" />
          <Parameter Name="keyValueItemType" Type="Microsoft.ML.Data.PrimitiveDataViewType" />
        </Parameters>
        <Docs>
          <param name="column">The column whose <see cref="P:Microsoft.ML.DataViewSchema.Column.Annotations" /> will be queried.</param>
          <param name="keyValueItemType">The type of the individual key-values to query. A common,
            though not universal, type to provide is <see cref="P:Microsoft.ML.Data.TextDataViewType.Instance" />, so if left unspecified
            this will be assumed to have the value <see cref="P:Microsoft.ML.Data.TextDataViewType.Instance" />.</param>
          <summary>
            Returns <see langword="true" /> if the input column is of <see cref="T:Microsoft.ML.Data.VectorDataViewType" />, and that has
            <c>SlotNames</c> annotation of a <see cref="T:Microsoft.ML.Data.VectorDataViewType" /> whose <see cref="P:Microsoft.ML.Data.VectorDataViewType.ItemType" />
            is of <see cref="T:Microsoft.ML.Data.TextDataViewType" />, and further whose <see cref="P:Microsoft.ML.Data.VectorDataViewType.Size" /> matches
            this input vector size.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.SchemaAnnotationsExtensions" Member="M:Microsoft.ML.Data.SchemaAnnotationsExtensions.HasKeyValues(Microsoft.ML.DataViewSchema.Column,Microsoft.ML.Data.PrimitiveDataViewType)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataViewSchema.Column" />
      </Targets>
      <Member MemberName="HasSlotNames">
        <MemberSignature Language="C#" Value="public static bool HasSlotNames (this Microsoft.ML.DataViewSchema.Column column);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasSlotNames(valuetype Microsoft.ML.DataViewSchema/Column column) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.SchemaAnnotationsExtensions.HasSlotNames(Microsoft.ML.DataViewSchema.Column)" />
        <MemberSignature Language="F#" Value="static member HasSlotNames : Microsoft.ML.DataViewSchema.Column -&gt; bool" Usage="Microsoft.ML.Data.SchemaAnnotationsExtensions.HasSlotNames column" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="column" Type="Microsoft.ML.DataViewSchema+Column" RefType="this" />
        </Parameters>
        <Docs>
          <param name="column">The column whose <see cref="P:Microsoft.ML.DataViewSchema.Column.Annotations" /> will be queried.</param>
          <summary>
            Returns <see langword="true" /> if the input column is of <see cref="T:Microsoft.ML.Data.VectorDataViewType" />, and that has
            <c>SlotNames</c> annotation of a <see cref="T:Microsoft.ML.Data.VectorDataViewType" /> whose <see cref="P:Microsoft.ML.Data.VectorDataViewType.ItemType" />
            is of <see cref="T:Microsoft.ML.Data.TextDataViewType" />, and further whose <see cref="P:Microsoft.ML.Data.VectorDataViewType.Size" /> matches
            this input vector size.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.SchemaAnnotationsExtensions" Member="M:Microsoft.ML.Data.SchemaAnnotationsExtensions.HasSlotNames(Microsoft.ML.DataViewSchema.Column)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataViewSchema.Column" />
      </Targets>
      <Member MemberName="IsNormalized">
        <MemberSignature Language="C#" Value="public static bool IsNormalized (this Microsoft.ML.DataViewSchema.Column column);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormalized(valuetype Microsoft.ML.DataViewSchema/Column column) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.SchemaAnnotationsExtensions.IsNormalized(Microsoft.ML.DataViewSchema.Column)" />
        <MemberSignature Language="F#" Value="static member IsNormalized : Microsoft.ML.DataViewSchema.Column -&gt; bool" Usage="Microsoft.ML.Data.SchemaAnnotationsExtensions.IsNormalized column" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="column" Type="Microsoft.ML.DataViewSchema+Column" RefType="this" />
        </Parameters>
        <Docs>
          <param name="column">To be added.</param>
          <summary>
            Returns <see langword="true" /> if and only if <paramref name="column" /> has <c>IsNormalized</c> annotation
            set to <see langword="true" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.SchemaAnnotationsExtensions" Member="M:Microsoft.ML.Data.SchemaAnnotationsExtensions.IsNormalized(Microsoft.ML.DataViewSchema.Column)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IDataLoader`1" />
      </Targets>
      <Member MemberName="Load">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.IDataView Load (this Microsoft.ML.IDataLoader&lt;Microsoft.ML.Data.IMultiStreamSource&gt; loader, params string[] path);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.IDataView Load(class Microsoft.ML.IDataLoader`1&lt;class Microsoft.ML.Data.IMultiStreamSource&gt; loader, string[] path) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.DataLoaderExtensions.Load(Microsoft.ML.IDataLoader{Microsoft.ML.Data.IMultiStreamSource},System.String[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Load (loader As IDataLoader(Of IMultiStreamSource), ParamArray path As String()) As IDataView" />
        <MemberSignature Language="F#" Value="static member Load : Microsoft.ML.IDataLoader&lt;Microsoft.ML.Data.IMultiStreamSource&gt; * string[] -&gt; Microsoft.ML.IDataView" Usage="Microsoft.ML.DataLoaderExtensions.Load (loader, path)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.IDataView</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="loader" Type="Microsoft.ML.IDataLoader&lt;Microsoft.ML.Data.IMultiStreamSource&gt;" RefType="this" />
          <Parameter Name="path" Type="System.String[]">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet">
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="loader">The loader to use.</param>
          <param name="path">One or more paths from which to load data.</param>
          <summary>
            Loads data from one or more file <paramref name="path" /> into an <see cref="T:Microsoft.ML.IDataView" />.
            Note that <see cref="T:Microsoft.ML.IDataView" />'s are lazy, so no actual loading happens here, just schema validation.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.DataLoaderExtensions" Member="M:Microsoft.ML.DataLoaderExtensions.Load(Microsoft.ML.IDataLoader{Microsoft.ML.Data.IMultiStreamSource},System.String[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IDataView" />
      </Targets>
      <Member MemberName="Preview">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.DataDebuggerPreview Preview (this Microsoft.ML.IDataView data, int maxRows = 100);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.DataDebuggerPreview Preview(class Microsoft.ML.IDataView data, int32 maxRows) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.DebuggerExtensions.Preview(Microsoft.ML.IDataView,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Preview (data As IDataView, Optional maxRows As Integer = 100) As DataDebuggerPreview" />
        <MemberSignature Language="F#" Value="static member Preview : Microsoft.ML.IDataView * int -&gt; Microsoft.ML.Data.DataDebuggerPreview" Usage="Microsoft.ML.DebuggerExtensions.Preview (data, maxRows)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.DataDebuggerPreview</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.IDataView" RefType="this" />
          <Parameter Name="maxRows" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="data">The data view to preview</param>
          <param name="maxRows">Maximum number of rows to pull</param>
          <summary>
            Extract a 'head' of the data view in a view that is convenient to debug.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.DebuggerExtensions" Member="M:Microsoft.ML.DebuggerExtensions.Preview(Microsoft.ML.IDataView,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IEstimator`1" />
      </Targets>
      <Member MemberName="Preview">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.DataDebuggerPreview Preview (this Microsoft.ML.IEstimator&lt;Microsoft.ML.ITransformer&gt; estimator, Microsoft.ML.IDataView data, int maxRows = 100, int maxTrainingRows = 100);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.DataDebuggerPreview Preview(class Microsoft.ML.IEstimator`1&lt;class Microsoft.ML.ITransformer&gt; estimator, class Microsoft.ML.IDataView data, int32 maxRows, int32 maxTrainingRows) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.DebuggerExtensions.Preview(Microsoft.ML.IEstimator{Microsoft.ML.ITransformer},Microsoft.ML.IDataView,System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Preview (estimator As IEstimator(Of ITransformer), data As IDataView, Optional maxRows As Integer = 100, Optional maxTrainingRows As Integer = 100) As DataDebuggerPreview" />
        <MemberSignature Language="F#" Value="static member Preview : Microsoft.ML.IEstimator&lt;Microsoft.ML.ITransformer&gt; * Microsoft.ML.IDataView * int * int -&gt; Microsoft.ML.Data.DataDebuggerPreview" Usage="Microsoft.ML.DebuggerExtensions.Preview (estimator, data, maxRows, maxTrainingRows)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.DataDebuggerPreview</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="estimator" Type="Microsoft.ML.IEstimator&lt;Microsoft.ML.ITransformer&gt;" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.IDataView" />
          <Parameter Name="maxRows" Type="System.Int32" />
          <Parameter Name="maxTrainingRows" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="estimator">The estimnator which effect we are previewing</param>
          <param name="data">The data view to use for preview</param>
          <param name="maxRows">Maximum number of rows to show in preview</param>
          <param name="maxTrainingRows">Maximum number of rows to fit the estimator</param>
          <summary>
            Preview an effect of the <paramref name="estimator" /> on a given <paramref name="data" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.DebuggerExtensions" Member="M:Microsoft.ML.DebuggerExtensions.Preview(Microsoft.ML.IEstimator{Microsoft.ML.ITransformer},Microsoft.ML.IDataView,System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.ITransformer" />
      </Targets>
      <Member MemberName="Preview">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.DataDebuggerPreview Preview (this Microsoft.ML.ITransformer transformer, Microsoft.ML.IDataView data, int maxRows = 100);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.DataDebuggerPreview Preview(class Microsoft.ML.ITransformer transformer, class Microsoft.ML.IDataView data, int32 maxRows) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.DebuggerExtensions.Preview(Microsoft.ML.ITransformer,Microsoft.ML.IDataView,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Preview (transformer As ITransformer, data As IDataView, Optional maxRows As Integer = 100) As DataDebuggerPreview" />
        <MemberSignature Language="F#" Value="static member Preview : Microsoft.ML.ITransformer * Microsoft.ML.IDataView * int -&gt; Microsoft.ML.Data.DataDebuggerPreview" Usage="Microsoft.ML.DebuggerExtensions.Preview (transformer, data, maxRows)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.DataDebuggerPreview</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="transformer" Type="Microsoft.ML.ITransformer" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.IDataView" />
          <Parameter Name="maxRows" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="transformer">The transformer which effect we are previewing</param>
          <param name="data">The data view to use for preview</param>
          <param name="maxRows">Maximum number of rows to pull</param>
          <summary>
            Preview an effect of the <paramref name="transformer" /> on a given <paramref name="data" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.DebuggerExtensions" Member="M:Microsoft.ML.DebuggerExtensions.Preview(Microsoft.ML.ITransformer,Microsoft.ML.IDataView,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IDataLoader`1" />
      </Targets>
      <Member MemberName="Preview&lt;TSource&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.DataDebuggerPreview Preview&lt;TSource&gt; (this Microsoft.ML.IDataLoader&lt;TSource&gt; loader, TSource source, int maxRows = 100);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.DataDebuggerPreview Preview&lt;TSource&gt;(class Microsoft.ML.IDataLoader`1&lt;!!TSource&gt; loader, !!TSource source, int32 maxRows) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.DebuggerExtensions.Preview``1(Microsoft.ML.IDataLoader{``0},``0,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Preview(Of TSource) (loader As IDataLoader(Of TSource), source As TSource, Optional maxRows As Integer = 100) As DataDebuggerPreview" />
        <MemberSignature Language="F#" Value="static member Preview : Microsoft.ML.IDataLoader&lt;'Source&gt; * 'Source * int -&gt; Microsoft.ML.Data.DataDebuggerPreview" Usage="Microsoft.ML.DebuggerExtensions.Preview (loader, source, maxRows)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.DataDebuggerPreview</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSource" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="loader" Type="Microsoft.ML.IDataLoader&lt;TSource&gt;" RefType="this" />
          <Parameter Name="source" Type="TSource" />
          <Parameter Name="maxRows" Type="System.Int32" />
        </Parameters>
        <Docs>
          <typeparam name="TSource">To be added.</typeparam>
          <param name="loader">The data loader to preview</param>
          <param name="source">The source to pull the data from</param>
          <param name="maxRows">Maximum number of rows to pull</param>
          <summary>
            Preview an effect of the <paramref name="loader" /> on a given <paramref name="source" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.DebuggerExtensions" Member="M:Microsoft.ML.DebuggerExtensions.Preview``1(Microsoft.ML.IDataLoader{``0},``0,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="CalculateFeatureContribution">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.FeatureContributionCalculatingEstimator CalculateFeatureContribution (this Microsoft.ML.TransformsCatalog catalog, Microsoft.ML.ISingleFeaturePredictionTransformer&lt;Microsoft.ML.Trainers.ICalculateFeatureContribution&gt; predictionTransformer, int numberOfPositiveContributions = 10, int numberOfNegativeContributions = 10, bool normalize = true);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.FeatureContributionCalculatingEstimator CalculateFeatureContribution(class Microsoft.ML.TransformsCatalog catalog, class Microsoft.ML.ISingleFeaturePredictionTransformer`1&lt;class Microsoft.ML.Trainers.ICalculateFeatureContribution&gt; predictionTransformer, int32 numberOfPositiveContributions, int32 numberOfNegativeContributions, bool normalize) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ExplainabilityCatalog.CalculateFeatureContribution(Microsoft.ML.TransformsCatalog,Microsoft.ML.ISingleFeaturePredictionTransformer{Microsoft.ML.Trainers.ICalculateFeatureContribution},System.Int32,System.Int32,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CalculateFeatureContribution (catalog As TransformsCatalog, predictionTransformer As ISingleFeaturePredictionTransformer(Of ICalculateFeatureContribution), Optional numberOfPositiveContributions As Integer = 10, Optional numberOfNegativeContributions As Integer = 10, Optional normalize As Boolean = true) As FeatureContributionCalculatingEstimator" />
        <MemberSignature Language="F#" Value="static member CalculateFeatureContribution : Microsoft.ML.TransformsCatalog * Microsoft.ML.ISingleFeaturePredictionTransformer&lt;Microsoft.ML.Trainers.ICalculateFeatureContribution&gt; * int * int * bool -&gt; Microsoft.ML.Transforms.FeatureContributionCalculatingEstimator" Usage="Microsoft.ML.ExplainabilityCatalog.CalculateFeatureContribution (catalog, predictionTransformer, numberOfPositiveContributions, numberOfNegativeContributions, normalize)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.FeatureContributionCalculatingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="predictionTransformer" Type="Microsoft.ML.ISingleFeaturePredictionTransformer&lt;Microsoft.ML.Trainers.ICalculateFeatureContribution&gt;" />
          <Parameter Name="numberOfPositiveContributions" Type="System.Int32" />
          <Parameter Name="numberOfNegativeContributions" Type="System.Int32" />
          <Parameter Name="normalize" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The model explainability operations catalog.</param>
          <param name="predictionTransformer">A <see cref="T:Microsoft.ML.ISingleFeaturePredictionTransformer`1" /> that supports Feature Contribution Calculation,
            and which will also be used for scoring.</param>
          <param name="numberOfPositiveContributions">The number of positive contributions to report, sorted from highest magnitude to lowest magnitude.
            Note that if there are fewer features with positive contributions than <paramref name="numberOfPositiveContributions" />, the rest will be returned as zeros.</param>
          <param name="numberOfNegativeContributions">The number of negative contributions to report, sorted from highest magnitude to lowest magnitude.
            Note that if there are fewer features with negative contributions than <paramref name="numberOfNegativeContributions" />, the rest will be returned as zeros.</param>
          <param name="normalize">Whether the feature contributions should be normalized to the [-1, 1] interval.</param>
          <summary>
            Feature Contribution Calculation computes model-specific contribution scores for each feature.
            Note that this functionality is not supported by all the models. See <see cref="T:Microsoft.ML.Transforms.FeatureContributionCalculatingTransformer" /> for a list of the suported models.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ExplainabilityCatalog" Member="M:Microsoft.ML.ExplainabilityCatalog.CalculateFeatureContribution(Microsoft.ML.TransformsCatalog,Microsoft.ML.ISingleFeaturePredictionTransformer{Microsoft.ML.Trainers.ICalculateFeatureContribution},System.Int32,System.Int32,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="CalculateFeatureContribution&lt;TModelParameters,TCalibrator&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.FeatureContributionCalculatingEstimator CalculateFeatureContribution&lt;TModelParameters,TCalibrator&gt; (this Microsoft.ML.TransformsCatalog catalog, Microsoft.ML.ISingleFeaturePredictionTransformer&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;TModelParameters,TCalibrator&gt;&gt; predictionTransformer, int numberOfPositiveContributions = 10, int numberOfNegativeContributions = 10, bool normalize = true) where TModelParameters : class, Microsoft.ML.Trainers.ICalculateFeatureContribution where TCalibrator : class, Microsoft.ML.Calibrators.ICalibrator;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.FeatureContributionCalculatingEstimator CalculateFeatureContribution&lt;class (class Microsoft.ML.Trainers.ICalculateFeatureContribution) TModelParameters, class (class Microsoft.ML.Calibrators.ICalibrator) TCalibrator&gt;(class Microsoft.ML.TransformsCatalog catalog, class Microsoft.ML.ISingleFeaturePredictionTransformer`1&lt;class Microsoft.ML.Calibrators.CalibratedModelParametersBase`2&lt;!!TModelParameters, !!TCalibrator&gt;&gt; predictionTransformer, int32 numberOfPositiveContributions, int32 numberOfNegativeContributions, bool normalize) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ExplainabilityCatalog.CalculateFeatureContribution``2(Microsoft.ML.TransformsCatalog,Microsoft.ML.ISingleFeaturePredictionTransformer{Microsoft.ML.Calibrators.CalibratedModelParametersBase{``0,``1}},System.Int32,System.Int32,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CalculateFeatureContribution(Of TModelParameters As {Class, ICalculateFeatureContribution}, TCalibrator As {Class, ICalculateFeatureContribution}) (catalog As TransformsCatalog, predictionTransformer As ISingleFeaturePredictionTransformer(Of CalibratedModelParametersBase(Of TModelParameters, TCalibrator)), Optional numberOfPositiveContributions As Integer = 10, Optional numberOfNegativeContributions As Integer = 10, Optional normalize As Boolean = true) As FeatureContributionCalculatingEstimator" />
        <MemberSignature Language="F#" Value="static member CalculateFeatureContribution : Microsoft.ML.TransformsCatalog * Microsoft.ML.ISingleFeaturePredictionTransformer&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;'ModelParameters, 'Calibrator&gt;&gt; * int * int * bool -&gt; Microsoft.ML.Transforms.FeatureContributionCalculatingEstimator (requires 'ModelParameters : null and 'ModelParameters :&gt; Microsoft.ML.Trainers.ICalculateFeatureContribution and 'Calibrator : null and 'Calibrator :&gt; Microsoft.ML.Calibrators.ICalibrator)" Usage="Microsoft.ML.ExplainabilityCatalog.CalculateFeatureContribution (catalog, predictionTransformer, numberOfPositiveContributions, numberOfNegativeContributions, normalize)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.FeatureContributionCalculatingEstimator</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TModelParameters">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Trainers.ICalculateFeatureContribution</InterfaceName>
            </Constraints>
          </TypeParameter>
          <TypeParameter Name="TCalibrator">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Calibrators.ICalibrator</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="predictionTransformer" Type="Microsoft.ML.ISingleFeaturePredictionTransformer&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;TModelParameters,TCalibrator&gt;&gt;" />
          <Parameter Name="numberOfPositiveContributions" Type="System.Int32" />
          <Parameter Name="numberOfNegativeContributions" Type="System.Int32" />
          <Parameter Name="normalize" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <typeparam name="TModelParameters">To be added.</typeparam>
          <typeparam name="TCalibrator">To be added.</typeparam>
          <param name="catalog">The model explainability operations catalog.</param>
          <param name="predictionTransformer">A <see cref="T:Microsoft.ML.ISingleFeaturePredictionTransformer`1" /> that supports Feature Contribution Calculation,
            and which will also be used for scoring.</param>
          <param name="numberOfPositiveContributions">The number of positive contributions to report, sorted from highest magnitude to lowest magnitude.
            Note that if there are fewer features with positive contributions than <paramref name="numberOfPositiveContributions" />, the rest will be returned as zeros.</param>
          <param name="numberOfNegativeContributions">The number of negative contributions to report, sorted from highest magnitude to lowest magnitude.
            Note that if there are fewer features with negative contributions than <paramref name="numberOfNegativeContributions" />, the rest will be returned as zeros.</param>
          <param name="normalize">Whether the feature contributions should be normalized to the [-1, 1] interval.</param>
          <summary>
            Feature Contribution Calculation computes model-specific contribution scores for each feature.
            Note that this functionality is not supported by all the models. See <see cref="T:Microsoft.ML.Transforms.FeatureContributionCalculatingTransformer" /> for a list of the suported models.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ExplainabilityCatalog" Member="M:Microsoft.ML.ExplainabilityCatalog.CalculateFeatureContribution``2(Microsoft.ML.TransformsCatalog,Microsoft.ML.ISingleFeaturePredictionTransformer{Microsoft.ML.Calibrators.CalibratedModelParametersBase{``0,``1}},System.Int32,System.Int32,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="IndicateMissingValues">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.MissingValueIndicatorEstimator IndicateMissingValues (this Microsoft.ML.TransformsCatalog catalog, Microsoft.ML.InputOutputColumnPair[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.MissingValueIndicatorEstimator IndicateMissingValues(class Microsoft.ML.TransformsCatalog catalog, class Microsoft.ML.InputOutputColumnPair[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ExtensionsCatalog.IndicateMissingValues(Microsoft.ML.TransformsCatalog,Microsoft.ML.InputOutputColumnPair[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndicateMissingValues (catalog As TransformsCatalog, columns As InputOutputColumnPair()) As MissingValueIndicatorEstimator" />
        <MemberSignature Language="F#" Value="static member IndicateMissingValues : Microsoft.ML.TransformsCatalog * Microsoft.ML.InputOutputColumnPair[] -&gt; Microsoft.ML.Transforms.MissingValueIndicatorEstimator" Usage="Microsoft.ML.ExtensionsCatalog.IndicateMissingValues (catalog, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.MissingValueIndicatorEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.InputOutputColumnPair[]" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform extensions' catalog.</param>
          <param name="columns">Specifies the names of the columns on which to apply the transformation.</param>
          <summary>
            Creates a new output column, of boolean type, with the same number of slots as the input column. The value in the output column
            is true if the value in the input column is missing.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ExtensionsCatalog" Member="M:Microsoft.ML.ExtensionsCatalog.IndicateMissingValues(Microsoft.ML.TransformsCatalog,Microsoft.ML.InputOutputColumnPair[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="IndicateMissingValues">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.MissingValueIndicatorEstimator IndicateMissingValues (this Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.MissingValueIndicatorEstimator IndicateMissingValues(class Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ExtensionsCatalog.IndicateMissingValues(Microsoft.ML.TransformsCatalog,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndicateMissingValues (catalog As TransformsCatalog, outputColumnName As String, Optional inputColumnName As String = null) As MissingValueIndicatorEstimator" />
        <MemberSignature Language="F#" Value="static member IndicateMissingValues : Microsoft.ML.TransformsCatalog * string * string -&gt; Microsoft.ML.Transforms.MissingValueIndicatorEstimator" Usage="Microsoft.ML.ExtensionsCatalog.IndicateMissingValues (catalog, outputColumnName, inputColumnName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.MissingValueIndicatorEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform extensions' catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.
            If left to <value>null</value> the <paramref name="inputColumnName" /> will get replaced.</param>
          <summary>
            Creates a new output column, or replaces the source with a new column
            (depending on whether the <paramref name="inputColumnName" /> is given a value, or left to null)
            of boolean type, with the same number of slots as the input column. The value in the output column
            is true if the value in the input column is missing.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ExtensionsCatalog" Member="M:Microsoft.ML.ExtensionsCatalog.IndicateMissingValues(Microsoft.ML.TransformsCatalog,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="ReplaceMissingValues">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.MissingValueReplacingEstimator ReplaceMissingValues (this Microsoft.ML.TransformsCatalog catalog, Microsoft.ML.InputOutputColumnPair[] columns, Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode replacementMode = Microsoft.ML.Transforms.MissingValueReplacingEstimator+ReplacementMode.DefaultValue, bool imputeBySlot = true);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.MissingValueReplacingEstimator ReplaceMissingValues(class Microsoft.ML.TransformsCatalog catalog, class Microsoft.ML.InputOutputColumnPair[] columns, valuetype Microsoft.ML.Transforms.MissingValueReplacingEstimator/ReplacementMode replacementMode, bool imputeBySlot) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ExtensionsCatalog.ReplaceMissingValues(Microsoft.ML.TransformsCatalog,Microsoft.ML.InputOutputColumnPair[],Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode,System.Boolean)" />
        <MemberSignature Language="F#" Value="static member ReplaceMissingValues : Microsoft.ML.TransformsCatalog * Microsoft.ML.InputOutputColumnPair[] * Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode * bool -&gt; Microsoft.ML.Transforms.MissingValueReplacingEstimator" Usage="Microsoft.ML.ExtensionsCatalog.ReplaceMissingValues (catalog, columns, replacementMode, imputeBySlot)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.MissingValueReplacingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.InputOutputColumnPair[]" />
          <Parameter Name="replacementMode" Type="Microsoft.ML.Transforms.MissingValueReplacingEstimator+ReplacementMode" />
          <Parameter Name="imputeBySlot" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform extensions' catalog.</param>
          <param name="columns">Specifies the names of the columns on which to apply the transformation.</param>
          <param name="replacementMode">The type of replacement to use as specified in <see cref="T:Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode" /></param>
          <param name="imputeBySlot">If true, per-slot imputation of replacement is performed.
            Otherwise, replacement value is imputed for the entire vector column. This setting is ignored for scalars and variable vectors,
            where imputation is always for the entire column.</param>
          <summary>
            Creates a new output column, identical to the input column for everything but the missing values.
            The missing values of the input column, in this new column are replaced with <see cref="F:Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode.DefaultValue" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ExtensionsCatalog" Member="M:Microsoft.ML.ExtensionsCatalog.ReplaceMissingValues(Microsoft.ML.TransformsCatalog,Microsoft.ML.InputOutputColumnPair[],Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="ReplaceMissingValues">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.MissingValueReplacingEstimator ReplaceMissingValues (this Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName = null, Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode replacementMode = Microsoft.ML.Transforms.MissingValueReplacingEstimator+ReplacementMode.DefaultValue, bool imputeBySlot = true);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.MissingValueReplacingEstimator ReplaceMissingValues(class Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName, valuetype Microsoft.ML.Transforms.MissingValueReplacingEstimator/ReplacementMode replacementMode, bool imputeBySlot) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ExtensionsCatalog.ReplaceMissingValues(Microsoft.ML.TransformsCatalog,System.String,System.String,Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode,System.Boolean)" />
        <MemberSignature Language="F#" Value="static member ReplaceMissingValues : Microsoft.ML.TransformsCatalog * string * string * Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode * bool -&gt; Microsoft.ML.Transforms.MissingValueReplacingEstimator" Usage="Microsoft.ML.ExtensionsCatalog.ReplaceMissingValues (catalog, outputColumnName, inputColumnName, replacementMode, imputeBySlot)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.MissingValueReplacingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="replacementMode" Type="Microsoft.ML.Transforms.MissingValueReplacingEstimator+ReplacementMode" />
          <Parameter Name="imputeBySlot" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform extensions' catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.
            If not provided, the <paramref name="inputColumnName" /> will be replaced with the results of the transforms.</param>
          <param name="replacementMode">The type of replacement to use as specified in <see cref="T:Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode" /></param>
          <param name="imputeBySlot">If true, per-slot imputation of replacement is performed.
            Otherwise, replacement value is imputed for the entire vector column. This setting is ignored for scalars and variable vectors,
            where imputation is always for the entire column.</param>
          <summary>
            Creates a new output column, or replaces the source with a new column
            (depending on whether the <paramref name="outputColumnName" /> is given a value, or left to null)
            identical to the input column for everything but the missing values. The missing values of the input column, in this new column are replaced with
            one of the values specifid in the <paramref name="replacementMode" />. The default for the <paramref name="replacementMode" /> is
            <see cref="F:Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode.DefaultValue" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ExtensionsCatalog" Member="M:Microsoft.ML.ExtensionsCatalog.ReplaceMissingValues(Microsoft.ML.TransformsCatalog,System.String,System.String,Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="FieldAwareFactorizationMachine">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer FieldAwareFactorizationMachine (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer FieldAwareFactorizationMachine(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.FactorizationMachineExtensions.FieldAwareFactorizationMachine(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member FieldAwareFactorizationMachine : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer.Options -&gt; Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer" Usage="Microsoft.ML.FactorizationMachineExtensions.FieldAwareFactorizationMachine (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="options">Advanced arguments to the algorithm.</param>
          <summary>
            Predict a target using a field-aware factorization machine algorithm.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.FactorizationMachineExtensions" Member="M:Microsoft.ML.FactorizationMachineExtensions.FieldAwareFactorizationMachine(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="FieldAwareFactorizationMachine">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer FieldAwareFactorizationMachine (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, string featureColumnName = &quot;Features&quot;, string labelColumnName = &quot;Label&quot;, string exampleWeightColumnName = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer FieldAwareFactorizationMachine(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, string featureColumnName, string labelColumnName, string exampleWeightColumnName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.FactorizationMachineExtensions.FieldAwareFactorizationMachine(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FieldAwareFactorizationMachine (catalog As BinaryClassificationCatalog.BinaryClassificationTrainers, Optional featureColumnName As String = &quot;Features&quot;, Optional labelColumnName As String = &quot;Label&quot;, Optional exampleWeightColumnName As String = null) As FieldAwareFactorizationMachineTrainer" />
        <MemberSignature Language="F#" Value="static member FieldAwareFactorizationMachine : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * string * string * string -&gt; Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer" Usage="Microsoft.ML.FactorizationMachineExtensions.FieldAwareFactorizationMachine (catalog, featureColumnName, labelColumnName, exampleWeightColumnName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <summary>
            Predict a target using a field-aware factorization machine algorithm.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.FactorizationMachineExtensions" Member="M:Microsoft.ML.FactorizationMachineExtensions.FieldAwareFactorizationMachine(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="FieldAwareFactorizationMachine">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer FieldAwareFactorizationMachine (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, string[] featureColumnNames, string labelColumnName = &quot;Label&quot;, string exampleWeightColumnName = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer FieldAwareFactorizationMachine(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, string[] featureColumnNames, string labelColumnName, string exampleWeightColumnName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.FactorizationMachineExtensions.FieldAwareFactorizationMachine(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String[],System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FieldAwareFactorizationMachine (catalog As BinaryClassificationCatalog.BinaryClassificationTrainers, featureColumnNames As String(), Optional labelColumnName As String = &quot;Label&quot;, Optional exampleWeightColumnName As String = null) As FieldAwareFactorizationMachineTrainer" />
        <MemberSignature Language="F#" Value="static member FieldAwareFactorizationMachine : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * string[] * string * string -&gt; Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer" Usage="Microsoft.ML.FactorizationMachineExtensions.FieldAwareFactorizationMachine (catalog, featureColumnNames, labelColumnName, exampleWeightColumnName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="featureColumnNames" Type="System.String[]" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="featureColumnNames">The name(s) of the feature columns.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <summary>
            Predict a target using a field-aware factorization machine algorithm.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.FactorizationMachineExtensions" Member="M:Microsoft.ML.FactorizationMachineExtensions.FieldAwareFactorizationMachine(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String[],System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnCount">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.CountFeatureSelectingEstimator SelectFeaturesBasedOnCount (this Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms catalog, Microsoft.ML.InputOutputColumnPair[] columns, long count = 1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.CountFeatureSelectingEstimator SelectFeaturesBasedOnCount(class Microsoft.ML.TransformsCatalog/FeatureSelectionTransforms catalog, class Microsoft.ML.InputOutputColumnPair[] columns, int64 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.FeatureSelectionCatalog.SelectFeaturesBasedOnCount(Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms,Microsoft.ML.InputOutputColumnPair[],System.Int64)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnCount (catalog As TransformsCatalog.FeatureSelectionTransforms, columns As InputOutputColumnPair(), Optional count As Long = 1) As CountFeatureSelectingEstimator" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnCount : Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms * Microsoft.ML.InputOutputColumnPair[] * int64 -&gt; Microsoft.ML.Transforms.CountFeatureSelectingEstimator" Usage="Microsoft.ML.FeatureSelectionCatalog.SelectFeaturesBasedOnCount (catalog, columns, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.CountFeatureSelectingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+FeatureSelectionTransforms" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.InputOutputColumnPair[]" />
          <Parameter Name="count" Type="System.Int64" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="columns">Specifies the names of the columns on which to apply the transformation.</param>
          <param name="count">If the count of non-default values for a slot is greater than or equal to this threshold in the training data, the slot is preserved.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.FeatureSelectionCatalog" Member="M:Microsoft.ML.FeatureSelectionCatalog.SelectFeaturesBasedOnCount(Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms,Microsoft.ML.InputOutputColumnPair[],System.Int64)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnCount">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.CountFeatureSelectingEstimator SelectFeaturesBasedOnCount (this Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms catalog, string outputColumnName, string inputColumnName = null, long count = 1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.CountFeatureSelectingEstimator SelectFeaturesBasedOnCount(class Microsoft.ML.TransformsCatalog/FeatureSelectionTransforms catalog, string outputColumnName, string inputColumnName, int64 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.FeatureSelectionCatalog.SelectFeaturesBasedOnCount(Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms,System.String,System.String,System.Int64)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnCount (catalog As TransformsCatalog.FeatureSelectionTransforms, outputColumnName As String, Optional inputColumnName As String = null, Optional count As Long = 1) As CountFeatureSelectingEstimator" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnCount : Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms * string * string * int64 -&gt; Microsoft.ML.Transforms.CountFeatureSelectingEstimator" Usage="Microsoft.ML.FeatureSelectionCatalog.SelectFeaturesBasedOnCount (catalog, outputColumnName, inputColumnName, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.CountFeatureSelectingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+FeatureSelectionTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="count" Type="System.Int64" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="count">If the count of non-default values for a slot is greater than or equal to this threshold in the training data, the slot is preserved.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.FeatureSelectionCatalog" Member="M:Microsoft.ML.FeatureSelectionCatalog.SelectFeaturesBasedOnCount(Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms,System.String,System.String,System.Int64)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnMutualInformation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.MutualInformationFeatureSelectingEstimator SelectFeaturesBasedOnMutualInformation (this Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms catalog, Microsoft.ML.InputOutputColumnPair[] columns, string labelColumnName = &quot;Label&quot;, int slotsInOutput = 1000, int numberOfBins = 256);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.MutualInformationFeatureSelectingEstimator SelectFeaturesBasedOnMutualInformation(class Microsoft.ML.TransformsCatalog/FeatureSelectionTransforms catalog, class Microsoft.ML.InputOutputColumnPair[] columns, string labelColumnName, int32 slotsInOutput, int32 numberOfBins) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.FeatureSelectionCatalog.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms,Microsoft.ML.InputOutputColumnPair[],System.String,System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnMutualInformation (catalog As TransformsCatalog.FeatureSelectionTransforms, columns As InputOutputColumnPair(), Optional labelColumnName As String = &quot;Label&quot;, Optional slotsInOutput As Integer = 1000, Optional numberOfBins As Integer = 256) As MutualInformationFeatureSelectingEstimator" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnMutualInformation : Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms * Microsoft.ML.InputOutputColumnPair[] * string * int * int -&gt; Microsoft.ML.Transforms.MutualInformationFeatureSelectingEstimator" Usage="Microsoft.ML.FeatureSelectionCatalog.SelectFeaturesBasedOnMutualInformation (catalog, columns, labelColumnName, slotsInOutput, numberOfBins)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.MutualInformationFeatureSelectingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+FeatureSelectionTransforms" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.InputOutputColumnPair[]" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="slotsInOutput" Type="System.Int32" />
          <Parameter Name="numberOfBins" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="columns">Specifies the names of the input columns for the transformation, and their respective output column names.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="slotsInOutput">The maximum number of slots to preserve in the output. The number of slots to preserve is taken across all input columns.</param>
          <param name="numberOfBins">Max number of bins used to approximate mutual information between each input column and the label column. Power of 2 recommended.</param>
          <summary>
        Selects the top k slots across all specified columns ordered by their mutual information with the label column.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.FeatureSelectionCatalog" Member="M:Microsoft.ML.FeatureSelectionCatalog.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms,Microsoft.ML.InputOutputColumnPair[],System.String,System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnMutualInformation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.MutualInformationFeatureSelectingEstimator SelectFeaturesBasedOnMutualInformation (this Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms catalog, string outputColumnName, string inputColumnName = null, string labelColumnName = &quot;Label&quot;, int slotsInOutput = 1000, int numberOfBins = 256);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.MutualInformationFeatureSelectingEstimator SelectFeaturesBasedOnMutualInformation(class Microsoft.ML.TransformsCatalog/FeatureSelectionTransforms catalog, string outputColumnName, string inputColumnName, string labelColumnName, int32 slotsInOutput, int32 numberOfBins) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.FeatureSelectionCatalog.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms,System.String,System.String,System.String,System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnMutualInformation (catalog As TransformsCatalog.FeatureSelectionTransforms, outputColumnName As String, Optional inputColumnName As String = null, Optional labelColumnName As String = &quot;Label&quot;, Optional slotsInOutput As Integer = 1000, Optional numberOfBins As Integer = 256) As MutualInformationFeatureSelectingEstimator" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnMutualInformation : Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms * string * string * string * int * int -&gt; Microsoft.ML.Transforms.MutualInformationFeatureSelectingEstimator" Usage="Microsoft.ML.FeatureSelectionCatalog.SelectFeaturesBasedOnMutualInformation (catalog, outputColumnName, inputColumnName, labelColumnName, slotsInOutput, numberOfBins)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.MutualInformationFeatureSelectingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+FeatureSelectionTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="slotsInOutput" Type="System.Int32" />
          <Parameter Name="numberOfBins" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="slotsInOutput">The maximum number of slots to preserve in the output. The number of slots to preserve is taken across all input columns.</param>
          <param name="numberOfBins">Max number of bins used to approximate mutual information between each input column and the label column. Power of 2 recommended.</param>
          <summary>
        Selects the top k slots across all specified columns ordered by their mutual information with the label column.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.FeatureSelectionCatalog" Member="M:Microsoft.ML.FeatureSelectionCatalog.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms,System.String,System.String,System.String,System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="ConvertToGrayscale">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Image.ImageGrayscalingEstimator ConvertToGrayscale (this Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Image.ImageGrayscalingEstimator ConvertToGrayscale(class Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ImageEstimatorsCatalog.ConvertToGrayscale(Microsoft.ML.TransformsCatalog,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConvertToGrayscale (catalog As TransformsCatalog, outputColumnName As String, Optional inputColumnName As String = null) As ImageGrayscalingEstimator" />
        <MemberSignature Language="F#" Value="static member ConvertToGrayscale : Microsoft.ML.TransformsCatalog * string * string -&gt; Microsoft.ML.Transforms.Image.ImageGrayscalingEstimator" Usage="Microsoft.ML.ImageEstimatorsCatalog.ConvertToGrayscale (catalog, outputColumnName, inputColumnName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Image.ImageGrayscalingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <summary>
        Converts the images to grayscale.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.ImageEstimatorsCatalog" Member="M:Microsoft.ML.ImageEstimatorsCatalog.ConvertToGrayscale(Microsoft.ML.TransformsCatalog,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="ConvertToImage">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Image.VectorToImageConvertingEstimator ConvertToImage (this Microsoft.ML.TransformsCatalog catalog, int imageHeight, int imageWidth, string outputColumnName, string inputColumnName = null, Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorBits colorsPresent = Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator+ColorBits.Rgb, Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorsOrder orderOfColors = Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator+ColorsOrder.ARGB, bool interleavedColors = false, float scaleImage = 1, float offsetImage = 0, int defaultAlpha = 255, int defaultRed = 0, int defaultGreen = 0, int defaultBlue = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Image.VectorToImageConvertingEstimator ConvertToImage(class Microsoft.ML.TransformsCatalog catalog, int32 imageHeight, int32 imageWidth, string outputColumnName, string inputColumnName, valuetype Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator/ColorBits colorsPresent, valuetype Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator/ColorsOrder orderOfColors, bool interleavedColors, float32 scaleImage, float32 offsetImage, int32 defaultAlpha, int32 defaultRed, int32 defaultGreen, int32 defaultBlue) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ImageEstimatorsCatalog.ConvertToImage(Microsoft.ML.TransformsCatalog,System.Int32,System.Int32,System.String,System.String,Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorBits,Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorsOrder,System.Boolean,System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConvertToImage (catalog As TransformsCatalog, imageHeight As Integer, imageWidth As Integer, outputColumnName As String, Optional inputColumnName As String = null, Optional colorsPresent As ImagePixelExtractingEstimator.ColorBits = Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator+ColorBits.Rgb, Optional orderOfColors As ImagePixelExtractingEstimator.ColorsOrder = Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator+ColorsOrder.ARGB, Optional interleavedColors As Boolean = false, Optional scaleImage As Single = 1, Optional offsetImage As Single = 0, Optional defaultAlpha As Integer = 255, Optional defaultRed As Integer = 0, Optional defaultGreen As Integer = 0, Optional defaultBlue As Integer = 0) As VectorToImageConvertingEstimator" />
        <MemberSignature Language="F#" Value="static member ConvertToImage : Microsoft.ML.TransformsCatalog * int * int * string * string * Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorBits * Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorsOrder * bool * single * single * int * int * int * int -&gt; Microsoft.ML.Transforms.Image.VectorToImageConvertingEstimator" Usage="Microsoft.ML.ImageEstimatorsCatalog.ConvertToImage (catalog, imageHeight, imageWidth, outputColumnName, inputColumnName, colorsPresent, orderOfColors, interleavedColors, scaleImage, offsetImage, defaultAlpha, defaultRed, defaultGreen, defaultBlue)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Image.VectorToImageConvertingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="imageHeight" Type="System.Int32" />
          <Parameter Name="imageWidth" Type="System.Int32" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="colorsPresent" Type="Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator+ColorBits" />
          <Parameter Name="orderOfColors" Type="Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator+ColorsOrder" />
          <Parameter Name="interleavedColors" Type="System.Boolean" />
          <Parameter Name="scaleImage" Type="System.Single" />
          <Parameter Name="offsetImage" Type="System.Single" />
          <Parameter Name="defaultAlpha" Type="System.Int32" />
          <Parameter Name="defaultRed" Type="System.Int32" />
          <Parameter Name="defaultGreen" Type="System.Int32" />
          <Parameter Name="defaultBlue" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The transforms' catalog.</param>
          <param name="imageHeight">The height of the output images.</param>
          <param name="imageWidth">The width of the output images.</param>
          <param name="outputColumnName"> Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName"> Name of column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="colorsPresent">Specifies which <see cref="T:Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorBits" /> are in present the input pixel vectors. The order of colors is specified in <paramref name="orderOfColors" />.</param>
          <param name="orderOfColors">The order in which colors are presented in the input vector.</param>
          <param name="interleavedColors">Whether the pixels are interleaved, meaning whether they are in <paramref name="orderOfColors" /> order, or separated in the planar form:
            all the values for one color for all pixels, then all the values for another color and so on.</param>
          <param name="scaleImage">The values are scaled by this value before being converted to pixels. Applied to vector value before <paramref name="offsetImage" />.</param>
          <param name="offsetImage">The offset is subtracted before converting the values to pixels. Applied to vector value after <paramref name="scaleImage" />.</param>
          <param name="defaultAlpha">Default value for alpha color, would be overriden if <paramref name="colorsPresent" /> contains <see cref="F:Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorBits.Alpha" />.</param>
          <param name="defaultRed">Default value for red color, would be overriden if <paramref name="colorsPresent" /> contains <see cref="F:Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorBits.Red" />.</param>
          <param name="defaultGreen">Default value for grenn color, would be overriden if <paramref name="colorsPresent" /> contains <see cref="F:Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorBits.Green" />.</param>
          <param name="defaultBlue">Default value for blue color, would be overriden if <paramref name="colorsPresent" /> contains <see cref="F:Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorBits.Blue" />.</param>
          <summary>
            Converts vectors of pixels into <see cref="T:Microsoft.ML.Transforms.Image.ImageDataViewType" /> representation.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ImageEstimatorsCatalog" Member="M:Microsoft.ML.ImageEstimatorsCatalog.ConvertToImage(Microsoft.ML.TransformsCatalog,System.Int32,System.Int32,System.String,System.String,Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorBits,Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorsOrder,System.Boolean,System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="ExtractPixels">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator ExtractPixels (this Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName = null, Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorBits colorsToExtract = Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator+ColorBits.Rgb, Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorsOrder orderOfExtraction = Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator+ColorsOrder.ARGB, bool interleavePixelColors = false, float offsetImage = 0, float scaleImage = 1, bool outputAsFloatArray = true);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator ExtractPixels(class Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName, valuetype Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator/ColorBits colorsToExtract, valuetype Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator/ColorsOrder orderOfExtraction, bool interleavePixelColors, float32 offsetImage, float32 scaleImage, bool outputAsFloatArray) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ImageEstimatorsCatalog.ExtractPixels(Microsoft.ML.TransformsCatalog,System.String,System.String,Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorBits,Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorsOrder,System.Boolean,System.Single,System.Single,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExtractPixels (catalog As TransformsCatalog, outputColumnName As String, Optional inputColumnName As String = null, Optional colorsToExtract As ImagePixelExtractingEstimator.ColorBits = Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator+ColorBits.Rgb, Optional orderOfExtraction As ImagePixelExtractingEstimator.ColorsOrder = Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator+ColorsOrder.ARGB, Optional interleavePixelColors As Boolean = false, Optional offsetImage As Single = 0, Optional scaleImage As Single = 1, Optional outputAsFloatArray As Boolean = true) As ImagePixelExtractingEstimator" />
        <MemberSignature Language="F#" Value="static member ExtractPixels : Microsoft.ML.TransformsCatalog * string * string * Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorBits * Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorsOrder * bool * single * single * bool -&gt; Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator" Usage="Microsoft.ML.ImageEstimatorsCatalog.ExtractPixels (catalog, outputColumnName, inputColumnName, colorsToExtract, orderOfExtraction, interleavePixelColors, offsetImage, scaleImage, outputAsFloatArray)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="colorsToExtract" Type="Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator+ColorBits" />
          <Parameter Name="orderOfExtraction" Type="Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator+ColorsOrder" />
          <Parameter Name="interleavePixelColors" Type="System.Boolean" />
          <Parameter Name="offsetImage" Type="System.Single" />
          <Parameter Name="scaleImage" Type="System.Single" />
          <Parameter Name="outputAsFloatArray" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="colorsToExtract">The colors to extract from the image.</param>
          <param name="orderOfExtraction">The order in which to extract colors from pixel.</param>
          <param name="interleavePixelColors">Whether to interleave the pixels colors, meaning keep them in the <paramref name="orderOfExtraction" /> order, or leave them in the plannar form:
            all the values for one color for all pixels, then all the values for another color, and so on.</param>
          <param name="offsetImage">Offset each pixel's color value by this amount. Applied to color value before <paramref name="scaleImage" />.</param>
          <param name="scaleImage">Scale each pixel's color value by this amount. Applied to color value after <paramref name="offsetImage" />.</param>
          <param name="outputAsFloatArray">Output array as float array. If false, output as byte array and ignores <paramref name="offsetImage" /> and <paramref name="scaleImage" />.</param>
          <summary>
        Extracts the pixels from the input images and, converts them into a vector of numbers. This can be further used as feature by the algorithms added to the pipeline.   
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.ImageEstimatorsCatalog" Member="M:Microsoft.ML.ImageEstimatorsCatalog.ExtractPixels(Microsoft.ML.TransformsCatalog,System.String,System.String,Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorBits,Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorsOrder,System.Boolean,System.Single,System.Single,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="LoadImages">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.ImageLoadingEstimator LoadImages (this Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string imageFolder, string inputColumnName = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.ImageLoadingEstimator LoadImages(class Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string imageFolder, string inputColumnName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ImageEstimatorsCatalog.LoadImages(Microsoft.ML.TransformsCatalog,System.String,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LoadImages (catalog As TransformsCatalog, outputColumnName As String, imageFolder As String, Optional inputColumnName As String = null) As ImageLoadingEstimator" />
        <MemberSignature Language="F#" Value="static member LoadImages : Microsoft.ML.TransformsCatalog * string * string * string -&gt; Microsoft.ML.Data.ImageLoadingEstimator" Usage="Microsoft.ML.ImageEstimatorsCatalog.LoadImages (catalog, outputColumnName, imageFolder, inputColumnName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.ImageLoadingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="imageFolder" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="imageFolder">The images folder.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <summary>
            Loads the images from the <see cref="F:Microsoft.ML.Data.ImageLoadingTransformer.ImageFolder" /> into memory.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ImageEstimatorsCatalog" Member="M:Microsoft.ML.ImageEstimatorsCatalog.LoadImages(Microsoft.ML.TransformsCatalog,System.String,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="ResizeImages">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Image.ImageResizingEstimator ResizeImages (this Microsoft.ML.TransformsCatalog catalog, string outputColumnName, int imageWidth, int imageHeight, string inputColumnName = null, Microsoft.ML.Transforms.Image.ImageResizingEstimator.ResizingKind resizing = Microsoft.ML.Transforms.Image.ImageResizingEstimator+ResizingKind.IsoCrop, Microsoft.ML.Transforms.Image.ImageResizingEstimator.Anchor cropAnchor = Microsoft.ML.Transforms.Image.ImageResizingEstimator+Anchor.Center);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Image.ImageResizingEstimator ResizeImages(class Microsoft.ML.TransformsCatalog catalog, string outputColumnName, int32 imageWidth, int32 imageHeight, string inputColumnName, valuetype Microsoft.ML.Transforms.Image.ImageResizingEstimator/ResizingKind resizing, valuetype Microsoft.ML.Transforms.Image.ImageResizingEstimator/Anchor cropAnchor) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ImageEstimatorsCatalog.ResizeImages(Microsoft.ML.TransformsCatalog,System.String,System.Int32,System.Int32,System.String,Microsoft.ML.Transforms.Image.ImageResizingEstimator.ResizingKind,Microsoft.ML.Transforms.Image.ImageResizingEstimator.Anchor)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ResizeImages (catalog As TransformsCatalog, outputColumnName As String, imageWidth As Integer, imageHeight As Integer, Optional inputColumnName As String = null, Optional resizing As ImageResizingEstimator.ResizingKind = Microsoft.ML.Transforms.Image.ImageResizingEstimator+ResizingKind.IsoCrop, Optional cropAnchor As ImageResizingEstimator.Anchor = Microsoft.ML.Transforms.Image.ImageResizingEstimator+Anchor.Center) As ImageResizingEstimator" />
        <MemberSignature Language="F#" Value="static member ResizeImages : Microsoft.ML.TransformsCatalog * string * int * int * string * Microsoft.ML.Transforms.Image.ImageResizingEstimator.ResizingKind * Microsoft.ML.Transforms.Image.ImageResizingEstimator.Anchor -&gt; Microsoft.ML.Transforms.Image.ImageResizingEstimator" Usage="Microsoft.ML.ImageEstimatorsCatalog.ResizeImages (catalog, outputColumnName, imageWidth, imageHeight, inputColumnName, resizing, cropAnchor)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Image.ImageResizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="imageWidth" Type="System.Int32" />
          <Parameter Name="imageHeight" Type="System.Int32" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="resizing" Type="Microsoft.ML.Transforms.Image.ImageResizingEstimator+ResizingKind" />
          <Parameter Name="cropAnchor" Type="Microsoft.ML.Transforms.Image.ImageResizingEstimator+Anchor" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="imageWidth">The transformed image width.</param>
          <param name="imageHeight">The transformed image height.</param>
          <param name="inputColumnName">Name of column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="resizing"> The type of image resizing as specified in <see cref="T:Microsoft.ML.Transforms.Image.ImageResizingEstimator.ResizingKind" />.</param>
          <param name="cropAnchor">Where to place the anchor, to start cropping. Options defined in <see cref="T:Microsoft.ML.Transforms.Image.ImageResizingEstimator.Anchor" /></param>
          <summary>
            Resizes the images to a new width and height.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ImageEstimatorsCatalog" Member="M:Microsoft.ML.ImageEstimatorsCatalog.ResizeImages(Microsoft.ML.TransformsCatalog,System.String,System.Int32,System.Int32,System.String,Microsoft.ML.Transforms.Image.ImageResizingEstimator.ResizingKind,Microsoft.ML.Transforms.Image.ImageResizingEstimator.Anchor)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="ApproximatedKernelMap">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.ApproximatedKernelMappingEstimator ApproximatedKernelMap (this Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName = null, int rank = 1000, bool useCosAndSinBases = false, Microsoft.ML.Transforms.KernelBase generator = null, Nullable&lt;int&gt; seed = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.ApproximatedKernelMappingEstimator ApproximatedKernelMap(class Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName, int32 rank, bool useCosAndSinBases, class Microsoft.ML.Transforms.KernelBase generator, valuetype System.Nullable`1&lt;int32&gt; seed) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.KernelExpansionCatalog.ApproximatedKernelMap(Microsoft.ML.TransformsCatalog,System.String,System.String,System.Int32,System.Boolean,Microsoft.ML.Transforms.KernelBase,System.Nullable{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ApproximatedKernelMap (catalog As TransformsCatalog, outputColumnName As String, Optional inputColumnName As String = null, Optional rank As Integer = 1000, Optional useCosAndSinBases As Boolean = false, Optional generator As KernelBase = null, Optional seed As Nullable(Of Integer) = null) As ApproximatedKernelMappingEstimator" />
        <MemberSignature Language="F#" Value="static member ApproximatedKernelMap : Microsoft.ML.TransformsCatalog * string * string * int * bool * Microsoft.ML.Transforms.KernelBase * Nullable&lt;int&gt; -&gt; Microsoft.ML.Transforms.ApproximatedKernelMappingEstimator" Usage="Microsoft.ML.KernelExpansionCatalog.ApproximatedKernelMap (catalog, outputColumnName, inputColumnName, rank, useCosAndSinBases, generator, seed)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.ApproximatedKernelMappingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="rank" Type="System.Int32" />
          <Parameter Name="useCosAndSinBases" Type="System.Boolean" />
          <Parameter Name="generator" Type="Microsoft.ML.Transforms.KernelBase" />
          <Parameter Name="seed" Type="System.Nullable&lt;System.Int32&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="rank">The number of random Fourier features to create.</param>
          <param name="useCosAndSinBases">If <see langword="true" />, use both of cos and sin basis functions to create two features for every random Fourier frequency.
            Otherwise, only cos bases would be used.</param>
          <param name="generator">Which fourier generator to use.</param>
          <param name="seed">The seed of the random number generator for generating the new features (if unspecified, the global random is used).</param>
          <summary>
            Takes column filled with a vector of floats and maps its to a random low-dimensional feature space.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.KernelExpansionCatalog" Member="M:Microsoft.ML.KernelExpansionCatalog.ApproximatedKernelMap(Microsoft.ML.TransformsCatalog,System.String,System.String,System.Int32,System.Boolean,Microsoft.ML.Transforms.KernelBase,System.Nullable{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.ClusteringCatalog.ClusteringTrainers" />
      </Targets>
      <Member MemberName="KMeans">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.KMeansTrainer KMeans (this Microsoft.ML.ClusteringCatalog.ClusteringTrainers catalog, Microsoft.ML.Trainers.KMeansTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.KMeansTrainer KMeans(class Microsoft.ML.ClusteringCatalog/ClusteringTrainers catalog, class Microsoft.ML.Trainers.KMeansTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.KMeansClusteringExtensions.KMeans(Microsoft.ML.ClusteringCatalog.ClusteringTrainers,Microsoft.ML.Trainers.KMeansTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member KMeans : Microsoft.ML.ClusteringCatalog.ClusteringTrainers * Microsoft.ML.Trainers.KMeansTrainer.Options -&gt; Microsoft.ML.Trainers.KMeansTrainer" Usage="Microsoft.ML.KMeansClusteringExtensions.KMeans (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.KMeansTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.ClusteringCatalog+ClusteringTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.KMeansTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The clustering catalog trainer object.</param>
          <param name="options">Algorithm advanced options.</param>
          <summary>
            Train a KMeans++ clustering algorithm using <see cref="T:Microsoft.ML.Trainers.KMeansTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.KMeansClusteringExtensions" Member="M:Microsoft.ML.KMeansClusteringExtensions.KMeans(Microsoft.ML.ClusteringCatalog.ClusteringTrainers,Microsoft.ML.Trainers.KMeansTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.ClusteringCatalog.ClusteringTrainers" />
      </Targets>
      <Member MemberName="KMeans">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.KMeansTrainer KMeans (this Microsoft.ML.ClusteringCatalog.ClusteringTrainers catalog, string featureColumnName = &quot;Features&quot;, string exampleWeightColumnName = null, int numberOfClusters = 5);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.KMeansTrainer KMeans(class Microsoft.ML.ClusteringCatalog/ClusteringTrainers catalog, string featureColumnName, string exampleWeightColumnName, int32 numberOfClusters) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.KMeansClusteringExtensions.KMeans(Microsoft.ML.ClusteringCatalog.ClusteringTrainers,System.String,System.String,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function KMeans (catalog As ClusteringCatalog.ClusteringTrainers, Optional featureColumnName As String = &quot;Features&quot;, Optional exampleWeightColumnName As String = null, Optional numberOfClusters As Integer = 5) As KMeansTrainer" />
        <MemberSignature Language="F#" Value="static member KMeans : Microsoft.ML.ClusteringCatalog.ClusteringTrainers * string * string * int -&gt; Microsoft.ML.Trainers.KMeansTrainer" Usage="Microsoft.ML.KMeansClusteringExtensions.KMeans (catalog, featureColumnName, exampleWeightColumnName, numberOfClusters)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.KMeansTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.ClusteringCatalog+ClusteringTrainers" RefType="this" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="numberOfClusters" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The clustering catalog trainer object.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="numberOfClusters">The number of clusters to use for KMeans.</param>
          <summary>
            Train a KMeans++ clustering algorithm using <see cref="T:Microsoft.ML.Trainers.KMeansTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.KMeansClusteringExtensions" Member="M:Microsoft.ML.KMeansClusteringExtensions.KMeans(Microsoft.ML.ClusteringCatalog.ClusteringTrainers,System.String,System.String,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IEstimator`1" />
      </Targets>
      <Member MemberName="Append&lt;TTrans&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.EstimatorChain&lt;TTrans&gt; Append&lt;TTrans&gt; (this Microsoft.ML.IEstimator&lt;Microsoft.ML.ITransformer&gt; start, Microsoft.ML.IEstimator&lt;TTrans&gt; estimator, Microsoft.ML.Data.TransformerScope scope = Microsoft.ML.Data.TransformerScope.Everything) where TTrans : class, Microsoft.ML.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.EstimatorChain`1&lt;!!TTrans&gt; Append&lt;class (class Microsoft.ML.ITransformer) TTrans&gt;(class Microsoft.ML.IEstimator`1&lt;class Microsoft.ML.ITransformer&gt; start, class Microsoft.ML.IEstimator`1&lt;!!TTrans&gt; estimator, valuetype Microsoft.ML.Data.TransformerScope scope) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LearningPipelineExtensions.Append``1(Microsoft.ML.IEstimator{Microsoft.ML.ITransformer},Microsoft.ML.IEstimator{``0},Microsoft.ML.Data.TransformerScope)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Append(Of TTrans As {Class, ITransformer}) (start As IEstimator(Of ITransformer), estimator As IEstimator(Of TTrans), Optional scope As TransformerScope = Microsoft.ML.Data.TransformerScope.Everything) As EstimatorChain(Of TTrans)" />
        <MemberSignature Language="F#" Value="static member Append : Microsoft.ML.IEstimator&lt;Microsoft.ML.ITransformer&gt; * Microsoft.ML.IEstimator&lt;'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.ITransformer)&gt; * Microsoft.ML.Data.TransformerScope -&gt; Microsoft.ML.Data.EstimatorChain&lt;'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.ITransformer)&gt; (requires 'rans : null and 'rans :&gt; Microsoft.ML.ITransformer)" Usage="Microsoft.ML.LearningPipelineExtensions.Append (start, estimator, scope)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.EstimatorChain&lt;TTrans&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TTrans">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="start" Type="Microsoft.ML.IEstimator&lt;Microsoft.ML.ITransformer&gt;" RefType="this" />
          <Parameter Name="estimator" Type="Microsoft.ML.IEstimator&lt;TTrans&gt;" />
          <Parameter Name="scope" Type="Microsoft.ML.Data.TransformerScope" />
        </Parameters>
        <Docs>
          <typeparam name="TTrans">To be added.</typeparam>
          <param name="start">To be added.</param>
          <param name="estimator">To be added.</param>
          <param name="scope">To be added.</param>
          <summary>
            Create a new estimator chain, by appending another estimator to the end of this estimator.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LearningPipelineExtensions" Member="M:Microsoft.ML.LearningPipelineExtensions.Append``1(Microsoft.ML.IEstimator{Microsoft.ML.ITransformer},Microsoft.ML.IEstimator{``0},Microsoft.ML.Data.TransformerScope)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.ITransformer" />
      </Targets>
      <Member MemberName="Append&lt;TTrans&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.TransformerChain&lt;TTrans&gt; Append&lt;TTrans&gt; (this Microsoft.ML.ITransformer start, TTrans transformer) where TTrans : class, Microsoft.ML.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.TransformerChain`1&lt;!!TTrans&gt; Append&lt;class (class Microsoft.ML.ITransformer) TTrans&gt;(class Microsoft.ML.ITransformer start, !!TTrans transformer) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LearningPipelineExtensions.Append``1(Microsoft.ML.ITransformer,``0)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Append(Of TTrans As {Class, ITransformer}) (start As ITransformer, transformer As TTrans) As TransformerChain(Of TTrans)" />
        <MemberSignature Language="F#" Value="static member Append : Microsoft.ML.ITransformer * 'rans -&gt; Microsoft.ML.Data.TransformerChain&lt;'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.ITransformer)&gt; (requires 'rans : null and 'rans :&gt; Microsoft.ML.ITransformer)" Usage="Microsoft.ML.LearningPipelineExtensions.Append (start, transformer)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.TransformerChain&lt;TTrans&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TTrans">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="start" Type="Microsoft.ML.ITransformer" RefType="this" />
          <Parameter Name="transformer" Type="TTrans" />
        </Parameters>
        <Docs>
          <typeparam name="TTrans">To be added.</typeparam>
          <param name="start">To be added.</param>
          <param name="transformer">To be added.</param>
          <summary>
            Create a new transformer chain, by appending another transformer to the end of this transformer chain.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LearningPipelineExtensions" Member="M:Microsoft.ML.LearningPipelineExtensions.Append``1(Microsoft.ML.ITransformer,``0)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IDataLoader`1" />
      </Targets>
      <Member MemberName="Append&lt;TSource,TTrans&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.CompositeDataLoader&lt;TSource,TTrans&gt; Append&lt;TSource,TTrans&gt; (this Microsoft.ML.IDataLoader&lt;TSource&gt; loader, TTrans transformer) where TTrans : class, Microsoft.ML.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.CompositeDataLoader`2&lt;!!TSource, !!TTrans&gt; Append&lt;TSource, class (class Microsoft.ML.ITransformer) TTrans&gt;(class Microsoft.ML.IDataLoader`1&lt;!!TSource&gt; loader, !!TTrans transformer) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LearningPipelineExtensions.Append``2(Microsoft.ML.IDataLoader{``0},``1)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Append(Of TSource, TTrans) (loader As IDataLoader(Of TSource), transformer As TTrans) As CompositeDataLoader(Of TSource, TTrans)" />
        <MemberSignature Language="F#" Value="static member Append : Microsoft.ML.IDataLoader&lt;'Source&gt; * 'rans -&gt; Microsoft.ML.Data.CompositeDataLoader&lt;'Source, 'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.ITransformer)&gt; (requires 'rans : null and 'rans :&gt; Microsoft.ML.ITransformer)" Usage="Microsoft.ML.LearningPipelineExtensions.Append (loader, transformer)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.CompositeDataLoader&lt;TSource,TTrans&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSource" />
          <TypeParameter Name="TTrans">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="loader" Type="Microsoft.ML.IDataLoader&lt;TSource&gt;" RefType="this" />
          <Parameter Name="transformer" Type="TTrans" />
        </Parameters>
        <Docs>
          <typeparam name="TSource">To be added.</typeparam>
          <typeparam name="TTrans">To be added.</typeparam>
          <param name="loader">To be added.</param>
          <param name="transformer">To be added.</param>
          <summary>
            Create a new composite loader, by appending a transformer to this data loader.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LearningPipelineExtensions" Member="M:Microsoft.ML.LearningPipelineExtensions.Append``2(Microsoft.ML.IDataLoader{``0},``1)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IDataLoader`1" />
      </Targets>
      <Member MemberName="Append&lt;TSource,TTrans&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.CompositeLoaderEstimator&lt;TSource,TTrans&gt; Append&lt;TSource,TTrans&gt; (this Microsoft.ML.IDataLoader&lt;TSource&gt; start, Microsoft.ML.IEstimator&lt;TTrans&gt; estimator) where TTrans : class, Microsoft.ML.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.CompositeLoaderEstimator`2&lt;!!TSource, !!TTrans&gt; Append&lt;TSource, class (class Microsoft.ML.ITransformer) TTrans&gt;(class Microsoft.ML.IDataLoader`1&lt;!!TSource&gt; start, class Microsoft.ML.IEstimator`1&lt;!!TTrans&gt; estimator) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LearningPipelineExtensions.Append``2(Microsoft.ML.IDataLoader{``0},Microsoft.ML.IEstimator{``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Append(Of TSource, TTrans) (start As IDataLoader(Of TSource), estimator As IEstimator(Of TTrans)) As CompositeLoaderEstimator(Of TSource, TTrans)" />
        <MemberSignature Language="F#" Value="static member Append : Microsoft.ML.IDataLoader&lt;'Source&gt; * Microsoft.ML.IEstimator&lt;'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.ITransformer)&gt; -&gt; Microsoft.ML.Data.CompositeLoaderEstimator&lt;'Source, 'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.ITransformer)&gt; (requires 'rans : null and 'rans :&gt; Microsoft.ML.ITransformer)" Usage="Microsoft.ML.LearningPipelineExtensions.Append (start, estimator)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.CompositeLoaderEstimator&lt;TSource,TTrans&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSource" />
          <TypeParameter Name="TTrans">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="start" Type="Microsoft.ML.IDataLoader&lt;TSource&gt;" RefType="this" />
          <Parameter Name="estimator" Type="Microsoft.ML.IEstimator&lt;TTrans&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TSource">To be added.</typeparam>
          <typeparam name="TTrans">To be added.</typeparam>
          <param name="start">To be added.</param>
          <param name="estimator">To be added.</param>
          <summary>
            Create a new composite loader estimator, by appending an estimator to this data loader.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LearningPipelineExtensions" Member="M:Microsoft.ML.LearningPipelineExtensions.Append``2(Microsoft.ML.IDataLoader{``0},Microsoft.ML.IEstimator{``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IDataLoaderEstimator`2" />
      </Targets>
      <Member MemberName="Append&lt;TSource,TTrans&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.CompositeLoaderEstimator&lt;TSource,TTrans&gt; Append&lt;TSource,TTrans&gt; (this Microsoft.ML.IDataLoaderEstimator&lt;TSource,Microsoft.ML.IDataLoader&lt;TSource&gt;&gt; start, Microsoft.ML.IEstimator&lt;TTrans&gt; estimator) where TTrans : class, Microsoft.ML.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.CompositeLoaderEstimator`2&lt;!!TSource, !!TTrans&gt; Append&lt;TSource, class (class Microsoft.ML.ITransformer) TTrans&gt;(class Microsoft.ML.IDataLoaderEstimator`2&lt;!!TSource, class Microsoft.ML.IDataLoader`1&lt;!!TSource&gt;&gt; start, class Microsoft.ML.IEstimator`1&lt;!!TTrans&gt; estimator) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LearningPipelineExtensions.Append``2(Microsoft.ML.IDataLoaderEstimator{``0,Microsoft.ML.IDataLoader{``0}},Microsoft.ML.IEstimator{``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Append(Of TSource, TTrans) (start As IDataLoaderEstimator(Of TSource, IDataLoader(Of TSource)), estimator As IEstimator(Of TTrans)) As CompositeLoaderEstimator(Of TSource, TTrans)" />
        <MemberSignature Language="F#" Value="static member Append : Microsoft.ML.IDataLoaderEstimator&lt;'Source, Microsoft.ML.IDataLoader&lt;'Source&gt;&gt; * Microsoft.ML.IEstimator&lt;'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.ITransformer)&gt; -&gt; Microsoft.ML.Data.CompositeLoaderEstimator&lt;'Source, 'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.ITransformer)&gt; (requires 'rans : null and 'rans :&gt; Microsoft.ML.ITransformer)" Usage="Microsoft.ML.LearningPipelineExtensions.Append (start, estimator)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.CompositeLoaderEstimator&lt;TSource,TTrans&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSource" />
          <TypeParameter Name="TTrans">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="start" Type="Microsoft.ML.IDataLoaderEstimator&lt;TSource,Microsoft.ML.IDataLoader&lt;TSource&gt;&gt;" RefType="this" />
          <Parameter Name="estimator" Type="Microsoft.ML.IEstimator&lt;TTrans&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TSource">To be added.</typeparam>
          <typeparam name="TTrans">To be added.</typeparam>
          <param name="start">To be added.</param>
          <param name="estimator">To be added.</param>
          <summary>
            Create a new composite loader estimator, by appending another estimator to the end of this data loader estimator.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LearningPipelineExtensions" Member="M:Microsoft.ML.LearningPipelineExtensions.Append``2(Microsoft.ML.IDataLoaderEstimator{``0,Microsoft.ML.IDataLoader{``0}},Microsoft.ML.IEstimator{``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IEstimator`1" />
      </Targets>
      <Member MemberName="AppendCacheCheckpoint&lt;TTrans&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.EstimatorChain&lt;TTrans&gt; AppendCacheCheckpoint&lt;TTrans&gt; (this Microsoft.ML.IEstimator&lt;TTrans&gt; start, Microsoft.ML.Runtime.IHostEnvironment env) where TTrans : class, Microsoft.ML.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.EstimatorChain`1&lt;!!TTrans&gt; AppendCacheCheckpoint&lt;class (class Microsoft.ML.ITransformer) TTrans&gt;(class Microsoft.ML.IEstimator`1&lt;!!TTrans&gt; start, class Microsoft.ML.Runtime.IHostEnvironment env) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LearningPipelineExtensions.AppendCacheCheckpoint``1(Microsoft.ML.IEstimator{``0},Microsoft.ML.Runtime.IHostEnvironment)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AppendCacheCheckpoint(Of TTrans As {Class, ITransformer}) (start As IEstimator(Of TTrans), env As IHostEnvironment) As EstimatorChain(Of TTrans)" />
        <MemberSignature Language="F#" Value="static member AppendCacheCheckpoint : Microsoft.ML.IEstimator&lt;'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.ITransformer)&gt; * Microsoft.ML.Runtime.IHostEnvironment -&gt; Microsoft.ML.Data.EstimatorChain&lt;'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.ITransformer)&gt; (requires 'rans : null and 'rans :&gt; Microsoft.ML.ITransformer)" Usage="Microsoft.ML.LearningPipelineExtensions.AppendCacheCheckpoint (start, env)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.EstimatorChain&lt;TTrans&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TTrans">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="start" Type="Microsoft.ML.IEstimator&lt;TTrans&gt;" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
        </Parameters>
        <Docs>
          <typeparam name="TTrans">To be added.</typeparam>
          <param name="start">The starting estimator</param>
          <param name="env">The host environment to use for caching.</param>
          <summary>
            Append a 'caching checkpoint' to the estimator chain. This will ensure that the downstream estimators will be trained against
            cached data. It is helpful to have a caching checkpoint before trainers that take multiple data passes.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LearningPipelineExtensions" Member="M:Microsoft.ML.LearningPipelineExtensions.AppendCacheCheckpoint``1(Microsoft.ML.IEstimator{``0},Microsoft.ML.Runtime.IHostEnvironment)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IEstimator`1" />
      </Targets>
      <Member MemberName="WithOnFitDelegate&lt;TTransformer&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.IEstimator&lt;TTransformer&gt; WithOnFitDelegate&lt;TTransformer&gt; (this Microsoft.ML.IEstimator&lt;TTransformer&gt; estimator, Action&lt;TTransformer&gt; onFit) where TTransformer : class, Microsoft.ML.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.IEstimator`1&lt;!!TTransformer&gt; WithOnFitDelegate&lt;class (class Microsoft.ML.ITransformer) TTransformer&gt;(class Microsoft.ML.IEstimator`1&lt;!!TTransformer&gt; estimator, class System.Action`1&lt;!!TTransformer&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LearningPipelineExtensions.WithOnFitDelegate``1(Microsoft.ML.IEstimator{``0},System.Action{``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithOnFitDelegate(Of TTransformer As {Class, ITransformer}) (estimator As IEstimator(Of TTransformer), onFit As Action(Of TTransformer)) As IEstimator(Of TTransformer)" />
        <MemberSignature Language="F#" Value="static member WithOnFitDelegate : Microsoft.ML.IEstimator&lt;'ransformer (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.ITransformer)&gt; * Action&lt;'ransformer (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.ITransformer)&gt; -&gt; Microsoft.ML.IEstimator&lt;'ransformer (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.ITransformer)&gt; (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.ITransformer)" Usage="Microsoft.ML.LearningPipelineExtensions.WithOnFitDelegate (estimator, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.IEstimator&lt;TTransformer&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TTransformer">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="estimator" Type="Microsoft.ML.IEstimator&lt;TTransformer&gt;" RefType="this" />
          <Parameter Name="onFit" Type="System.Action&lt;TTransformer&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TTransformer">The type of <see cref="T:Microsoft.ML.ITransformer" /> returned by <paramref name="estimator" /></typeparam>
          <param name="estimator">The estimator to wrap</param>
          <param name="onFit">The delegate that is called with the resulting <typeparamref name="TTransformer" /> instances once
            <see cref="M:Microsoft.ML.IEstimator`1.Fit(Microsoft.ML.IDataView)" /> is called. Because <see cref="M:Microsoft.ML.IEstimator`1.Fit(Microsoft.ML.IDataView)" />
            may be called multiple times, this delegate may also be called multiple times.</param>
          <summary>
            Given an estimator, return a wrapping object that will call a delegate once <see cref="M:Microsoft.ML.IEstimator`1.Fit(Microsoft.ML.IDataView)" />
            is called. It is often important for an estimator to return information about what was fit, which is why the
            <see cref="M:Microsoft.ML.IEstimator`1.Fit(Microsoft.ML.IDataView)" /> method returns a specifically typed object, rather than just a general
            <see cref="T:Microsoft.ML.ITransformer" />. However, at the same time, <see cref="T:Microsoft.ML.IEstimator`1" /> are often formed into pipelines
            with many objects, so we may need to build a chain of estimators via <see cref="T:Microsoft.ML.Data.EstimatorChain`1" /> where the
            estimator for which we want to get the transformer is buried somewhere in this chain. For that scenario, we can through this
            method attach a delegate that will be called once fit is called.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LearningPipelineExtensions" Member="M:Microsoft.ML.LearningPipelineExtensions.WithOnFitDelegate``1(Microsoft.ML.IEstimator{``0},System.Action{``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="LightGbm">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.LightGbm.LightGbmBinaryTrainer LightGbm (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.Trainers.LightGbm.LightGbmBinaryTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.LightGbm.LightGbmBinaryTrainer LightGbm(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.Trainers.LightGbm.LightGbmBinaryTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LightGbmExtensions.LightGbm(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.LightGbm.LightGbmBinaryTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member LightGbm : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.Trainers.LightGbm.LightGbmBinaryTrainer.Options -&gt; Microsoft.ML.Trainers.LightGbm.LightGbmBinaryTrainer" Usage="Microsoft.ML.LightGbmExtensions.LightGbm (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.LightGbm.LightGbmBinaryTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.LightGbm.LightGbmBinaryTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.BinaryClassificationCatalog" />.</param>
          <param name="options">Trainer options.</param>
          <summary>
            Predict a target using a gradient boosting decision tree binary classification model trained with the <see cref="T:Microsoft.ML.Trainers.LightGbm.LightGbmBinaryTrainer" /> and advanced options.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LightGbmExtensions" Member="M:Microsoft.ML.LightGbmExtensions.LightGbm(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.LightGbm.LightGbmBinaryTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="LightGbm">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.LightGbm.LightGbmBinaryTrainer LightGbm (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, string exampleWeightColumnName = null, Nullable&lt;int&gt; numberOfLeaves = null, Nullable&lt;int&gt; minimumExampleCountPerLeaf = null, Nullable&lt;double&gt; learningRate = null, int numberOfIterations = 100);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.LightGbm.LightGbmBinaryTrainer LightGbm(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, string labelColumnName, string featureColumnName, string exampleWeightColumnName, valuetype System.Nullable`1&lt;int32&gt; numberOfLeaves, valuetype System.Nullable`1&lt;int32&gt; minimumExampleCountPerLeaf, valuetype System.Nullable`1&lt;float64&gt; learningRate, int32 numberOfIterations) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LightGbmExtensions.LightGbm(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LightGbm (catalog As BinaryClassificationCatalog.BinaryClassificationTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional exampleWeightColumnName As String = null, Optional numberOfLeaves As Nullable(Of Integer) = null, Optional minimumExampleCountPerLeaf As Nullable(Of Integer) = null, Optional learningRate As Nullable(Of Double) = null, Optional numberOfIterations As Integer = 100) As LightGbmBinaryTrainer" />
        <MemberSignature Language="F#" Value="static member LightGbm : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * string * string * string * Nullable&lt;int&gt; * Nullable&lt;int&gt; * Nullable&lt;double&gt; * int -&gt; Microsoft.ML.Trainers.LightGbm.LightGbmBinaryTrainer" Usage="Microsoft.ML.LightGbmExtensions.LightGbm (catalog, labelColumnName, featureColumnName, exampleWeightColumnName, numberOfLeaves, minimumExampleCountPerLeaf, learningRate, numberOfIterations)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.LightGbm.LightGbmBinaryTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="numberOfLeaves" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="minimumExampleCountPerLeaf" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="learningRate" Type="System.Nullable&lt;System.Double&gt;" />
          <Parameter Name="numberOfIterations" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.BinaryClassificationCatalog" />.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="numberOfLeaves">The maximum number of leaves in one tree.</param>
          <param name="minimumExampleCountPerLeaf">The minimal number of data points required to form a new tree leaf.</param>
          <param name="learningRate">The learning rate.</param>
          <param name="numberOfIterations">The number of boosting iterations. A new tree is created in each iteration, so this is equivalent to the number of trees.</param>
          <summary>
            Predict a target using a gradient boosting decision tree binary classification model trained with the <see cref="T:Microsoft.ML.Trainers.LightGbm.LightGbmBinaryTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LightGbmExtensions" Member="M:Microsoft.ML.LightGbmExtensions.LightGbm(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="LightGbm">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.LightGbm.LightGbmMulticlassTrainer LightGbm (this Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers catalog, Microsoft.ML.Trainers.LightGbm.LightGbmMulticlassTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.LightGbm.LightGbmMulticlassTrainer LightGbm(class Microsoft.ML.MulticlassClassificationCatalog/MulticlassClassificationTrainers catalog, class Microsoft.ML.Trainers.LightGbm.LightGbmMulticlassTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LightGbmExtensions.LightGbm(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.Trainers.LightGbm.LightGbmMulticlassTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member LightGbm : Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers * Microsoft.ML.Trainers.LightGbm.LightGbmMulticlassTrainer.Options -&gt; Microsoft.ML.Trainers.LightGbm.LightGbmMulticlassTrainer" Usage="Microsoft.ML.LightGbmExtensions.LightGbm (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.LightGbm.LightGbmMulticlassTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.MulticlassClassificationCatalog+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.LightGbm.LightGbmMulticlassTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.MulticlassClassificationCatalog" />.</param>
          <param name="options">Trainer options.</param>
          <summary>
            Predict a target using a gradient boosting decision tree multiclass classification model trained with the <see cref="T:Microsoft.ML.Trainers.LightGbm.LightGbmMulticlassTrainer" /> and advanced options.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LightGbmExtensions" Member="M:Microsoft.ML.LightGbmExtensions.LightGbm(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.Trainers.LightGbm.LightGbmMulticlassTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="LightGbm">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.LightGbm.LightGbmMulticlassTrainer LightGbm (this Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, string exampleWeightColumnName = null, Nullable&lt;int&gt; numberOfLeaves = null, Nullable&lt;int&gt; minimumExampleCountPerLeaf = null, Nullable&lt;double&gt; learningRate = null, int numberOfIterations = 100);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.LightGbm.LightGbmMulticlassTrainer LightGbm(class Microsoft.ML.MulticlassClassificationCatalog/MulticlassClassificationTrainers catalog, string labelColumnName, string featureColumnName, string exampleWeightColumnName, valuetype System.Nullable`1&lt;int32&gt; numberOfLeaves, valuetype System.Nullable`1&lt;int32&gt; minimumExampleCountPerLeaf, valuetype System.Nullable`1&lt;float64&gt; learningRate, int32 numberOfIterations) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LightGbmExtensions.LightGbm(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LightGbm (catalog As MulticlassClassificationCatalog.MulticlassClassificationTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional exampleWeightColumnName As String = null, Optional numberOfLeaves As Nullable(Of Integer) = null, Optional minimumExampleCountPerLeaf As Nullable(Of Integer) = null, Optional learningRate As Nullable(Of Double) = null, Optional numberOfIterations As Integer = 100) As LightGbmMulticlassTrainer" />
        <MemberSignature Language="F#" Value="static member LightGbm : Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers * string * string * string * Nullable&lt;int&gt; * Nullable&lt;int&gt; * Nullable&lt;double&gt; * int -&gt; Microsoft.ML.Trainers.LightGbm.LightGbmMulticlassTrainer" Usage="Microsoft.ML.LightGbmExtensions.LightGbm (catalog, labelColumnName, featureColumnName, exampleWeightColumnName, numberOfLeaves, minimumExampleCountPerLeaf, learningRate, numberOfIterations)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.LightGbm.LightGbmMulticlassTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.MulticlassClassificationCatalog+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="numberOfLeaves" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="minimumExampleCountPerLeaf" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="learningRate" Type="System.Nullable&lt;System.Double&gt;" />
          <Parameter Name="numberOfIterations" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.MulticlassClassificationCatalog" />.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="numberOfLeaves">The maximum number of leaves in one tree.</param>
          <param name="minimumExampleCountPerLeaf">The minimal number of data points required to form a new tree leaf.</param>
          <param name="learningRate">The learning rate.</param>
          <param name="numberOfIterations">The number of boosting iterations. A new tree is created in each iteration, so this is equivalent to the number of trees.</param>
          <summary>
            Predict a target using a gradient boosting decision tree multiclass classification model trained with the <see cref="T:Microsoft.ML.Trainers.LightGbm.LightGbmMulticlassTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LightGbmExtensions" Member="M:Microsoft.ML.LightGbmExtensions.LightGbm(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RankingCatalog.RankingTrainers" />
      </Targets>
      <Member MemberName="LightGbm">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.LightGbm.LightGbmRankingTrainer LightGbm (this Microsoft.ML.RankingCatalog.RankingTrainers catalog, Microsoft.ML.Trainers.LightGbm.LightGbmRankingTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.LightGbm.LightGbmRankingTrainer LightGbm(class Microsoft.ML.RankingCatalog/RankingTrainers catalog, class Microsoft.ML.Trainers.LightGbm.LightGbmRankingTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LightGbmExtensions.LightGbm(Microsoft.ML.RankingCatalog.RankingTrainers,Microsoft.ML.Trainers.LightGbm.LightGbmRankingTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member LightGbm : Microsoft.ML.RankingCatalog.RankingTrainers * Microsoft.ML.Trainers.LightGbm.LightGbmRankingTrainer.Options -&gt; Microsoft.ML.Trainers.LightGbm.LightGbmRankingTrainer" Usage="Microsoft.ML.LightGbmExtensions.LightGbm (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.LightGbm.LightGbmRankingTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RankingCatalog+RankingTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.LightGbm.LightGbmRankingTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.RankingCatalog" />.</param>
          <param name="options">Trainer options.</param>
          <summary>
            Predict a target using a gradient boosting decision tree ranking model trained with the <see cref="T:Microsoft.ML.Trainers.LightGbm.LightGbmRankingTrainer" /> and advanced options.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LightGbmExtensions" Member="M:Microsoft.ML.LightGbmExtensions.LightGbm(Microsoft.ML.RankingCatalog.RankingTrainers,Microsoft.ML.Trainers.LightGbm.LightGbmRankingTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RankingCatalog.RankingTrainers" />
      </Targets>
      <Member MemberName="LightGbm">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.LightGbm.LightGbmRankingTrainer LightGbm (this Microsoft.ML.RankingCatalog.RankingTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, string rowGroupColumnName = &quot;GroupId&quot;, string exampleWeightColumnName = null, Nullable&lt;int&gt; numberOfLeaves = null, Nullable&lt;int&gt; minimumExampleCountPerLeaf = null, Nullable&lt;double&gt; learningRate = null, int numberOfIterations = 100);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.LightGbm.LightGbmRankingTrainer LightGbm(class Microsoft.ML.RankingCatalog/RankingTrainers catalog, string labelColumnName, string featureColumnName, string rowGroupColumnName, string exampleWeightColumnName, valuetype System.Nullable`1&lt;int32&gt; numberOfLeaves, valuetype System.Nullable`1&lt;int32&gt; minimumExampleCountPerLeaf, valuetype System.Nullable`1&lt;float64&gt; learningRate, int32 numberOfIterations) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LightGbmExtensions.LightGbm(Microsoft.ML.RankingCatalog.RankingTrainers,System.String,System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LightGbm (catalog As RankingCatalog.RankingTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional rowGroupColumnName As String = &quot;GroupId&quot;, Optional exampleWeightColumnName As String = null, Optional numberOfLeaves As Nullable(Of Integer) = null, Optional minimumExampleCountPerLeaf As Nullable(Of Integer) = null, Optional learningRate As Nullable(Of Double) = null, Optional numberOfIterations As Integer = 100) As LightGbmRankingTrainer" />
        <MemberSignature Language="F#" Value="static member LightGbm : Microsoft.ML.RankingCatalog.RankingTrainers * string * string * string * string * Nullable&lt;int&gt; * Nullable&lt;int&gt; * Nullable&lt;double&gt; * int -&gt; Microsoft.ML.Trainers.LightGbm.LightGbmRankingTrainer" Usage="Microsoft.ML.LightGbmExtensions.LightGbm (catalog, labelColumnName, featureColumnName, rowGroupColumnName, exampleWeightColumnName, numberOfLeaves, minimumExampleCountPerLeaf, learningRate, numberOfIterations)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.LightGbm.LightGbmRankingTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RankingCatalog+RankingTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="rowGroupColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="numberOfLeaves" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="minimumExampleCountPerLeaf" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="learningRate" Type="System.Nullable&lt;System.Double&gt;" />
          <Parameter Name="numberOfIterations" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.RankingCatalog" />.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="rowGroupColumnName">The name of the group column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="numberOfLeaves">The maximum number of leaves in one tree.</param>
          <param name="minimumExampleCountPerLeaf">The minimal number of data points required to form a new tree leaf.</param>
          <param name="learningRate">The learning rate.</param>
          <param name="numberOfIterations">The number of boosting iterations. A new tree is created in each iteration, so this is equivalent to the number of trees.</param>
          <summary>
            Predict a target using a gradient boosting decision tree ranking model trained with the <see cref="T:Microsoft.ML.Trainers.LightGbm.LightGbmRankingTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LightGbmExtensions" Member="M:Microsoft.ML.LightGbmExtensions.LightGbm(Microsoft.ML.RankingCatalog.RankingTrainers,System.String,System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="LightGbm">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.LightGbm.LightGbmRegressionTrainer LightGbm (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, Microsoft.ML.Trainers.LightGbm.LightGbmRegressionTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.LightGbm.LightGbmRegressionTrainer LightGbm(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, class Microsoft.ML.Trainers.LightGbm.LightGbmRegressionTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LightGbmExtensions.LightGbm(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.Trainers.LightGbm.LightGbmRegressionTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member LightGbm : Microsoft.ML.RegressionCatalog.RegressionTrainers * Microsoft.ML.Trainers.LightGbm.LightGbmRegressionTrainer.Options -&gt; Microsoft.ML.Trainers.LightGbm.LightGbmRegressionTrainer" Usage="Microsoft.ML.LightGbmExtensions.LightGbm (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.LightGbm.LightGbmRegressionTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.LightGbm.LightGbmRegressionTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.RegressionCatalog" />.</param>
          <param name="options">Trainer options.</param>
          <summary>
            Predict a target using a gradient boosting decision tree regression model trained with the <see cref="T:Microsoft.ML.Trainers.LightGbm.LightGbmRegressionTrainer" /> and advanced options.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LightGbmExtensions" Member="M:Microsoft.ML.LightGbmExtensions.LightGbm(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.Trainers.LightGbm.LightGbmRegressionTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="LightGbm">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.LightGbm.LightGbmRegressionTrainer LightGbm (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, string exampleWeightColumnName = null, Nullable&lt;int&gt; numberOfLeaves = null, Nullable&lt;int&gt; minimumExampleCountPerLeaf = null, Nullable&lt;double&gt; learningRate = null, int numberOfIterations = 100);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.LightGbm.LightGbmRegressionTrainer LightGbm(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, string labelColumnName, string featureColumnName, string exampleWeightColumnName, valuetype System.Nullable`1&lt;int32&gt; numberOfLeaves, valuetype System.Nullable`1&lt;int32&gt; minimumExampleCountPerLeaf, valuetype System.Nullable`1&lt;float64&gt; learningRate, int32 numberOfIterations) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LightGbmExtensions.LightGbm(Microsoft.ML.RegressionCatalog.RegressionTrainers,System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LightGbm (catalog As RegressionCatalog.RegressionTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional exampleWeightColumnName As String = null, Optional numberOfLeaves As Nullable(Of Integer) = null, Optional minimumExampleCountPerLeaf As Nullable(Of Integer) = null, Optional learningRate As Nullable(Of Double) = null, Optional numberOfIterations As Integer = 100) As LightGbmRegressionTrainer" />
        <MemberSignature Language="F#" Value="static member LightGbm : Microsoft.ML.RegressionCatalog.RegressionTrainers * string * string * string * Nullable&lt;int&gt; * Nullable&lt;int&gt; * Nullable&lt;double&gt; * int -&gt; Microsoft.ML.Trainers.LightGbm.LightGbmRegressionTrainer" Usage="Microsoft.ML.LightGbmExtensions.LightGbm (catalog, labelColumnName, featureColumnName, exampleWeightColumnName, numberOfLeaves, minimumExampleCountPerLeaf, learningRate, numberOfIterations)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.LightGbm.LightGbmRegressionTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="numberOfLeaves" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="minimumExampleCountPerLeaf" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="learningRate" Type="System.Nullable&lt;System.Double&gt;" />
          <Parameter Name="numberOfIterations" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.RegressionCatalog" />.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="numberOfLeaves">The maximum number of leaves in one tree.</param>
          <param name="minimumExampleCountPerLeaf">The minimal number of data points required to form a new tree leaf.</param>
          <param name="learningRate">The learning rate.</param>
          <param name="numberOfIterations">The number of boosting iterations. A new tree is created in each iteration, so this is equivalent to the number of trees.</param>
          <summary>
            Predict a target using a gradient boosting decision tree regression model trained with the <see cref="T:Microsoft.ML.Trainers.LightGbm.LightGbmRegressionTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LightGbmExtensions" Member="M:Microsoft.ML.LightGbmExtensions.LightGbm(Microsoft.ML.RegressionCatalog.RegressionTrainers,System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="Ols">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.OlsTrainer Ols (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, Microsoft.ML.Trainers.OlsTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.OlsTrainer Ols(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, class Microsoft.ML.Trainers.OlsTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.MklComponentsCatalog.Ols(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.Trainers.OlsTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member Ols : Microsoft.ML.RegressionCatalog.RegressionTrainers * Microsoft.ML.Trainers.OlsTrainer.Options -&gt; Microsoft.ML.Trainers.OlsTrainer" Usage="Microsoft.ML.MklComponentsCatalog.Ols (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.OlsTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.OlsTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.RegressionCatalog" />.</param>
          <param name="options">Algorithm advanced options. See <see cref="T:Microsoft.ML.Trainers.OlsTrainer.Options" />.</param>
          <summary>
            Predict a target using a linear regression model trained with the <see cref="T:Microsoft.ML.Trainers.OlsTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.MklComponentsCatalog" Member="M:Microsoft.ML.MklComponentsCatalog.Ols(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.Trainers.OlsTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="Ols">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.OlsTrainer Ols (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, string exampleWeightColumnName = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.OlsTrainer Ols(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, string labelColumnName, string featureColumnName, string exampleWeightColumnName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.MklComponentsCatalog.Ols(Microsoft.ML.RegressionCatalog.RegressionTrainers,System.String,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Ols (catalog As RegressionCatalog.RegressionTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional exampleWeightColumnName As String = null) As OlsTrainer" />
        <MemberSignature Language="F#" Value="static member Ols : Microsoft.ML.RegressionCatalog.RegressionTrainers * string * string * string -&gt; Microsoft.ML.Trainers.OlsTrainer" Usage="Microsoft.ML.MklComponentsCatalog.Ols (catalog, labelColumnName, featureColumnName, exampleWeightColumnName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.OlsTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.RegressionCatalog" />.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <summary>
            Predict a target using a linear regression model trained with the <see cref="T:Microsoft.ML.Trainers.OlsTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.MklComponentsCatalog" Member="M:Microsoft.ML.MklComponentsCatalog.Ols(Microsoft.ML.RegressionCatalog.RegressionTrainers,System.String,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="SymbolicSgdLogisticRegression">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.SymbolicSgdLogisticRegressionBinaryTrainer SymbolicSgdLogisticRegression (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.Trainers.SymbolicSgdLogisticRegressionBinaryTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.SymbolicSgdLogisticRegressionBinaryTrainer SymbolicSgdLogisticRegression(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.Trainers.SymbolicSgdLogisticRegressionBinaryTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.MklComponentsCatalog.SymbolicSgdLogisticRegression(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.SymbolicSgdLogisticRegressionBinaryTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member SymbolicSgdLogisticRegression : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.Trainers.SymbolicSgdLogisticRegressionBinaryTrainer.Options -&gt; Microsoft.ML.Trainers.SymbolicSgdLogisticRegressionBinaryTrainer" Usage="Microsoft.ML.MklComponentsCatalog.SymbolicSgdLogisticRegression (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.SymbolicSgdLogisticRegressionBinaryTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.SymbolicSgdLogisticRegressionBinaryTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.BinaryClassificationCatalog" />.</param>
          <param name="options">Algorithm advanced options. See <see cref="T:Microsoft.ML.Trainers.SymbolicSgdLogisticRegressionBinaryTrainer.Options" />.</param>
          <summary>
             Predict a target using a linear binary classification model trained with the <see cref="T:Microsoft.ML.Trainers.SymbolicSgdLogisticRegressionBinaryTrainer" />.
            Stochastic gradient descent (SGD) is an iterative algorithm that optimizes a differentiable objective function.
            The <see cref="T:Microsoft.ML.Trainers.SymbolicSgdLogisticRegressionBinaryTrainer" /> parallelizes SGD using <a href="https://www.microsoft.com/en-us/research/project/project-parade/#!symbolic-execution">symbolic execution</a>.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.MklComponentsCatalog" Member="M:Microsoft.ML.MklComponentsCatalog.SymbolicSgdLogisticRegression(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.SymbolicSgdLogisticRegressionBinaryTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="SymbolicSgdLogisticRegression">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.SymbolicSgdLogisticRegressionBinaryTrainer SymbolicSgdLogisticRegression (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, int numberOfIterations = 50);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.SymbolicSgdLogisticRegressionBinaryTrainer SymbolicSgdLogisticRegression(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, string labelColumnName, string featureColumnName, int32 numberOfIterations) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.MklComponentsCatalog.SymbolicSgdLogisticRegression(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SymbolicSgdLogisticRegression (catalog As BinaryClassificationCatalog.BinaryClassificationTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional numberOfIterations As Integer = 50) As SymbolicSgdLogisticRegressionBinaryTrainer" />
        <MemberSignature Language="F#" Value="static member SymbolicSgdLogisticRegression : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * string * string * int -&gt; Microsoft.ML.Trainers.SymbolicSgdLogisticRegressionBinaryTrainer" Usage="Microsoft.ML.MklComponentsCatalog.SymbolicSgdLogisticRegression (catalog, labelColumnName, featureColumnName, numberOfIterations)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.SymbolicSgdLogisticRegressionBinaryTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="numberOfIterations" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.BinaryClassificationCatalog" />.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="numberOfIterations">Number of training iterations.</param>
          <summary>
            Predict a target using a linear binary classification model trained with the <see cref="T:Microsoft.ML.Trainers.SymbolicSgdLogisticRegressionBinaryTrainer" />.
            Stochastic gradient descent (SGD) is an iterative algorithm that optimizes a differentiable objective function.
            The <see cref="T:Microsoft.ML.Trainers.SymbolicSgdLogisticRegressionBinaryTrainer" /> parallelizes SGD using <a href="https://www.microsoft.com/en-us/research/project/project-parade/#!symbolic-execution">symbolic execution</a>.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.MklComponentsCatalog" Member="M:Microsoft.ML.MklComponentsCatalog.SymbolicSgdLogisticRegression(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="VectorWhiten">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.VectorWhiteningEstimator VectorWhiten (this Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName = null, Microsoft.ML.Transforms.WhiteningKind kind = Microsoft.ML.Transforms.WhiteningKind.ZeroPhaseComponentAnalysis, float epsilon = 1E-05, int maximumNumberOfRows = 100000, int rank = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.VectorWhiteningEstimator VectorWhiten(class Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName, valuetype Microsoft.ML.Transforms.WhiteningKind kind, float32 epsilon, int32 maximumNumberOfRows, int32 rank) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.MklComponentsCatalog.VectorWhiten(Microsoft.ML.TransformsCatalog,System.String,System.String,Microsoft.ML.Transforms.WhiteningKind,System.Single,System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function VectorWhiten (catalog As TransformsCatalog, outputColumnName As String, Optional inputColumnName As String = null, Optional kind As WhiteningKind = Microsoft.ML.Transforms.WhiteningKind.ZeroPhaseComponentAnalysis, Optional epsilon As Single = 1E-05, Optional maximumNumberOfRows As Integer = 100000, Optional rank As Integer = 0) As VectorWhiteningEstimator" />
        <MemberSignature Language="F#" Value="static member VectorWhiten : Microsoft.ML.TransformsCatalog * string * string * Microsoft.ML.Transforms.WhiteningKind * single * int * int -&gt; Microsoft.ML.Transforms.VectorWhiteningEstimator" Usage="Microsoft.ML.MklComponentsCatalog.VectorWhiten (catalog, outputColumnName, inputColumnName, kind, epsilon, maximumNumberOfRows, rank)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.VectorWhiteningEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="kind" Type="Microsoft.ML.Transforms.WhiteningKind" />
          <Parameter Name="epsilon" Type="System.Single" />
          <Parameter Name="maximumNumberOfRows" Type="System.Int32" />
          <Parameter Name="rank" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="kind">Whitening kind (PCA/ZCA).</param>
          <param name="epsilon">Whitening constant, prevents division by zero.</param>
          <param name="maximumNumberOfRows">Maximum number of rows used to train the transform.</param>
          <param name="rank">In case of PCA whitening, indicates the number of components to retain.</param>
          <summary>
            Takes column filled with a vector of random variables with a known covariance matrix into a set of new variables whose covariance is the identity matrix,
            meaning that they are uncorrelated and each have variance 1.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.MklComponentsCatalog" Member="M:Microsoft.ML.MklComponentsCatalog.VectorWhiten(Microsoft.ML.TransformsCatalog,System.String,System.String,Microsoft.ML.Transforms.WhiteningKind,System.Single,System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="NormalizeBinning">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.NormalizingEstimator NormalizeBinning (this Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName = null, long maximumExampleCount = 1000000000, bool fixZero = true, int maximumBinCount = 1024);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.NormalizingEstimator NormalizeBinning(class Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName, int64 maximumExampleCount, bool fixZero, int32 maximumBinCount) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.NormalizationCatalog.NormalizeBinning(Microsoft.ML.TransformsCatalog,System.String,System.String,System.Int64,System.Boolean,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeBinning (catalog As TransformsCatalog, outputColumnName As String, Optional inputColumnName As String = null, Optional maximumExampleCount As Long = 1000000000, Optional fixZero As Boolean = true, Optional maximumBinCount As Integer = 1024) As NormalizingEstimator" />
        <MemberSignature Language="F#" Value="static member NormalizeBinning : Microsoft.ML.TransformsCatalog * string * string * int64 * bool * int -&gt; Microsoft.ML.Transforms.NormalizingEstimator" Usage="Microsoft.ML.NormalizationCatalog.NormalizeBinning (catalog, outputColumnName, inputColumnName, maximumExampleCount, fixZero, maximumBinCount)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.NormalizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="maximumExampleCount" Type="System.Int64" />
          <Parameter Name="fixZero" Type="System.Boolean" />
          <Parameter Name="maximumBinCount" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform catalog</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="maximumExampleCount">Maximum number of examples used to train the normalizer.</param>
          <param name="fixZero">Whether to map zero to zero, preserving sparsity.</param>
          <param name="maximumBinCount">Maximum number of bins (power of 2 recommended).</param>
          <summary>
            The values are assigned into bins with equal density.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.NormalizationCatalog" Member="M:Microsoft.ML.NormalizationCatalog.NormalizeBinning(Microsoft.ML.TransformsCatalog,System.String,System.String,System.Int64,System.Boolean,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="NormalizeGlobalContrast">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.GlobalContrastNormalizingEstimator NormalizeGlobalContrast (this Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName = null, bool ensureZeroMean = true, bool ensureUnitStandardDeviation = false, float scale = 1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.GlobalContrastNormalizingEstimator NormalizeGlobalContrast(class Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName, bool ensureZeroMean, bool ensureUnitStandardDeviation, float32 scale) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.NormalizationCatalog.NormalizeGlobalContrast(Microsoft.ML.TransformsCatalog,System.String,System.String,System.Boolean,System.Boolean,System.Single)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeGlobalContrast (catalog As TransformsCatalog, outputColumnName As String, Optional inputColumnName As String = null, Optional ensureZeroMean As Boolean = true, Optional ensureUnitStandardDeviation As Boolean = false, Optional scale As Single = 1) As GlobalContrastNormalizingEstimator" />
        <MemberSignature Language="F#" Value="static member NormalizeGlobalContrast : Microsoft.ML.TransformsCatalog * string * string * bool * bool * single -&gt; Microsoft.ML.Transforms.GlobalContrastNormalizingEstimator" Usage="Microsoft.ML.NormalizationCatalog.NormalizeGlobalContrast (catalog, outputColumnName, inputColumnName, ensureZeroMean, ensureUnitStandardDeviation, scale)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.GlobalContrastNormalizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="ensureZeroMean" Type="System.Boolean" />
          <Parameter Name="ensureUnitStandardDeviation" Type="System.Boolean" />
          <Parameter Name="scale" Type="System.Single" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="ensureZeroMean">If <see langword="true" />, subtract mean from each value before normalizing and use the raw input otherwise.</param>
          <param name="ensureUnitStandardDeviation">If <see langword="true" />, resulted vector's standard deviation would be one. Otherwise, resulted vector's L2-norm would be one.</param>
          <param name="scale">Scale features by this value.</param>
          <summary>
            Takes column filled with a vector of floats and computes global contrast normalization of it. By setting <paramref name="ensureZeroMean" /> to <see langword="true" />,
            a pre-processing step would be applied to make the specified column's mean be a zero vector.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.NormalizationCatalog" Member="M:Microsoft.ML.NormalizationCatalog.NormalizeGlobalContrast(Microsoft.ML.TransformsCatalog,System.String,System.String,System.Boolean,System.Boolean,System.Single)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="NormalizeLogMeanVariance">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.NormalizingEstimator NormalizeLogMeanVariance (this Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName = null, long maximumExampleCount = 1000000000, bool useCdf = true);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.NormalizingEstimator NormalizeLogMeanVariance(class Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName, int64 maximumExampleCount, bool useCdf) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.NormalizationCatalog.NormalizeLogMeanVariance(Microsoft.ML.TransformsCatalog,System.String,System.String,System.Int64,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeLogMeanVariance (catalog As TransformsCatalog, outputColumnName As String, Optional inputColumnName As String = null, Optional maximumExampleCount As Long = 1000000000, Optional useCdf As Boolean = true) As NormalizingEstimator" />
        <MemberSignature Language="F#" Value="static member NormalizeLogMeanVariance : Microsoft.ML.TransformsCatalog * string * string * int64 * bool -&gt; Microsoft.ML.Transforms.NormalizingEstimator" Usage="Microsoft.ML.NormalizationCatalog.NormalizeLogMeanVariance (catalog, outputColumnName, inputColumnName, maximumExampleCount, useCdf)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.NormalizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="maximumExampleCount" Type="System.Int64" />
          <Parameter Name="useCdf" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform catalog</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="maximumExampleCount">Maximum number of examples used to train the normalizer.</param>
          <param name="useCdf">Whether to use CDF as the output.</param>
          <summary>
            It normalizes the data based on the computed mean and variance of the logarithm of the data.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.NormalizationCatalog" Member="M:Microsoft.ML.NormalizationCatalog.NormalizeLogMeanVariance(Microsoft.ML.TransformsCatalog,System.String,System.String,System.Int64,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="NormalizeLpNorm">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.LpNormNormalizingEstimator NormalizeLpNorm (this Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName = null, Microsoft.ML.Transforms.LpNormNormalizingEstimatorBase.NormFunction norm = Microsoft.ML.Transforms.LpNormNormalizingEstimatorBase+NormFunction.L2, bool ensureZeroMean = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.LpNormNormalizingEstimator NormalizeLpNorm(class Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName, valuetype Microsoft.ML.Transforms.LpNormNormalizingEstimatorBase/NormFunction norm, bool ensureZeroMean) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.NormalizationCatalog.NormalizeLpNorm(Microsoft.ML.TransformsCatalog,System.String,System.String,Microsoft.ML.Transforms.LpNormNormalizingEstimatorBase.NormFunction,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeLpNorm (catalog As TransformsCatalog, outputColumnName As String, Optional inputColumnName As String = null, Optional norm As LpNormNormalizingEstimatorBase.NormFunction = Microsoft.ML.Transforms.LpNormNormalizingEstimatorBase+NormFunction.L2, Optional ensureZeroMean As Boolean = false) As LpNormNormalizingEstimator" />
        <MemberSignature Language="F#" Value="static member NormalizeLpNorm : Microsoft.ML.TransformsCatalog * string * string * Microsoft.ML.Transforms.LpNormNormalizingEstimatorBase.NormFunction * bool -&gt; Microsoft.ML.Transforms.LpNormNormalizingEstimator" Usage="Microsoft.ML.NormalizationCatalog.NormalizeLpNorm (catalog, outputColumnName, inputColumnName, norm, ensureZeroMean)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.LpNormNormalizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="norm" Type="Microsoft.ML.Transforms.LpNormNormalizingEstimatorBase+NormFunction" />
          <Parameter Name="ensureZeroMean" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="norm">Type of norm to use to normalize each sample. The indicated norm of the resulted vector will be normalized to one.</param>
          <param name="ensureZeroMean">If <see langword="true" />, subtract mean from each value before normalizing and use the raw input otherwise.</param>
          <summary>
            Takes column filled with a vector of floats and normalize its <paramref name="norm" /> to one. By setting <paramref name="ensureZeroMean" /> to <see langword="true" />,
            a pre-processing step would be applied to make the specified column's mean be a zero vector.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.NormalizationCatalog" Member="M:Microsoft.ML.NormalizationCatalog.NormalizeLpNorm(Microsoft.ML.TransformsCatalog,System.String,System.String,Microsoft.ML.Transforms.LpNormNormalizingEstimatorBase.NormFunction,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="NormalizeMeanVariance">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.NormalizingEstimator NormalizeMeanVariance (this Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName = null, long maximumExampleCount = 1000000000, bool fixZero = true, bool useCdf = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.NormalizingEstimator NormalizeMeanVariance(class Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName, int64 maximumExampleCount, bool fixZero, bool useCdf) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.NormalizationCatalog.NormalizeMeanVariance(Microsoft.ML.TransformsCatalog,System.String,System.String,System.Int64,System.Boolean,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeMeanVariance (catalog As TransformsCatalog, outputColumnName As String, Optional inputColumnName As String = null, Optional maximumExampleCount As Long = 1000000000, Optional fixZero As Boolean = true, Optional useCdf As Boolean = false) As NormalizingEstimator" />
        <MemberSignature Language="F#" Value="static member NormalizeMeanVariance : Microsoft.ML.TransformsCatalog * string * string * int64 * bool * bool -&gt; Microsoft.ML.Transforms.NormalizingEstimator" Usage="Microsoft.ML.NormalizationCatalog.NormalizeMeanVariance (catalog, outputColumnName, inputColumnName, maximumExampleCount, fixZero, useCdf)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.NormalizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="maximumExampleCount" Type="System.Int64" />
          <Parameter Name="fixZero" Type="System.Boolean" />
          <Parameter Name="useCdf" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform catalog</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="maximumExampleCount">Maximum number of examples used to train the normalizer.</param>
          <param name="fixZero">Whether to map zero to zero, preserving sparsity.</param>
          <param name="useCdf">Whether to use CDF as the output.</param>
          <summary>
            It normalizes the data based on the computed mean and variance of the data.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.NormalizationCatalog" Member="M:Microsoft.ML.NormalizationCatalog.NormalizeMeanVariance(Microsoft.ML.TransformsCatalog,System.String,System.String,System.Int64,System.Boolean,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="NormalizeMinMax">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.NormalizingEstimator NormalizeMinMax (this Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName = null, long maximumExampleCount = 1000000000, bool fixZero = true);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.NormalizingEstimator NormalizeMinMax(class Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName, int64 maximumExampleCount, bool fixZero) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.NormalizationCatalog.NormalizeMinMax(Microsoft.ML.TransformsCatalog,System.String,System.String,System.Int64,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeMinMax (catalog As TransformsCatalog, outputColumnName As String, Optional inputColumnName As String = null, Optional maximumExampleCount As Long = 1000000000, Optional fixZero As Boolean = true) As NormalizingEstimator" />
        <MemberSignature Language="F#" Value="static member NormalizeMinMax : Microsoft.ML.TransformsCatalog * string * string * int64 * bool -&gt; Microsoft.ML.Transforms.NormalizingEstimator" Usage="Microsoft.ML.NormalizationCatalog.NormalizeMinMax (catalog, outputColumnName, inputColumnName, maximumExampleCount, fixZero)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.NormalizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="maximumExampleCount" Type="System.Int64" />
          <Parameter Name="fixZero" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform catalog</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="maximumExampleCount">Maximum number of examples used to train the normalizer.</param>
          <param name="fixZero">Whether to map zero to zero, preserving sparsity.</param>
          <summary>
            It normalizes the data based on the observed minimum and maximum values of the data.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.NormalizationCatalog" Member="M:Microsoft.ML.NormalizationCatalog.NormalizeMinMax(Microsoft.ML.TransformsCatalog,System.String,System.String,System.Int64,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="NormalizeSupervisedBinning">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.NormalizingEstimator NormalizeSupervisedBinning (this Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName = null, string labelColumnName = &quot;Label&quot;, long maximumExampleCount = 1000000000, bool fixZero = true, int maximumBinCount = 1024, int mininimumExamplesPerBin = 10);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.NormalizingEstimator NormalizeSupervisedBinning(class Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName, string labelColumnName, int64 maximumExampleCount, bool fixZero, int32 maximumBinCount, int32 mininimumExamplesPerBin) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.NormalizationCatalog.NormalizeSupervisedBinning(Microsoft.ML.TransformsCatalog,System.String,System.String,System.String,System.Int64,System.Boolean,System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeSupervisedBinning (catalog As TransformsCatalog, outputColumnName As String, Optional inputColumnName As String = null, Optional labelColumnName As String = &quot;Label&quot;, Optional maximumExampleCount As Long = 1000000000, Optional fixZero As Boolean = true, Optional maximumBinCount As Integer = 1024, Optional mininimumExamplesPerBin As Integer = 10) As NormalizingEstimator" />
        <MemberSignature Language="F#" Value="static member NormalizeSupervisedBinning : Microsoft.ML.TransformsCatalog * string * string * string * int64 * bool * int * int -&gt; Microsoft.ML.Transforms.NormalizingEstimator" Usage="Microsoft.ML.NormalizationCatalog.NormalizeSupervisedBinning (catalog, outputColumnName, inputColumnName, labelColumnName, maximumExampleCount, fixZero, maximumBinCount, mininimumExamplesPerBin)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.NormalizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="maximumExampleCount" Type="System.Int64" />
          <Parameter Name="fixZero" Type="System.Boolean" />
          <Parameter Name="maximumBinCount" Type="System.Int32" />
          <Parameter Name="mininimumExamplesPerBin" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform catalog</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="labelColumnName">Name of the label column for supervised binning.</param>
          <param name="maximumExampleCount">Maximum number of examples used to train the normalizer.</param>
          <param name="fixZero">Whether to map zero to zero, preserving sparsity.</param>
          <param name="maximumBinCount">Maximum number of bins (power of 2 recommended).</param>
          <param name="mininimumExamplesPerBin">Minimum number of examples per bin.</param>
          <summary>
            The values are assigned into bins based on correlation with the <paramref name="labelColumnName" /> column.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.NormalizationCatalog" Member="M:Microsoft.ML.NormalizationCatalog.NormalizeSupervisedBinning(Microsoft.ML.TransformsCatalog,System.String,System.String,System.String,System.Int64,System.Boolean,System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="ApplyOnnxModel">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Onnx.OnnxScoringEstimator ApplyOnnxModel (this Microsoft.ML.TransformsCatalog catalog, string modelFile, Nullable&lt;int&gt; gpuDeviceId = null, bool fallbackToCpu = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Onnx.OnnxScoringEstimator ApplyOnnxModel(class Microsoft.ML.TransformsCatalog catalog, string modelFile, valuetype System.Nullable`1&lt;int32&gt; gpuDeviceId, bool fallbackToCpu) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.OnnxCatalog.ApplyOnnxModel(Microsoft.ML.TransformsCatalog,System.String,System.Nullable{System.Int32},System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ApplyOnnxModel (catalog As TransformsCatalog, modelFile As String, Optional gpuDeviceId As Nullable(Of Integer) = null, Optional fallbackToCpu As Boolean = false) As OnnxScoringEstimator" />
        <MemberSignature Language="F#" Value="static member ApplyOnnxModel : Microsoft.ML.TransformsCatalog * string * Nullable&lt;int&gt; * bool -&gt; Microsoft.ML.Transforms.Onnx.OnnxScoringEstimator" Usage="Microsoft.ML.OnnxCatalog.ApplyOnnxModel (catalog, modelFile, gpuDeviceId, fallbackToCpu)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Onnx.OnnxScoringEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="modelFile" Type="System.String" />
          <Parameter Name="gpuDeviceId" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="fallbackToCpu" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="modelFile">The path of the file containing the ONNX model.</param>
          <param name="gpuDeviceId">Optional GPU device ID to run execution on, <see langword="null" /> to run on CPU.</param>
          <param name="fallbackToCpu">If GPU error, raise exception or fallback to CPU.</param>
          <summary>
            Applies a pre-trained Onnx model.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.OnnxCatalog" Member="M:Microsoft.ML.OnnxCatalog.ApplyOnnxModel(Microsoft.ML.TransformsCatalog,System.String,System.Nullable{System.Int32},System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="ApplyOnnxModel">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Onnx.OnnxScoringEstimator ApplyOnnxModel (this Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName, string modelFile, Nullable&lt;int&gt; gpuDeviceId = null, bool fallbackToCpu = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Onnx.OnnxScoringEstimator ApplyOnnxModel(class Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName, string modelFile, valuetype System.Nullable`1&lt;int32&gt; gpuDeviceId, bool fallbackToCpu) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.OnnxCatalog.ApplyOnnxModel(Microsoft.ML.TransformsCatalog,System.String,System.String,System.String,System.Nullable{System.Int32},System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ApplyOnnxModel (catalog As TransformsCatalog, outputColumnName As String, inputColumnName As String, modelFile As String, Optional gpuDeviceId As Nullable(Of Integer) = null, Optional fallbackToCpu As Boolean = false) As OnnxScoringEstimator" />
        <MemberSignature Language="F#" Value="static member ApplyOnnxModel : Microsoft.ML.TransformsCatalog * string * string * string * Nullable&lt;int&gt; * bool -&gt; Microsoft.ML.Transforms.Onnx.OnnxScoringEstimator" Usage="Microsoft.ML.OnnxCatalog.ApplyOnnxModel (catalog, outputColumnName, inputColumnName, modelFile, gpuDeviceId, fallbackToCpu)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Onnx.OnnxScoringEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="modelFile" Type="System.String" />
          <Parameter Name="gpuDeviceId" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="fallbackToCpu" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="outputColumnName">The output column resulting from the transformation.</param>
          <param name="inputColumnName">The input column.</param>
          <param name="modelFile">The path of the file containing the ONNX model.</param>
          <param name="gpuDeviceId">Optional GPU device ID to run execution on, <see langword="null" /> to run on CPU.</param>
          <param name="fallbackToCpu">If GPU error, raise exception or fallback to CPU.</param>
          <summary>
            Applies a pre-trained Onnx model.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.OnnxCatalog" Member="M:Microsoft.ML.OnnxCatalog.ApplyOnnxModel(Microsoft.ML.TransformsCatalog,System.String,System.String,System.String,System.Nullable{System.Int32},System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="ApplyOnnxModel">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Onnx.OnnxScoringEstimator ApplyOnnxModel (this Microsoft.ML.TransformsCatalog catalog, string[] outputColumnNames, string[] inputColumnNames, string modelFile, Nullable&lt;int&gt; gpuDeviceId = null, bool fallbackToCpu = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Onnx.OnnxScoringEstimator ApplyOnnxModel(class Microsoft.ML.TransformsCatalog catalog, string[] outputColumnNames, string[] inputColumnNames, string modelFile, valuetype System.Nullable`1&lt;int32&gt; gpuDeviceId, bool fallbackToCpu) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.OnnxCatalog.ApplyOnnxModel(Microsoft.ML.TransformsCatalog,System.String[],System.String[],System.String,System.Nullable{System.Int32},System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ApplyOnnxModel (catalog As TransformsCatalog, outputColumnNames As String(), inputColumnNames As String(), modelFile As String, Optional gpuDeviceId As Nullable(Of Integer) = null, Optional fallbackToCpu As Boolean = false) As OnnxScoringEstimator" />
        <MemberSignature Language="F#" Value="static member ApplyOnnxModel : Microsoft.ML.TransformsCatalog * string[] * string[] * string * Nullable&lt;int&gt; * bool -&gt; Microsoft.ML.Transforms.Onnx.OnnxScoringEstimator" Usage="Microsoft.ML.OnnxCatalog.ApplyOnnxModel (catalog, outputColumnNames, inputColumnNames, modelFile, gpuDeviceId, fallbackToCpu)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Onnx.OnnxScoringEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumnNames" Type="System.String[]" />
          <Parameter Name="inputColumnNames" Type="System.String[]" />
          <Parameter Name="modelFile" Type="System.String" />
          <Parameter Name="gpuDeviceId" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="fallbackToCpu" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="outputColumnNames">The output columns resulting from the transformation.</param>
          <param name="inputColumnNames">The input columns.</param>
          <param name="modelFile">The path of the file containing the ONNX model.</param>
          <param name="gpuDeviceId">Optional GPU device ID to run execution on, <see langword="null" /> to run on CPU.</param>
          <param name="fallbackToCpu">If GPU error, raise exception or fallback to CPU.</param>
          <summary>
            Applies a pre-trained Onnx model.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.OnnxCatalog" Member="M:Microsoft.ML.OnnxCatalog.ApplyOnnxModel(Microsoft.ML.TransformsCatalog,System.String[],System.String[],System.String,System.Nullable{System.Int32},System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="DnnFeaturizeImage">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Onnx.DnnImageFeaturizerEstimator DnnFeaturizeImage (this Microsoft.ML.TransformsCatalog catalog, string outputColumnName, Func&lt;Microsoft.ML.Transforms.Onnx.DnnImageFeaturizerInput,Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;&gt; modelFactory, string inputColumnName = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Onnx.DnnImageFeaturizerEstimator DnnFeaturizeImage(class Microsoft.ML.TransformsCatalog catalog, string outputColumnName, class System.Func`2&lt;class Microsoft.ML.Transforms.Onnx.DnnImageFeaturizerInput, class Microsoft.ML.Data.EstimatorChain`1&lt;class Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;&gt; modelFactory, string inputColumnName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.OnnxCatalog.DnnFeaturizeImage(Microsoft.ML.TransformsCatalog,System.String,System.Func{Microsoft.ML.Transforms.Onnx.DnnImageFeaturizerInput,Microsoft.ML.Data.EstimatorChain{Microsoft.ML.Transforms.ColumnCopyingTransformer}},System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DnnFeaturizeImage (catalog As TransformsCatalog, outputColumnName As String, modelFactory As Func(Of DnnImageFeaturizerInput, EstimatorChain(Of ColumnCopyingTransformer)), Optional inputColumnName As String = null) As DnnImageFeaturizerEstimator" />
        <MemberSignature Language="F#" Value="static member DnnFeaturizeImage : Microsoft.ML.TransformsCatalog * string * Func&lt;Microsoft.ML.Transforms.Onnx.DnnImageFeaturizerInput, Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;&gt; * string -&gt; Microsoft.ML.Transforms.Onnx.DnnImageFeaturizerEstimator" Usage="Microsoft.ML.OnnxCatalog.DnnFeaturizeImage (catalog, outputColumnName, modelFactory, inputColumnName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Onnx.DnnImageFeaturizerEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="modelFactory" Type="System.Func&lt;Microsoft.ML.Transforms.Onnx.DnnImageFeaturizerInput,Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;&gt;" />
          <Parameter Name="inputColumnName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="outputColumnName">The name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="modelFactory">An extension method on the <see cref="T:Microsoft.ML.Transforms.Onnx.DnnImageModelSelector" /> that creates a chain of two
            <see cref="T:Microsoft.ML.Transforms.Onnx.OnnxScoringEstimator" /> (one for preprocessing and one with a pretrained image DNN) with specific models
            included in a package together with that extension method.</param>
          <param name="inputColumnName">Name of column to transform.
            If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <summary>
            Creates a new instance of <see cref="T:Microsoft.ML.Transforms.Onnx.DnnImageFeaturizerEstimator" /> which applies one of the pre-trained DNN models in
            <see cref="T:Microsoft.ML.Transforms.Onnx.DnnImageModelSelector" />to featurize an image.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.OnnxCatalog" Member="M:Microsoft.ML.OnnxCatalog.DnnFeaturizeImage(Microsoft.ML.TransformsCatalog,System.String,System.Func{Microsoft.ML.Transforms.Onnx.DnnImageFeaturizerInput,Microsoft.ML.Data.EstimatorChain{Microsoft.ML.Transforms.ColumnCopyingTransformer}},System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.ModelOperationsCatalog" />
      </Targets>
      <Member MemberName="ConvertToOnnx">
        <MemberSignature Language="C#" Value="public static void ConvertToOnnx (this Microsoft.ML.ModelOperationsCatalog catalog, Microsoft.ML.ITransformer transform, Microsoft.ML.IDataView inputData, System.IO.Stream stream);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConvertToOnnx(class Microsoft.ML.ModelOperationsCatalog catalog, class Microsoft.ML.ITransformer transform, class Microsoft.ML.IDataView inputData, class System.IO.Stream stream) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.OnnxExportExtensions.ConvertToOnnx(Microsoft.ML.ModelOperationsCatalog,Microsoft.ML.ITransformer,Microsoft.ML.IDataView,System.IO.Stream)" />
        <MemberSignature Language="F#" Value="static member ConvertToOnnx : Microsoft.ML.ModelOperationsCatalog * Microsoft.ML.ITransformer * Microsoft.ML.IDataView * System.IO.Stream -&gt; unit" Usage="Microsoft.ML.OnnxExportExtensions.ConvertToOnnx (catalog, transform, inputData, stream)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.ModelOperationsCatalog" RefType="this" />
          <Parameter Name="transform" Type="Microsoft.ML.ITransformer" />
          <Parameter Name="inputData" Type="Microsoft.ML.IDataView" />
          <Parameter Name="stream" Type="System.IO.Stream" />
        </Parameters>
        <Docs>
          <param name="catalog">The class that <see cref="M:Microsoft.ML.OnnxExportExtensions.ConvertToOnnx(Microsoft.ML.ModelOperationsCatalog,Microsoft.ML.ITransformer,Microsoft.ML.IDataView,System.IO.Stream)" /> attached to.</param>
          <param name="transform">The <see cref="T:Microsoft.ML.ITransformer" /> that will be converted into ONNX format.</param>
          <param name="inputData">The input of the specified transform.</param>
          <param name="stream">The stream to write the protobuf model to.</param>
          <summary>
            Convert the specified <see cref="T:Microsoft.ML.ITransformer" /> to ONNX format and writes to a stream.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.OnnxExportExtensions" Member="M:Microsoft.ML.OnnxExportExtensions.ConvertToOnnx(Microsoft.ML.ModelOperationsCatalog,Microsoft.ML.ITransformer,Microsoft.ML.IDataView,System.IO.Stream)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="ProjectToPrincipalComponents">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.PrincipalComponentAnalyzer ProjectToPrincipalComponents (this Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName = null, string exampleWeightColumnName = null, int rank = 20, int overSampling = 20, bool ensureZeroMean = true, Nullable&lt;int&gt; seed = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.PrincipalComponentAnalyzer ProjectToPrincipalComponents(class Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName, string exampleWeightColumnName, int32 rank, int32 overSampling, bool ensureZeroMean, valuetype System.Nullable`1&lt;int32&gt; seed) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.PcaCatalog.ProjectToPrincipalComponents(Microsoft.ML.TransformsCatalog,System.String,System.String,System.String,System.Int32,System.Int32,System.Boolean,System.Nullable{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProjectToPrincipalComponents (catalog As TransformsCatalog, outputColumnName As String, Optional inputColumnName As String = null, Optional exampleWeightColumnName As String = null, Optional rank As Integer = 20, Optional overSampling As Integer = 20, Optional ensureZeroMean As Boolean = true, Optional seed As Nullable(Of Integer) = null) As PrincipalComponentAnalyzer" />
        <MemberSignature Language="F#" Value="static member ProjectToPrincipalComponents : Microsoft.ML.TransformsCatalog * string * string * string * int * int * bool * Nullable&lt;int&gt; -&gt; Microsoft.ML.Transforms.PrincipalComponentAnalyzer" Usage="Microsoft.ML.PcaCatalog.ProjectToPrincipalComponents (catalog, outputColumnName, inputColumnName, exampleWeightColumnName, rank, overSampling, ensureZeroMean, seed)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.PrincipalComponentAnalyzer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="rank" Type="System.Int32" />
          <Parameter Name="overSampling" Type="System.Int32" />
          <Parameter Name="ensureZeroMean" Type="System.Boolean" />
          <Parameter Name="seed" Type="System.Nullable&lt;System.Int32&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="rank">The number of principal components.</param>
          <param name="overSampling">Oversampling parameter for randomized PrincipalComponentAnalysis training.</param>
          <param name="ensureZeroMean">If enabled, data is centered to be zero mean.</param>
          <param name="seed">The seed for random number generation.</param>
          <summary>Initializes a new instance of <see cref="T:Microsoft.ML.Transforms.PrincipalComponentAnalyzer" />.</summary>
        </Docs>
        <Link Type="Microsoft.ML.PcaCatalog" Member="M:Microsoft.ML.PcaCatalog.ProjectToPrincipalComponents(Microsoft.ML.TransformsCatalog,System.String,System.String,System.String,System.Int32,System.Int32,System.Boolean,System.Nullable{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.AnomalyDetectionCatalog.AnomalyDetectionTrainers" />
      </Targets>
      <Member MemberName="RandomizedPca">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.RandomizedPcaTrainer RandomizedPca (this Microsoft.ML.AnomalyDetectionCatalog.AnomalyDetectionTrainers catalog, Microsoft.ML.Trainers.RandomizedPcaTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.RandomizedPcaTrainer RandomizedPca(class Microsoft.ML.AnomalyDetectionCatalog/AnomalyDetectionTrainers catalog, class Microsoft.ML.Trainers.RandomizedPcaTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.PcaCatalog.RandomizedPca(Microsoft.ML.AnomalyDetectionCatalog.AnomalyDetectionTrainers,Microsoft.ML.Trainers.RandomizedPcaTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member RandomizedPca : Microsoft.ML.AnomalyDetectionCatalog.AnomalyDetectionTrainers * Microsoft.ML.Trainers.RandomizedPcaTrainer.Options -&gt; Microsoft.ML.Trainers.RandomizedPcaTrainer" Usage="Microsoft.ML.PcaCatalog.RandomizedPca (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.RandomizedPcaTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.AnomalyDetectionCatalog+AnomalyDetectionTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.RandomizedPcaTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The anomaly detection catalog trainer object.</param>
          <param name="options">Advanced options to the algorithm.</param>
          <summary>
            Trains an approximate principal component analysis (PCA) model using randomized SVD algorithm.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.PcaCatalog" Member="M:Microsoft.ML.PcaCatalog.RandomizedPca(Microsoft.ML.AnomalyDetectionCatalog.AnomalyDetectionTrainers,Microsoft.ML.Trainers.RandomizedPcaTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.AnomalyDetectionCatalog.AnomalyDetectionTrainers" />
      </Targets>
      <Member MemberName="RandomizedPca">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.RandomizedPcaTrainer RandomizedPca (this Microsoft.ML.AnomalyDetectionCatalog.AnomalyDetectionTrainers catalog, string featureColumnName = &quot;Features&quot;, string exampleWeightColumnName = null, int rank = 20, int oversampling = 20, bool ensureZeroMean = true, Nullable&lt;int&gt; seed = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.RandomizedPcaTrainer RandomizedPca(class Microsoft.ML.AnomalyDetectionCatalog/AnomalyDetectionTrainers catalog, string featureColumnName, string exampleWeightColumnName, int32 rank, int32 oversampling, bool ensureZeroMean, valuetype System.Nullable`1&lt;int32&gt; seed) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.PcaCatalog.RandomizedPca(Microsoft.ML.AnomalyDetectionCatalog.AnomalyDetectionTrainers,System.String,System.String,System.Int32,System.Int32,System.Boolean,System.Nullable{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function RandomizedPca (catalog As AnomalyDetectionCatalog.AnomalyDetectionTrainers, Optional featureColumnName As String = &quot;Features&quot;, Optional exampleWeightColumnName As String = null, Optional rank As Integer = 20, Optional oversampling As Integer = 20, Optional ensureZeroMean As Boolean = true, Optional seed As Nullable(Of Integer) = null) As RandomizedPcaTrainer" />
        <MemberSignature Language="F#" Value="static member RandomizedPca : Microsoft.ML.AnomalyDetectionCatalog.AnomalyDetectionTrainers * string * string * int * int * bool * Nullable&lt;int&gt; -&gt; Microsoft.ML.Trainers.RandomizedPcaTrainer" Usage="Microsoft.ML.PcaCatalog.RandomizedPca (catalog, featureColumnName, exampleWeightColumnName, rank, oversampling, ensureZeroMean, seed)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.RandomizedPcaTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.AnomalyDetectionCatalog+AnomalyDetectionTrainers" RefType="this" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="rank" Type="System.Int32" />
          <Parameter Name="oversampling" Type="System.Int32" />
          <Parameter Name="ensureZeroMean" Type="System.Boolean" />
          <Parameter Name="seed" Type="System.Nullable&lt;System.Int32&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The anomaly detection catalog trainer object.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="rank">The number of components in the PCA.</param>
          <param name="oversampling">Oversampling parameter for randomized PCA training.</param>
          <param name="ensureZeroMean">If enabled, data is centered to be zero mean.</param>
          <param name="seed">The seed for random number generation.</param>
          <summary>
            Trains an approximate principal component analysis (PCA) model using randomized SVD algorithm.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.PcaCatalog" Member="M:Microsoft.ML.PcaCatalog.RandomizedPca(Microsoft.ML.AnomalyDetectionCatalog.AnomalyDetectionTrainers,System.String,System.String,System.Int32,System.Int32,System.Boolean,System.Nullable{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog" />
      </Targets>
      <Member MemberName="PermutationFeatureImportance&lt;TModel&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.ML.Data.BinaryClassificationMetricsStatistics&gt; PermutationFeatureImportance&lt;TModel&gt; (this Microsoft.ML.BinaryClassificationCatalog catalog, Microsoft.ML.ISingleFeaturePredictionTransformer&lt;TModel&gt; predictionTransformer, Microsoft.ML.IDataView data, string labelColumnName = &quot;Label&quot;, bool useFeatureWeightFilter = false, Nullable&lt;int&gt; numberOfExamplesToUse = null, int permutationCount = 1) where TModel : class;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.ML.Data.BinaryClassificationMetricsStatistics&gt; PermutationFeatureImportance&lt;class TModel&gt;(class Microsoft.ML.BinaryClassificationCatalog catalog, class Microsoft.ML.ISingleFeaturePredictionTransformer`1&lt;!!TModel&gt; predictionTransformer, class Microsoft.ML.IDataView data, string labelColumnName, bool useFeatureWeightFilter, valuetype System.Nullable`1&lt;int32&gt; numberOfExamplesToUse, int32 permutationCount) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.PermutationFeatureImportanceExtensions.PermutationFeatureImportance``1(Microsoft.ML.BinaryClassificationCatalog,Microsoft.ML.ISingleFeaturePredictionTransformer{``0},Microsoft.ML.IDataView,System.String,System.Boolean,System.Nullable{System.Int32},System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function PermutationFeatureImportance(Of TModel As Class) (catalog As BinaryClassificationCatalog, predictionTransformer As ISingleFeaturePredictionTransformer(Of TModel), data As IDataView, Optional labelColumnName As String = &quot;Label&quot;, Optional useFeatureWeightFilter As Boolean = false, Optional numberOfExamplesToUse As Nullable(Of Integer) = null, Optional permutationCount As Integer = 1) As ImmutableArray(Of BinaryClassificationMetricsStatistics)" />
        <MemberSignature Language="F#" Value="static member PermutationFeatureImportance : Microsoft.ML.BinaryClassificationCatalog * Microsoft.ML.ISingleFeaturePredictionTransformer&lt;'Model (requires 'Model : null)&gt; * Microsoft.ML.IDataView * string * bool * Nullable&lt;int&gt; * int -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.ML.Data.BinaryClassificationMetricsStatistics&gt; (requires 'Model : null)" Usage="Microsoft.ML.PermutationFeatureImportanceExtensions.PermutationFeatureImportance (catalog, predictionTransformer, data, labelColumnName, useFeatureWeightFilter, numberOfExamplesToUse, permutationCount)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.ML.Data.BinaryClassificationMetricsStatistics&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TModel">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog" RefType="this" />
          <Parameter Name="predictionTransformer" Type="Microsoft.ML.ISingleFeaturePredictionTransformer&lt;TModel&gt;" />
          <Parameter Name="data" Type="Microsoft.ML.IDataView" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="useFeatureWeightFilter" Type="System.Boolean" />
          <Parameter Name="numberOfExamplesToUse" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="permutationCount" Type="System.Int32" />
        </Parameters>
        <Docs>
          <typeparam name="TModel">To be added.</typeparam>
          <param name="catalog">The binary classification catalog.</param>
          <param name="predictionTransformer">The model on which to evaluate feature importance.</param>
          <param name="data">The evaluation data set.</param>
          <param name="labelColumnName">Label column name.</param>
          <param name="useFeatureWeightFilter">Use features weight to pre-filter features.</param>
          <param name="numberOfExamplesToUse">Limit the number of examples to evaluate on. <cref langword="null" /> means up to ~2 bln examples from <paramref param="data" /> will be used.</param>
          <param name="permutationCount">The number of permutations to perform.</param>
          <summary>
            Permutation Feature Importance (PFI) for Binary Classification
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.PermutationFeatureImportanceExtensions" Member="M:Microsoft.ML.PermutationFeatureImportanceExtensions.PermutationFeatureImportance``1(Microsoft.ML.BinaryClassificationCatalog,Microsoft.ML.ISingleFeaturePredictionTransformer{``0},Microsoft.ML.IDataView,System.String,System.Boolean,System.Nullable{System.Int32},System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationCatalog" />
      </Targets>
      <Member MemberName="PermutationFeatureImportance&lt;TModel&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.ML.Data.MulticlassClassificationMetricsStatistics&gt; PermutationFeatureImportance&lt;TModel&gt; (this Microsoft.ML.MulticlassClassificationCatalog catalog, Microsoft.ML.ISingleFeaturePredictionTransformer&lt;TModel&gt; predictionTransformer, Microsoft.ML.IDataView data, string labelColumnName = &quot;Label&quot;, bool useFeatureWeightFilter = false, Nullable&lt;int&gt; numberOfExamplesToUse = null, int permutationCount = 1) where TModel : class;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.ML.Data.MulticlassClassificationMetricsStatistics&gt; PermutationFeatureImportance&lt;class TModel&gt;(class Microsoft.ML.MulticlassClassificationCatalog catalog, class Microsoft.ML.ISingleFeaturePredictionTransformer`1&lt;!!TModel&gt; predictionTransformer, class Microsoft.ML.IDataView data, string labelColumnName, bool useFeatureWeightFilter, valuetype System.Nullable`1&lt;int32&gt; numberOfExamplesToUse, int32 permutationCount) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.PermutationFeatureImportanceExtensions.PermutationFeatureImportance``1(Microsoft.ML.MulticlassClassificationCatalog,Microsoft.ML.ISingleFeaturePredictionTransformer{``0},Microsoft.ML.IDataView,System.String,System.Boolean,System.Nullable{System.Int32},System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function PermutationFeatureImportance(Of TModel As Class) (catalog As MulticlassClassificationCatalog, predictionTransformer As ISingleFeaturePredictionTransformer(Of TModel), data As IDataView, Optional labelColumnName As String = &quot;Label&quot;, Optional useFeatureWeightFilter As Boolean = false, Optional numberOfExamplesToUse As Nullable(Of Integer) = null, Optional permutationCount As Integer = 1) As ImmutableArray(Of MulticlassClassificationMetricsStatistics)" />
        <MemberSignature Language="F#" Value="static member PermutationFeatureImportance : Microsoft.ML.MulticlassClassificationCatalog * Microsoft.ML.ISingleFeaturePredictionTransformer&lt;'Model (requires 'Model : null)&gt; * Microsoft.ML.IDataView * string * bool * Nullable&lt;int&gt; * int -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.ML.Data.MulticlassClassificationMetricsStatistics&gt; (requires 'Model : null)" Usage="Microsoft.ML.PermutationFeatureImportanceExtensions.PermutationFeatureImportance (catalog, predictionTransformer, data, labelColumnName, useFeatureWeightFilter, numberOfExamplesToUse, permutationCount)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.ML.Data.MulticlassClassificationMetricsStatistics&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TModel">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.MulticlassClassificationCatalog" RefType="this" />
          <Parameter Name="predictionTransformer" Type="Microsoft.ML.ISingleFeaturePredictionTransformer&lt;TModel&gt;" />
          <Parameter Name="data" Type="Microsoft.ML.IDataView" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="useFeatureWeightFilter" Type="System.Boolean" />
          <Parameter Name="numberOfExamplesToUse" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="permutationCount" Type="System.Int32" />
        </Parameters>
        <Docs>
          <typeparam name="TModel">To be added.</typeparam>
          <param name="catalog">The clustering catalog.</param>
          <param name="predictionTransformer">The model on which to evaluate feature importance.</param>
          <param name="data">The evaluation data set.</param>
          <param name="labelColumnName">Label column name.</param>
          <param name="useFeatureWeightFilter">Use features weight to pre-filter features.</param>
          <param name="numberOfExamplesToUse">Limit the number of examples to evaluate on. <cref langword="null" /> means up to ~2 bln examples from <paramref param="data" /> will be used.</param>
          <param name="permutationCount">The number of permutations to perform.</param>
          <summary>
            Permutation Feature Importance (PFI) for MulticlassClassification
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.PermutationFeatureImportanceExtensions" Member="M:Microsoft.ML.PermutationFeatureImportanceExtensions.PermutationFeatureImportance``1(Microsoft.ML.MulticlassClassificationCatalog,Microsoft.ML.ISingleFeaturePredictionTransformer{``0},Microsoft.ML.IDataView,System.String,System.Boolean,System.Nullable{System.Int32},System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RankingCatalog" />
      </Targets>
      <Member MemberName="PermutationFeatureImportance&lt;TModel&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.ML.Data.RankingMetricsStatistics&gt; PermutationFeatureImportance&lt;TModel&gt; (this Microsoft.ML.RankingCatalog catalog, Microsoft.ML.ISingleFeaturePredictionTransformer&lt;TModel&gt; predictionTransformer, Microsoft.ML.IDataView data, string labelColumnName = &quot;Label&quot;, string rowGroupColumnName = &quot;GroupId&quot;, bool useFeatureWeightFilter = false, Nullable&lt;int&gt; numberOfExamplesToUse = null, int permutationCount = 1) where TModel : class;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.ML.Data.RankingMetricsStatistics&gt; PermutationFeatureImportance&lt;class TModel&gt;(class Microsoft.ML.RankingCatalog catalog, class Microsoft.ML.ISingleFeaturePredictionTransformer`1&lt;!!TModel&gt; predictionTransformer, class Microsoft.ML.IDataView data, string labelColumnName, string rowGroupColumnName, bool useFeatureWeightFilter, valuetype System.Nullable`1&lt;int32&gt; numberOfExamplesToUse, int32 permutationCount) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.PermutationFeatureImportanceExtensions.PermutationFeatureImportance``1(Microsoft.ML.RankingCatalog,Microsoft.ML.ISingleFeaturePredictionTransformer{``0},Microsoft.ML.IDataView,System.String,System.String,System.Boolean,System.Nullable{System.Int32},System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function PermutationFeatureImportance(Of TModel As Class) (catalog As RankingCatalog, predictionTransformer As ISingleFeaturePredictionTransformer(Of TModel), data As IDataView, Optional labelColumnName As String = &quot;Label&quot;, Optional rowGroupColumnName As String = &quot;GroupId&quot;, Optional useFeatureWeightFilter As Boolean = false, Optional numberOfExamplesToUse As Nullable(Of Integer) = null, Optional permutationCount As Integer = 1) As ImmutableArray(Of RankingMetricsStatistics)" />
        <MemberSignature Language="F#" Value="static member PermutationFeatureImportance : Microsoft.ML.RankingCatalog * Microsoft.ML.ISingleFeaturePredictionTransformer&lt;'Model (requires 'Model : null)&gt; * Microsoft.ML.IDataView * string * string * bool * Nullable&lt;int&gt; * int -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.ML.Data.RankingMetricsStatistics&gt; (requires 'Model : null)" Usage="Microsoft.ML.PermutationFeatureImportanceExtensions.PermutationFeatureImportance (catalog, predictionTransformer, data, labelColumnName, rowGroupColumnName, useFeatureWeightFilter, numberOfExamplesToUse, permutationCount)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.ML.Data.RankingMetricsStatistics&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TModel">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RankingCatalog" RefType="this" />
          <Parameter Name="predictionTransformer" Type="Microsoft.ML.ISingleFeaturePredictionTransformer&lt;TModel&gt;" />
          <Parameter Name="data" Type="Microsoft.ML.IDataView" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="rowGroupColumnName" Type="System.String" />
          <Parameter Name="useFeatureWeightFilter" Type="System.Boolean" />
          <Parameter Name="numberOfExamplesToUse" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="permutationCount" Type="System.Int32" />
        </Parameters>
        <Docs>
          <typeparam name="TModel">To be added.</typeparam>
          <param name="catalog">The clustering catalog.</param>
          <param name="predictionTransformer">The model on which to evaluate feature importance.</param>
          <param name="data">The evaluation data set.</param>
          <param name="labelColumnName">Label column name.</param>
          <param name="rowGroupColumnName">GroupId column name</param>
          <param name="useFeatureWeightFilter">Use features weight to pre-filter features.</param>
          <param name="numberOfExamplesToUse">Limit the number of examples to evaluate on. <cref langword="null" /> means up to ~2 bln examples from <paramref param="data" /> will be used.</param>
          <param name="permutationCount">The number of permutations to perform.</param>
          <summary>
            Permutation Feature Importance (PFI) for Ranking
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.PermutationFeatureImportanceExtensions" Member="M:Microsoft.ML.PermutationFeatureImportanceExtensions.PermutationFeatureImportance``1(Microsoft.ML.RankingCatalog,Microsoft.ML.ISingleFeaturePredictionTransformer{``0},Microsoft.ML.IDataView,System.String,System.String,System.Boolean,System.Nullable{System.Int32},System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog" />
      </Targets>
      <Member MemberName="PermutationFeatureImportance&lt;TModel&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.ML.Data.RegressionMetricsStatistics&gt; PermutationFeatureImportance&lt;TModel&gt; (this Microsoft.ML.RegressionCatalog catalog, Microsoft.ML.ISingleFeaturePredictionTransformer&lt;TModel&gt; predictionTransformer, Microsoft.ML.IDataView data, string labelColumnName = &quot;Label&quot;, bool useFeatureWeightFilter = false, Nullable&lt;int&gt; numberOfExamplesToUse = null, int permutationCount = 1) where TModel : class;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.ML.Data.RegressionMetricsStatistics&gt; PermutationFeatureImportance&lt;class TModel&gt;(class Microsoft.ML.RegressionCatalog catalog, class Microsoft.ML.ISingleFeaturePredictionTransformer`1&lt;!!TModel&gt; predictionTransformer, class Microsoft.ML.IDataView data, string labelColumnName, bool useFeatureWeightFilter, valuetype System.Nullable`1&lt;int32&gt; numberOfExamplesToUse, int32 permutationCount) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.PermutationFeatureImportanceExtensions.PermutationFeatureImportance``1(Microsoft.ML.RegressionCatalog,Microsoft.ML.ISingleFeaturePredictionTransformer{``0},Microsoft.ML.IDataView,System.String,System.Boolean,System.Nullable{System.Int32},System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function PermutationFeatureImportance(Of TModel As Class) (catalog As RegressionCatalog, predictionTransformer As ISingleFeaturePredictionTransformer(Of TModel), data As IDataView, Optional labelColumnName As String = &quot;Label&quot;, Optional useFeatureWeightFilter As Boolean = false, Optional numberOfExamplesToUse As Nullable(Of Integer) = null, Optional permutationCount As Integer = 1) As ImmutableArray(Of RegressionMetricsStatistics)" />
        <MemberSignature Language="F#" Value="static member PermutationFeatureImportance : Microsoft.ML.RegressionCatalog * Microsoft.ML.ISingleFeaturePredictionTransformer&lt;'Model (requires 'Model : null)&gt; * Microsoft.ML.IDataView * string * bool * Nullable&lt;int&gt; * int -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.ML.Data.RegressionMetricsStatistics&gt; (requires 'Model : null)" Usage="Microsoft.ML.PermutationFeatureImportanceExtensions.PermutationFeatureImportance (catalog, predictionTransformer, data, labelColumnName, useFeatureWeightFilter, numberOfExamplesToUse, permutationCount)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.ML.Data.RegressionMetricsStatistics&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TModel">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog" RefType="this" />
          <Parameter Name="predictionTransformer" Type="Microsoft.ML.ISingleFeaturePredictionTransformer&lt;TModel&gt;" />
          <Parameter Name="data" Type="Microsoft.ML.IDataView" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="useFeatureWeightFilter" Type="System.Boolean" />
          <Parameter Name="numberOfExamplesToUse" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="permutationCount" Type="System.Int32" />
        </Parameters>
        <Docs>
          <typeparam name="TModel">To be added.</typeparam>
          <param name="catalog">The regression catalog.</param>
          <param name="predictionTransformer">The model on which to evaluate feature importance.</param>
          <param name="data">The evaluation data set.</param>
          <param name="labelColumnName">Label column name.</param>
          <param name="useFeatureWeightFilter">Use features weight to pre-filter features.</param>
          <param name="numberOfExamplesToUse">Limit the number of examples to evaluate on. <cref langword="null" /> means up to ~2 bln examples from <paramref param="data" /> will be used.</param>
          <param name="permutationCount">The number of permutations to perform.</param>
          <summary>
            Permutation Feature Importance (PFI) for Regression
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.PermutationFeatureImportanceExtensions" Member="M:Microsoft.ML.PermutationFeatureImportanceExtensions.PermutationFeatureImportance``1(Microsoft.ML.RegressionCatalog,Microsoft.ML.ISingleFeaturePredictionTransformer{``0},Microsoft.ML.IDataView,System.String,System.Boolean,System.Nullable{System.Int32},System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MLContext" />
      </Targets>
      <Member MemberName="Recommendation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.RecommendationCatalog Recommendation (this Microsoft.ML.MLContext ctx);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.RecommendationCatalog Recommendation(class Microsoft.ML.MLContext ctx) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.RecommenderCatalog.Recommendation(Microsoft.ML.MLContext)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Recommendation (ctx As MLContext) As RecommendationCatalog" />
        <MemberSignature Language="F#" Value="static member Recommendation : Microsoft.ML.MLContext -&gt; Microsoft.ML.RecommendationCatalog" Usage="Microsoft.ML.RecommenderCatalog.Recommendation ctx" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.RecommendationCatalog</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.MLContext" RefType="this" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <summary>
            Trainers and tasks specific to recommendation problems.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.RecommenderCatalog" Member="M:Microsoft.ML.RecommenderCatalog.Recommendation(Microsoft.ML.MLContext)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Transforms.Onnx.DnnImageModelSelector" />
      </Targets>
      <Member MemberName="ResNet101">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; ResNet101 (this Microsoft.ML.Transforms.Onnx.DnnImageModelSelector dnnModelContext, Microsoft.ML.Runtime.IHostEnvironment env, string outputColumnName, string inputColumnName);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.EstimatorChain`1&lt;class Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; ResNet101(class Microsoft.ML.Transforms.Onnx.DnnImageModelSelector dnnModelContext, class Microsoft.ML.Runtime.IHostEnvironment env, string outputColumnName, string inputColumnName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ResNet101Extension.ResNet101(Microsoft.ML.Transforms.Onnx.DnnImageModelSelector,Microsoft.ML.Runtime.IHostEnvironment,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ResNet101 (dnnModelContext As DnnImageModelSelector, env As IHostEnvironment, outputColumnName As String, inputColumnName As String) As EstimatorChain(Of ColumnCopyingTransformer)" />
        <MemberSignature Language="F#" Value="static member ResNet101 : Microsoft.ML.Transforms.Onnx.DnnImageModelSelector * Microsoft.ML.Runtime.IHostEnvironment * string * string -&gt; Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;" Usage="Microsoft.ML.ResNet101Extension.ResNet101 (dnnModelContext, env, outputColumnName, inputColumnName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="dnnModelContext" Type="Microsoft.ML.Transforms.Onnx.DnnImageModelSelector" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="dnnModelContext">To be added.</param>
          <param name="env">To be added.</param>
          <param name="outputColumnName">To be added.</param>
          <param name="inputColumnName">To be added.</param>
          <summary>
            Returns an estimator chain with the two corresponding models (a preprocessing one and a main one) required for the ResNet pipeline.
            Also includes the renaming ColumnsCopyingTransforms required to be able to use arbitrary input and output column names.
            This assumes both of the models are in the same location as the file containing this method, which they will be if used through the NuGet.
            This should be the default way to use ResNet101 if importing the model from a NuGet.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ResNet101Extension" Member="M:Microsoft.ML.ResNet101Extension.ResNet101(Microsoft.ML.Transforms.Onnx.DnnImageModelSelector,Microsoft.ML.Runtime.IHostEnvironment,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Transforms.Onnx.DnnImageModelSelector" />
      </Targets>
      <Member MemberName="ResNet101">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; ResNet101 (this Microsoft.ML.Transforms.Onnx.DnnImageModelSelector dnnModelContext, Microsoft.ML.Runtime.IHostEnvironment env, string outputColumnName, string inputColumnName, string modelDir);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.EstimatorChain`1&lt;class Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; ResNet101(class Microsoft.ML.Transforms.Onnx.DnnImageModelSelector dnnModelContext, class Microsoft.ML.Runtime.IHostEnvironment env, string outputColumnName, string inputColumnName, string modelDir) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ResNet101Extension.ResNet101(Microsoft.ML.Transforms.Onnx.DnnImageModelSelector,Microsoft.ML.Runtime.IHostEnvironment,System.String,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ResNet101 (dnnModelContext As DnnImageModelSelector, env As IHostEnvironment, outputColumnName As String, inputColumnName As String, modelDir As String) As EstimatorChain(Of ColumnCopyingTransformer)" />
        <MemberSignature Language="F#" Value="static member ResNet101 : Microsoft.ML.Transforms.Onnx.DnnImageModelSelector * Microsoft.ML.Runtime.IHostEnvironment * string * string * string -&gt; Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;" Usage="Microsoft.ML.ResNet101Extension.ResNet101 (dnnModelContext, env, outputColumnName, inputColumnName, modelDir)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="dnnModelContext" Type="Microsoft.ML.Transforms.Onnx.DnnImageModelSelector" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="modelDir" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="dnnModelContext">To be added.</param>
          <param name="env">To be added.</param>
          <param name="outputColumnName">To be added.</param>
          <param name="inputColumnName">To be added.</param>
          <param name="modelDir">To be added.</param>
          <summary>
            This allows a custom model location to be specified. This is useful is a custom model is specified,
            or if the model is desired to be placed or shipped separately in a different folder from the main application. Note that because Onnx models
            must be in a directory all by themsleves for the OnnxTransformer to work, this method appends a ResNet101Onnx/ResNetPrepOnnx subdirectory
            to the passed in directory to prevent having to make that directory manually each time.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ResNet101Extension" Member="M:Microsoft.ML.ResNet101Extension.ResNet101(Microsoft.ML.Transforms.Onnx.DnnImageModelSelector,Microsoft.ML.Runtime.IHostEnvironment,System.String,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Transforms.Onnx.DnnImageModelSelector" />
      </Targets>
      <Member MemberName="ResNet18">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; ResNet18 (this Microsoft.ML.Transforms.Onnx.DnnImageModelSelector dnnModelContext, Microsoft.ML.Runtime.IHostEnvironment env, string outputColumnName, string inputColumnName);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.EstimatorChain`1&lt;class Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; ResNet18(class Microsoft.ML.Transforms.Onnx.DnnImageModelSelector dnnModelContext, class Microsoft.ML.Runtime.IHostEnvironment env, string outputColumnName, string inputColumnName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ResNet18Extension.ResNet18(Microsoft.ML.Transforms.Onnx.DnnImageModelSelector,Microsoft.ML.Runtime.IHostEnvironment,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ResNet18 (dnnModelContext As DnnImageModelSelector, env As IHostEnvironment, outputColumnName As String, inputColumnName As String) As EstimatorChain(Of ColumnCopyingTransformer)" />
        <MemberSignature Language="F#" Value="static member ResNet18 : Microsoft.ML.Transforms.Onnx.DnnImageModelSelector * Microsoft.ML.Runtime.IHostEnvironment * string * string -&gt; Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;" Usage="Microsoft.ML.ResNet18Extension.ResNet18 (dnnModelContext, env, outputColumnName, inputColumnName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="dnnModelContext" Type="Microsoft.ML.Transforms.Onnx.DnnImageModelSelector" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="dnnModelContext">To be added.</param>
          <param name="env">To be added.</param>
          <param name="outputColumnName">To be added.</param>
          <param name="inputColumnName">To be added.</param>
          <summary>
            Returns an estimator chain with the two corresponding models (a preprocessing one and a main one) required for the ResNet pipeline.
            Also includes the renaming ColumnsCopyingTransforms required to be able to use arbitrary input and output column names.
            This assumes both of the models are in the same location as the file containing this method, which they will be if used through the NuGet.
            This should be the default way to use ResNet18 if importing the model from a NuGet.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ResNet18Extension" Member="M:Microsoft.ML.ResNet18Extension.ResNet18(Microsoft.ML.Transforms.Onnx.DnnImageModelSelector,Microsoft.ML.Runtime.IHostEnvironment,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Transforms.Onnx.DnnImageModelSelector" />
      </Targets>
      <Member MemberName="ResNet18">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; ResNet18 (this Microsoft.ML.Transforms.Onnx.DnnImageModelSelector dnnModelContext, Microsoft.ML.Runtime.IHostEnvironment env, string outputColumnName, string inputColumnName, string modelDir);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.EstimatorChain`1&lt;class Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; ResNet18(class Microsoft.ML.Transforms.Onnx.DnnImageModelSelector dnnModelContext, class Microsoft.ML.Runtime.IHostEnvironment env, string outputColumnName, string inputColumnName, string modelDir) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ResNet18Extension.ResNet18(Microsoft.ML.Transforms.Onnx.DnnImageModelSelector,Microsoft.ML.Runtime.IHostEnvironment,System.String,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ResNet18 (dnnModelContext As DnnImageModelSelector, env As IHostEnvironment, outputColumnName As String, inputColumnName As String, modelDir As String) As EstimatorChain(Of ColumnCopyingTransformer)" />
        <MemberSignature Language="F#" Value="static member ResNet18 : Microsoft.ML.Transforms.Onnx.DnnImageModelSelector * Microsoft.ML.Runtime.IHostEnvironment * string * string * string -&gt; Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;" Usage="Microsoft.ML.ResNet18Extension.ResNet18 (dnnModelContext, env, outputColumnName, inputColumnName, modelDir)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="dnnModelContext" Type="Microsoft.ML.Transforms.Onnx.DnnImageModelSelector" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="modelDir" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="dnnModelContext">To be added.</param>
          <param name="env">To be added.</param>
          <param name="outputColumnName">To be added.</param>
          <param name="inputColumnName">To be added.</param>
          <param name="modelDir">To be added.</param>
          <summary>
            This allows a custom model location to be specified. This is useful is a custom model is specified,
            or if the model is desired to be placed or shipped separately in a different folder from the main application. Note that because Onnx models
            must be in a directory all by themsleves for the OnnxTransformer to work, this method appends a ResNet18Onnx/ResNetPrepOnnx subdirectory
            to the passed in directory to prevent having to make that directory manually each time.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ResNet18Extension" Member="M:Microsoft.ML.ResNet18Extension.ResNet18(Microsoft.ML.Transforms.Onnx.DnnImageModelSelector,Microsoft.ML.Runtime.IHostEnvironment,System.String,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Transforms.Onnx.DnnImageModelSelector" />
      </Targets>
      <Member MemberName="ResNet50">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; ResNet50 (this Microsoft.ML.Transforms.Onnx.DnnImageModelSelector dnnModelContext, Microsoft.ML.Runtime.IHostEnvironment env, string outputColumnName, string inputColumnName);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.EstimatorChain`1&lt;class Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; ResNet50(class Microsoft.ML.Transforms.Onnx.DnnImageModelSelector dnnModelContext, class Microsoft.ML.Runtime.IHostEnvironment env, string outputColumnName, string inputColumnName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ResNet50Extension.ResNet50(Microsoft.ML.Transforms.Onnx.DnnImageModelSelector,Microsoft.ML.Runtime.IHostEnvironment,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ResNet50 (dnnModelContext As DnnImageModelSelector, env As IHostEnvironment, outputColumnName As String, inputColumnName As String) As EstimatorChain(Of ColumnCopyingTransformer)" />
        <MemberSignature Language="F#" Value="static member ResNet50 : Microsoft.ML.Transforms.Onnx.DnnImageModelSelector * Microsoft.ML.Runtime.IHostEnvironment * string * string -&gt; Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;" Usage="Microsoft.ML.ResNet50Extension.ResNet50 (dnnModelContext, env, outputColumnName, inputColumnName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="dnnModelContext" Type="Microsoft.ML.Transforms.Onnx.DnnImageModelSelector" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="dnnModelContext">To be added.</param>
          <param name="env">To be added.</param>
          <param name="outputColumnName">To be added.</param>
          <param name="inputColumnName">To be added.</param>
          <summary>
            Returns an estimator chain with the two corresponding models (a preprocessing one and a main one) required for the ResNet pipeline.
            Also includes the renaming ColumnsCopyingTransforms required to be able to use arbitrary input and output column names.
            This assumes both of the models are in the same location as the file containing this method, which they will be if used through the NuGet.
            This should be the default way to use ResNet50 if importing the model from a NuGet.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ResNet50Extension" Member="M:Microsoft.ML.ResNet50Extension.ResNet50(Microsoft.ML.Transforms.Onnx.DnnImageModelSelector,Microsoft.ML.Runtime.IHostEnvironment,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Transforms.Onnx.DnnImageModelSelector" />
      </Targets>
      <Member MemberName="ResNet50">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; ResNet50 (this Microsoft.ML.Transforms.Onnx.DnnImageModelSelector dnnModelContext, Microsoft.ML.Runtime.IHostEnvironment env, string outputColumnName, string inputColumnName, string modelDir);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.EstimatorChain`1&lt;class Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; ResNet50(class Microsoft.ML.Transforms.Onnx.DnnImageModelSelector dnnModelContext, class Microsoft.ML.Runtime.IHostEnvironment env, string outputColumnName, string inputColumnName, string modelDir) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ResNet50Extension.ResNet50(Microsoft.ML.Transforms.Onnx.DnnImageModelSelector,Microsoft.ML.Runtime.IHostEnvironment,System.String,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ResNet50 (dnnModelContext As DnnImageModelSelector, env As IHostEnvironment, outputColumnName As String, inputColumnName As String, modelDir As String) As EstimatorChain(Of ColumnCopyingTransformer)" />
        <MemberSignature Language="F#" Value="static member ResNet50 : Microsoft.ML.Transforms.Onnx.DnnImageModelSelector * Microsoft.ML.Runtime.IHostEnvironment * string * string * string -&gt; Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;" Usage="Microsoft.ML.ResNet50Extension.ResNet50 (dnnModelContext, env, outputColumnName, inputColumnName, modelDir)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="dnnModelContext" Type="Microsoft.ML.Transforms.Onnx.DnnImageModelSelector" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="modelDir" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="dnnModelContext">To be added.</param>
          <param name="env">To be added.</param>
          <param name="outputColumnName">To be added.</param>
          <param name="inputColumnName">To be added.</param>
          <param name="modelDir">To be added.</param>
          <summary>
            This allows a custom model location to be specified. This is useful is a custom model is specified,
            or if the model is desired to be placed or shipped separately in a different folder from the main application. Note that because Onnx models
            must be in a directory all by themsleves for the OnnxTransformer to work, this method appends a ResNet50Onnx/ResNetPrepOnnx subdirectory
            to the passed in directory to prevent having to make that directory manually each time.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ResNet50Extension" Member="M:Microsoft.ML.ResNet50Extension.ResNet50(Microsoft.ML.Transforms.Onnx.DnnImageModelSelector,Microsoft.ML.Runtime.IHostEnvironment,System.String,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="AveragedPerceptron">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.AveragedPerceptronTrainer AveragedPerceptron (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.Trainers.AveragedPerceptronTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.AveragedPerceptronTrainer AveragedPerceptron(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.Trainers.AveragedPerceptronTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.AveragedPerceptron(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.AveragedPerceptronTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member AveragedPerceptron : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.Trainers.AveragedPerceptronTrainer.Options -&gt; Microsoft.ML.Trainers.AveragedPerceptronTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.AveragedPerceptron (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.AveragedPerceptronTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.AveragedPerceptronTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="options">Trainer options.</param>
          <summary>
            Predict a target using a linear binary classification model trained with <see cref="T:Microsoft.ML.Trainers.AveragedPerceptronTrainer" /> and advanced options.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.AveragedPerceptron(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.AveragedPerceptronTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="AveragedPerceptron">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.AveragedPerceptronTrainer AveragedPerceptron (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, Microsoft.ML.Trainers.IClassificationLoss lossFunction = null, float learningRate = 1, bool decreaseLearningRate = false, float l2Regularization = 0, int numberOfIterations = 1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.AveragedPerceptronTrainer AveragedPerceptron(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, string labelColumnName, string featureColumnName, class Microsoft.ML.Trainers.IClassificationLoss lossFunction, float32 learningRate, bool decreaseLearningRate, float32 l2Regularization, int32 numberOfIterations) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.AveragedPerceptron(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,Microsoft.ML.Trainers.IClassificationLoss,System.Single,System.Boolean,System.Single,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AveragedPerceptron (catalog As BinaryClassificationCatalog.BinaryClassificationTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional lossFunction As IClassificationLoss = null, Optional learningRate As Single = 1, Optional decreaseLearningRate As Boolean = false, Optional l2Regularization As Single = 0, Optional numberOfIterations As Integer = 1) As AveragedPerceptronTrainer" />
        <MemberSignature Language="F#" Value="static member AveragedPerceptron : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * string * string * Microsoft.ML.Trainers.IClassificationLoss * single * bool * single * int -&gt; Microsoft.ML.Trainers.AveragedPerceptronTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.AveragedPerceptron (catalog, labelColumnName, featureColumnName, lossFunction, learningRate, decreaseLearningRate, l2Regularization, numberOfIterations)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.AveragedPerceptronTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="lossFunction" Type="Microsoft.ML.Trainers.IClassificationLoss" />
          <Parameter Name="learningRate" Type="System.Single" />
          <Parameter Name="decreaseLearningRate" Type="System.Boolean" />
          <Parameter Name="l2Regularization" Type="System.Single" />
          <Parameter Name="numberOfIterations" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="lossFunction">The <a href="tmpurl_loss">loss</a> function minimized in the training process. If <see langword="null" />, <see cref="T:Microsoft.ML.Trainers.HingeLoss" /> would be used and lead to a max-margin averaged perceptron trainer.</param>
          <param name="learningRate">The initial <a href="tmpurl_lr">learning rate</a> used by SGD.</param>
          <param name="decreaseLearningRate">
            <see langword="true" /> to decrease the <paramref name="learningRate" /> as iterations progress; otherwise, <see langword="false" />.
            Default is <see langword="false" />.
            </param>
          <param name="l2Regularization">The L2 weight for <a href="tmpurl_regularization">regularization</a>.</param>
          <param name="numberOfIterations">Number of passes through the training dataset.</param>
          <summary>
            Predict a target using a linear binary classification model trained with <see cref="T:Microsoft.ML.Trainers.AveragedPerceptronTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.AveragedPerceptron(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,Microsoft.ML.Trainers.IClassificationLoss,System.Single,System.Boolean,System.Single,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="LbfgsLogisticRegression">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer LbfgsLogisticRegression (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer LbfgsLogisticRegression(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.LbfgsLogisticRegression(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member LbfgsLogisticRegression : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer.Options -&gt; Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.LbfgsLogisticRegression (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="options">Advanced arguments to the algorithm.</param>
          <summary>
             Predict a target using a linear binary classification model trained with the <see cref="T:Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.LbfgsLogisticRegression(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="LbfgsLogisticRegression">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer LbfgsLogisticRegression (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, string exampleWeightColumnName = null, float l1Regularization = 1, float l2Regularization = 1, float optimizationTolerance = 1E-07, int historySize = 20, bool enforceNonNegativity = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer LbfgsLogisticRegression(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, string labelColumnName, string featureColumnName, string exampleWeightColumnName, float32 l1Regularization, float32 l2Regularization, float32 optimizationTolerance, int32 historySize, bool enforceNonNegativity) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.LbfgsLogisticRegression(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,System.String,System.Single,System.Single,System.Single,System.Int32,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LbfgsLogisticRegression (catalog As BinaryClassificationCatalog.BinaryClassificationTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional exampleWeightColumnName As String = null, Optional l1Regularization As Single = 1, Optional l2Regularization As Single = 1, Optional optimizationTolerance As Single = 1E-07, Optional historySize As Integer = 20, Optional enforceNonNegativity As Boolean = false) As LbfgsLogisticRegressionBinaryTrainer" />
        <MemberSignature Language="F#" Value="static member LbfgsLogisticRegression : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * string * string * string * single * single * single * int * bool -&gt; Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.LbfgsLogisticRegression (catalog, labelColumnName, featureColumnName, exampleWeightColumnName, l1Regularization, l2Regularization, optimizationTolerance, historySize, enforceNonNegativity)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="l1Regularization" Type="System.Single" />
          <Parameter Name="l2Regularization" Type="System.Single" />
          <Parameter Name="optimizationTolerance" Type="System.Single" />
          <Parameter Name="historySize" Type="System.Int32" />
          <Parameter Name="enforceNonNegativity" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="l1Regularization">The L1 <a href="tmpurl_regularization">regularization</a> hyperparameter. Higher values will tend to lead to more sparse model.</param>
          <param name="l2Regularization">The L2 weight for <a href="tmpurl_regularization">regularization</a>.</param>
          <param name="optimizationTolerance">Threshold for optimizer convergence.</param>
          <param name="historySize">Memory size for <see cref="T:Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer" />. Low=faster, less accurate.</param>
          <param name="enforceNonNegativity">Enforce non-negative weights.</param>
          <summary>
             Predict a target using a linear binary classification model trained with the <see cref="T:Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.LbfgsLogisticRegression(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,System.String,System.Single,System.Single,System.Single,System.Int32,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="LbfgsMaximumEntropy">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer LbfgsMaximumEntropy (this Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers catalog, Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer LbfgsMaximumEntropy(class Microsoft.ML.MulticlassClassificationCatalog/MulticlassClassificationTrainers catalog, class Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.LbfgsMaximumEntropy(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member LbfgsMaximumEntropy : Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers * Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer.Options -&gt; Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.LbfgsMaximumEntropy (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.MulticlassClassificationCatalog+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers" />.</param>
          <param name="options">Advanced arguments to the algorithm.</param>
          <summary>
            Predict a target using a maximum entropy classification model trained with the L-BFGS method implemented in <see cref="T:Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.LbfgsMaximumEntropy(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="LbfgsMaximumEntropy">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer LbfgsMaximumEntropy (this Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, string exampleWeightColumnName = null, float l1Regularization = 1, float l2Regularization = 1, float optimizationTolerance = 1E-07, int historySize = 20, bool enforceNonNegativity = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer LbfgsMaximumEntropy(class Microsoft.ML.MulticlassClassificationCatalog/MulticlassClassificationTrainers catalog, string labelColumnName, string featureColumnName, string exampleWeightColumnName, float32 l1Regularization, float32 l2Regularization, float32 optimizationTolerance, int32 historySize, bool enforceNonNegativity) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.LbfgsMaximumEntropy(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,System.String,System.String,System.String,System.Single,System.Single,System.Single,System.Int32,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LbfgsMaximumEntropy (catalog As MulticlassClassificationCatalog.MulticlassClassificationTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional exampleWeightColumnName As String = null, Optional l1Regularization As Single = 1, Optional l2Regularization As Single = 1, Optional optimizationTolerance As Single = 1E-07, Optional historySize As Integer = 20, Optional enforceNonNegativity As Boolean = false) As LbfgsMaximumEntropyMulticlassTrainer" />
        <MemberSignature Language="F#" Value="static member LbfgsMaximumEntropy : Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers * string * string * string * single * single * single * int * bool -&gt; Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.LbfgsMaximumEntropy (catalog, labelColumnName, featureColumnName, exampleWeightColumnName, l1Regularization, l2Regularization, optimizationTolerance, historySize, enforceNonNegativity)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.MulticlassClassificationCatalog+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="l1Regularization" Type="System.Single" />
          <Parameter Name="l2Regularization" Type="System.Single" />
          <Parameter Name="optimizationTolerance" Type="System.Single" />
          <Parameter Name="historySize" Type="System.Int32" />
          <Parameter Name="enforceNonNegativity" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers" />.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="l1Regularization">The L1 <a href="tmpurl_regularization">regularization</a> hyperparameter. Higher values will tend to lead to more sparse model.</param>
          <param name="l2Regularization">The L2 weight for <a href="tmpurl_regularization">regularization</a>.</param>
          <param name="optimizationTolerance">Threshold for optimizer convergence.</param>
          <param name="historySize">Memory size for <see cref="T:Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer" />. Low=faster, less accurate.</param>
          <param name="enforceNonNegativity">Enforce non-negative weights.</param>
          <summary>
            Predict a target using a maximum entropy classification model trained with the L-BFGS method implemented in <see cref="T:Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.LbfgsMaximumEntropy(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,System.String,System.String,System.String,System.Single,System.Single,System.Single,System.Int32,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="LbfgsPoissonRegression">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.LbfgsPoissonRegressionTrainer LbfgsPoissonRegression (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, Microsoft.ML.Trainers.LbfgsPoissonRegressionTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.LbfgsPoissonRegressionTrainer LbfgsPoissonRegression(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, class Microsoft.ML.Trainers.LbfgsPoissonRegressionTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.LbfgsPoissonRegression(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.Trainers.LbfgsPoissonRegressionTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member LbfgsPoissonRegression : Microsoft.ML.RegressionCatalog.RegressionTrainers * Microsoft.ML.Trainers.LbfgsPoissonRegressionTrainer.Options -&gt; Microsoft.ML.Trainers.LbfgsPoissonRegressionTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.LbfgsPoissonRegression (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.LbfgsPoissonRegressionTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.LbfgsPoissonRegressionTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The regression catalog trainer object.</param>
          <param name="options">Trainer options.</param>
          <summary>
            Predict a target using a linear regression model trained with the <see cref="T:Microsoft.ML.Trainers.LbfgsPoissonRegressionTrainer" /> and advanced options.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.LbfgsPoissonRegression(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.Trainers.LbfgsPoissonRegressionTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="LbfgsPoissonRegression">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.LbfgsPoissonRegressionTrainer LbfgsPoissonRegression (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, string exampleWeightColumnName = null, float l1Regularization = 1, float l2Regularization = 1, float optimizationTolerance = 1E-07, int historySize = 20, bool enforceNonNegativity = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.LbfgsPoissonRegressionTrainer LbfgsPoissonRegression(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, string labelColumnName, string featureColumnName, string exampleWeightColumnName, float32 l1Regularization, float32 l2Regularization, float32 optimizationTolerance, int32 historySize, bool enforceNonNegativity) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.LbfgsPoissonRegression(Microsoft.ML.RegressionCatalog.RegressionTrainers,System.String,System.String,System.String,System.Single,System.Single,System.Single,System.Int32,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LbfgsPoissonRegression (catalog As RegressionCatalog.RegressionTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional exampleWeightColumnName As String = null, Optional l1Regularization As Single = 1, Optional l2Regularization As Single = 1, Optional optimizationTolerance As Single = 1E-07, Optional historySize As Integer = 20, Optional enforceNonNegativity As Boolean = false) As LbfgsPoissonRegressionTrainer" />
        <MemberSignature Language="F#" Value="static member LbfgsPoissonRegression : Microsoft.ML.RegressionCatalog.RegressionTrainers * string * string * string * single * single * single * int * bool -&gt; Microsoft.ML.Trainers.LbfgsPoissonRegressionTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.LbfgsPoissonRegression (catalog, labelColumnName, featureColumnName, exampleWeightColumnName, l1Regularization, l2Regularization, optimizationTolerance, historySize, enforceNonNegativity)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.LbfgsPoissonRegressionTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="l1Regularization" Type="System.Single" />
          <Parameter Name="l2Regularization" Type="System.Single" />
          <Parameter Name="optimizationTolerance" Type="System.Single" />
          <Parameter Name="historySize" Type="System.Int32" />
          <Parameter Name="enforceNonNegativity" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The regression catalog trainer object.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="l1Regularization">The L1 <a href="tmpurl_regularization">regularization</a> hyperparameter. Higher values will tend to lead to more sparse model.</param>
          <param name="l2Regularization">The L2 weight for <a href="tmpurl_regularization">regularization</a>.</param>
          <param name="optimizationTolerance">Threshold for optimizer convergence.</param>
          <param name="historySize">Number of previous iterations to remember for estimating the Hessian. Lower values mean faster but less accurate estimates.</param>
          <param name="enforceNonNegativity">Enforce non-negative weights.</param>
          <summary>
            Predict a target using a linear regression model trained with the <see cref="T:Microsoft.ML.Trainers.LbfgsPoissonRegressionTrainer" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.LbfgsPoissonRegression(Microsoft.ML.RegressionCatalog.RegressionTrainers,System.String,System.String,System.String,System.Single,System.Single,System.Single,System.Int32,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="LinearSvm">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.LinearSvmTrainer LinearSvm (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.Trainers.LinearSvmTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.LinearSvmTrainer LinearSvm(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.Trainers.LinearSvmTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.LinearSvm(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.LinearSvmTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member LinearSvm : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.Trainers.LinearSvmTrainer.Options -&gt; Microsoft.ML.Trainers.LinearSvmTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.LinearSvm (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.LinearSvmTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.LinearSvmTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.BinaryClassificationCatalog" />.</param>
          <param name="options">Advanced arguments to the algorithm.</param>
          <summary>
            Predict a target using a linear binary classification model trained with the <see cref="T:Microsoft.ML.Trainers.LinearSvmTrainer" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.LinearSvm(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.LinearSvmTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="LinearSvm">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.LinearSvmTrainer LinearSvm (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, string exampleWeightColumnName = null, int numberOfIterations = 1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.LinearSvmTrainer LinearSvm(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, string labelColumnName, string featureColumnName, string exampleWeightColumnName, int32 numberOfIterations) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.LinearSvm(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,System.String,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LinearSvm (catalog As BinaryClassificationCatalog.BinaryClassificationTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional exampleWeightColumnName As String = null, Optional numberOfIterations As Integer = 1) As LinearSvmTrainer" />
        <MemberSignature Language="F#" Value="static member LinearSvm : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * string * string * string * int -&gt; Microsoft.ML.Trainers.LinearSvmTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.LinearSvm (catalog, labelColumnName, featureColumnName, exampleWeightColumnName, numberOfIterations)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.LinearSvmTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="numberOfIterations" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.BinaryClassificationCatalog" />.</param>
          <param name="labelColumnName">The name of the label column. </param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="numberOfIterations">The number of training iteraitons.</param>
          <summary>
            Predict a target using a linear binary classification model trained with the <see cref="T:Microsoft.ML.Trainers.LinearSvmTrainer" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.LinearSvm(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,System.String,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="NaiveBayes">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.NaiveBayesMulticlassTrainer NaiveBayes (this Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.NaiveBayesMulticlassTrainer NaiveBayes(class Microsoft.ML.MulticlassClassificationCatalog/MulticlassClassificationTrainers catalog, string labelColumnName, string featureColumnName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.NaiveBayes(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NaiveBayes (catalog As MulticlassClassificationCatalog.MulticlassClassificationTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;) As NaiveBayesMulticlassTrainer" />
        <MemberSignature Language="F#" Value="static member NaiveBayes : Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers * string * string -&gt; Microsoft.ML.Trainers.NaiveBayesMulticlassTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.NaiveBayes (catalog, labelColumnName, featureColumnName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.NaiveBayesMulticlassTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.MulticlassClassificationCatalog+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers" />.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <summary>
            Predicts a target using a linear multiclass classification model trained with the <see cref="T:Microsoft.ML.Trainers.NaiveBayesMulticlassTrainer" />.
            The <see cref="T:Microsoft.ML.Trainers.NaiveBayesMulticlassTrainer" /> trains a multiclass Naive Bayes predictor that supports binary feature values.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.NaiveBayes(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="OneVersusAll&lt;TModel&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.OneVersusAllTrainer OneVersusAll&lt;TModel&gt; (this Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers catalog, Microsoft.ML.Trainers.ITrainerEstimator&lt;Microsoft.ML.Data.BinaryPredictionTransformer&lt;TModel&gt;,TModel&gt; binaryEstimator, string labelColumnName = &quot;Label&quot;, bool imputeMissingLabelsAsNegative = false, Microsoft.ML.IEstimator&lt;Microsoft.ML.ISingleFeaturePredictionTransformer&lt;Microsoft.ML.Calibrators.ICalibrator&gt;&gt; calibrator = null, int maximumCalibrationExampleCount = 1000000000, bool useProbabilities = true) where TModel : class;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.OneVersusAllTrainer OneVersusAll&lt;class TModel&gt;(class Microsoft.ML.MulticlassClassificationCatalog/MulticlassClassificationTrainers catalog, class Microsoft.ML.Trainers.ITrainerEstimator`2&lt;class Microsoft.ML.Data.BinaryPredictionTransformer`1&lt;!!TModel&gt;, !!TModel&gt; binaryEstimator, string labelColumnName, bool imputeMissingLabelsAsNegative, class Microsoft.ML.IEstimator`1&lt;class Microsoft.ML.ISingleFeaturePredictionTransformer`1&lt;class Microsoft.ML.Calibrators.ICalibrator&gt;&gt; calibrator, int32 maximumCalibrationExampleCount, bool useProbabilities) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.OneVersusAll``1(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.Trainers.ITrainerEstimator{Microsoft.ML.Data.BinaryPredictionTransformer{``0},``0},System.String,System.Boolean,Microsoft.ML.IEstimator{Microsoft.ML.ISingleFeaturePredictionTransformer{Microsoft.ML.Calibrators.ICalibrator}},System.Int32,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OneVersusAll(Of TModel As Class) (catalog As MulticlassClassificationCatalog.MulticlassClassificationTrainers, binaryEstimator As ITrainerEstimator(Of BinaryPredictionTransformer(Of TModel), TModel), Optional labelColumnName As String = &quot;Label&quot;, Optional imputeMissingLabelsAsNegative As Boolean = false, Optional calibrator As IEstimator(Of ISingleFeaturePredictionTransformer(Of ICalibrator)) = null, Optional maximumCalibrationExampleCount As Integer = 1000000000, Optional useProbabilities As Boolean = true) As OneVersusAllTrainer" />
        <MemberSignature Language="F#" Value="static member OneVersusAll : Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers * Microsoft.ML.Trainers.ITrainerEstimator&lt;Microsoft.ML.Data.BinaryPredictionTransformer&lt;'Model&gt;, 'Model (requires 'Model : null)&gt; * string * bool * Microsoft.ML.IEstimator&lt;Microsoft.ML.ISingleFeaturePredictionTransformer&lt;Microsoft.ML.Calibrators.ICalibrator&gt;&gt; * int * bool -&gt; Microsoft.ML.Trainers.OneVersusAllTrainer (requires 'Model : null)" Usage="Microsoft.ML.StandardTrainersCatalog.OneVersusAll (catalog, binaryEstimator, labelColumnName, imputeMissingLabelsAsNegative, calibrator, maximumCalibrationExampleCount, useProbabilities)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.OneVersusAllTrainer</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TModel">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.MulticlassClassificationCatalog+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="binaryEstimator" Type="Microsoft.ML.Trainers.ITrainerEstimator&lt;Microsoft.ML.Data.BinaryPredictionTransformer&lt;TModel&gt;,TModel&gt;" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="imputeMissingLabelsAsNegative" Type="System.Boolean" />
          <Parameter Name="calibrator" Type="Microsoft.ML.IEstimator&lt;Microsoft.ML.ISingleFeaturePredictionTransformer&lt;Microsoft.ML.Calibrators.ICalibrator&gt;&gt;" />
          <Parameter Name="maximumCalibrationExampleCount" Type="System.Int32" />
          <Parameter Name="useProbabilities" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <typeparam name="TModel">The type of the model. This type parameter will usually be inferred automatically from <paramref name="binaryEstimator" />.</typeparam>
          <param name="catalog">The <see cref="T:Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers" />.</param>
          <param name="binaryEstimator">An instance of a binary <see cref="T:Microsoft.ML.Trainers.ITrainerEstimator`2" /> used as the base trainer.</param>
          <param name="labelColumnName">The name of the label colum.</param>
          <param name="imputeMissingLabelsAsNegative">Whether to treat missing labels as having negative labels, instead of keeping them missing.</param>
          <param name="calibrator">The calibrator. If a calibrator is not explicitely provided, it will default to <see cref="T:Microsoft.ML.Calibrators.PlattCalibratorTrainer" /></param>
          <param name="maximumCalibrationExampleCount">Number of instances to train the calibrator.</param>
          <param name="useProbabilities">Use probabilities (vs. raw outputs) to identify top-score category.</param>
          <summary>
            Predicts a target using a linear multiclass classification model trained with the <see cref="T:Microsoft.ML.Trainers.OneVersusAllTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.OneVersusAll``1(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.Trainers.ITrainerEstimator{Microsoft.ML.Data.BinaryPredictionTransformer{``0},``0},System.String,System.Boolean,Microsoft.ML.IEstimator{Microsoft.ML.ISingleFeaturePredictionTransformer{Microsoft.ML.Calibrators.ICalibrator}},System.Int32,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="OnlineGradientDescent">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.OnlineGradientDescentTrainer OnlineGradientDescent (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, Microsoft.ML.Trainers.OnlineGradientDescentTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.OnlineGradientDescentTrainer OnlineGradientDescent(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, class Microsoft.ML.Trainers.OnlineGradientDescentTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.OnlineGradientDescent(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.Trainers.OnlineGradientDescentTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member OnlineGradientDescent : Microsoft.ML.RegressionCatalog.RegressionTrainers * Microsoft.ML.Trainers.OnlineGradientDescentTrainer.Options -&gt; Microsoft.ML.Trainers.OnlineGradientDescentTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.OnlineGradientDescent (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.OnlineGradientDescentTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.OnlineGradientDescentTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The regression catalog trainer object.</param>
          <param name="options">Trainer options.</param>
          <summary>
            Predict a target using a linear regression model trained with the <see cref="T:Microsoft.ML.Trainers.OnlineGradientDescentTrainer" /> and advanced options.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.OnlineGradientDescent(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.Trainers.OnlineGradientDescentTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="OnlineGradientDescent">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.OnlineGradientDescentTrainer OnlineGradientDescent (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, Microsoft.ML.Trainers.IRegressionLoss lossFunction = null, float learningRate = 0.1, bool decreaseLearningRate = true, float l2Regularization = 0, int numberOfIterations = 1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.OnlineGradientDescentTrainer OnlineGradientDescent(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, string labelColumnName, string featureColumnName, class Microsoft.ML.Trainers.IRegressionLoss lossFunction, float32 learningRate, bool decreaseLearningRate, float32 l2Regularization, int32 numberOfIterations) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.OnlineGradientDescent(Microsoft.ML.RegressionCatalog.RegressionTrainers,System.String,System.String,Microsoft.ML.Trainers.IRegressionLoss,System.Single,System.Boolean,System.Single,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OnlineGradientDescent (catalog As RegressionCatalog.RegressionTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional lossFunction As IRegressionLoss = null, Optional learningRate As Single = 0.1, Optional decreaseLearningRate As Boolean = true, Optional l2Regularization As Single = 0, Optional numberOfIterations As Integer = 1) As OnlineGradientDescentTrainer" />
        <MemberSignature Language="F#" Value="static member OnlineGradientDescent : Microsoft.ML.RegressionCatalog.RegressionTrainers * string * string * Microsoft.ML.Trainers.IRegressionLoss * single * bool * single * int -&gt; Microsoft.ML.Trainers.OnlineGradientDescentTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.OnlineGradientDescent (catalog, labelColumnName, featureColumnName, lossFunction, learningRate, decreaseLearningRate, l2Regularization, numberOfIterations)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.OnlineGradientDescentTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="lossFunction" Type="Microsoft.ML.Trainers.IRegressionLoss" />
          <Parameter Name="learningRate" Type="System.Single" />
          <Parameter Name="decreaseLearningRate" Type="System.Boolean" />
          <Parameter Name="l2Regularization" Type="System.Single" />
          <Parameter Name="numberOfIterations" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The regression catalog trainer object.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="lossFunction">The <a href="tmpurl_loss">loss</a> function minimized in the training process. Using, for example, <see cref="T:Microsoft.ML.Trainers.SquaredLoss" /> leads to a least square trainer.</param>
          <param name="learningRate">The initial <a href="tmpurl_lr">learning rate</a> used by SGD.</param>
          <param name="decreaseLearningRate">Decrease learning rate as iterations progress.</param>
          <param name="l2Regularization">The L2 weight for <a href="tmpurl_regularization">regularization</a>.</param>
          <param name="numberOfIterations">The number of passes through the training dataset.</param>
          <summary>
            Predict a target using a linear regression model trained with the <see cref="T:Microsoft.ML.Trainers.OnlineGradientDescentTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.OnlineGradientDescent(Microsoft.ML.RegressionCatalog.RegressionTrainers,System.String,System.String,Microsoft.ML.Trainers.IRegressionLoss,System.Single,System.Boolean,System.Single,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="PairwiseCoupling&lt;TModel&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.PairwiseCouplingTrainer PairwiseCoupling&lt;TModel&gt; (this Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers catalog, Microsoft.ML.Trainers.ITrainerEstimator&lt;Microsoft.ML.ISingleFeaturePredictionTransformer&lt;TModel&gt;,TModel&gt; binaryEstimator, string labelColumnName = &quot;Label&quot;, bool imputeMissingLabelsAsNegative = false, Microsoft.ML.IEstimator&lt;Microsoft.ML.ISingleFeaturePredictionTransformer&lt;Microsoft.ML.Calibrators.ICalibrator&gt;&gt; calibrator = null, int maximumCalibrationExampleCount = 1000000000) where TModel : class;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.PairwiseCouplingTrainer PairwiseCoupling&lt;class TModel&gt;(class Microsoft.ML.MulticlassClassificationCatalog/MulticlassClassificationTrainers catalog, class Microsoft.ML.Trainers.ITrainerEstimator`2&lt;class Microsoft.ML.ISingleFeaturePredictionTransformer`1&lt;!!TModel&gt;, !!TModel&gt; binaryEstimator, string labelColumnName, bool imputeMissingLabelsAsNegative, class Microsoft.ML.IEstimator`1&lt;class Microsoft.ML.ISingleFeaturePredictionTransformer`1&lt;class Microsoft.ML.Calibrators.ICalibrator&gt;&gt; calibrator, int32 maximumCalibrationExampleCount) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.PairwiseCoupling``1(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.Trainers.ITrainerEstimator{Microsoft.ML.ISingleFeaturePredictionTransformer{``0},``0},System.String,System.Boolean,Microsoft.ML.IEstimator{Microsoft.ML.ISingleFeaturePredictionTransformer{Microsoft.ML.Calibrators.ICalibrator}},System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function PairwiseCoupling(Of TModel As Class) (catalog As MulticlassClassificationCatalog.MulticlassClassificationTrainers, binaryEstimator As ITrainerEstimator(Of ISingleFeaturePredictionTransformer(Of TModel), TModel), Optional labelColumnName As String = &quot;Label&quot;, Optional imputeMissingLabelsAsNegative As Boolean = false, Optional calibrator As IEstimator(Of ISingleFeaturePredictionTransformer(Of ICalibrator)) = null, Optional maximumCalibrationExampleCount As Integer = 1000000000) As PairwiseCouplingTrainer" />
        <MemberSignature Language="F#" Value="static member PairwiseCoupling : Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers * Microsoft.ML.Trainers.ITrainerEstimator&lt;Microsoft.ML.ISingleFeaturePredictionTransformer&lt;'Model&gt;, 'Model (requires 'Model : null)&gt; * string * bool * Microsoft.ML.IEstimator&lt;Microsoft.ML.ISingleFeaturePredictionTransformer&lt;Microsoft.ML.Calibrators.ICalibrator&gt;&gt; * int -&gt; Microsoft.ML.Trainers.PairwiseCouplingTrainer (requires 'Model : null)" Usage="Microsoft.ML.StandardTrainersCatalog.PairwiseCoupling (catalog, binaryEstimator, labelColumnName, imputeMissingLabelsAsNegative, calibrator, maximumCalibrationExampleCount)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.PairwiseCouplingTrainer</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TModel">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.MulticlassClassificationCatalog+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="binaryEstimator" Type="Microsoft.ML.Trainers.ITrainerEstimator&lt;Microsoft.ML.ISingleFeaturePredictionTransformer&lt;TModel&gt;,TModel&gt;" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="imputeMissingLabelsAsNegative" Type="System.Boolean" />
          <Parameter Name="calibrator" Type="Microsoft.ML.IEstimator&lt;Microsoft.ML.ISingleFeaturePredictionTransformer&lt;Microsoft.ML.Calibrators.ICalibrator&gt;&gt;" />
          <Parameter Name="maximumCalibrationExampleCount" Type="System.Int32" />
        </Parameters>
        <Docs>
          <typeparam name="TModel">The type of the model. This type parameter will usually be inferred automatically from <paramref name="binaryEstimator" />.</typeparam>
          <param name="catalog">The <see cref="T:Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers" />.</param>
          <param name="binaryEstimator">An instance of a binary <see cref="T:Microsoft.ML.Trainers.ITrainerEstimator`2" /> used as the base trainer.</param>
          <param name="labelColumnName">The name of the label colum.</param>
          <param name="imputeMissingLabelsAsNegative">Whether to treat missing labels as having negative labels, instead of keeping them missing.</param>
          <param name="calibrator">The calibrator. If a calibrator is not explicitely provided, it will default to <see cref="T:Microsoft.ML.Calibrators.PlattCalibratorTrainer" /></param>
          <param name="maximumCalibrationExampleCount">Number of instances to train the calibrator.</param>
          <summary>
            Predicts a target using a linear multiclass classification model trained with the <see cref="T:Microsoft.ML.Trainers.PairwiseCouplingTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.PairwiseCoupling``1(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.Trainers.ITrainerEstimator{Microsoft.ML.ISingleFeaturePredictionTransformer{``0},``0},System.String,System.Boolean,Microsoft.ML.IEstimator{Microsoft.ML.ISingleFeaturePredictionTransformer{Microsoft.ML.Calibrators.ICalibrator}},System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="Prior">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.PriorTrainer Prior (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, string labelColumnName = &quot;Label&quot;, string exampleWeightColumnName = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.PriorTrainer Prior(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, string labelColumnName, string exampleWeightColumnName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.Prior(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Prior (catalog As BinaryClassificationCatalog.BinaryClassificationTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional exampleWeightColumnName As String = null) As PriorTrainer" />
        <MemberSignature Language="F#" Value="static member Prior : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * string * string -&gt; Microsoft.ML.Trainers.PriorTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.Prior (catalog, labelColumnName, exampleWeightColumnName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.PriorTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.BinaryClassificationCatalog" />.</param>
          <param name="labelColumnName">The name of the label column. </param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <summary>
            Predict a target using a binary classification model trained with <see cref="T:Microsoft.ML.Trainers.PriorTrainer" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.Prior(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="Sdca">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.SdcaRegressionTrainer Sdca (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, Microsoft.ML.Trainers.SdcaRegressionTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.SdcaRegressionTrainer Sdca(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, class Microsoft.ML.Trainers.SdcaRegressionTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.Sdca(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.Trainers.SdcaRegressionTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member Sdca : Microsoft.ML.RegressionCatalog.RegressionTrainers * Microsoft.ML.Trainers.SdcaRegressionTrainer.Options -&gt; Microsoft.ML.Trainers.SdcaRegressionTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.Sdca (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.SdcaRegressionTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.SdcaRegressionTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The regression catalog trainer object.</param>
          <param name="options">Trainer options.</param>
          <summary>
            Predict a target using a linear regression model trained with <see cref="T:Microsoft.ML.Trainers.SdcaRegressionTrainer" /> and advanced options.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.Sdca(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.Trainers.SdcaRegressionTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="Sdca">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.SdcaRegressionTrainer Sdca (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, string exampleWeightColumnName = null, Microsoft.ML.Trainers.ISupportSdcaRegressionLoss lossFunction = null, Nullable&lt;float&gt; l2Regularization = null, Nullable&lt;float&gt; l1Regularization = null, Nullable&lt;int&gt; maximumNumberOfIterations = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.SdcaRegressionTrainer Sdca(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, string labelColumnName, string featureColumnName, string exampleWeightColumnName, class Microsoft.ML.Trainers.ISupportSdcaRegressionLoss lossFunction, valuetype System.Nullable`1&lt;float32&gt; l2Regularization, valuetype System.Nullable`1&lt;float32&gt; l1Regularization, valuetype System.Nullable`1&lt;int32&gt; maximumNumberOfIterations) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.Sdca(Microsoft.ML.RegressionCatalog.RegressionTrainers,System.String,System.String,System.String,Microsoft.ML.Trainers.ISupportSdcaRegressionLoss,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sdca (catalog As RegressionCatalog.RegressionTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional exampleWeightColumnName As String = null, Optional lossFunction As ISupportSdcaRegressionLoss = null, Optional l2Regularization As Nullable(Of Single) = null, Optional l1Regularization As Nullable(Of Single) = null, Optional maximumNumberOfIterations As Nullable(Of Integer) = null) As SdcaRegressionTrainer" />
        <MemberSignature Language="F#" Value="static member Sdca : Microsoft.ML.RegressionCatalog.RegressionTrainers * string * string * string * Microsoft.ML.Trainers.ISupportSdcaRegressionLoss * Nullable&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;int&gt; -&gt; Microsoft.ML.Trainers.SdcaRegressionTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.Sdca (catalog, labelColumnName, featureColumnName, exampleWeightColumnName, lossFunction, l2Regularization, l1Regularization, maximumNumberOfIterations)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.SdcaRegressionTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="lossFunction" Type="Microsoft.ML.Trainers.ISupportSdcaRegressionLoss" />
          <Parameter Name="l2Regularization" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="l1Regularization" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="maximumNumberOfIterations" Type="System.Nullable&lt;System.Int32&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The regression catalog trainer object.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="lossFunction">The <a href="tmpurl_loss">loss</a> function minimized in the training process. Using, for example, its default <see cref="T:Microsoft.ML.Trainers.SquaredLoss" /> leads to a least square trainer.</param>
          <param name="l2Regularization">The L2 weight for <a href="tmpurl_regularization">regularization</a>.</param>
          <param name="l1Regularization">The L1 <a href="tmpurl_regularization">regularization</a> hyperparameter. Higher values will tend to lead to more sparse model.</param>
          <param name="maximumNumberOfIterations">The maximum number of passes to perform over the data.</param>
          <summary>
            Predict a target using a linear regression model trained with <see cref="T:Microsoft.ML.Trainers.SdcaRegressionTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.Sdca(Microsoft.ML.RegressionCatalog.RegressionTrainers,System.String,System.String,System.String,Microsoft.ML.Trainers.ISupportSdcaRegressionLoss,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="SdcaLogisticRegression">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.SdcaLogisticRegressionBinaryTrainer SdcaLogisticRegression (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.Trainers.SdcaLogisticRegressionBinaryTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.SdcaLogisticRegressionBinaryTrainer SdcaLogisticRegression(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.Trainers.SdcaLogisticRegressionBinaryTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.SdcaLogisticRegression(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.SdcaLogisticRegressionBinaryTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member SdcaLogisticRegression : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.Trainers.SdcaLogisticRegressionBinaryTrainer.Options -&gt; Microsoft.ML.Trainers.SdcaLogisticRegressionBinaryTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.SdcaLogisticRegression (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.SdcaLogisticRegressionBinaryTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.SdcaLogisticRegressionBinaryTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="options">Trainer options.</param>
          <summary>
            Predict a target using a linear classification model trained with <see cref="T:Microsoft.ML.Trainers.SdcaLogisticRegressionBinaryTrainer" /> and advanced options.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.SdcaLogisticRegression(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.SdcaLogisticRegressionBinaryTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="SdcaLogisticRegression">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.SdcaLogisticRegressionBinaryTrainer SdcaLogisticRegression (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, string exampleWeightColumnName = null, Nullable&lt;float&gt; l2Regularization = null, Nullable&lt;float&gt; l1Regularization = null, Nullable&lt;int&gt; maximumNumberOfIterations = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.SdcaLogisticRegressionBinaryTrainer SdcaLogisticRegression(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, string labelColumnName, string featureColumnName, string exampleWeightColumnName, valuetype System.Nullable`1&lt;float32&gt; l2Regularization, valuetype System.Nullable`1&lt;float32&gt; l1Regularization, valuetype System.Nullable`1&lt;int32&gt; maximumNumberOfIterations) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.SdcaLogisticRegression(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SdcaLogisticRegression (catalog As BinaryClassificationCatalog.BinaryClassificationTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional exampleWeightColumnName As String = null, Optional l2Regularization As Nullable(Of Single) = null, Optional l1Regularization As Nullable(Of Single) = null, Optional maximumNumberOfIterations As Nullable(Of Integer) = null) As SdcaLogisticRegressionBinaryTrainer" />
        <MemberSignature Language="F#" Value="static member SdcaLogisticRegression : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * string * string * string * Nullable&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;int&gt; -&gt; Microsoft.ML.Trainers.SdcaLogisticRegressionBinaryTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.SdcaLogisticRegression (catalog, labelColumnName, featureColumnName, exampleWeightColumnName, l2Regularization, l1Regularization, maximumNumberOfIterations)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.SdcaLogisticRegressionBinaryTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="l2Regularization" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="l1Regularization" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="maximumNumberOfIterations" Type="System.Nullable&lt;System.Int32&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="l2Regularization">The L2 weight for <a href="tmpurl_regularization">regularization</a>.</param>
          <param name="l1Regularization">The L1 <a href="tmpurl_regularization">regularization</a> hyperparameter. Higher values will tend to lead to more sparse model.</param>
          <param name="maximumNumberOfIterations">The maximum number of passes to perform over the data.</param>
          <summary>
            Predict a target using a linear classification model trained with <see cref="T:Microsoft.ML.Trainers.SdcaLogisticRegressionBinaryTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.SdcaLogisticRegression(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="SdcaMaximumEntropy">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.SdcaMaximumEntropyMulticlassTrainer SdcaMaximumEntropy (this Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers catalog, Microsoft.ML.Trainers.SdcaMaximumEntropyMulticlassTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.SdcaMaximumEntropyMulticlassTrainer SdcaMaximumEntropy(class Microsoft.ML.MulticlassClassificationCatalog/MulticlassClassificationTrainers catalog, class Microsoft.ML.Trainers.SdcaMaximumEntropyMulticlassTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.SdcaMaximumEntropy(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.Trainers.SdcaMaximumEntropyMulticlassTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member SdcaMaximumEntropy : Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers * Microsoft.ML.Trainers.SdcaMaximumEntropyMulticlassTrainer.Options -&gt; Microsoft.ML.Trainers.SdcaMaximumEntropyMulticlassTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.SdcaMaximumEntropy (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.SdcaMaximumEntropyMulticlassTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.MulticlassClassificationCatalog+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.SdcaMaximumEntropyMulticlassTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The multiclass classification catalog trainer object.</param>
          <param name="options">Trainer options.</param>
          <summary>
            Predict a target using a maximum entropy classification model trained with <see cref="T:Microsoft.ML.Trainers.SdcaMaximumEntropyMulticlassTrainer" /> and advanced options.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.SdcaMaximumEntropy(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.Trainers.SdcaMaximumEntropyMulticlassTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="SdcaMaximumEntropy">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.SdcaMaximumEntropyMulticlassTrainer SdcaMaximumEntropy (this Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, string exampleWeightColumnName = null, Nullable&lt;float&gt; l2Regularization = null, Nullable&lt;float&gt; l1Regularization = null, Nullable&lt;int&gt; maximumNumberOfIterations = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.SdcaMaximumEntropyMulticlassTrainer SdcaMaximumEntropy(class Microsoft.ML.MulticlassClassificationCatalog/MulticlassClassificationTrainers catalog, string labelColumnName, string featureColumnName, string exampleWeightColumnName, valuetype System.Nullable`1&lt;float32&gt; l2Regularization, valuetype System.Nullable`1&lt;float32&gt; l1Regularization, valuetype System.Nullable`1&lt;int32&gt; maximumNumberOfIterations) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.SdcaMaximumEntropy(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SdcaMaximumEntropy (catalog As MulticlassClassificationCatalog.MulticlassClassificationTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional exampleWeightColumnName As String = null, Optional l2Regularization As Nullable(Of Single) = null, Optional l1Regularization As Nullable(Of Single) = null, Optional maximumNumberOfIterations As Nullable(Of Integer) = null) As SdcaMaximumEntropyMulticlassTrainer" />
        <MemberSignature Language="F#" Value="static member SdcaMaximumEntropy : Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers * string * string * string * Nullable&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;int&gt; -&gt; Microsoft.ML.Trainers.SdcaMaximumEntropyMulticlassTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.SdcaMaximumEntropy (catalog, labelColumnName, featureColumnName, exampleWeightColumnName, l2Regularization, l1Regularization, maximumNumberOfIterations)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.SdcaMaximumEntropyMulticlassTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.MulticlassClassificationCatalog+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="l2Regularization" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="l1Regularization" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="maximumNumberOfIterations" Type="System.Nullable&lt;System.Int32&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The multiclass classification catalog trainer object.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="l2Regularization">The L2 weight for <a href="tmpurl_regularization">regularization</a>.</param>
          <param name="l1Regularization">The L1 <a href="tmpurl_regularization">regularization</a> hyperparameter. Higher values will tend to lead to more sparse model.</param>
          <param name="maximumNumberOfIterations">The maximum number of passes to perform over the data.</param>
          <summary>
            Predict a target using a maximum entropy classification model trained with <see cref="T:Microsoft.ML.Trainers.SdcaMaximumEntropyMulticlassTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.SdcaMaximumEntropy(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="SdcaNonCalibrated">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.SdcaNonCalibratedBinaryTrainer SdcaNonCalibrated (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.Trainers.SdcaNonCalibratedBinaryTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.SdcaNonCalibratedBinaryTrainer SdcaNonCalibrated(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.Trainers.SdcaNonCalibratedBinaryTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.SdcaNonCalibrated(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.SdcaNonCalibratedBinaryTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member SdcaNonCalibrated : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.Trainers.SdcaNonCalibratedBinaryTrainer.Options -&gt; Microsoft.ML.Trainers.SdcaNonCalibratedBinaryTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.SdcaNonCalibrated (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.SdcaNonCalibratedBinaryTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.SdcaNonCalibratedBinaryTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="options">Trainer options.</param>
          <summary>
            Predict a target using a linear classification model trained with <see cref="T:Microsoft.ML.Trainers.SdcaNonCalibratedBinaryTrainer" /> and advanced options.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.SdcaNonCalibrated(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.SdcaNonCalibratedBinaryTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="SdcaNonCalibrated">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.SdcaNonCalibratedBinaryTrainer SdcaNonCalibrated (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, string exampleWeightColumnName = null, Microsoft.ML.Trainers.ISupportSdcaClassificationLoss lossFunction = null, Nullable&lt;float&gt; l2Regularization = null, Nullable&lt;float&gt; l1Regularization = null, Nullable&lt;int&gt; maximumNumberOfIterations = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.SdcaNonCalibratedBinaryTrainer SdcaNonCalibrated(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, string labelColumnName, string featureColumnName, string exampleWeightColumnName, class Microsoft.ML.Trainers.ISupportSdcaClassificationLoss lossFunction, valuetype System.Nullable`1&lt;float32&gt; l2Regularization, valuetype System.Nullable`1&lt;float32&gt; l1Regularization, valuetype System.Nullable`1&lt;int32&gt; maximumNumberOfIterations) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.SdcaNonCalibrated(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,System.String,Microsoft.ML.Trainers.ISupportSdcaClassificationLoss,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SdcaNonCalibrated (catalog As BinaryClassificationCatalog.BinaryClassificationTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional exampleWeightColumnName As String = null, Optional lossFunction As ISupportSdcaClassificationLoss = null, Optional l2Regularization As Nullable(Of Single) = null, Optional l1Regularization As Nullable(Of Single) = null, Optional maximumNumberOfIterations As Nullable(Of Integer) = null) As SdcaNonCalibratedBinaryTrainer" />
        <MemberSignature Language="F#" Value="static member SdcaNonCalibrated : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * string * string * string * Microsoft.ML.Trainers.ISupportSdcaClassificationLoss * Nullable&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;int&gt; -&gt; Microsoft.ML.Trainers.SdcaNonCalibratedBinaryTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.SdcaNonCalibrated (catalog, labelColumnName, featureColumnName, exampleWeightColumnName, lossFunction, l2Regularization, l1Regularization, maximumNumberOfIterations)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.SdcaNonCalibratedBinaryTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="lossFunction" Type="Microsoft.ML.Trainers.ISupportSdcaClassificationLoss" />
          <Parameter Name="l2Regularization" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="l1Regularization" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="maximumNumberOfIterations" Type="System.Nullable&lt;System.Int32&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="lossFunction">The <a href="tmpurl_loss">loss</a> function minimized in the training process. Defaults to <see cref="T:Microsoft.ML.Trainers.LogLoss" /> if not specified.</param>
          <param name="l2Regularization">The L2 weight for <a href="tmpurl_regularization">regularization</a>.</param>
          <param name="l1Regularization">The L1 <a href="tmpurl_regularization">regularization</a> hyperparameter. Higher values will tend to lead to more sparse model.</param>
          <param name="maximumNumberOfIterations">The maximum number of passes to perform over the data.</param>
          <summary>
            Predict a target using a linear classification model trained with <see cref="T:Microsoft.ML.Trainers.SdcaNonCalibratedBinaryTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.SdcaNonCalibrated(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,System.String,Microsoft.ML.Trainers.ISupportSdcaClassificationLoss,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="SdcaNonCalibrated">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.SdcaNonCalibratedMulticlassTrainer SdcaNonCalibrated (this Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers catalog, Microsoft.ML.Trainers.SdcaNonCalibratedMulticlassTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.SdcaNonCalibratedMulticlassTrainer SdcaNonCalibrated(class Microsoft.ML.MulticlassClassificationCatalog/MulticlassClassificationTrainers catalog, class Microsoft.ML.Trainers.SdcaNonCalibratedMulticlassTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.SdcaNonCalibrated(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.Trainers.SdcaNonCalibratedMulticlassTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member SdcaNonCalibrated : Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers * Microsoft.ML.Trainers.SdcaNonCalibratedMulticlassTrainer.Options -&gt; Microsoft.ML.Trainers.SdcaNonCalibratedMulticlassTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.SdcaNonCalibrated (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.SdcaNonCalibratedMulticlassTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.MulticlassClassificationCatalog+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.SdcaNonCalibratedMulticlassTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The multiclass classification catalog trainer object.</param>
          <param name="options">Trainer options.</param>
          <summary>
            Predict a target using linear multiclass classification model trained with <see cref="T:Microsoft.ML.Trainers.SdcaNonCalibratedMulticlassTrainer" /> and advanced options.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.SdcaNonCalibrated(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.Trainers.SdcaNonCalibratedMulticlassTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="SdcaNonCalibrated">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.SdcaNonCalibratedMulticlassTrainer SdcaNonCalibrated (this Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, string exampleWeightColumnName = null, Microsoft.ML.Trainers.ISupportSdcaClassificationLoss lossFunction = null, Nullable&lt;float&gt; l2Regularization = null, Nullable&lt;float&gt; l1Regularization = null, Nullable&lt;int&gt; maximumNumberOfIterations = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.SdcaNonCalibratedMulticlassTrainer SdcaNonCalibrated(class Microsoft.ML.MulticlassClassificationCatalog/MulticlassClassificationTrainers catalog, string labelColumnName, string featureColumnName, string exampleWeightColumnName, class Microsoft.ML.Trainers.ISupportSdcaClassificationLoss lossFunction, valuetype System.Nullable`1&lt;float32&gt; l2Regularization, valuetype System.Nullable`1&lt;float32&gt; l1Regularization, valuetype System.Nullable`1&lt;int32&gt; maximumNumberOfIterations) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.SdcaNonCalibrated(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,System.String,System.String,System.String,Microsoft.ML.Trainers.ISupportSdcaClassificationLoss,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SdcaNonCalibrated (catalog As MulticlassClassificationCatalog.MulticlassClassificationTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional exampleWeightColumnName As String = null, Optional lossFunction As ISupportSdcaClassificationLoss = null, Optional l2Regularization As Nullable(Of Single) = null, Optional l1Regularization As Nullable(Of Single) = null, Optional maximumNumberOfIterations As Nullable(Of Integer) = null) As SdcaNonCalibratedMulticlassTrainer" />
        <MemberSignature Language="F#" Value="static member SdcaNonCalibrated : Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers * string * string * string * Microsoft.ML.Trainers.ISupportSdcaClassificationLoss * Nullable&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;int&gt; -&gt; Microsoft.ML.Trainers.SdcaNonCalibratedMulticlassTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.SdcaNonCalibrated (catalog, labelColumnName, featureColumnName, exampleWeightColumnName, lossFunction, l2Regularization, l1Regularization, maximumNumberOfIterations)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.SdcaNonCalibratedMulticlassTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.MulticlassClassificationCatalog+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="lossFunction" Type="Microsoft.ML.Trainers.ISupportSdcaClassificationLoss" />
          <Parameter Name="l2Regularization" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="l1Regularization" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="maximumNumberOfIterations" Type="System.Nullable&lt;System.Int32&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The multiclass classification catalog trainer object.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="lossFunction">The <a href="tmpurl_loss">loss</a> function to be minimized. Defaults to <see cref="T:Microsoft.ML.Trainers.LogLoss" /> if not specified.</param>
          <param name="l2Regularization">The L2 weight for <a href="tmpurl_regularization">regularization</a>.</param>
          <param name="l1Regularization">The L1 <a href="tmpurl_regularization">regularization</a> hyperparameter. Higher values will tend to lead to more sparse model.</param>
          <param name="maximumNumberOfIterations">The maximum number of passes to perform over the data.</param>
          <summary>
            Predict a target using a linear multiclass classification model trained with <see cref="T:Microsoft.ML.Trainers.SdcaNonCalibratedMulticlassTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.SdcaNonCalibrated(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,System.String,System.String,System.String,Microsoft.ML.Trainers.ISupportSdcaClassificationLoss,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="SgdCalibrated">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.SgdCalibratedTrainer SgdCalibrated (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.Trainers.SgdCalibratedTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.SgdCalibratedTrainer SgdCalibrated(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.Trainers.SgdCalibratedTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.SgdCalibrated(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.SgdCalibratedTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member SgdCalibrated : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.Trainers.SgdCalibratedTrainer.Options -&gt; Microsoft.ML.Trainers.SgdCalibratedTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.SgdCalibrated (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.SgdCalibratedTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.SgdCalibratedTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="options">Trainer options.</param>
          <summary>
            Predict a target using a linear classification model trained with <see cref="T:Microsoft.ML.Trainers.SgdCalibratedTrainer" /> and advanced options.
            Stochastic gradient descent (SGD) is an iterative algorithm that optimizes a differentiable objective function.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.SgdCalibrated(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.SgdCalibratedTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="SgdCalibrated">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.SgdCalibratedTrainer SgdCalibrated (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, string exampleWeightColumnName = null, int numberOfIterations = 20, double learningRate = 0.01, float l2Regularization = 1E-06);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.SgdCalibratedTrainer SgdCalibrated(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, string labelColumnName, string featureColumnName, string exampleWeightColumnName, int32 numberOfIterations, float64 learningRate, float32 l2Regularization) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.SgdCalibrated(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,System.String,System.Int32,System.Double,System.Single)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SgdCalibrated (catalog As BinaryClassificationCatalog.BinaryClassificationTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional exampleWeightColumnName As String = null, Optional numberOfIterations As Integer = 20, Optional learningRate As Double = 0.01, Optional l2Regularization As Single = 1E-06) As SgdCalibratedTrainer" />
        <MemberSignature Language="F#" Value="static member SgdCalibrated : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * string * string * string * int * double * single -&gt; Microsoft.ML.Trainers.SgdCalibratedTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.SgdCalibrated (catalog, labelColumnName, featureColumnName, exampleWeightColumnName, numberOfIterations, learningRate, l2Regularization)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.SgdCalibratedTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="numberOfIterations" Type="System.Int32" />
          <Parameter Name="learningRate" Type="System.Double" />
          <Parameter Name="l2Regularization" Type="System.Single" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="labelColumnName">The name of the label column, or dependent variable.</param>
          <param name="featureColumnName">The features, or independent variables.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="numberOfIterations">The maximum number of passes through the training dataset; set to 1 to simulate online learning.</param>
          <param name="learningRate">The initial <a href="tmpurl_lr">learning rate</a> used by SGD.</param>
          <param name="l2Regularization">The L2 weight for <a href="tmpurl_regularization">regularization</a>.</param>
          <summary>
            Predict a target using a linear classification model trained with <see cref="T:Microsoft.ML.Trainers.SgdCalibratedTrainer" />.
            Stochastic gradient descent (SGD) is an iterative algorithm that optimizes a differentiable objective function.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.SgdCalibrated(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,System.String,System.Int32,System.Double,System.Single)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="SgdNonCalibrated">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.SgdNonCalibratedTrainer SgdNonCalibrated (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.Trainers.SgdNonCalibratedTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.SgdNonCalibratedTrainer SgdNonCalibrated(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.Trainers.SgdNonCalibratedTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.SgdNonCalibrated(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.SgdNonCalibratedTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member SgdNonCalibrated : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.Trainers.SgdNonCalibratedTrainer.Options -&gt; Microsoft.ML.Trainers.SgdNonCalibratedTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.SgdNonCalibrated (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.SgdNonCalibratedTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.SgdNonCalibratedTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="options">Trainer options.</param>
          <summary>
            Predict a target using a linear classification model trained with <see cref="T:Microsoft.ML.Trainers.SgdNonCalibratedTrainer" /> and advanced options.
            Stochastic gradient descent (SGD) is an iterative algorithm that optimizes a differentiable objective function.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.SgdNonCalibrated(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.SgdNonCalibratedTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="SgdNonCalibrated">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.SgdNonCalibratedTrainer SgdNonCalibrated (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, string exampleWeightColumnName = null, Microsoft.ML.Trainers.IClassificationLoss lossFunction = null, int numberOfIterations = 20, double learningRate = 0.01, float l2Regularization = 1E-06);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.SgdNonCalibratedTrainer SgdNonCalibrated(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, string labelColumnName, string featureColumnName, string exampleWeightColumnName, class Microsoft.ML.Trainers.IClassificationLoss lossFunction, int32 numberOfIterations, float64 learningRate, float32 l2Regularization) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardTrainersCatalog.SgdNonCalibrated(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,System.String,Microsoft.ML.Trainers.IClassificationLoss,System.Int32,System.Double,System.Single)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SgdNonCalibrated (catalog As BinaryClassificationCatalog.BinaryClassificationTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional exampleWeightColumnName As String = null, Optional lossFunction As IClassificationLoss = null, Optional numberOfIterations As Integer = 20, Optional learningRate As Double = 0.01, Optional l2Regularization As Single = 1E-06) As SgdNonCalibratedTrainer" />
        <MemberSignature Language="F#" Value="static member SgdNonCalibrated : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * string * string * string * Microsoft.ML.Trainers.IClassificationLoss * int * double * single -&gt; Microsoft.ML.Trainers.SgdNonCalibratedTrainer" Usage="Microsoft.ML.StandardTrainersCatalog.SgdNonCalibrated (catalog, labelColumnName, featureColumnName, exampleWeightColumnName, lossFunction, numberOfIterations, learningRate, l2Regularization)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.SgdNonCalibratedTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="lossFunction" Type="Microsoft.ML.Trainers.IClassificationLoss" />
          <Parameter Name="numberOfIterations" Type="System.Int32" />
          <Parameter Name="learningRate" Type="System.Double" />
          <Parameter Name="l2Regularization" Type="System.Single" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="labelColumnName">The name of the label column, or dependent variable.</param>
          <param name="featureColumnName">The features, or independent variables.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="lossFunction">The <a href="tmpurl_loss">loss</a> function minimized in the training process. Using, for example, <see cref="T:Microsoft.ML.Trainers.HingeLoss" /> leads to a support vector machine trainer.</param>
          <param name="numberOfIterations">The maximum number of passes through the training dataset; set to 1 to simulate online learning.</param>
          <param name="learningRate">The initial <a href="tmpurl_lr">learning rate</a> used by SGD.</param>
          <param name="l2Regularization">The L2 weight for <a href="tmpurl_regularization">regularization</a>.</param>
          <summary>
            Predict a target using a linear classification model trained with <see cref="T:Microsoft.ML.Trainers.SgdNonCalibratedTrainer" />.
            Stochastic gradient descent (SGD) is an iterative algorithm that optimizes a differentiable objective function.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardTrainersCatalog" Member="M:Microsoft.ML.StandardTrainersCatalog.SgdNonCalibrated(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,System.String,Microsoft.ML.Trainers.IClassificationLoss,System.Int32,System.Double,System.Single)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ApproximatedKernelMap">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ApproximatedKernelMap (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, int rank = 1000, bool useCosAndSinBases = false, Microsoft.ML.Transforms.KernelBase generator = null, Nullable&lt;int&gt; seed = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ApproximatedKernelMap(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, int32 rank, bool useCosAndSinBases, class Microsoft.ML.Transforms.KernelBase generator, valuetype System.Nullable`1&lt;int32&gt; seed) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ApproximatedKernelMappingStaticExtenensions.ApproximatedKernelMap(Microsoft.ML.StaticPipe.Vector{System.Single},System.Int32,System.Boolean,Microsoft.ML.Transforms.KernelBase,System.Nullable{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ApproximatedKernelMap (input As Vector(Of Single), Optional rank As Integer = 1000, Optional useCosAndSinBases As Boolean = false, Optional generator As KernelBase = null, Optional seed As Nullable(Of Integer) = null) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ApproximatedKernelMap : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * int * bool * Microsoft.ML.Transforms.KernelBase * Nullable&lt;int&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ApproximatedKernelMappingStaticExtenensions.ApproximatedKernelMap (input, rank, useCosAndSinBases, generator, seed)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="rank" Type="System.Int32" />
          <Parameter Name="useCosAndSinBases" Type="System.Boolean" />
          <Parameter Name="generator" Type="Microsoft.ML.Transforms.KernelBase" />
          <Parameter Name="seed" Type="System.Nullable&lt;System.Int32&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply Random Fourier transfomration.</param>
          <param name="rank">The number of random Fourier features to create.</param>
          <param name="useCosAndSinBases">If <see langword="true" />, use both of cos and sin basis functions to create two features for every random Fourier frequency.
            Otherwise, only cos bases would be used.</param>
          <param name="generator">Which kernel to use. (if it is null, <see cref="T:Microsoft.ML.Transforms.GaussianKernel" /> is used.)</param>
          <param name="seed">The seed of the random number generator for generating the new features. If not specified global random would be used.</param>
          <summary>
            It maps input to a random low-dimensional feature space. It is useful when data has non-linear features, since the transform
            is designed so that the inner products of the transformed data are approximately equal to those in the feature space of a user
            speciﬁed shift-invariant kernel. With this transform, we are able to use linear methods (which are scalable) to approximate more complex kernel SVM models.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ApproximatedKernelMappingStaticExtenensions" Member="M:Microsoft.ML.StaticPipe.ApproximatedKernelMappingStaticExtenensions.ApproximatedKernelMap(Microsoft.ML.StaticPipe.Vector{System.Single},System.Int32,System.Boolean,Microsoft.ML.Transforms.KernelBase,System.Nullable{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="AveragedPerceptron">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; AveragedPerceptron (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights, Microsoft.ML.Trainers.IClassificationLoss lossFunction, Microsoft.ML.Trainers.AveragedPerceptronTrainer.Options options, Action&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; AveragedPerceptron(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, class Microsoft.ML.Trainers.IClassificationLoss lossFunction, class Microsoft.ML.Trainers.AveragedPerceptronTrainer/Options options, class System.Action`1&lt;class Microsoft.ML.Trainers.LinearBinaryModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.AveragedPerceptronStaticExtensions.AveragedPerceptron(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.IClassificationLoss,Microsoft.ML.Trainers.AveragedPerceptronTrainer.Options,System.Action{Microsoft.ML.Trainers.LinearBinaryModelParameters})" />
        <MemberSignature Language="F#" Value="static member AveragedPerceptron : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.Trainers.IClassificationLoss * Microsoft.ML.Trainers.AveragedPerceptronTrainer.Options * Action&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.AveragedPerceptronStaticExtensions.AveragedPerceptron (catalog, label, features, weights, lossFunction, options, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="lossFunction" Type="Microsoft.ML.Trainers.IClassificationLoss" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.AveragedPerceptronTrainer+Options" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="lossFunction">The custom loss.</param>
          <param name="options">Advanced arguments to the algorithm.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained, as well as the calibrator on top of that model. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear binary classification model trained with the AveragedPerceptron trainer, and a custom loss.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.AveragedPerceptronStaticExtensions" Member="M:Microsoft.ML.StaticPipe.AveragedPerceptronStaticExtensions.AveragedPerceptron(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.IClassificationLoss,Microsoft.ML.Trainers.AveragedPerceptronTrainer.Options,System.Action{Microsoft.ML.Trainers.LinearBinaryModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="AveragedPerceptron">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; AveragedPerceptron (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, Microsoft.ML.Trainers.IClassificationLoss lossFunction = null, float learningRate = 1, bool decreaseLearningRate = false, float l2Regularization = 0, int numIterations = 1, Action&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; AveragedPerceptron(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, class Microsoft.ML.Trainers.IClassificationLoss lossFunction, float32 learningRate, bool decreaseLearningRate, float32 l2Regularization, int32 numIterations, class System.Action`1&lt;class Microsoft.ML.Trainers.LinearBinaryModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.AveragedPerceptronStaticExtensions.AveragedPerceptron(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.IClassificationLoss,System.Single,System.Boolean,System.Single,System.Int32,System.Action{Microsoft.ML.Trainers.LinearBinaryModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AveragedPerceptron (catalog As BinaryClassificationCatalog.BinaryClassificationTrainers, label As Scalar(Of Boolean), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional lossFunction As IClassificationLoss = null, Optional learningRate As Single = 1, Optional decreaseLearningRate As Boolean = false, Optional l2Regularization As Single = 0, Optional numIterations As Integer = 1, Optional onFit As Action(Of LinearBinaryModelParameters) = null) As ValueTuple(Of Scalar(Of Single), Scalar(Of Boolean))" />
        <MemberSignature Language="F#" Value="static member AveragedPerceptron : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.Trainers.IClassificationLoss * single * bool * single * int * Action&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.AveragedPerceptronStaticExtensions.AveragedPerceptron (catalog, label, features, weights, lossFunction, learningRate, decreaseLearningRate, l2Regularization, numIterations, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="lossFunction" Type="Microsoft.ML.Trainers.IClassificationLoss" />
          <Parameter Name="learningRate" Type="System.Single" />
          <Parameter Name="decreaseLearningRate" Type="System.Boolean" />
          <Parameter Name="l2Regularization" Type="System.Single" />
          <Parameter Name="numIterations" Type="System.Int32" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="lossFunction">The custom loss.</param>
          <param name="learningRate">The learning Rate.</param>
          <param name="decreaseLearningRate">Decrease learning rate as iterations progress.</param>
          <param name="l2Regularization">L2 regularization weight.</param>
          <param name="numIterations">Number of training iterations through the data.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained, as well as the calibrator on top of that model. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear binary classification model trained with the AveragedPerceptron trainer, and a custom loss.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.AveragedPerceptronStaticExtensions" Member="M:Microsoft.ML.StaticPipe.AveragedPerceptronStaticExtensions.AveragedPerceptron(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.IClassificationLoss,System.Single,System.Boolean,System.Single,System.Int32,System.Action{Microsoft.ML.Trainers.LinearBinaryModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="OneHotHashEncoding">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; OneHotHashEncoding (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashScalarOutputKind outputKind = (Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions+OneHotHashScalarOutputKind) 1, int numberOfBits = 16, uint seed = 314489979, bool ordered = true, int maximumNumberOfInverts = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; OneHotHashEncoding(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, valuetype Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions/OneHotHashScalarOutputKind outputKind, int32 numberOfBits, unsigned int32 seed, bool ordered, int32 maximumNumberOfInverts) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashEncoding(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashScalarOutputKind,System.Int32,System.UInt32,System.Boolean,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OneHotHashEncoding (input As Scalar(Of String), Optional outputKind As CategoricalHashStaticExtensions.OneHotHashScalarOutputKind = (Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions+OneHotHashScalarOutputKind) 1, Optional numberOfBits As Integer = 16, Optional seed As UInteger = 314489979, Optional ordered As Boolean = true, Optional maximumNumberOfInverts As Integer = 0) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member OneHotHashEncoding : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashScalarOutputKind * int * uint32 * bool * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashEncoding (input, outputKind, numberOfBits, seed, ordered, maximumNumberOfInverts)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="outputKind" Type="Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions+OneHotHashScalarOutputKind" />
          <Parameter Name="numberOfBits" Type="System.Int32" />
          <Parameter Name="seed" Type="System.UInt32" />
          <Parameter Name="ordered" Type="System.Boolean" />
          <Parameter Name="maximumNumberOfInverts" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="outputKind">Specify the output type of indicator array: array or binary encoded data.</param>
          <param name="numberOfBits">Amount of bits to use for hashing.</param>
          <param name="seed">Seed value used for hashing.</param>
          <param name="ordered">Whether the position of each term should be included in the hash.</param>
          <param name="maximumNumberOfInverts">During hashing we constuct mappings between original values and the produced hash values.
            Text representation of original values are stored in the slot names of the  metadata for the new column.Hashing, as such, can map many initial values to one.
            <paramref name="maximumNumberOfInverts" /> specifies the upper bound of the number of distinct input values mapping to a hash that should be retained.
            <value>0</value> does not retain any input values. <value>-1</value> retains all input values mapping to each hash.</param>
          <summary>
            Converts the categorical value into an indicator array by hashing categories into certain value and using that value as the index in the array.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions" Member="M:Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashEncoding(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashScalarOutputKind,System.Int32,System.UInt32,System.Boolean,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="OneHotHashEncoding">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; OneHotHashEncoding (this Microsoft.ML.StaticPipe.VarVector&lt;string&gt; input, Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashVectorOutputKind outputKind = Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions+OneHotHashVectorOutputKind.Bag, int numberOfBits = 16, uint seed = 314489979, bool ordered = true, int maximumNumberOfInverts = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; OneHotHashEncoding(class Microsoft.ML.StaticPipe.VarVector`1&lt;string&gt; input, valuetype Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions/OneHotHashVectorOutputKind outputKind, int32 numberOfBits, unsigned int32 seed, bool ordered, int32 maximumNumberOfInverts) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashEncoding(Microsoft.ML.StaticPipe.VarVector{System.String},Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashVectorOutputKind,System.Int32,System.UInt32,System.Boolean,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OneHotHashEncoding (input As VarVector(Of String), Optional outputKind As CategoricalHashStaticExtensions.OneHotHashVectorOutputKind = Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions+OneHotHashVectorOutputKind.Bag, Optional numberOfBits As Integer = 16, Optional seed As UInteger = 314489979, Optional ordered As Boolean = true, Optional maximumNumberOfInverts As Integer = 0) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member OneHotHashEncoding : Microsoft.ML.StaticPipe.VarVector&lt;string&gt; * Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashVectorOutputKind * int * uint32 * bool * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashEncoding (input, outputKind, numberOfBits, seed, ordered, maximumNumberOfInverts)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.String&gt;" RefType="this" />
          <Parameter Name="outputKind" Type="Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions+OneHotHashVectorOutputKind" />
          <Parameter Name="numberOfBits" Type="System.Int32" />
          <Parameter Name="seed" Type="System.UInt32" />
          <Parameter Name="ordered" Type="System.Boolean" />
          <Parameter Name="maximumNumberOfInverts" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="outputKind">Specify the output type of indicator array: array or binary encoded data.</param>
          <param name="numberOfBits">Amount of bits to use for hashing.</param>
          <param name="seed">Seed value used for hashing.</param>
          <param name="ordered">Whether the position of each term should be included in the hash.</param>
          <param name="maximumNumberOfInverts">During hashing we constuct mappings between original values and the produced hash values.
            Text representation of original values are stored in the slot names of the  metadata for the new column.Hashing, as such, can map many initial values to one.
            <paramref name="maximumNumberOfInverts" /> specifies the upper bound of the number of distinct input values mapping to a hash that should be retained.
            <value>0</value> does not retain any input values. <value>-1</value> retains all input values mapping to each hash.</param>
          <summary>
            Converts the categorical value into an indicator array by building a dictionary of categories based on the data and using the id in the dictionary as the index in the array
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions" Member="M:Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashEncoding(Microsoft.ML.StaticPipe.VarVector{System.String},Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashVectorOutputKind,System.Int32,System.UInt32,System.Boolean,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="OneHotHashEncoding">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; OneHotHashEncoding (this Microsoft.ML.StaticPipe.Vector&lt;string&gt; input, Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashVectorOutputKind outputKind = Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions+OneHotHashVectorOutputKind.Bag, int numberOfBits = 16, uint seed = 314489979, bool ordered = true, int maximumNumberOfInverts = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; OneHotHashEncoding(class Microsoft.ML.StaticPipe.Vector`1&lt;string&gt; input, valuetype Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions/OneHotHashVectorOutputKind outputKind, int32 numberOfBits, unsigned int32 seed, bool ordered, int32 maximumNumberOfInverts) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashEncoding(Microsoft.ML.StaticPipe.Vector{System.String},Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashVectorOutputKind,System.Int32,System.UInt32,System.Boolean,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OneHotHashEncoding (input As Vector(Of String), Optional outputKind As CategoricalHashStaticExtensions.OneHotHashVectorOutputKind = Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions+OneHotHashVectorOutputKind.Bag, Optional numberOfBits As Integer = 16, Optional seed As UInteger = 314489979, Optional ordered As Boolean = true, Optional maximumNumberOfInverts As Integer = 0) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member OneHotHashEncoding : Microsoft.ML.StaticPipe.Vector&lt;string&gt; * Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashVectorOutputKind * int * uint32 * bool * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashEncoding (input, outputKind, numberOfBits, seed, ordered, maximumNumberOfInverts)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.String&gt;" RefType="this" />
          <Parameter Name="outputKind" Type="Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions+OneHotHashVectorOutputKind" />
          <Parameter Name="numberOfBits" Type="System.Int32" />
          <Parameter Name="seed" Type="System.UInt32" />
          <Parameter Name="ordered" Type="System.Boolean" />
          <Parameter Name="maximumNumberOfInverts" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="outputKind">Specify the output type of indicator array: array or binary encoded data.</param>
          <param name="numberOfBits">Amount of bits to use for hashing.</param>
          <param name="seed">Seed value used for hashing.</param>
          <param name="ordered">Whether the position of each term should be included in the hash.</param>
          <param name="maximumNumberOfInverts">During hashing we constuct mappings between original values and the produced hash values.
            Text representation of original values are stored in the slot names of the  metadata for the new column.Hashing, as such, can map many initial values to one.
            <paramref name="maximumNumberOfInverts" /> specifies the upper bound of the number of distinct input values mapping to a hash that should be retained.
            <value>0</value> does not retain any input values. <value>-1</value> retains all input values mapping to each hash.</param>
          <summary>
            Converts the categorical value into an indicator array by building a dictionary of categories based on the data and using the id in the dictionary as the index in the array
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions" Member="M:Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashEncoding(Microsoft.ML.StaticPipe.Vector{System.String},Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashVectorOutputKind,System.Int32,System.UInt32,System.Boolean,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="OneHotEncoding">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; OneHotEncoding (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotScalarOutputKind outputKind = Microsoft.ML.StaticPipe.CategoricalStaticExtensions+OneHotScalarOutputKind.Ind, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maximumNumberOfItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; OneHotEncoding(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, valuetype Microsoft.ML.StaticPipe.CategoricalStaticExtensions/OneHotScalarOutputKind outputKind, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maximumNumberOfItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotEncoding(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotScalarOutputKind,Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.ReadOnlyMemory{System.Char}})" />
        <MemberSignature Language="F#" Value="static member OneHotEncoding : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotScalarOutputKind * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotEncoding (input, outputKind, keyOrdinality, maximumNumberOfItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="outputKind" Type="Microsoft.ML.StaticPipe.CategoricalStaticExtensions+OneHotScalarOutputKind" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maximumNumberOfItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="outputKind">Specify the output type of indicator array: array or binary encoded data.</param>
          <param name="keyOrdinality">How the Id for each value would be assigined: by occurrence or by value.</param>
          <param name="maximumNumberOfItems">Maximum number of ids to keep during data scanning.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Converts the categorical value into an indicator array by building a dictionary of categories based on the data and using the id in the dictionary as the index in the array.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.CategoricalStaticExtensions" Member="M:Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotEncoding(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotScalarOutputKind,Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="OneHotEncoding">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; OneHotEncoding (this Microsoft.ML.StaticPipe.Vector&lt;string&gt; input, Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotVectorOutputKind outputKind = Microsoft.ML.StaticPipe.CategoricalStaticExtensions+OneHotVectorOutputKind.Ind, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maximumNumberOfItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; OneHotEncoding(class Microsoft.ML.StaticPipe.Vector`1&lt;string&gt; input, valuetype Microsoft.ML.StaticPipe.CategoricalStaticExtensions/OneHotVectorOutputKind outputKind, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maximumNumberOfItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotEncoding(Microsoft.ML.StaticPipe.Vector{System.String},Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotVectorOutputKind,Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.ReadOnlyMemory{System.Char}})" />
        <MemberSignature Language="F#" Value="static member OneHotEncoding : Microsoft.ML.StaticPipe.Vector&lt;string&gt; * Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotVectorOutputKind * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotEncoding (input, outputKind, keyOrdinality, maximumNumberOfItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.String&gt;" RefType="this" />
          <Parameter Name="outputKind" Type="Microsoft.ML.StaticPipe.CategoricalStaticExtensions+OneHotVectorOutputKind" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maximumNumberOfItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="outputKind">Specify the output type of indicator array: Multiarray, array or binary encoded data.</param>
          <param name="keyOrdinality">How the Id for each value would be assigined: by occurrence or by value.</param>
          <param name="maximumNumberOfItems">Maximum number of ids to keep during data scanning.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Converts the categorical value into an indicator array by building a dictionary of categories based on the data and using the id in the dictionary as the index in the array.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.CategoricalStaticExtensions" Member="M:Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotEncoding(Microsoft.ML.StaticPipe.Vector{System.String},Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotVectorOutputKind,Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="TokenizeIntoCharactersAsKeys">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;ushort,string&gt;&gt; TokenizeIntoCharactersAsKeys (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, bool useMarkerCharacters = true);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int16, string&gt;&gt; TokenizeIntoCharactersAsKeys(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, bool useMarkerCharacters) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.CharacterTokenizerStaticExtensions.TokenizeIntoCharactersAsKeys(Microsoft.ML.StaticPipe.Scalar{System.String},System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TokenizeIntoCharactersAsKeys (input As Scalar(Of String), Optional useMarkerCharacters As Boolean = true) As VarVector(Of Key(Of UShort, String))" />
        <MemberSignature Language="F#" Value="static member TokenizeIntoCharactersAsKeys : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * bool -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint16, string&gt;&gt;" Usage="Microsoft.ML.StaticPipe.CharacterTokenizerStaticExtensions.TokenizeIntoCharactersAsKeys (input, useMarkerCharacters)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt16,System.String&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="useMarkerCharacters" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="useMarkerCharacters">Whether to use marker characters to separate words.</param>
          <summary>
            Tokenize incoming text into a sequence of characters.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.CharacterTokenizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.CharacterTokenizerStaticExtensions.TokenizeIntoCharactersAsKeys(Microsoft.ML.StaticPipe.Scalar{System.String},System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="AsVector&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;T&gt; AsVector&lt;T&gt; (this Microsoft.ML.StaticPipe.Scalar&lt;T&gt; me);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;!!T&gt; AsVector&lt;T&gt;(class Microsoft.ML.StaticPipe.Scalar`1&lt;!!T&gt; me) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.AsVector``1(Microsoft.ML.StaticPipe.Scalar{``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsVector(Of T) (me As Scalar(Of T)) As Vector(Of T)" />
        <MemberSignature Language="F#" Value="static member AsVector : Microsoft.ML.StaticPipe.Scalar&lt;'T&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;'T&gt;" Usage="Microsoft.ML.StaticPipe.ConcatStaticExtensions.AsVector me" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="me" Type="Microsoft.ML.StaticPipe.Scalar&lt;T&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="T">The value type.</typeparam>
          <param name="me">The scalar column.</param>
          <summary>
            Given a scalar vector, produce a vector of length one.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConcatStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.AsVector``1(Microsoft.ML.StaticPipe.Scalar{``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.NormVector`1" />
      </Targets>
      <Member MemberName="ConcatWith&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;T&gt; ConcatWith&lt;T&gt; (this Microsoft.ML.StaticPipe.NormVector&lt;T&gt; me, params Microsoft.ML.StaticPipe.NormVector&lt;T&gt;[] others);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;!!T&gt; ConcatWith&lt;T&gt;(class Microsoft.ML.StaticPipe.NormVector`1&lt;!!T&gt; me, class Microsoft.ML.StaticPipe.NormVector`1&lt;!!T&gt;[] others) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.NormVector{``0},Microsoft.ML.StaticPipe.NormVector{``0}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConcatWith(Of T) (me As NormVector(Of T), ParamArray others As NormVector(Of T)()) As NormVector(Of T)" />
        <MemberSignature Language="F#" Value="static member ConcatWith : Microsoft.ML.StaticPipe.NormVector&lt;'T&gt; * Microsoft.ML.StaticPipe.NormVector&lt;'T&gt;[] -&gt; Microsoft.ML.StaticPipe.NormVector&lt;'T&gt;" Usage="Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith (me, others)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="me" Type="Microsoft.ML.StaticPipe.NormVector&lt;T&gt;" RefType="this" />
          <Parameter Name="others" Type="Microsoft.ML.StaticPipe.NormVector&lt;T&gt;[]">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet-preview">
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">The value type.</typeparam>
          <param name="me">The first input column.</param>
          <param name="others">Subsequent input columns.</param>
          <summary>
            Given a bunch of normalized vectors, concatenate them together into a normalized vector.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConcatStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.NormVector{``0},Microsoft.ML.StaticPipe.NormVector{``0}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ConcatWith&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;T&gt; ConcatWith&lt;T&gt; (this Microsoft.ML.StaticPipe.Scalar&lt;T&gt; me, params Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVector&lt;T&gt;[] others);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;!!T&gt; ConcatWith&lt;T&gt;(class Microsoft.ML.StaticPipe.Scalar`1&lt;!!T&gt; me, class Microsoft.ML.StaticPipe.ConcatStaticExtensions/ScalarOrVector`1&lt;!!T&gt;[] others) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Scalar{``0},Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVector{``0}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConcatWith(Of T) (me As Scalar(Of T), ParamArray others As ConcatStaticExtensions.ScalarOrVector(Of T)()) As Vector(Of T)" />
        <MemberSignature Language="F#" Value="static member ConcatWith : Microsoft.ML.StaticPipe.Scalar&lt;'T&gt; * Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVector&lt;'T&gt;[] -&gt; Microsoft.ML.StaticPipe.Vector&lt;'T&gt;" Usage="Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith (me, others)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="me" Type="Microsoft.ML.StaticPipe.Scalar&lt;T&gt;" RefType="this" />
          <Parameter Name="others" Type="Microsoft.ML.StaticPipe.ConcatStaticExtensions+ScalarOrVector&lt;T&gt;[]">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet-preview">
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">The value type.</typeparam>
          <param name="me">The first input column.</param>
          <param name="others">Subsequent input columns.</param>
          <summary>
            Given a set of columns, concatenate them together into a vector valued column of the same type.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConcatStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Scalar{``0},Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVector{``0}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ConcatWith&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;T&gt; ConcatWith&lt;T&gt; (this Microsoft.ML.StaticPipe.Scalar&lt;T&gt; me, params Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVectorOrVarVector&lt;T&gt;[] others);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;!!T&gt; ConcatWith&lt;T&gt;(class Microsoft.ML.StaticPipe.Scalar`1&lt;!!T&gt; me, class Microsoft.ML.StaticPipe.ConcatStaticExtensions/ScalarOrVectorOrVarVector`1&lt;!!T&gt;[] others) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Scalar{``0},Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVectorOrVarVector{``0}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConcatWith(Of T) (me As Scalar(Of T), ParamArray others As ConcatStaticExtensions.ScalarOrVectorOrVarVector(Of T)()) As VarVector(Of T)" />
        <MemberSignature Language="F#" Value="static member ConcatWith : Microsoft.ML.StaticPipe.Scalar&lt;'T&gt; * Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVectorOrVarVector&lt;'T&gt;[] -&gt; Microsoft.ML.StaticPipe.VarVector&lt;'T&gt;" Usage="Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith (me, others)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="me" Type="Microsoft.ML.StaticPipe.Scalar&lt;T&gt;" RefType="this" />
          <Parameter Name="others" Type="Microsoft.ML.StaticPipe.ConcatStaticExtensions+ScalarOrVectorOrVarVector&lt;T&gt;[]">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet-preview">
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">The value type.</typeparam>
          <param name="me">The first input column.</param>
          <param name="others">Subsequent input columns.</param>
          <summary>
            Given a set of columns including at least one variable sized vector column, concatenate them
            together into a vector valued column of the same type.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConcatStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Scalar{``0},Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVectorOrVarVector{``0}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ConcatWith&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;T&gt; ConcatWith&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;T&gt; me, params Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVectorOrVarVector&lt;T&gt;[] others);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;!!T&gt; ConcatWith&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;!!T&gt; me, class Microsoft.ML.StaticPipe.ConcatStaticExtensions/ScalarOrVectorOrVarVector`1&lt;!!T&gt;[] others) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.VarVector{``0},Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVectorOrVarVector{``0}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConcatWith(Of T) (me As VarVector(Of T), ParamArray others As ConcatStaticExtensions.ScalarOrVectorOrVarVector(Of T)()) As VarVector(Of T)" />
        <MemberSignature Language="F#" Value="static member ConcatWith : Microsoft.ML.StaticPipe.VarVector&lt;'T&gt; * Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVectorOrVarVector&lt;'T&gt;[] -&gt; Microsoft.ML.StaticPipe.VarVector&lt;'T&gt;" Usage="Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith (me, others)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="me" Type="Microsoft.ML.StaticPipe.VarVector&lt;T&gt;" RefType="this" />
          <Parameter Name="others" Type="Microsoft.ML.StaticPipe.ConcatStaticExtensions+ScalarOrVectorOrVarVector&lt;T&gt;[]">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet-preview">
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">The value type.</typeparam>
          <param name="me">The first input column.</param>
          <param name="others">Subsequent input columns.</param>
          <summary>
            Given a set of columns including at least one variable sized vector column, concatenate them
            together into a vector valued column of the same type.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConcatStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.VarVector{``0},Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVectorOrVarVector{``0}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ConcatWith&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;T&gt; ConcatWith&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;T&gt; me, params Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVector&lt;T&gt;[] others);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;!!T&gt; ConcatWith&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;!!T&gt; me, class Microsoft.ML.StaticPipe.ConcatStaticExtensions/ScalarOrVector`1&lt;!!T&gt;[] others) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Vector{``0},Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVector{``0}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConcatWith(Of T) (me As Vector(Of T), ParamArray others As ConcatStaticExtensions.ScalarOrVector(Of T)()) As Vector(Of T)" />
        <MemberSignature Language="F#" Value="static member ConcatWith : Microsoft.ML.StaticPipe.Vector&lt;'T&gt; * Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVector&lt;'T&gt;[] -&gt; Microsoft.ML.StaticPipe.Vector&lt;'T&gt;" Usage="Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith (me, others)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="me" Type="Microsoft.ML.StaticPipe.Vector&lt;T&gt;" RefType="this" />
          <Parameter Name="others" Type="Microsoft.ML.StaticPipe.ConcatStaticExtensions+ScalarOrVector&lt;T&gt;[]">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet-preview">
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">The value type.</typeparam>
          <param name="me">The first input column.</param>
          <param name="others">Subsequent input columns.</param>
          <summary>
            Given a set of columns, concatenate them together into a vector valued column of the same type.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConcatStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Vector{``0},Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVector{``0}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ConcatWith&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;T&gt; ConcatWith&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;T&gt; me, params Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVectorOrVarVector&lt;T&gt;[] others);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;!!T&gt; ConcatWith&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;!!T&gt; me, class Microsoft.ML.StaticPipe.ConcatStaticExtensions/ScalarOrVectorOrVarVector`1&lt;!!T&gt;[] others) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Vector{``0},Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVectorOrVarVector{``0}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConcatWith(Of T) (me As Vector(Of T), ParamArray others As ConcatStaticExtensions.ScalarOrVectorOrVarVector(Of T)()) As VarVector(Of T)" />
        <MemberSignature Language="F#" Value="static member ConcatWith : Microsoft.ML.StaticPipe.Vector&lt;'T&gt; * Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVectorOrVarVector&lt;'T&gt;[] -&gt; Microsoft.ML.StaticPipe.VarVector&lt;'T&gt;" Usage="Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith (me, others)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="me" Type="Microsoft.ML.StaticPipe.Vector&lt;T&gt;" RefType="this" />
          <Parameter Name="others" Type="Microsoft.ML.StaticPipe.ConcatStaticExtensions+ScalarOrVectorOrVarVector&lt;T&gt;[]">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet-preview">
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">The value type.</typeparam>
          <param name="me">The first input column.</param>
          <param name="others">Subsequent input columns.</param>
          <summary>
            Given a set of columns including at least one variable sized vector column, concatenate them
            together into a vector valued column of the same type.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConcatStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Vector{``0},Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVectorOrVarVector{``0}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.Boolean})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Scalar(Of Boolean)) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to float.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.Boolean})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Scalar&lt;byte&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Scalar`1&lt;unsigned int8&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.Byte})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Scalar(Of Byte)) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Scalar&lt;byte&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Byte&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to float.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.Byte})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Scalar&lt;double&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Scalar`1&lt;float64&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.Double})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Scalar(Of Double)) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Scalar&lt;double&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Double&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to float.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.Double})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Scalar&lt;short&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Scalar`1&lt;int16&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.Int16})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Scalar(Of Short)) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Scalar&lt;int16&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Int16&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to float.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.Int16})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Scalar&lt;int&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Scalar`1&lt;int32&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Scalar(Of Integer)) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Scalar&lt;int&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Int32&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to float.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Scalar&lt;long&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Scalar`1&lt;int64&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.Int64})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Scalar(Of Long)) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Scalar&lt;int64&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Int64&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to float.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.Int64})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Scalar&lt;sbyte&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Scalar`1&lt;int8&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.SByte})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Scalar(Of SByte)) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Scalar&lt;sbyte&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.SByte&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to float.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.SByte})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.String})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Scalar(Of String)) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to float.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.String})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Scalar&lt;ushort&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Scalar`1&lt;unsigned int16&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.UInt16})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Scalar(Of UShort)) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Scalar&lt;uint16&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.UInt16&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to float.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.UInt16})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Scalar&lt;uint&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Scalar`1&lt;unsigned int32&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.UInt32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Scalar(Of UInteger)) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Scalar&lt;uint32&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.UInt32&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to float.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.UInt32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Scalar&lt;ulong&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Scalar`1&lt;unsigned int64&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.UInt64})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Scalar(Of ULong)) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Scalar&lt;uint64&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.UInt64&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to float.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.UInt64})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.VarVector&lt;bool&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.VarVector`1&lt;bool&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.Boolean})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As VarVector(Of Boolean)) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.VarVector&lt;bool&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Boolean&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to variable array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.Boolean})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.VarVector&lt;byte&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.VarVector`1&lt;unsigned int8&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.Byte})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As VarVector(Of Byte)) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.VarVector&lt;byte&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Byte&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to variable array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.Byte})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.VarVector&lt;double&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.VarVector`1&lt;float64&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.Double})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As VarVector(Of Double)) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.VarVector&lt;double&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Double&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to variable array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.Double})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.VarVector&lt;short&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.VarVector`1&lt;int16&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.Int16})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As VarVector(Of Short)) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.VarVector&lt;int16&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Int16&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to variable array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.Int16})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.VarVector&lt;int&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.VarVector`1&lt;int32&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As VarVector(Of Integer)) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.VarVector&lt;int&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Int32&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to variable array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.VarVector&lt;long&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.VarVector`1&lt;int64&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.Int64})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As VarVector(Of Long)) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.VarVector&lt;int64&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Int64&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to variable array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.Int64})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.VarVector&lt;sbyte&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.VarVector`1&lt;int8&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.SByte})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As VarVector(Of SByte)) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.VarVector&lt;sbyte&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.SByte&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to variable array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.SByte})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.VarVector&lt;string&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.VarVector`1&lt;string&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.String})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As VarVector(Of String)) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.VarVector&lt;string&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.String&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to variable array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.String})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.VarVector&lt;ushort&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.VarVector`1&lt;unsigned int16&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.UInt16})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As VarVector(Of UShort)) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.VarVector&lt;uint16&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.UInt16&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to variable array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.UInt16})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.VarVector&lt;uint&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.VarVector`1&lt;unsigned int32&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.UInt32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As VarVector(Of UInteger)) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.VarVector&lt;uint32&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.UInt32&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to variable array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.UInt32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.VarVector&lt;ulong&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.VarVector`1&lt;unsigned int64&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.UInt64})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As VarVector(Of ULong)) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.VarVector&lt;uint64&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.UInt64&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to variable array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.UInt64})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Vector&lt;bool&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Vector`1&lt;bool&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.Boolean})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Vector(Of Boolean)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Vector&lt;bool&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Boolean&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.Boolean})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Vector&lt;byte&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Vector`1&lt;unsigned int8&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.Byte})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Vector(Of Byte)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Vector&lt;byte&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Byte&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.Byte})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.Double})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Vector(Of Double)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Vector&lt;double&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.Double})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Vector&lt;short&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Vector`1&lt;int16&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.Int16})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Vector(Of Short)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Vector&lt;int16&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Int16&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.Int16})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Vector&lt;int&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Vector`1&lt;int32&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Vector(Of Integer)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Vector&lt;int&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Int32&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Vector&lt;long&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Vector`1&lt;int64&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.Int64})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Vector(Of Long)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Vector&lt;int64&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Int64&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.Int64})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Vector&lt;sbyte&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Vector`1&lt;int8&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.SByte})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Vector(Of SByte)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Vector&lt;sbyte&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.SByte&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.SByte})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Vector&lt;string&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Vector`1&lt;string&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.String})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Vector(Of String)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Vector&lt;string&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.String&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.String})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Vector&lt;ushort&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Vector`1&lt;unsigned int16&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.UInt16})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Vector(Of UShort)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Vector&lt;uint16&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.UInt16&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.UInt16})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Vector&lt;uint&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Vector`1&lt;unsigned int32&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.UInt32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Vector(Of UInteger)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Vector&lt;uint32&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.UInt32&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.UInt32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Vector&lt;ulong&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Vector`1&lt;unsigned int64&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.UInt64})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Vector(Of ULong)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Vector&lt;uint64&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.UInt64&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.UInt64})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnCount">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;double&gt; SelectFeaturesBasedOnCount (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, long count = 1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; SelectFeaturesBasedOnCount(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, int64 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.CountFeatureSelectorStaticExtensions.SelectFeaturesBasedOnCount(Microsoft.ML.StaticPipe.Vector{System.Double},System.Int64)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnCount (input As Vector(Of Double), Optional count As Long = 1) As Vector(Of Double)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnCount : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * int64 -&gt; Microsoft.ML.StaticPipe.Vector&lt;double&gt;" Usage="Microsoft.ML.StaticPipe.CountFeatureSelectorStaticExtensions.SelectFeaturesBasedOnCount (input, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="count" Type="System.Int64" />
        </Parameters>
        <Docs>
          <param name="input">Name of the input column.</param>
          <param name="count">If the count of non-default values for a slot is greater than or equal to this threshold, the slot is preserved.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.CountFeatureSelectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.CountFeatureSelectorStaticExtensions.SelectFeaturesBasedOnCount(Microsoft.ML.StaticPipe.Vector{System.Double},System.Int64)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnCount">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; SelectFeaturesBasedOnCount (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, long count = 1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; SelectFeaturesBasedOnCount(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, int64 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.CountFeatureSelectorStaticExtensions.SelectFeaturesBasedOnCount(Microsoft.ML.StaticPipe.Vector{System.Single},System.Int64)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnCount (input As Vector(Of Single), Optional count As Long = 1) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnCount : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * int64 -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.CountFeatureSelectorStaticExtensions.SelectFeaturesBasedOnCount (input, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="count" Type="System.Int64" />
        </Parameters>
        <Docs>
          <param name="input">Name of the input column.</param>
          <param name="count">If the count of non-default values for a slot is greater than or equal to this threshold, the slot is preserved.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.CountFeatureSelectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.CountFeatureSelectorStaticExtensions.SelectFeaturesBasedOnCount(Microsoft.ML.StaticPipe.Vector{System.Single},System.Int64)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnCount">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;string&gt; SelectFeaturesBasedOnCount (this Microsoft.ML.StaticPipe.Vector&lt;string&gt; input, long count = 1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;string&gt; SelectFeaturesBasedOnCount(class Microsoft.ML.StaticPipe.Vector`1&lt;string&gt; input, int64 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.CountFeatureSelectorStaticExtensions.SelectFeaturesBasedOnCount(Microsoft.ML.StaticPipe.Vector{System.String},System.Int64)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnCount (input As Vector(Of String), Optional count As Long = 1) As Vector(Of String)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnCount : Microsoft.ML.StaticPipe.Vector&lt;string&gt; * int64 -&gt; Microsoft.ML.StaticPipe.Vector&lt;string&gt;" Usage="Microsoft.ML.StaticPipe.CountFeatureSelectorStaticExtensions.SelectFeaturesBasedOnCount (input, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.String&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.String&gt;" RefType="this" />
          <Parameter Name="count" Type="System.Int64" />
        </Parameters>
        <Docs>
          <param name="input">Name of the input column.</param>
          <param name="count">If the count of non-default values for a slot is greater than or equal to this threshold, the slot is preserved.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.CountFeatureSelectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.CountFeatureSelectorStaticExtensions.SelectFeaturesBasedOnCount(Microsoft.ML.StaticPipe.Vector{System.String},System.Int64)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataOperationsCatalog" />
      </Targets>
      <Member MemberName="CreateTextLoader&lt;TShape&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.DataLoader&lt;Microsoft.ML.Data.IMultiStreamSource,TShape&gt; CreateTextLoader&lt;TShape&gt; (this Microsoft.ML.DataOperationsCatalog catalog, Func&lt;Microsoft.ML.StaticPipe.TextLoaderStatic.Context,TShape&gt; func, Microsoft.ML.Data.IMultiStreamSource files = null, bool hasHeader = false, char separator = '\t', bool allowQuoting = true, bool allowSparse = true, bool trimWhitspace = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.DataLoader`2&lt;class Microsoft.ML.Data.IMultiStreamSource, !!TShape&gt; CreateTextLoader&lt;TShape&gt;(class Microsoft.ML.DataOperationsCatalog catalog, class System.Func`2&lt;class Microsoft.ML.StaticPipe.TextLoaderStatic/Context, !!TShape&gt; func, class Microsoft.ML.Data.IMultiStreamSource files, bool hasHeader, char separator, bool allowQuoting, bool allowSparse, bool trimWhitspace) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.DataLoadSaveOperationsExtensions.CreateTextLoader``1(Microsoft.ML.DataOperationsCatalog,System.Func{Microsoft.ML.StaticPipe.TextLoaderStatic.Context,``0},Microsoft.ML.Data.IMultiStreamSource,System.Boolean,System.Char,System.Boolean,System.Boolean,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateTextLoader(Of TShape) (catalog As DataOperationsCatalog, func As Func(Of TextLoaderStatic.Context, TShape), Optional files As IMultiStreamSource = null, Optional hasHeader As Boolean = false, Optional separator As Char = '\t', Optional allowQuoting As Boolean = true, Optional allowSparse As Boolean = true, Optional trimWhitspace As Boolean = false) As DataLoader(Of IMultiStreamSource, TShape)" />
        <MemberSignature Language="F#" Value="static member CreateTextLoader : Microsoft.ML.DataOperationsCatalog * Func&lt;Microsoft.ML.StaticPipe.TextLoaderStatic.Context, 'Shape&gt; * Microsoft.ML.Data.IMultiStreamSource * bool * char * bool * bool * bool -&gt; Microsoft.ML.StaticPipe.DataLoader&lt;Microsoft.ML.Data.IMultiStreamSource, 'Shape&gt;" Usage="Microsoft.ML.StaticPipe.DataLoadSaveOperationsExtensions.CreateTextLoader (catalog, func, files, hasHeader, separator, allowQuoting, allowSparse, trimWhitspace)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.DataLoader&lt;Microsoft.ML.Data.IMultiStreamSource,TShape&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TShape">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet-preview">
                <AttributeName>Microsoft.ML.StaticPipe.IsShape</AttributeName>
              </Attribute>
            </Attributes>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.DataOperationsCatalog" RefType="this" />
          <Parameter Name="func" Type="System.Func&lt;Microsoft.ML.StaticPipe.TextLoaderStatic+Context,TShape&gt;" />
          <Parameter Name="files" Type="Microsoft.ML.Data.IMultiStreamSource" />
          <Parameter Name="hasHeader" Type="System.Boolean" />
          <Parameter Name="separator" Type="System.Char" />
          <Parameter Name="allowQuoting" Type="System.Boolean" />
          <Parameter Name="allowSparse" Type="System.Boolean" />
          <Parameter Name="trimWhitspace" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <typeparam name="TShape">The type shape parameter, which must be a valid-schema shape. As a practical
            matter this is generally not explicitly defined from the user, but is instead inferred from the return
            type of the <paramref name="func" /> where one takes an input <see cref="T:Microsoft.ML.StaticPipe.TextLoaderStatic.Context" /> and uses it to compose
            a shape-type instance describing what the columns are and how to load them from the file.</typeparam>
          <param name="catalog">The catalog.</param>
          <param name="func">The delegate that describes what fields to read from the text file, as well as
            describing their input type. The way in which it works is that the delegate is fed a <see cref="T:Microsoft.ML.StaticPipe.TextLoaderStatic.Context" />,
            and the user composes a shape type with <see cref="T:Microsoft.ML.StaticPipe.PipelineColumn" /> instances out of that <see cref="T:Microsoft.ML.StaticPipe.TextLoaderStatic.Context" />.
            The resulting data will have columns with the names corresponding to their names in the shape type.</param>
          <param name="files">Input files.</param>
          <param name="hasHeader">Data file has header with feature names.</param>
          <param name="separator">Text field separator.</param>
          <param name="allowQuoting">Whether the input -may include quoted values, which can contain separator
            characters, colons, and distinguish empty values from missing values. When true, consecutive separators
            denote a missing value and an empty value is denoted by <c>""</c>. When false, consecutive separators
            denote an empty value.</param>
          <param name="allowSparse">Whether the input may include sparse representations.</param>
          <param name="trimWhitspace">Remove trailing whitespace from lines.</param>
          <summary>
            Configures a loader for text files.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.DataLoadSaveOperationsExtensions" Member="M:Microsoft.ML.StaticPipe.DataLoadSaveOperationsExtensions.CreateTextLoader``1(Microsoft.ML.DataOperationsCatalog,System.Func{Microsoft.ML.StaticPipe.TextLoaderStatic.Context,``0},Microsoft.ML.Data.IMultiStreamSource,System.Boolean,System.Char,System.Boolean,System.Boolean,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.DataView`1" />
      </Targets>
      <Member MemberName="GetColumn&lt;TItem,TShape&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TItem&gt; GetColumn&lt;TItem,TShape&gt; (this Microsoft.ML.StaticPipe.DataView&lt;TShape&gt; data, Func&lt;TShape,Microsoft.ML.StaticPipe.Scalar&lt;TItem&gt;&gt; column);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TItem&gt; GetColumn&lt;TItem, TShape&gt;(class Microsoft.ML.StaticPipe.DataView`1&lt;!!TShape&gt; data, class System.Func`2&lt;!!TShape, class Microsoft.ML.StaticPipe.Scalar`1&lt;!!TItem&gt;&gt; column) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn``2(Microsoft.ML.StaticPipe.DataView{``1},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetColumn(Of TItem, TShape) (data As DataView(Of TShape), column As Func(Of TShape, Scalar(Of TItem))) As IEnumerable(Of TItem)" />
        <MemberSignature Language="F#" Value="static member GetColumn : Microsoft.ML.StaticPipe.DataView&lt;'Shape&gt; * Func&lt;'Shape, Microsoft.ML.StaticPipe.Scalar&lt;'Item&gt;&gt; -&gt; seq&lt;'Item&gt;" Usage="Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn (data, column)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;TItem&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TItem" />
          <TypeParameter Name="TShape" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;TShape&gt;" RefType="this" />
          <Parameter Name="column" Type="System.Func&lt;TShape,Microsoft.ML.StaticPipe.Scalar&lt;TItem&gt;&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TItem">To be added.</typeparam>
          <typeparam name="TShape">To be added.</typeparam>
          <param name="data">To be added.</param>
          <param name="column">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.DataViewExtensions" Member="M:Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn``2(Microsoft.ML.StaticPipe.DataView{``1},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.DataView`1" />
      </Targets>
      <Member MemberName="GetColumn&lt;TItem,TShape&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TItem[]&gt; GetColumn&lt;TItem,TShape&gt; (this Microsoft.ML.StaticPipe.DataView&lt;TShape&gt; data, Func&lt;TShape,Microsoft.ML.StaticPipe.VarVector&lt;TItem&gt;&gt; column);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TItem[]&gt; GetColumn&lt;TItem, TShape&gt;(class Microsoft.ML.StaticPipe.DataView`1&lt;!!TShape&gt; data, class System.Func`2&lt;!!TShape, class Microsoft.ML.StaticPipe.VarVector`1&lt;!!TItem&gt;&gt; column) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn``2(Microsoft.ML.StaticPipe.DataView{``1},System.Func{``1,Microsoft.ML.StaticPipe.VarVector{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetColumn(Of TItem, TShape) (data As DataView(Of TShape), column As Func(Of TShape, VarVector(Of TItem))) As IEnumerable(Of TItem())" />
        <MemberSignature Language="F#" Value="static member GetColumn : Microsoft.ML.StaticPipe.DataView&lt;'Shape&gt; * Func&lt;'Shape, Microsoft.ML.StaticPipe.VarVector&lt;'Item&gt;&gt; -&gt; seq&lt;'Item[]&gt;" Usage="Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn (data, column)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;TItem[]&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TItem" />
          <TypeParameter Name="TShape" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;TShape&gt;" RefType="this" />
          <Parameter Name="column" Type="System.Func&lt;TShape,Microsoft.ML.StaticPipe.VarVector&lt;TItem&gt;&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TItem">To be added.</typeparam>
          <typeparam name="TShape">To be added.</typeparam>
          <param name="data">To be added.</param>
          <param name="column">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.DataViewExtensions" Member="M:Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn``2(Microsoft.ML.StaticPipe.DataView{``1},System.Func{``1,Microsoft.ML.StaticPipe.VarVector{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.DataView`1" />
      </Targets>
      <Member MemberName="GetColumn&lt;TItem,TShape&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TItem[]&gt; GetColumn&lt;TItem,TShape&gt; (this Microsoft.ML.StaticPipe.DataView&lt;TShape&gt; data, Func&lt;TShape,Microsoft.ML.StaticPipe.Vector&lt;TItem&gt;&gt; column);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TItem[]&gt; GetColumn&lt;TItem, TShape&gt;(class Microsoft.ML.StaticPipe.DataView`1&lt;!!TShape&gt; data, class System.Func`2&lt;!!TShape, class Microsoft.ML.StaticPipe.Vector`1&lt;!!TItem&gt;&gt; column) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn``2(Microsoft.ML.StaticPipe.DataView{``1},System.Func{``1,Microsoft.ML.StaticPipe.Vector{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetColumn(Of TItem, TShape) (data As DataView(Of TShape), column As Func(Of TShape, Vector(Of TItem))) As IEnumerable(Of TItem())" />
        <MemberSignature Language="F#" Value="static member GetColumn : Microsoft.ML.StaticPipe.DataView&lt;'Shape&gt; * Func&lt;'Shape, Microsoft.ML.StaticPipe.Vector&lt;'Item&gt;&gt; -&gt; seq&lt;'Item[]&gt;" Usage="Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn (data, column)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;TItem[]&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TItem" />
          <TypeParameter Name="TShape" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;TShape&gt;" RefType="this" />
          <Parameter Name="column" Type="System.Func&lt;TShape,Microsoft.ML.StaticPipe.Vector&lt;TItem&gt;&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TItem">To be added.</typeparam>
          <typeparam name="TShape">To be added.</typeparam>
          <param name="data">To be added.</param>
          <param name="column">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.DataViewExtensions" Member="M:Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn``2(Microsoft.ML.StaticPipe.DataView{``1},System.Func{``1,Microsoft.ML.StaticPipe.Vector{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog" />
      </Targets>
      <Member MemberName="Evaluate&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.BinaryClassificationMetrics Evaluate&lt;T&gt; (this Microsoft.ML.BinaryClassificationCatalog catalog, Microsoft.ML.StaticPipe.DataView&lt;T&gt; data, Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; label, Func&lt;T,ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;&gt; pred);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.BinaryClassificationMetrics Evaluate&lt;T&gt;(class Microsoft.ML.BinaryClassificationCatalog catalog, class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt; data, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; label, class System.Func`2&lt;!!T, valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt;&gt; pred) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.BinaryClassificationCatalog,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Func{``0,System.ValueTuple{Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Boolean}}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Evaluate(Of T) (catalog As BinaryClassificationCatalog, data As DataView(Of T), label As Func(Of T, Scalar(Of Boolean)), pred As Func(Of T, ValueTuple(Of Scalar(Of Single), Scalar(Of Boolean)))) As BinaryClassificationMetrics" />
        <MemberSignature Language="F#" Value="static member Evaluate : Microsoft.ML.BinaryClassificationCatalog * Microsoft.ML.StaticPipe.DataView&lt;'T&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; * Func&lt;'T, ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;&gt; -&gt; Microsoft.ML.Data.BinaryClassificationMetrics" Usage="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate (catalog, data, label, pred)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.BinaryClassificationMetrics</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;T&gt;" />
          <Parameter Name="label" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;" />
          <Parameter Name="pred" Type="System.Func&lt;T,System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;&gt;">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet-preview">
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">The shape type for the input data.</typeparam>
          <param name="catalog">The binary classification catalog.</param>
          <param name="data">The data to evaluate.</param>
          <param name="label">The index delegate for the label column.</param>
          <param name="pred">The index delegate for columns from uncalibrated prediction of a binary classifier.
            Under typical scenarios, this will just be the same tuple of results returned from the trainer.</param>
          <summary>
            Evaluates scored binary classification data, if the predictions are not calibrated.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.BinaryClassificationCatalog,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Func{``0,System.ValueTuple{Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Boolean}}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog" />
      </Targets>
      <Member MemberName="Evaluate&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.CalibratedBinaryClassificationMetrics Evaluate&lt;T&gt; (this Microsoft.ML.BinaryClassificationCatalog catalog, Microsoft.ML.StaticPipe.DataView&lt;T&gt; data, Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; label, Func&lt;T,ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;&gt; pred);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.CalibratedBinaryClassificationMetrics Evaluate&lt;T&gt;(class Microsoft.ML.BinaryClassificationCatalog catalog, class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt; data, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; label, class System.Func`2&lt;!!T, valuetype System.ValueTuple`3&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt;&gt; pred) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.BinaryClassificationCatalog,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Func{``0,System.ValueTuple{Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Boolean}}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Evaluate(Of T) (catalog As BinaryClassificationCatalog, data As DataView(Of T), label As Func(Of T, Scalar(Of Boolean)), pred As Func(Of T, ValueTuple(Of Scalar(Of Single), Scalar(Of Single), Scalar(Of Boolean)))) As CalibratedBinaryClassificationMetrics" />
        <MemberSignature Language="F#" Value="static member Evaluate : Microsoft.ML.BinaryClassificationCatalog * Microsoft.ML.StaticPipe.DataView&lt;'T&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; * Func&lt;'T, ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;&gt; -&gt; Microsoft.ML.Data.CalibratedBinaryClassificationMetrics" Usage="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate (catalog, data, label, pred)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.CalibratedBinaryClassificationMetrics</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;T&gt;" />
          <Parameter Name="label" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;" />
          <Parameter Name="pred" Type="System.Func&lt;T,System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;&gt;">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet-preview">
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "probability", "predictedLabel" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">The shape type for the input data.</typeparam>
          <param name="catalog">The binary classification catalog.</param>
          <param name="data">The data to evaluate.</param>
          <param name="label">The index delegate for the label column.</param>
          <param name="pred">The index delegate for columns from calibrated prediction of a binary classifier.
            Under typical scenarios, this will just be the same tuple of results returned from the trainer.</param>
          <summary>
            Evaluates scored binary classification data.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.BinaryClassificationCatalog,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Func{``0,System.ValueTuple{Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Boolean}}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.ClusteringCatalog" />
      </Targets>
      <Member MemberName="Evaluate&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.ClusteringMetrics Evaluate&lt;T&gt; (this Microsoft.ML.ClusteringCatalog catalog, Microsoft.ML.StaticPipe.DataView&lt;T&gt; data, Func&lt;T,Microsoft.ML.StaticPipe.Vector&lt;float&gt;&gt; score, Func&lt;T,Microsoft.ML.StaticPipe.Key&lt;uint&gt;&gt; label = null, Func&lt;T,Microsoft.ML.StaticPipe.Vector&lt;float&gt;&gt; features = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.ClusteringMetrics Evaluate&lt;T&gt;(class Microsoft.ML.ClusteringCatalog catalog, class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt; data, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;&gt; score, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Key`1&lt;unsigned int32&gt;&gt; label, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;&gt; features) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.ClusteringCatalog,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Vector{System.Single}},System.Func{``0,Microsoft.ML.StaticPipe.Key{System.UInt32}},System.Func{``0,Microsoft.ML.StaticPipe.Vector{System.Single}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Evaluate(Of T) (catalog As ClusteringCatalog, data As DataView(Of T), score As Func(Of T, Vector(Of Single)), Optional label As Func(Of T, Key(Of UInteger)) = null, Optional features As Func(Of T, Vector(Of Single)) = null) As ClusteringMetrics" />
        <MemberSignature Language="F#" Value="static member Evaluate : Microsoft.ML.ClusteringCatalog * Microsoft.ML.StaticPipe.DataView&lt;'T&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Vector&lt;single&gt;&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Key&lt;uint32&gt;&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Vector&lt;single&gt;&gt; -&gt; Microsoft.ML.Data.ClusteringMetrics" Usage="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate (catalog, data, score, label, features)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.ClusteringMetrics</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.ClusteringCatalog" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;T&gt;" />
          <Parameter Name="score" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;&gt;" />
          <Parameter Name="label" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Key&lt;System.UInt32&gt;&gt;" />
          <Parameter Name="features" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="T">The shape type for the input data.</typeparam>
          <param name="catalog">The clustering catalog.</param>
          <param name="data">The data to evaluate.</param>
          <param name="score">The index delegate for the predicted score column.</param>
          <param name="label">The optional index delegate for the label column.</param>
          <param name="features">The optional index delegate for the features column.</param>
          <summary>
            Evaluates scored clustering prediction data.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.ClusteringCatalog,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Vector{System.Single}},System.Func{``0,Microsoft.ML.StaticPipe.Key{System.UInt32}},System.Func{``0,Microsoft.ML.StaticPipe.Vector{System.Single}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog" />
      </Targets>
      <Member MemberName="Evaluate&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.RegressionMetrics Evaluate&lt;T&gt; (this Microsoft.ML.RegressionCatalog catalog, Microsoft.ML.StaticPipe.DataView&lt;T&gt; data, Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;&gt; label, Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;&gt; score, Microsoft.ML.Trainers.IRegressionLoss lossFunction = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.RegressionMetrics Evaluate&lt;T&gt;(class Microsoft.ML.RegressionCatalog catalog, class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt; data, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;&gt; label, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;&gt; score, class Microsoft.ML.Trainers.IRegressionLoss lossFunction) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.RegressionCatalog,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Single}},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Single}},Microsoft.ML.Trainers.IRegressionLoss)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Evaluate(Of T) (catalog As RegressionCatalog, data As DataView(Of T), label As Func(Of T, Scalar(Of Single)), score As Func(Of T, Scalar(Of Single)), Optional lossFunction As IRegressionLoss = null) As RegressionMetrics" />
        <MemberSignature Language="F#" Value="static member Evaluate : Microsoft.ML.RegressionCatalog * Microsoft.ML.StaticPipe.DataView&lt;'T&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;&gt; * Microsoft.ML.Trainers.IRegressionLoss -&gt; Microsoft.ML.Data.RegressionMetrics" Usage="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate (catalog, data, label, score, lossFunction)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.RegressionMetrics</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;T&gt;" />
          <Parameter Name="label" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;&gt;" />
          <Parameter Name="score" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;&gt;" />
          <Parameter Name="lossFunction" Type="Microsoft.ML.Trainers.IRegressionLoss" />
        </Parameters>
        <Docs>
          <typeparam name="T">The shape type for the input data.</typeparam>
          <param name="catalog">The regression catalog.</param>
          <param name="data">The data to evaluate.</param>
          <param name="label">The index delegate for the label column.</param>
          <param name="score">The index delegate for predicted score column.</param>
          <param name="lossFunction">Potentially custom loss function. If left unspecified defaults to <see cref="T:Microsoft.ML.Trainers.SquaredLoss" />.</param>
          <summary>
            Evaluates scored regression data.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.RegressionCatalog,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Single}},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Single}},Microsoft.ML.Trainers.IRegressionLoss)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationCatalog" />
      </Targets>
      <Member MemberName="Evaluate&lt;T,TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.MulticlassClassificationMetrics Evaluate&lt;T,TKey&gt; (this Microsoft.ML.MulticlassClassificationCatalog catalog, Microsoft.ML.StaticPipe.DataView&lt;T&gt; data, Func&lt;T,Microsoft.ML.StaticPipe.Key&lt;uint,TKey&gt;&gt; label, Func&lt;T,ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;float&gt;,Microsoft.ML.StaticPipe.Key&lt;uint,TKey&gt;&gt;&gt; pred, int topKPredictionCount = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.MulticlassClassificationMetrics Evaluate&lt;T, TKey&gt;(class Microsoft.ML.MulticlassClassificationCatalog catalog, class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt; data, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TKey&gt;&gt; label, class System.Func`2&lt;!!T, valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TKey&gt;&gt;&gt; pred, int32 topKPredictionCount) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate``2(Microsoft.ML.MulticlassClassificationCatalog,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Key{System.UInt32,``1}},System.Func{``0,System.ValueTuple{Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Key{System.UInt32,``1}}},System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Evaluate(Of T, TKey) (catalog As MulticlassClassificationCatalog, data As DataView(Of T), label As Func(Of T, Key(Of UInteger, TKey)), pred As Func(Of T, ValueTuple(Of Vector(Of Single), Key(Of UInteger, TKey))), Optional topKPredictionCount As Integer = 0) As MulticlassClassificationMetrics" />
        <MemberSignature Language="F#" Value="static member Evaluate : Microsoft.ML.MulticlassClassificationCatalog * Microsoft.ML.StaticPipe.DataView&lt;'T&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Key&lt;uint32, 'Key&gt;&gt; * Func&lt;'T, ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;single&gt;, Microsoft.ML.StaticPipe.Key&lt;uint32, 'Key&gt;&gt;&gt; * int -&gt; Microsoft.ML.Data.MulticlassClassificationMetrics" Usage="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate (catalog, data, label, pred, topKPredictionCount)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.MulticlassClassificationMetrics</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.MulticlassClassificationCatalog" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;T&gt;" />
          <Parameter Name="label" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TKey&gt;&gt;" />
          <Parameter Name="pred" Type="System.Func&lt;T,System.ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TKey&gt;&gt;&gt;">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet-preview">
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
          <Parameter Name="topKPredictionCount" Type="System.Int32" />
        </Parameters>
        <Docs>
          <typeparam name="T">The shape type for the input data.</typeparam>
          <typeparam name="TKey">The value type for the key label.</typeparam>
          <param name="catalog">The multiclass classification catalog.</param>
          <param name="data">The data to evaluate.</param>
          <param name="label">The index delegate for the label column.</param>
          <param name="pred">The index delegate for columns from the prediction of a multiclass classifier.
            Under typical scenarios, this will just be the same tuple of results returned from the trainer.</param>
          <param name="topKPredictionCount">If given a positive value, the <see cref="P:Microsoft.ML.Data.MulticlassClassificationMetrics.TopKAccuracy" /> will be filled with
            the top-K accuracy, that is, the accuracy assuming we consider an example with the correct class within
            the top-K values as being stored "correctly."</param>
          <summary>
            Evaluates scored multiclass classification data.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate``2(Microsoft.ML.MulticlassClassificationCatalog,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Key{System.UInt32,``1}},System.Func{``0,System.ValueTuple{Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Key{System.UInt32,``1}}},System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RankingCatalog" />
      </Targets>
      <Member MemberName="Evaluate&lt;T,TVal&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.RankingMetrics Evaluate&lt;T,TVal&gt; (this Microsoft.ML.RankingCatalog catalog, Microsoft.ML.StaticPipe.DataView&lt;T&gt; data, Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;&gt; label, Func&lt;T,Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt;&gt; groupId, Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;&gt; score);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.RankingMetrics Evaluate&lt;T, TVal&gt;(class Microsoft.ML.RankingCatalog catalog, class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt; data, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;&gt; label, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt;&gt; groupId, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;&gt; score) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate``2(Microsoft.ML.RankingCatalog,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Single}},System.Func{``0,Microsoft.ML.StaticPipe.Key{System.UInt32,``1}},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Single}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Evaluate(Of T, TVal) (catalog As RankingCatalog, data As DataView(Of T), label As Func(Of T, Scalar(Of Single)), groupId As Func(Of T, Key(Of UInteger, TVal)), score As Func(Of T, Scalar(Of Single))) As RankingMetrics" />
        <MemberSignature Language="F#" Value="static member Evaluate : Microsoft.ML.RankingCatalog * Microsoft.ML.StaticPipe.DataView&lt;'T&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt;&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;&gt; -&gt; Microsoft.ML.Data.RankingMetrics" Usage="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate (catalog, data, label, groupId, score)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.RankingMetrics</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
          <TypeParameter Name="TVal" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RankingCatalog" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;T&gt;" />
          <Parameter Name="label" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;&gt;" />
          <Parameter Name="groupId" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;&gt;" />
          <Parameter Name="score" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="T">The shape type for the input data.</typeparam>
          <typeparam name="TVal">The type of data, before being converted to a key.</typeparam>
          <param name="catalog">The ranking catalog.</param>
          <param name="data">The data to evaluate.</param>
          <param name="label">The index delegate for the label column.</param>
          <param name="groupId">The index delegate for the groupId column. </param>
          <param name="score">The index delegate for predicted score column.</param>
          <summary>
            Evaluates scored ranking data.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate``2(Microsoft.ML.RankingCatalog,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Single}},System.Func{``0,Microsoft.ML.StaticPipe.Key{System.UInt32,``1}},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Single}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog" />
      </Targets>
      <Member MemberName="EvaluateWithPRCurve&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.BinaryClassificationMetrics EvaluateWithPRCurve&lt;T&gt; (this Microsoft.ML.BinaryClassificationCatalog catalog, Microsoft.ML.StaticPipe.DataView&lt;T&gt; data, Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; label, Func&lt;T,ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;&gt; pred, out System.Collections.Generic.List&lt;Microsoft.ML.Data.BinaryPrecisionRecallDataPoint&gt; prCurve);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.BinaryClassificationMetrics EvaluateWithPRCurve&lt;T&gt;(class Microsoft.ML.BinaryClassificationCatalog catalog, class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt; data, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; label, class System.Func`2&lt;!!T, valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt;&gt; pred, [out] class System.Collections.Generic.List`1&lt;class Microsoft.ML.Data.BinaryPrecisionRecallDataPoint&gt;&amp; prCurve) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.EvaluateWithPRCurve``1(Microsoft.ML.BinaryClassificationCatalog,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Func{``0,System.ValueTuple{Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Boolean}}},System.Collections.Generic.List{Microsoft.ML.Data.BinaryPrecisionRecallDataPoint}@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EvaluateWithPRCurve(Of T) (catalog As BinaryClassificationCatalog, data As DataView(Of T), label As Func(Of T, Scalar(Of Boolean)), pred As Func(Of T, ValueTuple(Of Scalar(Of Single), Scalar(Of Boolean))), ByRef prCurve As List(Of BinaryPrecisionRecallDataPoint)) As BinaryClassificationMetrics" />
        <MemberSignature Language="F#" Value="static member EvaluateWithPRCurve : Microsoft.ML.BinaryClassificationCatalog * Microsoft.ML.StaticPipe.DataView&lt;'T&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; * Func&lt;'T, ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;&gt; *  -&gt; Microsoft.ML.Data.BinaryClassificationMetrics" Usage="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.EvaluateWithPRCurve (catalog, data, label, pred, prCurve)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.BinaryClassificationMetrics</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;T&gt;" />
          <Parameter Name="label" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;" />
          <Parameter Name="pred" Type="System.Func&lt;T,System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;&gt;">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet-preview">
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
          <Parameter Name="prCurve" Type="System.Collections.Generic.List&lt;Microsoft.ML.Data.BinaryPrecisionRecallDataPoint&gt;" RefType="out" />
        </Parameters>
        <Docs>
          <typeparam name="T">The shape type for the input data.</typeparam>
          <param name="catalog">The binary classification catalog.</param>
          <param name="data">The data to evaluate.</param>
          <param name="label">The index delegate for the label column.</param>
          <param name="pred">The index delegate for columns from uncalibrated prediction of a binary classifier.
            Under typical scenarios, this will just be the same tuple of results returned from the trainer.</param>
          <param name="prCurve">The generated precision recall curve data. Up to 100000 of samples are used for p/r curve generation.</param>
          <summary>
            Evaluates scored binary classification data, if the predictions are not calibrated
            and generates precision recall curve data.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.EvaluateWithPRCurve``1(Microsoft.ML.BinaryClassificationCatalog,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Func{``0,System.ValueTuple{Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Boolean}}},System.Collections.Generic.List{Microsoft.ML.Data.BinaryPrecisionRecallDataPoint}@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog" />
      </Targets>
      <Member MemberName="EvaluateWithPRCurve&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.CalibratedBinaryClassificationMetrics EvaluateWithPRCurve&lt;T&gt; (this Microsoft.ML.BinaryClassificationCatalog catalog, Microsoft.ML.StaticPipe.DataView&lt;T&gt; data, Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; label, Func&lt;T,ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;&gt; pred, out System.Collections.Generic.List&lt;Microsoft.ML.Data.BinaryPrecisionRecallDataPoint&gt; prCurve);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.CalibratedBinaryClassificationMetrics EvaluateWithPRCurve&lt;T&gt;(class Microsoft.ML.BinaryClassificationCatalog catalog, class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt; data, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; label, class System.Func`2&lt;!!T, valuetype System.ValueTuple`3&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt;&gt; pred, [out] class System.Collections.Generic.List`1&lt;class Microsoft.ML.Data.BinaryPrecisionRecallDataPoint&gt;&amp; prCurve) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.EvaluateWithPRCurve``1(Microsoft.ML.BinaryClassificationCatalog,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Func{``0,System.ValueTuple{Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Boolean}}},System.Collections.Generic.List{Microsoft.ML.Data.BinaryPrecisionRecallDataPoint}@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EvaluateWithPRCurve(Of T) (catalog As BinaryClassificationCatalog, data As DataView(Of T), label As Func(Of T, Scalar(Of Boolean)), pred As Func(Of T, ValueTuple(Of Scalar(Of Single), Scalar(Of Single), Scalar(Of Boolean))), ByRef prCurve As List(Of BinaryPrecisionRecallDataPoint)) As CalibratedBinaryClassificationMetrics" />
        <MemberSignature Language="F#" Value="static member EvaluateWithPRCurve : Microsoft.ML.BinaryClassificationCatalog * Microsoft.ML.StaticPipe.DataView&lt;'T&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; * Func&lt;'T, ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;&gt; *  -&gt; Microsoft.ML.Data.CalibratedBinaryClassificationMetrics" Usage="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.EvaluateWithPRCurve (catalog, data, label, pred, prCurve)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.CalibratedBinaryClassificationMetrics</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;T&gt;" />
          <Parameter Name="label" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;" />
          <Parameter Name="pred" Type="System.Func&lt;T,System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;&gt;">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet-preview">
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "probability", "predictedLabel" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
          <Parameter Name="prCurve" Type="System.Collections.Generic.List&lt;Microsoft.ML.Data.BinaryPrecisionRecallDataPoint&gt;" RefType="out" />
        </Parameters>
        <Docs>
          <typeparam name="T">The shape type for the input data.</typeparam>
          <param name="catalog">The binary classification catalog.</param>
          <param name="data">The data to evaluate.</param>
          <param name="label">The index delegate for the label column.</param>
          <param name="pred">The index delegate for columns from calibrated prediction of a binary classifier.
            Under typical scenarios, this will just be the same tuple of results returned from the trainer.</param>
          <param name="prCurve">The generated precision recall curve data. Up to 100000 of samples are used for p/r curve generation.</param>
          <summary>
            Evaluates scored binary classification data and generates precision recall curve data.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.EvaluateWithPRCurve``1(Microsoft.ML.BinaryClassificationCatalog,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Func{``0,System.ValueTuple{Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Boolean}}},System.Collections.Generic.List{Microsoft.ML.Data.BinaryPrecisionRecallDataPoint}@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="FieldAwareFactorizationMachine">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; FieldAwareFactorizationMachine (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt;[] features, Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer.Options options, Action&lt;Microsoft.ML.Trainers.FieldAwareFactorizationMachineModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; FieldAwareFactorizationMachine(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;[] features, class Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer/Options options, class System.Action`1&lt;class Microsoft.ML.Trainers.FieldAwareFactorizationMachineModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.FactorizationMachineExtensions.FieldAwareFactorizationMachine(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single}[],Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer.Options,System.Action{Microsoft.ML.Trainers.FieldAwareFactorizationMachineModelParameters})" />
        <MemberSignature Language="F#" Value="static member FieldAwareFactorizationMachine : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt;[] * Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer.Options * Action&lt;Microsoft.ML.Trainers.FieldAwareFactorizationMachineModelParameters&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.FactorizationMachineExtensions.FieldAwareFactorizationMachine (catalog, label, features, options, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;[]" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer+Options" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.FieldAwareFactorizationMachineModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classifier catalog trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="options">Advanced arguments to the algorithm.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this.
            This delegate will receive the model that was trained. The type of the model is <see cref="T:Microsoft.ML.Trainers.FieldAwareFactorizationMachineModelParameters" />.
            Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
            Predict a target using a field-aware factorization machine.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.FactorizationMachineExtensions" Member="M:Microsoft.ML.StaticPipe.FactorizationMachineExtensions.FieldAwareFactorizationMachine(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single}[],Microsoft.ML.Trainers.FieldAwareFactorizationMachineTrainer.Options,System.Action{Microsoft.ML.Trainers.FieldAwareFactorizationMachineModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="FieldAwareFactorizationMachine">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; FieldAwareFactorizationMachine (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt;[] features, Action&lt;Microsoft.ML.Trainers.FieldAwareFactorizationMachineModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; FieldAwareFactorizationMachine(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;[] features, class System.Action`1&lt;class Microsoft.ML.Trainers.FieldAwareFactorizationMachineModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.FactorizationMachineExtensions.FieldAwareFactorizationMachine(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single}[],System.Action{Microsoft.ML.Trainers.FieldAwareFactorizationMachineModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FieldAwareFactorizationMachine (catalog As BinaryClassificationCatalog.BinaryClassificationTrainers, label As Scalar(Of Boolean), features As Vector(Of Single)(), Optional onFit As Action(Of FieldAwareFactorizationMachineModelParameters) = null) As ValueTuple(Of Scalar(Of Single), Scalar(Of Boolean))" />
        <MemberSignature Language="F#" Value="static member FieldAwareFactorizationMachine : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt;[] * Action&lt;Microsoft.ML.Trainers.FieldAwareFactorizationMachineModelParameters&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.FactorizationMachineExtensions.FieldAwareFactorizationMachine (catalog, label, features, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;[]" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.FieldAwareFactorizationMachineModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classifier catalog trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this.
            This delegate will receive the model that was trained. The type of the model is <see cref="T:Microsoft.ML.Trainers.FieldAwareFactorizationMachineModelParameters" />.
            Note that this action cannot change the result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a field-aware factorization machine.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.FactorizationMachineExtensions" Member="M:Microsoft.ML.StaticPipe.FactorizationMachineExtensions.FieldAwareFactorizationMachine(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single}[],System.Action{Microsoft.ML.Trainers.FieldAwareFactorizationMachineModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="NormalizeGlobalContrast">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; NormalizeGlobalContrast (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, bool ensureZeroMean = true, bool ensureUnitStandardDeviation = false, float scale = 1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; NormalizeGlobalContrast(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, bool ensureZeroMean, bool ensureUnitStandardDeviation, float32 scale) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.GlobalContrastNormalizerStaticExtensions.NormalizeGlobalContrast(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Boolean,System.Single)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeGlobalContrast (input As Vector(Of Single), Optional ensureZeroMean As Boolean = true, Optional ensureUnitStandardDeviation As Boolean = false, Optional scale As Single = 1) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member NormalizeGlobalContrast : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * bool * bool * single -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.GlobalContrastNormalizerStaticExtensions.NormalizeGlobalContrast (input, ensureZeroMean, ensureUnitStandardDeviation, scale)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="ensureZeroMean" Type="System.Boolean" />
          <Parameter Name="ensureUnitStandardDeviation" Type="System.Boolean" />
          <Parameter Name="scale" Type="System.Single" />
        </Parameters>
        <Docs>
          <param name="input">The column containing the vectors to apply the normalization to.</param>
          <param name="ensureZeroMean">If <see langword="true" />, subtract mean from each value before normalizing and use the raw input otherwise.</param>
          <param name="ensureUnitStandardDeviation">If <see langword="true" />, resulted vector's standard deviation would be one. Otherwise, resulted vector's L2-norm would be one.</param>
          <param name="scale">Scale features by this value.</param>
          <summary>
            <para>Performs a global contrast normalization on input values:</para>
            <para>Y = (s * X - M) / D</para>
            <para>where s is a scale, M is mean and D is either the L2 norm or standard deviation.</para>
          </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.GlobalContrastNormalizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.GlobalContrastNormalizerStaticExtensions.NormalizeGlobalContrast(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Boolean,System.Single)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Custom`1" />
      </Targets>
      <Member MemberName="AsGrayscale">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Custom&lt;Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt; AsGrayscale (this Microsoft.ML.StaticPipe.Custom&lt;Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Custom`1&lt;class Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt; AsGrayscale(class Microsoft.ML.StaticPipe.Custom`1&lt;class Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ImageStaticPipe.AsGrayscale(Microsoft.ML.StaticPipe.Custom{Microsoft.ML.StaticPipe.UnknownSizeBitmap})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsGrayscale (input As Custom(Of UnknownSizeBitmap)) As Custom(Of UnknownSizeBitmap)" />
        <MemberSignature Language="F#" Value="static member AsGrayscale : Microsoft.ML.StaticPipe.Custom&lt;Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt; -&gt; Microsoft.ML.StaticPipe.Custom&lt;Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt;" Usage="Microsoft.ML.StaticPipe.ImageStaticPipe.AsGrayscale input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Custom&lt;Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Custom&lt;Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The image to convert</param>
          <summary>
            Converts the image to grayscale.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ImageStaticPipe" Member="M:Microsoft.ML.StaticPipe.ImageStaticPipe.AsGrayscale(Microsoft.ML.StaticPipe.Custom{Microsoft.ML.StaticPipe.UnknownSizeBitmap})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Custom`1" />
      </Targets>
      <Member MemberName="AsGrayscale">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt; AsGrayscale (this Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Custom`1&lt;class System.Drawing.Bitmap&gt; AsGrayscale(class Microsoft.ML.StaticPipe.Custom`1&lt;class System.Drawing.Bitmap&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ImageStaticPipe.AsGrayscale(Microsoft.ML.StaticPipe.Custom{System.Drawing.Bitmap})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsGrayscale (input As Custom(Of Bitmap)) As Custom(Of Bitmap)" />
        <MemberSignature Language="F#" Value="static member AsGrayscale : Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt; -&gt; Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt;" Usage="Microsoft.ML.StaticPipe.ImageStaticPipe.AsGrayscale input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The image to convert</param>
          <summary>
            Converts the image to grayscale.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ImageStaticPipe" Member="M:Microsoft.ML.StaticPipe.ImageStaticPipe.AsGrayscale(Microsoft.ML.StaticPipe.Custom{System.Drawing.Bitmap})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Custom`1" />
      </Targets>
      <Member MemberName="ExtractPixels">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ExtractPixels (this Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt; input, bool useAlpha = false, bool useRed = true, bool useGreen = true, bool useBlue = true, Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorsOrder order = Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator+ColorsOrder.ARGB, bool interleave = false, float scale = 1, float offset = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ExtractPixels(class Microsoft.ML.StaticPipe.Custom`1&lt;class System.Drawing.Bitmap&gt; input, bool useAlpha, bool useRed, bool useGreen, bool useBlue, valuetype Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator/ColorsOrder order, bool interleave, float32 scale, float32 offset) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ImageStaticPipe.ExtractPixels(Microsoft.ML.StaticPipe.Custom{System.Drawing.Bitmap},System.Boolean,System.Boolean,System.Boolean,System.Boolean,Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorsOrder,System.Boolean,System.Single,System.Single)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExtractPixels (input As Custom(Of Bitmap), Optional useAlpha As Boolean = false, Optional useRed As Boolean = true, Optional useGreen As Boolean = true, Optional useBlue As Boolean = true, Optional order As ImagePixelExtractingEstimator.ColorsOrder = Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator+ColorsOrder.ARGB, Optional interleave As Boolean = false, Optional scale As Single = 1, Optional offset As Single = 0) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ExtractPixels : Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt; * bool * bool * bool * bool * Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorsOrder * bool * single * single -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ImageStaticPipe.ExtractPixels (input, useAlpha, useRed, useGreen, useBlue, order, interleave, scale, offset)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt;" RefType="this" />
          <Parameter Name="useAlpha" Type="System.Boolean" />
          <Parameter Name="useRed" Type="System.Boolean" />
          <Parameter Name="useGreen" Type="System.Boolean" />
          <Parameter Name="useBlue" Type="System.Boolean" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator+ColorsOrder" />
          <Parameter Name="interleave" Type="System.Boolean" />
          <Parameter Name="scale" Type="System.Single" />
          <Parameter Name="offset" Type="System.Single" />
        </Parameters>
        <Docs>
          <param name="input">The input image to extract</param>
          <param name="useAlpha">Whether the alpha channel should be extracted</param>
          <param name="useRed">Whether the red channel should be extracted</param>
          <param name="useGreen">Whether the green channel should be extracted</param>
          <param name="useBlue">Whether the blue channel should be extracted</param>
          <param name="order">In which order extract channels.</param>
          <param name="interleave">Whether the pixel values should be interleaved, as opposed to being separated by channel</param>
          <param name="scale">Scale the normally 0 through 255 pixel values by this amount</param>
          <param name="offset">Add this amount to the pixel values, before scaling</param>
          <summary>
            Vectorizes the image as the numeric values of its pixels converted and possibly transformed to floating point values.
            The output vector is output in height then width major order, with the channels being the most minor (if
            <paramref name="interleave" /> is true) or major (if <paramref name="interleave" /> is false) dimension.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ImageStaticPipe" Member="M:Microsoft.ML.StaticPipe.ImageStaticPipe.ExtractPixels(Microsoft.ML.StaticPipe.Custom{System.Drawing.Bitmap},System.Boolean,System.Boolean,System.Boolean,System.Boolean,Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorsOrder,System.Boolean,System.Single,System.Single)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Custom`1" />
      </Targets>
      <Member MemberName="ExtractPixelsAsBytes">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;byte&gt; ExtractPixelsAsBytes (this Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt; input, bool useAlpha = false, bool useRed = true, bool useGreen = true, bool useBlue = true, Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorsOrder order = Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator+ColorsOrder.ARGB, bool interleave = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;unsigned int8&gt; ExtractPixelsAsBytes(class Microsoft.ML.StaticPipe.Custom`1&lt;class System.Drawing.Bitmap&gt; input, bool useAlpha, bool useRed, bool useGreen, bool useBlue, valuetype Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator/ColorsOrder order, bool interleave) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ImageStaticPipe.ExtractPixelsAsBytes(Microsoft.ML.StaticPipe.Custom{System.Drawing.Bitmap},System.Boolean,System.Boolean,System.Boolean,System.Boolean,Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorsOrder,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExtractPixelsAsBytes (input As Custom(Of Bitmap), Optional useAlpha As Boolean = false, Optional useRed As Boolean = true, Optional useGreen As Boolean = true, Optional useBlue As Boolean = true, Optional order As ImagePixelExtractingEstimator.ColorsOrder = Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator+ColorsOrder.ARGB, Optional interleave As Boolean = false) As Vector(Of Byte)" />
        <MemberSignature Language="F#" Value="static member ExtractPixelsAsBytes : Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt; * bool * bool * bool * bool * Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorsOrder * bool -&gt; Microsoft.ML.StaticPipe.Vector&lt;byte&gt;" Usage="Microsoft.ML.StaticPipe.ImageStaticPipe.ExtractPixelsAsBytes (input, useAlpha, useRed, useGreen, useBlue, order, interleave)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Byte&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt;" RefType="this" />
          <Parameter Name="useAlpha" Type="System.Boolean" />
          <Parameter Name="useRed" Type="System.Boolean" />
          <Parameter Name="useGreen" Type="System.Boolean" />
          <Parameter Name="useBlue" Type="System.Boolean" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator+ColorsOrder" />
          <Parameter Name="interleave" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="input">The input image to extract</param>
          <param name="useAlpha">Whether the alpha channel should be extracted</param>
          <param name="useRed">Whether the red channel should be extracted</param>
          <param name="useGreen">Whether the green channel should be extracted</param>
          <param name="useBlue">Whether the blue channel should be extracted</param>
          <param name="order">In which order extract channels.</param>
          <param name="interleave">Whether the pixel values should be interleaved, as opposed to being separated by channel</param>
          <summary>
            Vectorizes the image as the numeric byte values of its pixels.
            The output vector is output in height then width major order, with the channels being the most minor (if
            <paramref name="interleave" /> is true) or major (if <paramref name="interleave" /> is false) dimension.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ImageStaticPipe" Member="M:Microsoft.ML.StaticPipe.ImageStaticPipe.ExtractPixelsAsBytes(Microsoft.ML.StaticPipe.Custom{System.Drawing.Bitmap},System.Boolean,System.Boolean,System.Boolean,System.Boolean,Microsoft.ML.Transforms.Image.ImagePixelExtractingEstimator.ColorsOrder,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="LoadAsImage">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Custom&lt;Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt; LoadAsImage (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; path, string relativeTo = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Custom`1&lt;class Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt; LoadAsImage(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; path, string relativeTo) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ImageStaticPipe.LoadAsImage(Microsoft.ML.StaticPipe.Scalar{System.String},System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LoadAsImage (path As Scalar(Of String), Optional relativeTo As String = null) As Custom(Of UnknownSizeBitmap)" />
        <MemberSignature Language="F#" Value="static member LoadAsImage : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * string -&gt; Microsoft.ML.StaticPipe.Custom&lt;Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt;" Usage="Microsoft.ML.StaticPipe.ImageStaticPipe.LoadAsImage (path, relativeTo)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Custom&lt;Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="path" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="relativeTo" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="path">The scalar text column that holds paths to the images</param>
          <param name="relativeTo">If specified, paths are considered to be relative to this directory.
            However, since the transform can be persisted across machines, it is generally considered more
            safe for users to simply always make their input paths absolute.</param>
          <summary>
            Load an image from an input column that holds the paths to images.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ImageStaticPipe" Member="M:Microsoft.ML.StaticPipe.ImageStaticPipe.LoadAsImage(Microsoft.ML.StaticPipe.Scalar{System.String},System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Custom`1" />
      </Targets>
      <Member MemberName="Resize">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt; Resize (this Microsoft.ML.StaticPipe.Custom&lt;Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt; input, int width, int height, Microsoft.ML.Transforms.Image.ImageResizingEstimator.ResizingKind resizing = Microsoft.ML.Transforms.Image.ImageResizingEstimator+ResizingKind.IsoCrop, Microsoft.ML.Transforms.Image.ImageResizingEstimator.Anchor cropAnchor = Microsoft.ML.Transforms.Image.ImageResizingEstimator+Anchor.Center);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Custom`1&lt;class System.Drawing.Bitmap&gt; Resize(class Microsoft.ML.StaticPipe.Custom`1&lt;class Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt; input, int32 width, int32 height, valuetype Microsoft.ML.Transforms.Image.ImageResizingEstimator/ResizingKind resizing, valuetype Microsoft.ML.Transforms.Image.ImageResizingEstimator/Anchor cropAnchor) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ImageStaticPipe.Resize(Microsoft.ML.StaticPipe.Custom{Microsoft.ML.StaticPipe.UnknownSizeBitmap},System.Int32,System.Int32,Microsoft.ML.Transforms.Image.ImageResizingEstimator.ResizingKind,Microsoft.ML.Transforms.Image.ImageResizingEstimator.Anchor)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Resize (input As Custom(Of UnknownSizeBitmap), width As Integer, height As Integer, Optional resizing As ImageResizingEstimator.ResizingKind = Microsoft.ML.Transforms.Image.ImageResizingEstimator+ResizingKind.IsoCrop, Optional cropAnchor As ImageResizingEstimator.Anchor = Microsoft.ML.Transforms.Image.ImageResizingEstimator+Anchor.Center) As Custom(Of Bitmap)" />
        <MemberSignature Language="F#" Value="static member Resize : Microsoft.ML.StaticPipe.Custom&lt;Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt; * int * int * Microsoft.ML.Transforms.Image.ImageResizingEstimator.ResizingKind * Microsoft.ML.Transforms.Image.ImageResizingEstimator.Anchor -&gt; Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt;" Usage="Microsoft.ML.StaticPipe.ImageStaticPipe.Resize (input, width, height, resizing, cropAnchor)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Custom&lt;Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt;" RefType="this" />
          <Parameter Name="width" Type="System.Int32" />
          <Parameter Name="height" Type="System.Int32" />
          <Parameter Name="resizing" Type="Microsoft.ML.Transforms.Image.ImageResizingEstimator+ResizingKind" />
          <Parameter Name="cropAnchor" Type="Microsoft.ML.Transforms.Image.ImageResizingEstimator+Anchor" />
        </Parameters>
        <Docs>
          <param name="input">The input images</param>
          <param name="width">The width to resize to</param>
          <param name="height">The height to resize to</param>
          <param name="resizing">The type of resizing to do</param>
          <param name="cropAnchor">If cropping is necessary, at what position will the image be fixed?</param>
          <summary>
            Given a column of images of unfixed size, resize the images so they have uniform size.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ImageStaticPipe" Member="M:Microsoft.ML.StaticPipe.ImageStaticPipe.Resize(Microsoft.ML.StaticPipe.Custom{Microsoft.ML.StaticPipe.UnknownSizeBitmap},System.Int32,System.Int32,Microsoft.ML.Transforms.Image.ImageResizingEstimator.ResizingKind,Microsoft.ML.Transforms.Image.ImageResizingEstimator.Anchor)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Custom`1" />
      </Targets>
      <Member MemberName="Resize">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt; Resize (this Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt; input, int width, int height, Microsoft.ML.Transforms.Image.ImageResizingEstimator.ResizingKind resizing = Microsoft.ML.Transforms.Image.ImageResizingEstimator+ResizingKind.IsoCrop, Microsoft.ML.Transforms.Image.ImageResizingEstimator.Anchor cropAnchor = Microsoft.ML.Transforms.Image.ImageResizingEstimator+Anchor.Center);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Custom`1&lt;class System.Drawing.Bitmap&gt; Resize(class Microsoft.ML.StaticPipe.Custom`1&lt;class System.Drawing.Bitmap&gt; input, int32 width, int32 height, valuetype Microsoft.ML.Transforms.Image.ImageResizingEstimator/ResizingKind resizing, valuetype Microsoft.ML.Transforms.Image.ImageResizingEstimator/Anchor cropAnchor) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ImageStaticPipe.Resize(Microsoft.ML.StaticPipe.Custom{System.Drawing.Bitmap},System.Int32,System.Int32,Microsoft.ML.Transforms.Image.ImageResizingEstimator.ResizingKind,Microsoft.ML.Transforms.Image.ImageResizingEstimator.Anchor)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Resize (input As Custom(Of Bitmap), width As Integer, height As Integer, Optional resizing As ImageResizingEstimator.ResizingKind = Microsoft.ML.Transforms.Image.ImageResizingEstimator+ResizingKind.IsoCrop, Optional cropAnchor As ImageResizingEstimator.Anchor = Microsoft.ML.Transforms.Image.ImageResizingEstimator+Anchor.Center) As Custom(Of Bitmap)" />
        <MemberSignature Language="F#" Value="static member Resize : Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt; * int * int * Microsoft.ML.Transforms.Image.ImageResizingEstimator.ResizingKind * Microsoft.ML.Transforms.Image.ImageResizingEstimator.Anchor -&gt; Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt;" Usage="Microsoft.ML.StaticPipe.ImageStaticPipe.Resize (input, width, height, resizing, cropAnchor)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt;" RefType="this" />
          <Parameter Name="width" Type="System.Int32" />
          <Parameter Name="height" Type="System.Int32" />
          <Parameter Name="resizing" Type="Microsoft.ML.Transforms.Image.ImageResizingEstimator+ResizingKind" />
          <Parameter Name="cropAnchor" Type="Microsoft.ML.Transforms.Image.ImageResizingEstimator+Anchor" />
        </Parameters>
        <Docs>
          <param name="input">The input images</param>
          <param name="width">The width to resize to</param>
          <param name="height">The height to resize to</param>
          <param name="resizing">The type of resizing to do</param>
          <param name="cropAnchor">If cropping is necessary, at what </param>
          <summary>
            Given a column of images, resize them to a new fixed size.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ImageStaticPipe" Member="M:Microsoft.ML.StaticPipe.ImageStaticPipe.Resize(Microsoft.ML.StaticPipe.Custom{System.Drawing.Bitmap},System.Int32,System.Int32,Microsoft.ML.Transforms.Image.ImageResizingEstimator.ResizingKind,Microsoft.ML.Transforms.Image.ImageResizingEstimator.Anchor)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`1" />
      </Targets>
      <Member MemberName="ToBinaryVector&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBinaryVector&lt;TKey&gt; (this Microsoft.ML.StaticPipe.Key&lt;TKey&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBinaryVector&lt;TKey&gt;(class Microsoft.ML.StaticPipe.Key`1&lt;!!TKey&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector``1(Microsoft.ML.StaticPipe.Key{``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBinaryVector(Of TKey) (input As Key(Of TKey)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBinaryVector : Microsoft.ML.StaticPipe.Key&lt;'Key&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;TKey&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces a vector of bits representing the key in binary form.
            The first value is encoded as all zeros and missing values are encoded as all ones.
            In the case where a vector has multiple keys, the encoded values are concatenated.
            Number of bits per key is determined as the number of bits needed to represent the cardinality of the keys plus one.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector``1(Microsoft.ML.StaticPipe.Key{``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToBinaryVector&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToBinaryVector&lt;TKey&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToBinaryVector&lt;TKey&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`1&lt;!!TKey&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBinaryVector(Of TKey) (input As VarVector(Of Key(Of TKey))) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBinaryVector : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key&gt;&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces a vector of bits representing the key in binary form.
            The first value is encoded as all zeros and missing values are encoded as all ones.
            In the case where a vector has multiple keys, the encoded values are concatenated.
            Number of bits per key is determined as the number of bits needed to represent the cardinality of the keys plus one.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToBinaryVector&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBinaryVector&lt;TKey&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBinaryVector&lt;TKey&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`1&lt;!!TKey&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBinaryVector(Of TKey) (input As Vector(Of Key(Of TKey))) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBinaryVector : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces a vector of bits representing the key in binary form.
            The first value is encoded as all zeros and missing values are encoded as all ones.
            In the case where a vector has multiple keys, the encoded values are concatenated.
            Number of bits per key is determined as the number of bits needed to represent the cardinality of the keys plus one.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToBinaryVector&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBinaryVector&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBinaryVector&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector``2(Microsoft.ML.StaticPipe.Key{``0,``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBinaryVector(Of TKey, TValue) (input As Key(Of TKey, TValue)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBinaryVector : Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces a vector of bits representing the key in binary form.
            The first value is encoded as all zeros and missing values are encoded as all ones.
            In the case where a vector has multiple keys, the encoded values are concatenated.
            Number of bits per key is determined as the number of bits needed to represent the cardinality of the keys plus one.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector``2(Microsoft.ML.StaticPipe.Key{``0,``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToBinaryVector&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToBinaryVector&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToBinaryVector&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBinaryVector(Of TKey, TValue) (input As VarVector(Of Key(Of TKey, TValue))) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBinaryVector : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt;&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces a vector of bits representing the key in binary form.
            The first value is encoded as all zeros and missing values are encoded as all ones.
            In the case where a vector has multiple keys, the encoded values are concatenated.
            Number of bits per key is determined as the number of bits needed to represent the cardinality of the keys plus one.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToBinaryVector&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBinaryVector&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBinaryVector&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBinaryVector(Of TKey, TValue) (input As Vector(Of Key(Of TKey, TValue))) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBinaryVector : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces a vector of bits representing the key in binary form.
            The first value is encoded as all zeros and missing values are encoded as all ones.
            In the case where a vector has multiple keys, the encoded values are concatenated.
            Number of bits per key is determined as the number of bits needed to represent the cardinality of the keys plus one.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToValue&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;TValue&gt; ToValue&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;!!TValue&gt; ToValue&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.Key{``0,``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToValue(Of TKey, TValue) (input As Key(Of TKey, TValue)) As Scalar(Of TValue)" />
        <MemberSignature Language="F#" Value="static member ToValue : Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;'Value&gt;" Usage="Microsoft.ML.StaticPipe.KeyToValueStaticExtensions.ToValue input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;TValue&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Convert a key column to a column containing the corresponding value.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToValueStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.Key{``0,``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToValue&lt;TOuterKey,TInnerKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;TInnerKey&gt; ToValue&lt;TOuterKey,TInnerKey&gt; (this Microsoft.ML.StaticPipe.Key&lt;TOuterKey,Microsoft.ML.StaticPipe.Key&lt;TInnerKey&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`1&lt;!!TInnerKey&gt; ToValue&lt;TOuterKey, TInnerKey&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!TOuterKey, class Microsoft.ML.StaticPipe.Key`1&lt;!!TInnerKey&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.Key{``0,Microsoft.ML.StaticPipe.Key{``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToValue(Of TOuterKey, TInnerKey) (input As Key(Of TOuterKey, Key(Of TInnerKey))) As Key(Of TInnerKey)" />
        <MemberSignature Language="F#" Value="static member ToValue : Microsoft.ML.StaticPipe.Key&lt;'OuterKey, Microsoft.ML.StaticPipe.Key&lt;'InnerKey&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Key&lt;'InnerKey&gt;" Usage="Microsoft.ML.StaticPipe.KeyToValueStaticExtensions.ToValue input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;TInnerKey&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TOuterKey" />
          <TypeParameter Name="TInnerKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;TOuterKey,Microsoft.ML.StaticPipe.Key&lt;TInnerKey&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TOuterKey">To be added.</typeparam>
          <typeparam name="TInnerKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Convert a key column to a column containing the corresponding value.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToValueStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.Key{``0,Microsoft.ML.StaticPipe.Key{``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToValue&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;TValue&gt; ToValue&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;!!TValue&gt; ToValue&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToValue(Of TKey, TValue) (input As VarVector(Of Key(Of TKey, TValue))) As VarVector(Of TValue)" />
        <MemberSignature Language="F#" Value="static member ToValue : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt;&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;'Value&gt;" Usage="Microsoft.ML.StaticPipe.KeyToValueStaticExtensions.ToValue input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;TValue&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Convert a key column to a column containing the corresponding value.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToValueStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToValue&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;TValue&gt; ToValue&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;!!TValue&gt; ToValue&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToValue(Of TKey, TValue) (input As Vector(Of Key(Of TKey, TValue))) As Vector(Of TValue)" />
        <MemberSignature Language="F#" Value="static member ToValue : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;'Value&gt;" Usage="Microsoft.ML.StaticPipe.KeyToValueStaticExtensions.ToValue input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;TValue&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Convert a key column to a column containing the corresponding value.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToValueStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToBaggedVector&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBaggedVector&lt;TKey&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBaggedVector&lt;TKey&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`1&lt;!!TKey&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToBaggedVector``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBaggedVector(Of TKey) (input As VarVector(Of Key(Of TKey))) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBaggedVector : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToBaggedVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            In this case then the indicator vectors for all values in the column will be simply added together,
            to produce the final vector with type equal to the key cardinality; so, in all cases, whether vector or scalar,
            the output column will be a vector type of length equal to that cardinality.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToBaggedVector``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToBaggedVector&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBaggedVector&lt;TKey&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBaggedVector&lt;TKey&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`1&lt;!!TKey&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToBaggedVector``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBaggedVector(Of TKey) (input As Vector(Of Key(Of TKey))) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBaggedVector : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToBaggedVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            In this case then the indicator vectors for all values in the column will be simply added together,
            to produce the final vector with type equal to the key cardinality; so, in all cases, whether vector or scalar,
            the output column will be a vector type of length equal to that cardinality.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToBaggedVector``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToBaggedVector&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBaggedVector&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBaggedVector&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToBaggedVector``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBaggedVector(Of TKey, TValue) (input As VarVector(Of Key(Of TKey, TValue))) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBaggedVector : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToBaggedVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            In this case then the indicator vectors for all values in the column will be simply added together,
            to produce the final vector with type equal to the key cardinality; so, in all cases, whether vector or scalar,
            the output column will be a vector type of length equal to that cardinality.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToBaggedVector``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToBaggedVector&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBaggedVector&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBaggedVector&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToBaggedVector``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBaggedVector(Of TKey, TValue) (input As Vector(Of Key(Of TKey, TValue))) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBaggedVector : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToBaggedVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            In this case then the indicator vectors for all values in the column will be simply added together,
            to produce the final vector with type equal to the key cardinality; so, in all cases, whether vector or scalar,
            the output column will be a vector type of length equal to that cardinality.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToBaggedVector``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`1" />
      </Targets>
      <Member MemberName="ToVector&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToVector&lt;TKey&gt; (this Microsoft.ML.StaticPipe.Key&lt;TKey&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToVector&lt;TKey&gt;(class Microsoft.ML.StaticPipe.Key`1&lt;!!TKey&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector``1(Microsoft.ML.StaticPipe.Key{``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToVector(Of TKey) (input As Key(Of TKey)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToVector : Microsoft.ML.StaticPipe.Key&lt;'Key&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;TKey&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector``1(Microsoft.ML.StaticPipe.Key{``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToVector&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToVector&lt;TKey&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToVector&lt;TKey&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`1&lt;!!TKey&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToVector(Of TKey) (input As VarVector(Of Key(Of TKey))) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToVector : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key&gt;&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            In this case then the indicator vectors for all values in the column will be simply added together,
            to produce the final vector with type equal to the key cardinality; so, in all cases, whether vector or scalar,
            the output column will be a vector type of length equal to that cardinality.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToVector&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToVector&lt;TKey&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToVector&lt;TKey&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`1&lt;!!TKey&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToVector(Of TKey) (input As Vector(Of Key(Of TKey))) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToVector : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToVector&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToVector&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToVector&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector``2(Microsoft.ML.StaticPipe.Key{``0,``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToVector(Of TKey, TValue) (input As Key(Of TKey, TValue)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToVector : Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector``2(Microsoft.ML.StaticPipe.Key{``0,``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToVector&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToVector&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToVector&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToVector(Of TKey, TValue) (input As VarVector(Of Key(Of TKey, TValue))) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToVector : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt;&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            In this case then the indicator vectors for all values in the column will be simply added together,
            to produce the final vector with type equal to the key cardinality; so, in all cases, whether vector or scalar,
            the output column will be a vector type of length equal to that cardinality.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToVector&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToVector&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToVector&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToVector(Of TKey, TValue) (input As Vector(Of Key(Of TKey, TValue))) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToVector : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.ClusteringCatalog.ClusteringTrainers" />
      </Targets>
      <Member MemberName="KMeans">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;float&gt;,Microsoft.ML.StaticPipe.Key&lt;uint&gt;&gt; KMeans (this Microsoft.ML.ClusteringCatalog.ClusteringTrainers catalog, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights, Microsoft.ML.Trainers.KMeansTrainer.Options options, Action&lt;Microsoft.ML.Trainers.KMeansModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Key`1&lt;unsigned int32&gt;&gt; KMeans(class Microsoft.ML.ClusteringCatalog/ClusteringTrainers catalog, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, class Microsoft.ML.Trainers.KMeansTrainer/Options options, class System.Action`1&lt;class Microsoft.ML.Trainers.KMeansModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KMeansClusteringExtensions.KMeans(Microsoft.ML.ClusteringCatalog.ClusteringTrainers,Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.KMeansTrainer.Options,System.Action{Microsoft.ML.Trainers.KMeansModelParameters})" />
        <MemberSignature Language="F#" Value="static member KMeans : Microsoft.ML.ClusteringCatalog.ClusteringTrainers * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.Trainers.KMeansTrainer.Options * Action&lt;Microsoft.ML.Trainers.KMeansModelParameters&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;single&gt;, Microsoft.ML.StaticPipe.Key&lt;uint32&gt;&gt;" Usage="Microsoft.ML.StaticPipe.KMeansClusteringExtensions.KMeans (catalog, features, weights, options, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Key&lt;System.UInt32&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.ClusteringCatalog+ClusteringTrainers" RefType="this" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.KMeansTrainer+Options" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.KMeansModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The regression catalog trainer object.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="options">Algorithm advanced settings.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained.  Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
            KMeans <see cref="T:Microsoft.ML.ClusteringCatalog" /> extension method.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KMeansClusteringExtensions" Member="M:Microsoft.ML.StaticPipe.KMeansClusteringExtensions.KMeans(Microsoft.ML.ClusteringCatalog.ClusteringTrainers,Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.KMeansTrainer.Options,System.Action{Microsoft.ML.Trainers.KMeansModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.ClusteringCatalog.ClusteringTrainers" />
      </Targets>
      <Member MemberName="KMeans">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;float&gt;,Microsoft.ML.StaticPipe.Key&lt;uint&gt;&gt; KMeans (this Microsoft.ML.ClusteringCatalog.ClusteringTrainers catalog, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, int clustersCount = 5, Action&lt;Microsoft.ML.Trainers.KMeansModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Key`1&lt;unsigned int32&gt;&gt; KMeans(class Microsoft.ML.ClusteringCatalog/ClusteringTrainers catalog, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, int32 clustersCount, class System.Action`1&lt;class Microsoft.ML.Trainers.KMeansModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KMeansClusteringExtensions.KMeans(Microsoft.ML.ClusteringCatalog.ClusteringTrainers,Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Action{Microsoft.ML.Trainers.KMeansModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function KMeans (catalog As ClusteringCatalog.ClusteringTrainers, features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional clustersCount As Integer = 5, Optional onFit As Action(Of KMeansModelParameters) = null) As ValueTuple(Of Vector(Of Single), Key(Of UInteger))" />
        <MemberSignature Language="F#" Value="static member KMeans : Microsoft.ML.ClusteringCatalog.ClusteringTrainers * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * int * Action&lt;Microsoft.ML.Trainers.KMeansModelParameters&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;single&gt;, Microsoft.ML.StaticPipe.Key&lt;uint32&gt;&gt;" Usage="Microsoft.ML.StaticPipe.KMeansClusteringExtensions.KMeans (catalog, features, weights, clustersCount, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Key&lt;System.UInt32&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.ClusteringCatalog+ClusteringTrainers" RefType="this" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="clustersCount" Type="System.Int32" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.KMeansModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The clustering catalog trainer object.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="clustersCount">The number of clusters to use for KMeans.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained.  Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
            KMeans <see cref="T:Microsoft.ML.ClusteringCatalog" /> extension method.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KMeansClusteringExtensions" Member="M:Microsoft.ML.StaticPipe.KMeansClusteringExtensions.KMeans(Microsoft.ML.ClusteringCatalog.ClusteringTrainers,Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Action{Microsoft.ML.Trainers.KMeansModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="LatentDirichletAllocation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; LatentDirichletAllocation (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, int numberOfTopics = 100, float alphaSum = 100, float beta = 0.01, int samplingStepCount = 4, int maximumNumberOfIterations = 200, int likelihoodInterval = 5, int numberOfThreads = 0, int maximumTokenCountPerDocument = 512, int numberOfSummaryTermsPerTopic = 10, int numberOfBurninIterations = 10, bool resetRandomGenerator = false, Microsoft.ML.StaticPipe.LatentDirichletAllocationFitResult.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; LatentDirichletAllocation(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, int32 numberOfTopics, float32 alphaSum, float32 beta, int32 samplingStepCount, int32 maximumNumberOfIterations, int32 likelihoodInterval, int32 numberOfThreads, int32 maximumTokenCountPerDocument, int32 numberOfSummaryTermsPerTopic, int32 numberOfBurninIterations, bool resetRandomGenerator, class Microsoft.ML.StaticPipe.LatentDirichletAllocationFitResult/OnFit onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.LatentDirichletAllocationStaticExtensions.LatentDirichletAllocation(Microsoft.ML.StaticPipe.Vector{System.Single},System.Int32,System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,Microsoft.ML.StaticPipe.LatentDirichletAllocationFitResult.OnFit)" />
        <MemberSignature Language="F#" Value="static member LatentDirichletAllocation : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * int * single * single * int * int * int * int * int * int * int * bool * Microsoft.ML.StaticPipe.LatentDirichletAllocationFitResult.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.LatentDirichletAllocationStaticExtensions.LatentDirichletAllocation (input, numberOfTopics, alphaSum, beta, samplingStepCount, maximumNumberOfIterations, likelihoodInterval, numberOfThreads, maximumTokenCountPerDocument, numberOfSummaryTermsPerTopic, numberOfBurninIterations, resetRandomGenerator, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="numberOfTopics" Type="System.Int32" />
          <Parameter Name="alphaSum" Type="System.Single" />
          <Parameter Name="beta" Type="System.Single" />
          <Parameter Name="samplingStepCount" Type="System.Int32" />
          <Parameter Name="maximumNumberOfIterations" Type="System.Int32" />
          <Parameter Name="likelihoodInterval" Type="System.Int32" />
          <Parameter Name="numberOfThreads" Type="System.Int32" />
          <Parameter Name="maximumTokenCountPerDocument" Type="System.Int32" />
          <Parameter Name="numberOfSummaryTermsPerTopic" Type="System.Int32" />
          <Parameter Name="numberOfBurninIterations" Type="System.Int32" />
          <Parameter Name="resetRandomGenerator" Type="System.Boolean" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.LatentDirichletAllocationFitResult+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">A vector of floats representing the document.</param>
          <param name="numberOfTopics">The number of topics.</param>
          <param name="alphaSum">Dirichlet prior on document-topic vectors.</param>
          <param name="beta">Dirichlet prior on vocab-topic vectors.</param>
          <param name="samplingStepCount">Number of Metropolis Hasting step.</param>
          <param name="maximumNumberOfIterations">Number of iterations.</param>
          <param name="likelihoodInterval">Compute log likelihood over local dataset on this iteration interval.</param>
          <param name="numberOfThreads">The number of training threads. Default value depends on number of logical processors.</param>
          <param name="maximumTokenCountPerDocument">The threshold of maximum count of tokens per doc.</param>
          <param name="numberOfSummaryTermsPerTopic">The number of words to summarize the topic.</param>
          <param name="numberOfBurninIterations">The number of burn-in iterations.</param>
          <param name="resetRandomGenerator">Reset the random number generator for each document.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
        The LDA transform implements LightLDA, a state-of-the-art implementation of Latent Dirichlet Allocation.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.LatentDirichletAllocationStaticExtensions" Member="M:Microsoft.ML.StaticPipe.LatentDirichletAllocationStaticExtensions.LatentDirichletAllocation(Microsoft.ML.StaticPipe.Vector{System.Single},System.Int32,System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,Microsoft.ML.StaticPipe.LatentDirichletAllocationFitResult.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="LbfgsLogisticRegression">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; LbfgsLogisticRegression (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights, Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer.Options options, Action&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; LbfgsLogisticRegression(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, class Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer/Options options, class System.Action`1&lt;class Microsoft.ML.Calibrators.CalibratedModelParametersBase`2&lt;class Microsoft.ML.Trainers.LinearBinaryModelParameters, class Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.LbfgsBinaryStaticExtensions.LbfgsLogisticRegression(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer.Options,System.Action{Microsoft.ML.Calibrators.CalibratedModelParametersBase{Microsoft.ML.Trainers.LinearBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator}})" />
        <MemberSignature Language="F#" Value="static member LbfgsLogisticRegression : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer.Options * Action&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters, Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.LbfgsBinaryStaticExtensions.LbfgsLogisticRegression (catalog, label, features, weights, options, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "probability", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer+Options" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="options">Advanced arguments to the algorithm.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained.  Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
             Predict a target using a linear binary classification model trained with the <see cref="T:Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.LbfgsBinaryStaticExtensions" Member="M:Microsoft.ML.StaticPipe.LbfgsBinaryStaticExtensions.LbfgsLogisticRegression(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer.Options,System.Action{Microsoft.ML.Calibrators.CalibratedModelParametersBase{Microsoft.ML.Trainers.LinearBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="LbfgsLogisticRegression">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; LbfgsLogisticRegression (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, float l1Regularization = 1, float l2Regularization = 1, float optimizationTolerance = 1E-07, int historySize = 20, bool enforceNonNegativity = false, Action&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; LbfgsLogisticRegression(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, float32 l1Regularization, float32 l2Regularization, float32 optimizationTolerance, int32 historySize, bool enforceNonNegativity, class System.Action`1&lt;class Microsoft.ML.Calibrators.CalibratedModelParametersBase`2&lt;class Microsoft.ML.Trainers.LinearBinaryModelParameters, class Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.LbfgsBinaryStaticExtensions.LbfgsLogisticRegression(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Single,System.Single,System.Single,System.Int32,System.Boolean,System.Action{Microsoft.ML.Calibrators.CalibratedModelParametersBase{Microsoft.ML.Trainers.LinearBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LbfgsLogisticRegression (catalog As BinaryClassificationCatalog.BinaryClassificationTrainers, label As Scalar(Of Boolean), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional l1Regularization As Single = 1, Optional l2Regularization As Single = 1, Optional optimizationTolerance As Single = 1E-07, Optional historySize As Integer = 20, Optional enforceNonNegativity As Boolean = false, Optional onFit As Action(Of CalibratedModelParametersBase(Of LinearBinaryModelParameters, PlattCalibrator)) = null) As ValueTuple(Of Scalar(Of Single), Scalar(Of Single), Scalar(Of Boolean))" />
        <MemberSignature Language="F#" Value="static member LbfgsLogisticRegression : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * single * single * single * int * bool * Action&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters, Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.LbfgsBinaryStaticExtensions.LbfgsLogisticRegression (catalog, label, features, weights, l1Regularization, l2Regularization, optimizationTolerance, historySize, enforceNonNegativity, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "probability", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="l1Regularization" Type="System.Single" />
          <Parameter Name="l2Regularization" Type="System.Single" />
          <Parameter Name="optimizationTolerance" Type="System.Single" />
          <Parameter Name="historySize" Type="System.Int32" />
          <Parameter Name="enforceNonNegativity" Type="System.Boolean" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="l1Regularization">Weight of L1 regularization term.</param>
          <param name="l2Regularization">Weight of L2 regularization term.</param>
          <param name="optimizationTolerance">Threshold for optimizer convergence.</param>
          <param name="historySize">Memory size for <see cref="T:Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer" />. Low=faster, less accurate.</param>
          <param name="enforceNonNegativity">Enforce non-negative weights.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained.  Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
             Predict a target using a linear binary classification model trained with the <see cref="T:Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.LbfgsBinaryStaticExtensions" Member="M:Microsoft.ML.StaticPipe.LbfgsBinaryStaticExtensions.LbfgsLogisticRegression(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Single,System.Single,System.Single,System.Int32,System.Boolean,System.Action{Microsoft.ML.Calibrators.CalibratedModelParametersBase{Microsoft.ML.Trainers.LinearBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="LbfgsMaximumEntropy&lt;TVal&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;float&gt;,Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt;&gt; LbfgsMaximumEntropy&lt;TVal&gt; (this Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers catalog, Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights, Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer.Options options, Action&lt;Microsoft.ML.Trainers.MaximumEntropyModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt;&gt; LbfgsMaximumEntropy&lt;TVal&gt;(class Microsoft.ML.MulticlassClassificationCatalog/MulticlassClassificationTrainers catalog, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, class Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer/Options options, class System.Action`1&lt;class Microsoft.ML.Trainers.MaximumEntropyModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.LbfgsMulticlassStaticExtensions.LbfgsMaximumEntropy``1(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer.Options,System.Action{Microsoft.ML.Trainers.MaximumEntropyModelParameters})" />
        <MemberSignature Language="F#" Value="static member LbfgsMaximumEntropy : Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers * Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer.Options * Action&lt;Microsoft.ML.Trainers.MaximumEntropyModelParameters&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;single&gt;, Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt;&gt;" Usage="Microsoft.ML.StaticPipe.LbfgsMulticlassStaticExtensions.LbfgsMaximumEntropy (catalog, label, features, weights, options, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TVal" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.MulticlassClassificationCatalog+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer+Options" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.MaximumEntropyModelParameters&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TVal">To be added.</typeparam>
          <param name="catalog">The multiclass classification catalog trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="options">Advanced arguments to the algorithm.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a maximum entropy classification model trained with the L-BFGS method implemented in <see cref="T:Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.LbfgsMulticlassStaticExtensions" Member="M:Microsoft.ML.StaticPipe.LbfgsMulticlassStaticExtensions.LbfgsMaximumEntropy``1(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer.Options,System.Action{Microsoft.ML.Trainers.MaximumEntropyModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="LbfgsMaximumEntropy&lt;TVal&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;float&gt;,Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt;&gt; LbfgsMaximumEntropy&lt;TVal&gt; (this Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers catalog, Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, float l1Regularization = 1, float l2Regularization = 1, float optimizationTolerance = 1E-07, int historySize = 20, bool enforceNonNegativity = false, Action&lt;Microsoft.ML.Trainers.MaximumEntropyModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt;&gt; LbfgsMaximumEntropy&lt;TVal&gt;(class Microsoft.ML.MulticlassClassificationCatalog/MulticlassClassificationTrainers catalog, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, float32 l1Regularization, float32 l2Regularization, float32 optimizationTolerance, int32 historySize, bool enforceNonNegativity, class System.Action`1&lt;class Microsoft.ML.Trainers.MaximumEntropyModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.LbfgsMulticlassStaticExtensions.LbfgsMaximumEntropy``1(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Single,System.Single,System.Single,System.Int32,System.Boolean,System.Action{Microsoft.ML.Trainers.MaximumEntropyModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LbfgsMaximumEntropy(Of TVal) (catalog As MulticlassClassificationCatalog.MulticlassClassificationTrainers, label As Key(Of UInteger, TVal), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional l1Regularization As Single = 1, Optional l2Regularization As Single = 1, Optional optimizationTolerance As Single = 1E-07, Optional historySize As Integer = 20, Optional enforceNonNegativity As Boolean = false, Optional onFit As Action(Of MaximumEntropyModelParameters) = null) As ValueTuple(Of Vector(Of Single), Key(Of UInteger, TVal))" />
        <MemberSignature Language="F#" Value="static member LbfgsMaximumEntropy : Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers * Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * single * single * single * int * bool * Action&lt;Microsoft.ML.Trainers.MaximumEntropyModelParameters&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;single&gt;, Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt;&gt;" Usage="Microsoft.ML.StaticPipe.LbfgsMulticlassStaticExtensions.LbfgsMaximumEntropy (catalog, label, features, weights, l1Regularization, l2Regularization, optimizationTolerance, historySize, enforceNonNegativity, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TVal" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.MulticlassClassificationCatalog+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="l1Regularization" Type="System.Single" />
          <Parameter Name="l2Regularization" Type="System.Single" />
          <Parameter Name="optimizationTolerance" Type="System.Single" />
          <Parameter Name="historySize" Type="System.Int32" />
          <Parameter Name="enforceNonNegativity" Type="System.Boolean" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.MaximumEntropyModelParameters&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TVal">To be added.</typeparam>
          <param name="catalog">The multiclass classification catalog trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="l1Regularization">Weight of L1 regularization term.</param>
          <param name="l2Regularization">Weight of L2 regularization term.</param>
          <param name="optimizationTolerance">Threshold for optimizer convergence.</param>
          <param name="historySize">Memory size for <see cref="T:Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer" />. Low=faster, less accurate.</param>
          <param name="enforceNonNegativity">Enforce non-negative weights.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a maximum entropy classification model trained with the L-BFGS method implemented in <see cref="T:Microsoft.ML.Trainers.LbfgsMaximumEntropyMulticlassTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.LbfgsMulticlassStaticExtensions" Member="M:Microsoft.ML.StaticPipe.LbfgsMulticlassStaticExtensions.LbfgsMaximumEntropy``1(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Single,System.Single,System.Single,System.Int32,System.Boolean,System.Action{Microsoft.ML.Trainers.MaximumEntropyModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="LbfgsPoissonRegression">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; LbfgsPoissonRegression (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights, Microsoft.ML.Trainers.LbfgsPoissonRegressionTrainer.Options options, Action&lt;Microsoft.ML.Trainers.PoissonRegressionModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; LbfgsPoissonRegression(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, class Microsoft.ML.Trainers.LbfgsPoissonRegressionTrainer/Options options, class System.Action`1&lt;class Microsoft.ML.Trainers.PoissonRegressionModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.LbfgsRegressionStaticExtensions.LbfgsPoissonRegression(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.LbfgsPoissonRegressionTrainer.Options,System.Action{Microsoft.ML.Trainers.PoissonRegressionModelParameters})" />
        <MemberSignature Language="F#" Value="static member LbfgsPoissonRegression : Microsoft.ML.RegressionCatalog.RegressionTrainers * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.Trainers.LbfgsPoissonRegressionTrainer.Options * Action&lt;Microsoft.ML.Trainers.PoissonRegressionModelParameters&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.LbfgsRegressionStaticExtensions.LbfgsPoissonRegression (catalog, label, features, weights, options, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.LbfgsPoissonRegressionTrainer+Options" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.PoissonRegressionModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The regression catalog trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="options">Advanced arguments to the algorithm.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained.  Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear regression model trained with the <see cref="T:Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.LbfgsRegressionStaticExtensions" Member="M:Microsoft.ML.StaticPipe.LbfgsRegressionStaticExtensions.LbfgsPoissonRegression(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.LbfgsPoissonRegressionTrainer.Options,System.Action{Microsoft.ML.Trainers.PoissonRegressionModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="LbfgsPoissonRegression">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; LbfgsPoissonRegression (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, float l1Regularization = 1, float l2Regularization = 1, float optimizationTolerance = 1E-07, int historySize = 20, bool enforceNonNegativity = false, Action&lt;Microsoft.ML.Trainers.PoissonRegressionModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; LbfgsPoissonRegression(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, float32 l1Regularization, float32 l2Regularization, float32 optimizationTolerance, int32 historySize, bool enforceNonNegativity, class System.Action`1&lt;class Microsoft.ML.Trainers.PoissonRegressionModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.LbfgsRegressionStaticExtensions.LbfgsPoissonRegression(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Single,System.Single,System.Single,System.Int32,System.Boolean,System.Action{Microsoft.ML.Trainers.PoissonRegressionModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LbfgsPoissonRegression (catalog As RegressionCatalog.RegressionTrainers, label As Scalar(Of Single), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional l1Regularization As Single = 1, Optional l2Regularization As Single = 1, Optional optimizationTolerance As Single = 1E-07, Optional historySize As Integer = 20, Optional enforceNonNegativity As Boolean = false, Optional onFit As Action(Of PoissonRegressionModelParameters) = null) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member LbfgsPoissonRegression : Microsoft.ML.RegressionCatalog.RegressionTrainers * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * single * single * single * int * bool * Action&lt;Microsoft.ML.Trainers.PoissonRegressionModelParameters&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.LbfgsRegressionStaticExtensions.LbfgsPoissonRegression (catalog, label, features, weights, l1Regularization, l2Regularization, optimizationTolerance, historySize, enforceNonNegativity, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="l1Regularization" Type="System.Single" />
          <Parameter Name="l2Regularization" Type="System.Single" />
          <Parameter Name="optimizationTolerance" Type="System.Single" />
          <Parameter Name="historySize" Type="System.Int32" />
          <Parameter Name="enforceNonNegativity" Type="System.Boolean" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.PoissonRegressionModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The regression catalog trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="l1Regularization">Weight of L1 regularization term.</param>
          <param name="l2Regularization">Weight of L2 regularization term.</param>
          <param name="optimizationTolerance">Threshold for optimizer convergence.</param>
          <param name="historySize">Memory size for <see cref="T:Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer" />. Low=faster, less accurate.</param>
          <param name="enforceNonNegativity">Enforce non-negative weights.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained.  Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear regression model trained with the <see cref="T:Microsoft.ML.Trainers.LbfgsLogisticRegressionBinaryTrainer" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.LbfgsRegressionStaticExtensions" Member="M:Microsoft.ML.StaticPipe.LbfgsRegressionStaticExtensions.LbfgsPoissonRegression(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Single,System.Single,System.Single,System.Int32,System.Boolean,System.Action{Microsoft.ML.Trainers.PoissonRegressionModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.DataLoader`2" />
      </Targets>
      <Member MemberName="Load&lt;TShape&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.DataView&lt;TShape&gt; Load&lt;TShape&gt; (this Microsoft.ML.StaticPipe.DataLoader&lt;Microsoft.ML.Data.IMultiStreamSource,TShape&gt; loader, params string[] path);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.DataView`1&lt;!!TShape&gt; Load&lt;TShape&gt;(class Microsoft.ML.StaticPipe.DataLoader`2&lt;class Microsoft.ML.Data.IMultiStreamSource, !!TShape&gt; loader, string[] path) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.LocalPathReader.Load``1(Microsoft.ML.StaticPipe.DataLoader{Microsoft.ML.Data.IMultiStreamSource,``0},System.String[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Load(Of TShape) (loader As DataLoader(Of IMultiStreamSource, TShape), ParamArray path As String()) As DataView(Of TShape)" />
        <MemberSignature Language="F#" Value="static member Load : Microsoft.ML.StaticPipe.DataLoader&lt;Microsoft.ML.Data.IMultiStreamSource, 'Shape&gt; * string[] -&gt; Microsoft.ML.StaticPipe.DataView&lt;'Shape&gt;" Usage="Microsoft.ML.StaticPipe.LocalPathReader.Load (loader, path)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.DataView&lt;TShape&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TShape" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="loader" Type="Microsoft.ML.StaticPipe.DataLoader&lt;Microsoft.ML.Data.IMultiStreamSource,TShape&gt;" RefType="this" />
          <Parameter Name="path" Type="System.String[]">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet-preview">
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="TShape">To be added.</typeparam>
          <param name="loader">The loader to use.</param>
          <param name="path">One or more paths from which to load data.</param>
          <summary>
            Reads data from one or more file <paramref name="path" /> into an <see cref="T:System.Data.DataView" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.LocalPathReader" Member="M:Microsoft.ML.StaticPipe.LocalPathReader.Load``1(Microsoft.ML.StaticPipe.DataLoader{Microsoft.ML.Data.IMultiStreamSource,``0},System.String[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="NormalizeLpNorm">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; NormalizeLpNorm (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, Microsoft.ML.Transforms.LpNormNormalizingEstimatorBase.NormFunction norm = Microsoft.ML.Transforms.LpNormNormalizingEstimatorBase+NormFunction.L2, bool ensureZeroMean = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; NormalizeLpNorm(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, valuetype Microsoft.ML.Transforms.LpNormNormalizingEstimatorBase/NormFunction norm, bool ensureZeroMean) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.LpNormNormalizerStaticExtensions.NormalizeLpNorm(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.Transforms.LpNormNormalizingEstimatorBase.NormFunction,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeLpNorm (input As Vector(Of Single), Optional norm As LpNormNormalizingEstimatorBase.NormFunction = Microsoft.ML.Transforms.LpNormNormalizingEstimatorBase+NormFunction.L2, Optional ensureZeroMean As Boolean = false) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member NormalizeLpNorm : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.Transforms.LpNormNormalizingEstimatorBase.NormFunction * bool -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.LpNormNormalizerStaticExtensions.NormalizeLpNorm (input, norm, ensureZeroMean)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="norm" Type="Microsoft.ML.Transforms.LpNormNormalizingEstimatorBase+NormFunction" />
          <Parameter Name="ensureZeroMean" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="input">The column containing the vectors to apply the normalization to.</param>
          <param name="norm">Type of norm to use to normalize each sample.</param>
          <param name="ensureZeroMean">Subtract mean from each value before normalizing.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.LpNormNormalizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.LpNormNormalizerStaticExtensions.NormalizeLpNorm(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.Transforms.LpNormNormalizingEstimatorBase.NormFunction,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="MatrixFactorization&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; MatrixFactorization&lt;T&gt; (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; label, Microsoft.ML.StaticPipe.Key&lt;T&gt; matrixColumnIndex, Microsoft.ML.StaticPipe.Key&lt;T&gt; matrixRowIndex, Microsoft.ML.Trainers.MatrixFactorizationTrainer.Options options, Action&lt;Microsoft.ML.Trainers.Recommender.MatrixFactorizationModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; MatrixFactorization&lt;T&gt;(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; label, class Microsoft.ML.StaticPipe.Key`1&lt;!!T&gt; matrixColumnIndex, class Microsoft.ML.StaticPipe.Key`1&lt;!!T&gt; matrixRowIndex, class Microsoft.ML.Trainers.MatrixFactorizationTrainer/Options options, class System.Action`1&lt;class Microsoft.ML.Trainers.Recommender.MatrixFactorizationModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.MatrixFactorizationExtensions.MatrixFactorization``1(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Key{``0},Microsoft.ML.StaticPipe.Key{``0},Microsoft.ML.Trainers.MatrixFactorizationTrainer.Options,System.Action{Microsoft.ML.Trainers.Recommender.MatrixFactorizationModelParameters})" />
        <MemberSignature Language="F#" Value="static member MatrixFactorization : Microsoft.ML.RegressionCatalog.RegressionTrainers * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.StaticPipe.Key&lt;'T&gt; * Microsoft.ML.StaticPipe.Key&lt;'T&gt; * Microsoft.ML.Trainers.MatrixFactorizationTrainer.Options * Action&lt;Microsoft.ML.Trainers.Recommender.MatrixFactorizationModelParameters&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.MatrixFactorizationExtensions.MatrixFactorization (catalog, label, matrixColumnIndex, matrixRowIndex, options, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="matrixColumnIndex" Type="Microsoft.ML.StaticPipe.Key&lt;T&gt;" />
          <Parameter Name="matrixRowIndex" Type="Microsoft.ML.StaticPipe.Key&lt;T&gt;" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.MatrixFactorizationTrainer+Options" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.Recommender.MatrixFactorizationModelParameters&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="T">The type of physical value of matrix's row and column index. It must be an integer type such as uint.</typeparam>
          <param name="catalog">The regression catalog trainer object.</param>
          <param name="label">The label variable.</param>
          <param name="matrixColumnIndex">The column index of the considered matrix.</param>
          <param name="matrixRowIndex">The row index of the considered matrix.</param>
          <param name="options">Advanced algorithm settings.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the model that was trained.  Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
            Predict matrix entry using matrix factorization
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.MatrixFactorizationExtensions" Member="M:Microsoft.ML.StaticPipe.MatrixFactorizationExtensions.MatrixFactorization``1(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Key{``0},Microsoft.ML.StaticPipe.Key{``0},Microsoft.ML.Trainers.MatrixFactorizationTrainer.Options,System.Action{Microsoft.ML.Trainers.Recommender.MatrixFactorizationModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="MulticlassNaiveBayesTrainer&lt;TVal&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;float&gt;,Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt;&gt; MulticlassNaiveBayesTrainer&lt;TVal&gt; (this Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers catalog, Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Action&lt;Microsoft.ML.Trainers.NaiveBayesMulticlassModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt;&gt; MulticlassNaiveBayesTrainer&lt;TVal&gt;(class Microsoft.ML.MulticlassClassificationCatalog/MulticlassClassificationTrainers catalog, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class System.Action`1&lt;class Microsoft.ML.Trainers.NaiveBayesMulticlassModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.MulticlassClassificationStaticExtensions.MulticlassNaiveBayesTrainer``1(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},System.Action{Microsoft.ML.Trainers.NaiveBayesMulticlassModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function MulticlassNaiveBayesTrainer(Of TVal) (catalog As MulticlassClassificationCatalog.MulticlassClassificationTrainers, label As Key(Of UInteger, TVal), features As Vector(Of Single), Optional onFit As Action(Of NaiveBayesMulticlassModelParameters) = null) As ValueTuple(Of Vector(Of Single), Key(Of UInteger, TVal))" />
        <MemberSignature Language="F#" Value="static member MulticlassNaiveBayesTrainer : Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers * Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Action&lt;Microsoft.ML.Trainers.NaiveBayesMulticlassModelParameters&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;single&gt;, Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt;&gt;" Usage="Microsoft.ML.StaticPipe.MulticlassClassificationStaticExtensions.MulticlassNaiveBayesTrainer (catalog, label, features, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TVal" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.MulticlassClassificationCatalog+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.NaiveBayesMulticlassModelParameters&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TVal">To be added.</typeparam>
          <param name="catalog">The multiclass classification catalog trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear multiclass classification model trained with the <see cref="M:Microsoft.ML.StaticPipe.MulticlassClassificationStaticExtensions.MulticlassNaiveBayesTrainer``1(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},System.Action{Microsoft.ML.Trainers.NaiveBayesMulticlassModelParameters})" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.MulticlassClassificationStaticExtensions" Member="M:Microsoft.ML.StaticPipe.MulticlassClassificationStaticExtensions.MulticlassNaiveBayesTrainer``1(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},System.Action{Microsoft.ML.Trainers.NaiveBayesMulticlassModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnMutualInformation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;bool&gt; SelectFeaturesBasedOnMutualInformation (this Microsoft.ML.StaticPipe.Vector&lt;bool&gt; input, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; labelColumn, int slotsInOutput = 1000, int numBins = 256);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;bool&gt; SelectFeaturesBasedOnMutualInformation(class Microsoft.ML.StaticPipe.Vector`1&lt;bool&gt; input, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; labelColumn, int32 slotsInOutput, int32 numBins) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Boolean},Microsoft.ML.StaticPipe.Scalar{System.Boolean},System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnMutualInformation (input As Vector(Of Boolean), labelColumn As Scalar(Of Boolean), Optional slotsInOutput As Integer = 1000, Optional numBins As Integer = 256) As Vector(Of Boolean)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnMutualInformation : Microsoft.ML.StaticPipe.Vector&lt;bool&gt; * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * int * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;bool&gt;" Usage="Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation (input, labelColumn, slotsInOutput, numBins)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Boolean&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Boolean&gt;" RefType="this" />
          <Parameter Name="labelColumn" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="slotsInOutput" Type="System.Int32" />
          <Parameter Name="numBins" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">Name of the input column.</param>
          <param name="labelColumn">Name of the column to use for labels.</param>
          <param name="slotsInOutput">The maximum number of slots to preserve in the output. The number of slots to preserve is taken across all input columns.</param>
          <param name="numBins">Max number of bins used to approximate mutual information between each input column and the label column. Power of 2 recommended.</param>
          <summary>
        Selects the top k slots across all specified columns ordered by their mutual information with the label column.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Boolean},Microsoft.ML.StaticPipe.Scalar{System.Boolean},System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnMutualInformation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;bool&gt; SelectFeaturesBasedOnMutualInformation (this Microsoft.ML.StaticPipe.Vector&lt;bool&gt; input, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; labelColumn, int slotsInOutput = 1000, int numBins = 256);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;bool&gt; SelectFeaturesBasedOnMutualInformation(class Microsoft.ML.StaticPipe.Vector`1&lt;bool&gt; input, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; labelColumn, int32 slotsInOutput, int32 numBins) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Boolean},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnMutualInformation (input As Vector(Of Boolean), labelColumn As Scalar(Of Single), Optional slotsInOutput As Integer = 1000, Optional numBins As Integer = 256) As Vector(Of Boolean)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnMutualInformation : Microsoft.ML.StaticPipe.Vector&lt;bool&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * int * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;bool&gt;" Usage="Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation (input, labelColumn, slotsInOutput, numBins)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Boolean&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Boolean&gt;" RefType="this" />
          <Parameter Name="labelColumn" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="slotsInOutput" Type="System.Int32" />
          <Parameter Name="numBins" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">Name of the input column.</param>
          <param name="labelColumn">Name of the column to use for labels.</param>
          <param name="slotsInOutput">The maximum number of slots to preserve in the output. The number of slots to preserve is taken across all input columns.</param>
          <param name="numBins">Max number of bins used to approximate mutual information between each input column and the label column. Power of 2 recommended.</param>
          <summary>
        Selects the top k slots across all specified columns ordered by their mutual information with the label column.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Boolean},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnMutualInformation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;double&gt; SelectFeaturesBasedOnMutualInformation (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; labelColumn, int slotsInOutput = 1000, int numBins = 256);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; SelectFeaturesBasedOnMutualInformation(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; labelColumn, int32 slotsInOutput, int32 numBins) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Double},Microsoft.ML.StaticPipe.Scalar{System.Boolean},System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnMutualInformation (input As Vector(Of Double), labelColumn As Scalar(Of Boolean), Optional slotsInOutput As Integer = 1000, Optional numBins As Integer = 256) As Vector(Of Double)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnMutualInformation : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * int * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;double&gt;" Usage="Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation (input, labelColumn, slotsInOutput, numBins)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="labelColumn" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="slotsInOutput" Type="System.Int32" />
          <Parameter Name="numBins" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">Name of the input column.</param>
          <param name="labelColumn">Name of the column to use for labels.</param>
          <param name="slotsInOutput">The maximum number of slots to preserve in the output. The number of slots to preserve is taken across all input columns.</param>
          <param name="numBins">Max number of bins used to approximate mutual information between each input column and the label column. Power of 2 recommended.</param>
          <summary>
        Selects the top k slots across all specified columns ordered by their mutual information with the label column.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Double},Microsoft.ML.StaticPipe.Scalar{System.Boolean},System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnMutualInformation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;double&gt; SelectFeaturesBasedOnMutualInformation (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; labelColumn, int slotsInOutput = 1000, int numBins = 256);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; SelectFeaturesBasedOnMutualInformation(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; labelColumn, int32 slotsInOutput, int32 numBins) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Double},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnMutualInformation (input As Vector(Of Double), labelColumn As Scalar(Of Single), Optional slotsInOutput As Integer = 1000, Optional numBins As Integer = 256) As Vector(Of Double)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnMutualInformation : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * int * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;double&gt;" Usage="Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation (input, labelColumn, slotsInOutput, numBins)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="labelColumn" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="slotsInOutput" Type="System.Int32" />
          <Parameter Name="numBins" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">Name of the input column.</param>
          <param name="labelColumn">Name of the column to use for labels.</param>
          <param name="slotsInOutput">The maximum number of slots to preserve in the output. The number of slots to preserve is taken across all input columns.</param>
          <param name="numBins">Max number of bins used to approximate mutual information between each input column and the label column. Power of 2 recommended.</param>
          <summary>
        Selects the top k slots across all specified columns ordered by their mutual information with the label column.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Double},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnMutualInformation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; SelectFeaturesBasedOnMutualInformation (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; labelColumn, int slotsInOutput = 1000, int numBins = 256);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; SelectFeaturesBasedOnMutualInformation(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; labelColumn, int32 slotsInOutput, int32 numBins) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Boolean},System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnMutualInformation (input As Vector(Of Single), labelColumn As Scalar(Of Boolean), Optional slotsInOutput As Integer = 1000, Optional numBins As Integer = 256) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnMutualInformation : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * int * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation (input, labelColumn, slotsInOutput, numBins)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="labelColumn" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="slotsInOutput" Type="System.Int32" />
          <Parameter Name="numBins" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">Name of the input column.</param>
          <param name="labelColumn">Name of the column to use for labels.</param>
          <param name="slotsInOutput">The maximum number of slots to preserve in the output. The number of slots to preserve is taken across all input columns.</param>
          <param name="numBins">Max number of bins used to approximate mutual information between each input column and the label column. Power of 2 recommended.</param>
          <summary>
        Selects the top k slots across all specified columns ordered by their mutual information with the label column.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Boolean},System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnMutualInformation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; SelectFeaturesBasedOnMutualInformation (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; labelColumn, int slotsInOutput = 1000, int numBins = 256);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; SelectFeaturesBasedOnMutualInformation(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; labelColumn, int32 slotsInOutput, int32 numBins) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnMutualInformation (input As Vector(Of Single), labelColumn As Scalar(Of Single), Optional slotsInOutput As Integer = 1000, Optional numBins As Integer = 256) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnMutualInformation : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * int * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation (input, labelColumn, slotsInOutput, numBins)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="labelColumn" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="slotsInOutput" Type="System.Int32" />
          <Parameter Name="numBins" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">Name of the input column.</param>
          <param name="labelColumn">Name of the column to use for labels.</param>
          <param name="slotsInOutput">The maximum number of slots to preserve in the output. The number of slots to preserve is taken across all input columns.</param>
          <param name="numBins">Max number of bins used to approximate mutual information between each input column and the label column. Power of 2 recommended.</param>
          <summary>
        Selects the top k slots across all specified columns ordered by their mutual information with the label column.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="IsMissingValue">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; IsMissingValue (this Microsoft.ML.StaticPipe.Scalar&lt;double&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; IsMissingValue(class Microsoft.ML.StaticPipe.Scalar`1&lt;float64&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue(Microsoft.ML.StaticPipe.Scalar{System.Double})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsMissingValue (input As Scalar(Of Double)) As Scalar(Of Boolean)" />
        <MemberSignature Language="F#" Value="static member IsMissingValue : Microsoft.ML.StaticPipe.Scalar&lt;double&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;" Usage="Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Double&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Produces a column of boolean entries indicating whether input column entries were missing.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue(Microsoft.ML.StaticPipe.Scalar{System.Double})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="IsMissingValue">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; IsMissingValue (this Microsoft.ML.StaticPipe.Scalar&lt;float&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; IsMissingValue(class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue(Microsoft.ML.StaticPipe.Scalar{System.Single})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsMissingValue (input As Scalar(Of Single)) As Scalar(Of Boolean)" />
        <MemberSignature Language="F#" Value="static member IsMissingValue : Microsoft.ML.StaticPipe.Scalar&lt;single&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;" Usage="Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Produces a column of boolean entries indicating whether input column entries were missing.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue(Microsoft.ML.StaticPipe.Scalar{System.Single})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="IsMissingValue">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;bool&gt; IsMissingValue (this Microsoft.ML.StaticPipe.VarVector&lt;double&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;bool&gt; IsMissingValue(class Microsoft.ML.StaticPipe.VarVector`1&lt;float64&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue(Microsoft.ML.StaticPipe.VarVector{System.Double})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsMissingValue (input As VarVector(Of Double)) As VarVector(Of Boolean)" />
        <MemberSignature Language="F#" Value="static member IsMissingValue : Microsoft.ML.StaticPipe.VarVector&lt;double&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;bool&gt;" Usage="Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Boolean&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Double&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Produces a column of boolean entries indicating whether input column entries were missing.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue(Microsoft.ML.StaticPipe.VarVector{System.Double})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="IsMissingValue">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;bool&gt; IsMissingValue (this Microsoft.ML.StaticPipe.VarVector&lt;float&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;bool&gt; IsMissingValue(class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue(Microsoft.ML.StaticPipe.VarVector{System.Single})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsMissingValue (input As VarVector(Of Single)) As VarVector(Of Boolean)" />
        <MemberSignature Language="F#" Value="static member IsMissingValue : Microsoft.ML.StaticPipe.VarVector&lt;single&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;bool&gt;" Usage="Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Boolean&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Produces a column of boolean entries indicating whether input column entries were missing.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue(Microsoft.ML.StaticPipe.VarVector{System.Single})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="IsMissingValue">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;bool&gt; IsMissingValue (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;bool&gt; IsMissingValue(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue(Microsoft.ML.StaticPipe.Vector{System.Double})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsMissingValue (input As Vector(Of Double)) As Vector(Of Boolean)" />
        <MemberSignature Language="F#" Value="static member IsMissingValue : Microsoft.ML.StaticPipe.Vector&lt;double&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;bool&gt;" Usage="Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Boolean&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Produces a column of boolean entries indicating whether input column entries were missing.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue(Microsoft.ML.StaticPipe.Vector{System.Double})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="IsMissingValue">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;bool&gt; IsMissingValue (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;bool&gt; IsMissingValue(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue(Microsoft.ML.StaticPipe.Vector{System.Single})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsMissingValue (input As Vector(Of Single)) As Vector(Of Boolean)" />
        <MemberSignature Language="F#" Value="static member IsMissingValue : Microsoft.ML.StaticPipe.Vector&lt;single&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;bool&gt;" Usage="Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Boolean&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Produces a column of boolean entries indicating whether input column entries were missing.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue(Microsoft.ML.StaticPipe.Vector{System.Single})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ReplaceNaNValues">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;double&gt; ReplaceNaNValues (this Microsoft.ML.StaticPipe.Scalar&lt;double&gt; input, Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode replacementMode = Microsoft.ML.Transforms.MissingValueReplacingEstimator+ReplacementMode.DefaultValue);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float64&gt; ReplaceNaNValues(class Microsoft.ML.StaticPipe.Scalar`1&lt;float64&gt; input, valuetype Microsoft.ML.Transforms.MissingValueReplacingEstimator/ReplacementMode replacementMode) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.Scalar{System.Double},Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode)" />
        <MemberSignature Language="F#" Value="static member ReplaceNaNValues : Microsoft.ML.StaticPipe.Scalar&lt;double&gt; * Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode -&gt; Microsoft.ML.StaticPipe.Scalar&lt;double&gt;" Usage="Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues (input, replacementMode)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="replacementMode" Type="Microsoft.ML.Transforms.MissingValueReplacingEstimator+ReplacementMode" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="replacementMode">How NaN should be replaced</param>
          <summary>
            Scan through all rows and replace NaN values according to replacement strategy.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NAReplacerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.Scalar{System.Double},Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ReplaceNaNValues">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; ReplaceNaNValues (this Microsoft.ML.StaticPipe.Scalar&lt;float&gt; input, Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode replacementMode = Microsoft.ML.Transforms.MissingValueReplacingEstimator+ReplacementMode.DefaultValue);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; ReplaceNaNValues(class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; input, valuetype Microsoft.ML.Transforms.MissingValueReplacingEstimator/ReplacementMode replacementMode) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode)" />
        <MemberSignature Language="F#" Value="static member ReplaceNaNValues : Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues (input, replacementMode)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="replacementMode" Type="Microsoft.ML.Transforms.MissingValueReplacingEstimator+ReplacementMode" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="replacementMode">How NaN should be replaced</param>
          <summary>
            Scan through all rows and replace NaN values according to replacement strategy.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NAReplacerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ReplaceNaNValues">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;double&gt; ReplaceNaNValues (this Microsoft.ML.StaticPipe.VarVector&lt;double&gt; input, Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode replacementMode = Microsoft.ML.Transforms.MissingValueReplacingEstimator+ReplacementMode.DefaultValue);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float64&gt; ReplaceNaNValues(class Microsoft.ML.StaticPipe.VarVector`1&lt;float64&gt; input, valuetype Microsoft.ML.Transforms.MissingValueReplacingEstimator/ReplacementMode replacementMode) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.VarVector{System.Double},Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode)" />
        <MemberSignature Language="F#" Value="static member ReplaceNaNValues : Microsoft.ML.StaticPipe.VarVector&lt;double&gt; * Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode -&gt; Microsoft.ML.StaticPipe.VarVector&lt;double&gt;" Usage="Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues (input, replacementMode)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="replacementMode" Type="Microsoft.ML.Transforms.MissingValueReplacingEstimator+ReplacementMode" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="replacementMode">How NaN should be replaced</param>
          <summary>
            Scan through all rows and replace NaN values according to replacement strategy.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NAReplacerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.VarVector{System.Double},Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ReplaceNaNValues">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ReplaceNaNValues (this Microsoft.ML.StaticPipe.VarVector&lt;float&gt; input, Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode replacementMode = Microsoft.ML.Transforms.MissingValueReplacingEstimator+ReplacementMode.DefaultValue);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ReplaceNaNValues(class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; input, valuetype Microsoft.ML.Transforms.MissingValueReplacingEstimator/ReplacementMode replacementMode) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.VarVector{System.Single},Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode)" />
        <MemberSignature Language="F#" Value="static member ReplaceNaNValues : Microsoft.ML.StaticPipe.VarVector&lt;single&gt; * Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues (input, replacementMode)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="replacementMode" Type="Microsoft.ML.Transforms.MissingValueReplacingEstimator+ReplacementMode" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="replacementMode">How NaN should be replaced</param>
          <summary>
            Scan through all rows and replace NaN values according to replacement strategy.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NAReplacerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.VarVector{System.Single},Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ReplaceNaNValues">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;double&gt; ReplaceNaNValues (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode replacementMode = Microsoft.ML.Transforms.MissingValueReplacingEstimator+ReplacementMode.DefaultValue, bool imputeBySlot = true);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; ReplaceNaNValues(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, valuetype Microsoft.ML.Transforms.MissingValueReplacingEstimator/ReplacementMode replacementMode, bool imputeBySlot) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.Vector{System.Double},Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode,System.Boolean)" />
        <MemberSignature Language="F#" Value="static member ReplaceNaNValues : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode * bool -&gt; Microsoft.ML.StaticPipe.Vector&lt;double&gt;" Usage="Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues (input, replacementMode, imputeBySlot)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="replacementMode" Type="Microsoft.ML.Transforms.MissingValueReplacingEstimator+ReplacementMode" />
          <Parameter Name="imputeBySlot" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="replacementMode">How NaN should be replaced</param>
          <param name="imputeBySlot">If true, per-slot imputation of replacement is performed.
            Otherwise, replacement value is imputed for the entire vector column. This setting is ignored for scalars and variable vectors,
            where imputation is always for the entire column.</param>
          <summary>
            Scan through all rows and replace NaN values according to replacement strategy.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NAReplacerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.Vector{System.Double},Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ReplaceNaNValues">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ReplaceNaNValues (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode replacementMode = Microsoft.ML.Transforms.MissingValueReplacingEstimator+ReplacementMode.DefaultValue, bool imputeBySlot = true);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ReplaceNaNValues(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, valuetype Microsoft.ML.Transforms.MissingValueReplacingEstimator/ReplacementMode replacementMode, bool imputeBySlot) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode,System.Boolean)" />
        <MemberSignature Language="F#" Value="static member ReplaceNaNValues : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode * bool -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues (input, replacementMode, imputeBySlot)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="replacementMode" Type="Microsoft.ML.Transforms.MissingValueReplacingEstimator+ReplacementMode" />
          <Parameter Name="imputeBySlot" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="replacementMode">How NaN should be replaced</param>
          <param name="imputeBySlot">If true, per-slot imputation of replacement is performed.
            Otherwise, replacement value is imputed for the entire vector column. This setting is ignored for scalars and variable vectors,
            where imputation is always for the entire column.</param>
          <summary>
            Scan through all rows and replace NaN values according to replacement strategy.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NAReplacerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.Transforms.MissingValueReplacingEstimator.ReplacementMode,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ProduceNgrams&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ProduceNgrams&lt;TKey&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,string&gt;&gt; input, int ngramLength = 1, int skipLength = 0, bool useAllLengths = true, int maximumNgramsCount = 10000000, Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria weighting = Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria.Tf);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ProduceNgrams&lt;TKey&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, string&gt;&gt; input, int32 ngramLength, int32 skipLength, bool useAllLengths, int32 maximumNgramsCount, valuetype Microsoft.ML.Transforms.Text.NgramExtractingEstimator/WeightingCriteria weighting) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NgramEstimatorStaticExtensions.ProduceNgrams``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.String}},System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProduceNgrams(Of TKey) (input As VarVector(Of Key(Of TKey, String)), Optional ngramLength As Integer = 1, Optional skipLength As Integer = 0, Optional useAllLengths As Boolean = true, Optional maximumNgramsCount As Integer = 10000000, Optional weighting As NgramExtractingEstimator.WeightingCriteria = Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria.Tf) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ProduceNgrams : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, string&gt;&gt; * int * int * bool * int * Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.NgramEstimatorStaticExtensions.ProduceNgrams (input, ngramLength, skipLength, useAllLengths, maximumNgramsCount, weighting)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,System.String&gt;&gt;" RefType="this" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="useAllLengths" Type="System.Boolean" />
          <Parameter Name="maximumNgramsCount" Type="System.Int32" />
          <Parameter Name="weighting" Type="Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">The column to apply to.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="useAllLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="maximumNgramsCount">Maximum number of n-grams to store in the dictionary.</param>
          <param name="weighting">Statistical measure used to evaluate how important a word is to a document in a corpus.</param>
          <summary>
             Produces a bag of counts of ngrams (sequences of consecutive words ) in a given tokenized text.
             It does so by building a dictionary of ngrams and using the id in the dictionary as the index in the bag.
            
             /// <see cref="M:Microsoft.ML.StaticPipe.NgramEstimatorStaticExtensions.ProduceNgrams``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.String}},System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" /> is different from <see cref="M:Microsoft.ML.StaticPipe.WordBagEstimatorStaticExtensions.ProduceWordBags(Microsoft.ML.StaticPipe.Scalar{System.String},System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
             in a way that <see cref="M:Microsoft.ML.StaticPipe.NgramEstimatorStaticExtensions.ProduceNgrams``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.String}},System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" /> takes tokenized text as input while <see cref="M:Microsoft.ML.StaticPipe.WordBagEstimatorStaticExtensions.ProduceWordBags(Microsoft.ML.StaticPipe.Scalar{System.String},System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" /> tokenizes text internally.
             </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NgramEstimatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NgramEstimatorStaticExtensions.ProduceNgrams``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.String}},System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ProduceHashedNgrams">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ProduceHashedNgrams (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,string&gt;&gt; input, int numberOfBits = 16, int ngramLength = 2, int skipLength = 0, bool useAllLengths = true, uint seed = 314489979, bool useOrderedHashing = true, int maximumNumberOfInverts = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ProduceHashedNgrams(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, string&gt;&gt; input, int32 numberOfBits, int32 ngramLength, int32 skipLength, bool useAllLengths, unsigned int32 seed, bool useOrderedHashing, int32 maximumNumberOfInverts) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NgramHashEstimatorStaticExtensions.ProduceHashedNgrams(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{System.UInt32,System.String}},System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProduceHashedNgrams (input As VarVector(Of Key(Of UInteger, String)), Optional numberOfBits As Integer = 16, Optional ngramLength As Integer = 2, Optional skipLength As Integer = 0, Optional useAllLengths As Boolean = true, Optional seed As UInteger = 314489979, Optional useOrderedHashing As Boolean = true, Optional maximumNumberOfInverts As Integer = 0) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ProduceHashedNgrams : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, string&gt;&gt; * int * int * int * bool * uint32 * bool * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.NgramHashEstimatorStaticExtensions.ProduceHashedNgrams (input, numberOfBits, ngramLength, skipLength, useAllLengths, seed, useOrderedHashing, maximumNumberOfInverts)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.String&gt;&gt;" RefType="this" />
          <Parameter Name="numberOfBits" Type="System.Int32" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="useAllLengths" Type="System.Boolean" />
          <Parameter Name="seed" Type="System.UInt32" />
          <Parameter Name="useOrderedHashing" Type="System.Boolean" />
          <Parameter Name="maximumNumberOfInverts" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="numberOfBits">Number of bits to hash into. Must be between 1 and 30, inclusive.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="useAllLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="seed">Hashing seed.</param>
          <param name="useOrderedHashing">Whether the position of each source column should be included in the hash (when there are multiple source columns).</param>
          <param name="maximumNumberOfInverts">During hashing we constuct mappings between original values and the produced hash values.
             Text representation of original values are stored in the slot names of the  metadata for the new column.Hashing, as such, can map many initial values to one.
             <paramref name="maximumNumberOfInverts" /> specifies the upper bound of the number of distinct input values mapping to a hash that should be retained.
             <value>0</value> does not retain any input values. <value>-1</value> retains all input values mapping to each hash.</param>
          <summary>
             Produces a bag of counts of ngrams (sequences of consecutive words of length 1-n) in a given tokenized text.
             It does so by hashing each ngram and using the hash value as the index in the bag.
            
             <see cref="M:Microsoft.ML.StaticPipe.NgramHashEstimatorStaticExtensions.ProduceHashedNgrams(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{System.UInt32,System.String}},System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" /> is different from <see cref="M:Microsoft.ML.StaticPipe.WordHashBagEstimatorStaticExtensions.ProduceHashedWordBags(Microsoft.ML.StaticPipe.Scalar{System.String},System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
             in a way that <see cref="M:Microsoft.ML.StaticPipe.NgramHashEstimatorStaticExtensions.ProduceHashedNgrams(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{System.UInt32,System.String}},System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" /> takes tokenized text as input while <see cref="M:Microsoft.ML.StaticPipe.WordHashBagEstimatorStaticExtensions.ProduceHashedWordBags(Microsoft.ML.StaticPipe.Scalar{System.String},System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" /> tokenizes text internally.
             </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NgramHashEstimatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NgramHashEstimatorStaticExtensions.ProduceHashedNgrams(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{System.UInt32,System.String}},System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="Normalize">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;double&gt; Normalize (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, bool ensureZeroUntouched = true, long maximumExampleCount = 1000000000, Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;double&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;float64&gt; Normalize(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, bool ensureZeroUntouched, int64 maximumExampleCount, class Microsoft.ML.StaticPipe.NormalizerStaticExtensions/OnFitAffine`1&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;float64&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.Normalize(Microsoft.ML.StaticPipe.Vector{System.Double},System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Double}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Normalize (input As Vector(Of Double), Optional ensureZeroUntouched As Boolean = true, Optional maximumExampleCount As Long = 1000000000, Optional onFit As NormalizerStaticExtensions.OnFitAffine(Of ImmutableArray(Of Double)) = null) As NormVector(Of Double)" />
        <MemberSignature Language="F#" Value="static member Normalize : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * bool * int64 * Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;double&gt;&gt; -&gt; Microsoft.ML.StaticPipe.NormVector&lt;double&gt;" Usage="Microsoft.ML.StaticPipe.NormalizerStaticExtensions.Normalize (input, ensureZeroUntouched, maximumExampleCount, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="ensureZeroUntouched" Type="System.Boolean" />
          <Parameter Name="maximumExampleCount" Type="System.Int64" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions+OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;System.Double&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The column containing the vectors to apply the normalization to.</param>
          <param name="ensureZeroUntouched">If set to <c>false</c>, then the observed minimum and maximum during fitting
            will map to -1 and 1 respectively, exactly. If however set to <c>true</c>, then 0 will always map to 0.
            This is valuable for the sake of sparsity preservation, if normalizing sparse vectors.</param>
          <param name="maximumExampleCount">When gathering statistics only look at most this many examples.</param>
          <param name="onFit">A delegate called whenever the estimator is fit, with the learned slopes
            and, if <paramref name="ensureZeroUntouched" /> is <c>false</c>, the offsets as well.</param>
          <summary>
            Learns an affine function based on the minimum and maximum, so that all values between the minimum and
            maximum observed during fitting fall into the range of -1 to 1.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.Normalize(Microsoft.ML.StaticPipe.Vector{System.Double},System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Double}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="Normalize">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;float&gt; Normalize (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, bool ensureZeroUntouched = true, long maximumExampleCount = 1000000000, Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;float&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;float32&gt; Normalize(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, bool ensureZeroUntouched, int64 maximumExampleCount, class Microsoft.ML.StaticPipe.NormalizerStaticExtensions/OnFitAffine`1&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;float32&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.Normalize(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Single}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Normalize (input As Vector(Of Single), Optional ensureZeroUntouched As Boolean = true, Optional maximumExampleCount As Long = 1000000000, Optional onFit As NormalizerStaticExtensions.OnFitAffine(Of ImmutableArray(Of Single)) = null) As NormVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member Normalize : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * bool * int64 * Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;single&gt;&gt; -&gt; Microsoft.ML.StaticPipe.NormVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.NormalizerStaticExtensions.Normalize (input, ensureZeroUntouched, maximumExampleCount, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="ensureZeroUntouched" Type="System.Boolean" />
          <Parameter Name="maximumExampleCount" Type="System.Int64" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions+OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;System.Single&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="ensureZeroUntouched">If set to <c>false</c>, then the observed minimum and maximum during fitting
            will map to -1 and 1 respectively, exactly. If however set to <c>true</c>, then 0 will always map to 0.
            This is valuable for the sake of sparsity preservation, if normalizing sparse vectors.</param>
          <param name="maximumExampleCount">When gathering statistics only look at most this many examples.</param>
          <param name="onFit">A delegate that can be called whenever the function is fit, with the learned slopes
            and, if <paramref name="ensureZeroUntouched" /> is <c>false</c>, the offsets as well.</param>
          <summary>
            Learns an affine function based on the minimum and maximum, so that all values between the minimum and
            maximum observed during fitting fall into the range of -1 to 1.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.Normalize(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Single}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="NormalizeByBinning">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;double&gt; NormalizeByBinning (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, int maximumBinCount = 1024, bool ensureZeroUntouched = true, long maximumExampleCount = 1000000000, Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitBinned&lt;System.Collections.Immutable.ImmutableArray&lt;double&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;float64&gt; NormalizeByBinning(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, int32 maximumBinCount, bool ensureZeroUntouched, int64 maximumExampleCount, class Microsoft.ML.StaticPipe.NormalizerStaticExtensions/OnFitBinned`1&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;float64&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByBinning(Microsoft.ML.StaticPipe.Vector{System.Double},System.Int32,System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitBinned{System.Collections.Immutable.ImmutableArray{System.Double}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeByBinning (input As Vector(Of Double), Optional maximumBinCount As Integer = 1024, Optional ensureZeroUntouched As Boolean = true, Optional maximumExampleCount As Long = 1000000000, Optional onFit As NormalizerStaticExtensions.OnFitBinned(Of ImmutableArray(Of Double)) = null) As NormVector(Of Double)" />
        <MemberSignature Language="F#" Value="static member NormalizeByBinning : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * int * bool * int64 * Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitBinned&lt;System.Collections.Immutable.ImmutableArray&lt;double&gt;&gt; -&gt; Microsoft.ML.StaticPipe.NormVector&lt;double&gt;" Usage="Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByBinning (input, maximumBinCount, ensureZeroUntouched, maximumExampleCount, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="maximumBinCount" Type="System.Int32" />
          <Parameter Name="ensureZeroUntouched" Type="System.Boolean" />
          <Parameter Name="maximumExampleCount" Type="System.Int64" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions+OnFitBinned&lt;System.Collections.Immutable.ImmutableArray&lt;System.Double&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The column containing the vectors to apply the normalization to.</param>
          <param name="maximumBinCount">The maximum number of discretization points to learn per slot.</param>
          <param name="ensureZeroUntouched">Normally the output is in the range of 0 to 1, but if set to <c>true</c>, then what
            would have been the output for a zero input is subtracted off the value.
            This is valuable for the sake of sparsity preservation, if normalizing sparse vectors.</param>
          <param name="maximumExampleCount">When gathering statistics only look at most this many examples.</param>
          <param name="onFit">A delegate called whenever the estimator is fit, with the bin upper bounds for each slot.</param>
          <summary>
            Learns a function based on a discretization of the input values. The observed values for each slot are
            analyzed, and the range of numbers is partitioned into monotonically increasing bins. An attempt is made
            to make these bins equal in population, but under some circumstances this may be impossible (for example, a slot
            with a very dominant mode). The way the mapping works is, if there are <c>N</c> bins in a slot, and a value
            falls in the range of bin <c>n</c> (indexed from 0), the output value is <c>n / (N - 1)</c>, and then possibly
            subtracting off the binned value for what 0 would have been if <paramref name="ensureZeroUntouched" /> is true.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByBinning(Microsoft.ML.StaticPipe.Vector{System.Double},System.Int32,System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitBinned{System.Collections.Immutable.ImmutableArray{System.Double}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="NormalizeByBinning">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;float&gt; NormalizeByBinning (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, int maximumBinCount = 1024, bool ensureZeroUntouched = true, long maximumExampleCount = 1000000000, Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitBinned&lt;System.Collections.Immutable.ImmutableArray&lt;float&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;float32&gt; NormalizeByBinning(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, int32 maximumBinCount, bool ensureZeroUntouched, int64 maximumExampleCount, class Microsoft.ML.StaticPipe.NormalizerStaticExtensions/OnFitBinned`1&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;float32&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByBinning(Microsoft.ML.StaticPipe.Vector{System.Single},System.Int32,System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitBinned{System.Collections.Immutable.ImmutableArray{System.Single}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeByBinning (input As Vector(Of Single), Optional maximumBinCount As Integer = 1024, Optional ensureZeroUntouched As Boolean = true, Optional maximumExampleCount As Long = 1000000000, Optional onFit As NormalizerStaticExtensions.OnFitBinned(Of ImmutableArray(Of Single)) = null) As NormVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member NormalizeByBinning : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * int * bool * int64 * Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitBinned&lt;System.Collections.Immutable.ImmutableArray&lt;single&gt;&gt; -&gt; Microsoft.ML.StaticPipe.NormVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByBinning (input, maximumBinCount, ensureZeroUntouched, maximumExampleCount, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="maximumBinCount" Type="System.Int32" />
          <Parameter Name="ensureZeroUntouched" Type="System.Boolean" />
          <Parameter Name="maximumExampleCount" Type="System.Int64" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions+OnFitBinned&lt;System.Collections.Immutable.ImmutableArray&lt;System.Single&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The column containing the vectors to apply the normalization to.</param>
          <param name="maximumBinCount">The maximum number of discretization points to learn per slot.</param>
          <param name="ensureZeroUntouched">Normally the output is in the range of 0 to 1, but if set to <c>true</c>, then what
            would have been the output for a zero input is subtracted off the value.
            This is valuable for the sake of sparsity preservation, if normalizing sparse vectors.</param>
          <param name="maximumExampleCount">When gathering statistics only look at most this many examples.</param>
          <param name="onFit">A delegate called whenever the estimator is fit, with the bin upper bounds for each slot.</param>
          <summary>
            Learns a function based on a discretization of the input values. The observed values for each slot are
            analyzed, and the range of numbers is partitioned into monotonically increasing bins. An attempt is made
            to make these bins equal in population, but under some circumstances this may be impossible (for example, a slot
            with a very dominant mode). The way the mapping works is, if there are <c>N</c> bins in a slot, and a value
            falls in the range of bin <c>n</c> (indexed from 0), the output value is <c>n / (N - 1)</c>, and then possibly
            subtracting off the binned value for what 0 would have been if <paramref name="ensureZeroUntouched" /> is true.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByBinning(Microsoft.ML.StaticPipe.Vector{System.Single},System.Int32,System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitBinned{System.Collections.Immutable.ImmutableArray{System.Single}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="NormalizeByCumulativeDistribution">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;double&gt; NormalizeByCumulativeDistribution (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, bool ensureZeroUntouched = true, bool useLog = false, long maximumExampleCount = 1000000000, Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitCumulativeDistribution&lt;System.Collections.Immutable.ImmutableArray&lt;double&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;float64&gt; NormalizeByCumulativeDistribution(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, bool ensureZeroUntouched, bool useLog, int64 maximumExampleCount, class Microsoft.ML.StaticPipe.NormalizerStaticExtensions/OnFitCumulativeDistribution`1&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;float64&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByCumulativeDistribution(Microsoft.ML.StaticPipe.Vector{System.Double},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitCumulativeDistribution{System.Collections.Immutable.ImmutableArray{System.Double}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeByCumulativeDistribution (input As Vector(Of Double), Optional ensureZeroUntouched As Boolean = true, Optional useLog As Boolean = false, Optional maximumExampleCount As Long = 1000000000, Optional onFit As NormalizerStaticExtensions.OnFitCumulativeDistribution(Of ImmutableArray(Of Double)) = null) As NormVector(Of Double)" />
        <MemberSignature Language="F#" Value="static member NormalizeByCumulativeDistribution : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * bool * bool * int64 * Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitCumulativeDistribution&lt;System.Collections.Immutable.ImmutableArray&lt;double&gt;&gt; -&gt; Microsoft.ML.StaticPipe.NormVector&lt;double&gt;" Usage="Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByCumulativeDistribution (input, ensureZeroUntouched, useLog, maximumExampleCount, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="ensureZeroUntouched" Type="System.Boolean" />
          <Parameter Name="useLog" Type="System.Boolean" />
          <Parameter Name="maximumExampleCount" Type="System.Int64" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions+OnFitCumulativeDistribution&lt;System.Collections.Immutable.ImmutableArray&lt;System.Double&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The column containing the vectors to apply the normalization to.</param>
          <param name="ensureZeroUntouched">If set to <c>false</c>, then the learned distributional parameters will be
            adjusted in such a way as to ensure that the input 0 maps to the output 0.
            This is valuable for the sake of sparsity preservation, if normalizing sparse vectors.</param>
          <param name="useLog">If set to true then we transform over the logarithm of the values, rather
            than just the raw values. If this is set to <c>true</c> then <paramref name="ensureZeroUntouched" /> is ignored.</param>
          <param name="maximumExampleCount">When gathering statistics only look at most this many examples.</param>
          <param name="onFit">A delegate called whenever the estimator is fit, with the learned mean and standard
            deviation for all slots.</param>
          <summary>
            Learns a function based on the cumulative density function of a normal distribution parameterized by
            a mean and variance as observed during fitting.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByCumulativeDistribution(Microsoft.ML.StaticPipe.Vector{System.Double},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitCumulativeDistribution{System.Collections.Immutable.ImmutableArray{System.Double}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="NormalizeByCumulativeDistribution">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;float&gt; NormalizeByCumulativeDistribution (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, bool ensureZeroUntouched = true, bool useLog = false, long maximumNumberOfExamples = 1000000000, Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitCumulativeDistribution&lt;System.Collections.Immutable.ImmutableArray&lt;float&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;float32&gt; NormalizeByCumulativeDistribution(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, bool ensureZeroUntouched, bool useLog, int64 maximumNumberOfExamples, class Microsoft.ML.StaticPipe.NormalizerStaticExtensions/OnFitCumulativeDistribution`1&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;float32&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByCumulativeDistribution(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitCumulativeDistribution{System.Collections.Immutable.ImmutableArray{System.Single}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeByCumulativeDistribution (input As Vector(Of Single), Optional ensureZeroUntouched As Boolean = true, Optional useLog As Boolean = false, Optional maximumNumberOfExamples As Long = 1000000000, Optional onFit As NormalizerStaticExtensions.OnFitCumulativeDistribution(Of ImmutableArray(Of Single)) = null) As NormVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member NormalizeByCumulativeDistribution : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * bool * bool * int64 * Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitCumulativeDistribution&lt;System.Collections.Immutable.ImmutableArray&lt;single&gt;&gt; -&gt; Microsoft.ML.StaticPipe.NormVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByCumulativeDistribution (input, ensureZeroUntouched, useLog, maximumNumberOfExamples, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="ensureZeroUntouched" Type="System.Boolean" />
          <Parameter Name="useLog" Type="System.Boolean" />
          <Parameter Name="maximumNumberOfExamples" Type="System.Int64" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions+OnFitCumulativeDistribution&lt;System.Collections.Immutable.ImmutableArray&lt;System.Single&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The column containing the vectors to apply the normalization to.</param>
          <param name="ensureZeroUntouched">If set to <c>false</c>, then the learned distributional parameters will be
            adjusted in such a way as to ensure that the input 0 maps to the output 0.
            This is valuable for the sake of sparsity preservation, if normalizing sparse vectors.</param>
          <param name="useLog">If set to true then we transform over the logarithm of the values, rather
            than just the raw values. If this is set to <c>true</c> then <paramref name="ensureZeroUntouched" /> is ignored.</param>
          <param name="maximumNumberOfExamples">When gathering statistics only look at most this many examples.</param>
          <param name="onFit">A delegate called whenever the estimator is fit, with the learned mean and standard
            deviation for all slots.</param>
          <summary>
            Learns a function based on the cumulative density function of a normal distribution parameterized by
            a mean and variance as observed during fitting.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByCumulativeDistribution(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitCumulativeDistribution{System.Collections.Immutable.ImmutableArray{System.Single}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="NormalizeMeanVariance">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;double&gt; NormalizeMeanVariance (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, bool ensureZeroUntouched = true, bool useLog = false, long maximumExampleCount = 1000000000, Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;double&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;float64&gt; NormalizeMeanVariance(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, bool ensureZeroUntouched, bool useLog, int64 maximumExampleCount, class Microsoft.ML.StaticPipe.NormalizerStaticExtensions/OnFitAffine`1&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;float64&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeMeanVariance(Microsoft.ML.StaticPipe.Vector{System.Double},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Double}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeMeanVariance (input As Vector(Of Double), Optional ensureZeroUntouched As Boolean = true, Optional useLog As Boolean = false, Optional maximumExampleCount As Long = 1000000000, Optional onFit As NormalizerStaticExtensions.OnFitAffine(Of ImmutableArray(Of Double)) = null) As NormVector(Of Double)" />
        <MemberSignature Language="F#" Value="static member NormalizeMeanVariance : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * bool * bool * int64 * Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;double&gt;&gt; -&gt; Microsoft.ML.StaticPipe.NormVector&lt;double&gt;" Usage="Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeMeanVariance (input, ensureZeroUntouched, useLog, maximumExampleCount, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="ensureZeroUntouched" Type="System.Boolean" />
          <Parameter Name="useLog" Type="System.Boolean" />
          <Parameter Name="maximumExampleCount" Type="System.Int64" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions+OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;System.Double&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The column containing the vectors to apply the normalization to.</param>
          <param name="ensureZeroUntouched">If set to <c>true</c> then the offset will always be considered zero.</param>
          <param name="useLog">If set to true then we transform over the logarithm of the values, rather
            than just the raw values. If this is set to <c>true</c> then <paramref name="ensureZeroUntouched" /> is ignored.</param>
          <param name="maximumExampleCount">When gathering statistics only look at most this many examples.</param>
          <param name="onFit">A delegate called whenever the estimator is fit, with the learned slopes
            and, if <paramref name="ensureZeroUntouched" /> is <c>false</c>, the offsets as well.</param>
          <summary>
            Learns an affine function based on the observed mean and standard deviation. This is less susceptible
            to outliers as compared to <see cref="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.Normalize(Microsoft.ML.StaticPipe.Vector{System.Double},System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Double}})" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeMeanVariance(Microsoft.ML.StaticPipe.Vector{System.Double},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Double}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="NormalizeMeanVariance">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;float&gt; NormalizeMeanVariance (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, bool ensureZeroUntouched = true, bool useLog = false, long maximumExampleCount = 1000000000, Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;float&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;float32&gt; NormalizeMeanVariance(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, bool ensureZeroUntouched, bool useLog, int64 maximumExampleCount, class Microsoft.ML.StaticPipe.NormalizerStaticExtensions/OnFitAffine`1&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;float32&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeMeanVariance(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Single}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeMeanVariance (input As Vector(Of Single), Optional ensureZeroUntouched As Boolean = true, Optional useLog As Boolean = false, Optional maximumExampleCount As Long = 1000000000, Optional onFit As NormalizerStaticExtensions.OnFitAffine(Of ImmutableArray(Of Single)) = null) As NormVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member NormalizeMeanVariance : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * bool * bool * int64 * Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;single&gt;&gt; -&gt; Microsoft.ML.StaticPipe.NormVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeMeanVariance (input, ensureZeroUntouched, useLog, maximumExampleCount, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="ensureZeroUntouched" Type="System.Boolean" />
          <Parameter Name="useLog" Type="System.Boolean" />
          <Parameter Name="maximumExampleCount" Type="System.Int64" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions+OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;System.Single&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The column containing the vectors to apply the normalization to.</param>
          <param name="ensureZeroUntouched">If set to <c>true</c> then the offset will always be considered zero.</param>
          <param name="useLog">If set to true then we transform over the logarithm of the values, rather
            than just the raw values. If this is set to <c>true</c> then <paramref name="ensureZeroUntouched" /> is ignored.</param>
          <param name="maximumExampleCount">When gathering statistics only look at most this many examples.</param>
          <param name="onFit">A delegate called whenever the estimator is fit, with the learned slopes
            and, if <paramref name="ensureZeroUntouched" /> is <c>false</c>, the offsets as well.</param>
          <summary>
            Learns an affine function based on the observed mean and standard deviation. This is less susceptible
            to outliers as compared to <see cref="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.Normalize(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Single}})" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeMeanVariance(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Single}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="OnlineGradientDescent">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; OnlineGradientDescent (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, Microsoft.ML.Trainers.IRegressionLoss lossFunction = null, float learningRate = 0.1, bool decreaseLearningRate = true, float l2Regularization = 0, int numIterations = 1, Action&lt;Microsoft.ML.Trainers.LinearRegressionModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; OnlineGradientDescent(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, class Microsoft.ML.Trainers.IRegressionLoss lossFunction, float32 learningRate, bool decreaseLearningRate, float32 l2Regularization, int32 numIterations, class System.Action`1&lt;class Microsoft.ML.Trainers.LinearRegressionModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.OnlineGradientDescentExtensions.OnlineGradientDescent(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.IRegressionLoss,System.Single,System.Boolean,System.Single,System.Int32,System.Action{Microsoft.ML.Trainers.LinearRegressionModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OnlineGradientDescent (catalog As RegressionCatalog.RegressionTrainers, label As Scalar(Of Single), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional lossFunction As IRegressionLoss = null, Optional learningRate As Single = 0.1, Optional decreaseLearningRate As Boolean = true, Optional l2Regularization As Single = 0, Optional numIterations As Integer = 1, Optional onFit As Action(Of LinearRegressionModelParameters) = null) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member OnlineGradientDescent : Microsoft.ML.RegressionCatalog.RegressionTrainers * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.Trainers.IRegressionLoss * single * bool * single * int * Action&lt;Microsoft.ML.Trainers.LinearRegressionModelParameters&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.OnlineGradientDescentExtensions.OnlineGradientDescent (catalog, label, features, weights, lossFunction, learningRate, decreaseLearningRate, l2Regularization, numIterations, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="lossFunction" Type="Microsoft.ML.Trainers.IRegressionLoss" />
          <Parameter Name="learningRate" Type="System.Single" />
          <Parameter Name="decreaseLearningRate" Type="System.Boolean" />
          <Parameter Name="l2Regularization" Type="System.Single" />
          <Parameter Name="numIterations" Type="System.Int32" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.LinearRegressionModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The regression catalog trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="lossFunction">The custom loss. Defaults to <see cref="T:Microsoft.ML.Trainers.SquaredLoss" /> if not provided.</param>
          <param name="learningRate">The learning Rate.</param>
          <param name="decreaseLearningRate">Decrease learning rate as iterations progress.</param>
          <param name="l2Regularization">L2 regularization weight.</param>
          <param name="numIterations">Number of training iterations through the data.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained, as well as the calibrator on top of that model. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear regression model trained with the <see cref="T:Microsoft.ML.Trainers.OnlineGradientDescentTrainer" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.OnlineGradientDescentExtensions" Member="M:Microsoft.ML.StaticPipe.OnlineGradientDescentExtensions.OnlineGradientDescent(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.IRegressionLoss,System.Single,System.Boolean,System.Single,System.Int32,System.Action{Microsoft.ML.Trainers.LinearRegressionModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="OnlineGradientDescent">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; OnlineGradientDescent (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights, Microsoft.ML.Trainers.OnlineGradientDescentTrainer.Options options, Action&lt;Microsoft.ML.Trainers.LinearRegressionModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; OnlineGradientDescent(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, class Microsoft.ML.Trainers.OnlineGradientDescentTrainer/Options options, class System.Action`1&lt;class Microsoft.ML.Trainers.LinearRegressionModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.OnlineGradientDescentExtensions.OnlineGradientDescent(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.OnlineGradientDescentTrainer.Options,System.Action{Microsoft.ML.Trainers.LinearRegressionModelParameters})" />
        <MemberSignature Language="F#" Value="static member OnlineGradientDescent : Microsoft.ML.RegressionCatalog.RegressionTrainers * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.Trainers.OnlineGradientDescentTrainer.Options * Action&lt;Microsoft.ML.Trainers.LinearRegressionModelParameters&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.OnlineGradientDescentExtensions.OnlineGradientDescent (catalog, label, features, weights, options, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.OnlineGradientDescentTrainer+Options" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.LinearRegressionModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The regression catalog trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="options">Advanced arguments to the algorithm.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained, as well as the calibrator on top of that model. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear regression model trained with the <see cref="T:Microsoft.ML.Trainers.OnlineGradientDescentTrainer" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.OnlineGradientDescentExtensions" Member="M:Microsoft.ML.StaticPipe.OnlineGradientDescentExtensions.OnlineGradientDescent(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.OnlineGradientDescentTrainer.Options,System.Action{Microsoft.ML.Trainers.LinearRegressionModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ProjectToPrincipalComponents">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ProjectToPrincipalComponents (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, string weightColumn = null, int rank = 20, int overSampling = 20, bool ensureZeroMean = true, Nullable&lt;int&gt; seed = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ProjectToPrincipalComponents(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, string weightColumn, int32 rank, int32 overSampling, bool ensureZeroMean, valuetype System.Nullable`1&lt;int32&gt; seed) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.PcaStaticExtensions.ProjectToPrincipalComponents(Microsoft.ML.StaticPipe.Vector{System.Single},System.String,System.Int32,System.Int32,System.Boolean,System.Nullable{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProjectToPrincipalComponents (input As Vector(Of Single), Optional weightColumn As String = null, Optional rank As Integer = 20, Optional overSampling As Integer = 20, Optional ensureZeroMean As Boolean = true, Optional seed As Nullable(Of Integer) = null) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ProjectToPrincipalComponents : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * string * int * int * bool * Nullable&lt;int&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.PcaStaticExtensions.ProjectToPrincipalComponents (input, weightColumn, rank, overSampling, ensureZeroMean, seed)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="weightColumn" Type="System.String" />
          <Parameter Name="rank" Type="System.Int32" />
          <Parameter Name="overSampling" Type="System.Int32" />
          <Parameter Name="ensureZeroMean" Type="System.Boolean" />
          <Parameter Name="seed" Type="System.Nullable&lt;System.Int32&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply PCA to.</param>
          <param name="weightColumn">The name of the weight column.</param>
          <param name="rank">The number of components in the PCA.</param>
          <param name="overSampling">Oversampling parameter for randomized PCA training.</param>
          <param name="ensureZeroMean">If enabled, data is centered to be zero mean.</param>
          <param name="seed">The seed for random number generation</param>
          <summary>
            Replaces the input vector with its projection to the principal component subspace,
            which can significantly reduce size of vector.
            </summary>
          <summary>
        PCA is a dimensionality-reduction transform which computes the projection of the feature vector onto a low-rank subspace. 
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.PcaStaticExtensions" Member="M:Microsoft.ML.StaticPipe.PcaStaticExtensions.ProjectToPrincipalComponents(Microsoft.ML.StaticPipe.Vector{System.Single},System.String,System.Int32,System.Int32,System.Boolean,System.Nullable{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="Sdca">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; Sdca (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights, Microsoft.ML.Trainers.SdcaLogisticRegressionBinaryTrainer.Options options, Action&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; Sdca(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, class Microsoft.ML.Trainers.SdcaLogisticRegressionBinaryTrainer/Options options, class System.Action`1&lt;class Microsoft.ML.Calibrators.CalibratedModelParametersBase`2&lt;class Microsoft.ML.Trainers.LinearBinaryModelParameters, class Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.SdcaLogisticRegressionBinaryTrainer.Options,System.Action{Microsoft.ML.Calibrators.CalibratedModelParametersBase{Microsoft.ML.Trainers.LinearBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator}})" />
        <MemberSignature Language="F#" Value="static member Sdca : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.Trainers.SdcaLogisticRegressionBinaryTrainer.Options * Action&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters, Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca (catalog, label, features, weights, options, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "probability", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.SdcaLogisticRegressionBinaryTrainer+Options" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="options">Advanced arguments to the algorithm.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained, as well as the calibrator on top of that model. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear binary classification model trained with the SDCA trainer, and log-loss.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.SdcaStaticExtensions" Member="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.SdcaLogisticRegressionBinaryTrainer.Options,System.Action{Microsoft.ML.Calibrators.CalibratedModelParametersBase{Microsoft.ML.Trainers.LinearBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="Sdca">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; Sdca (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, Nullable&lt;float&gt; l2Regularization = null, Nullable&lt;float&gt; l1Threshold = null, Nullable&lt;int&gt; numberOfIterations = null, Action&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; Sdca(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, valuetype System.Nullable`1&lt;float32&gt; l2Regularization, valuetype System.Nullable`1&lt;float32&gt; l1Threshold, valuetype System.Nullable`1&lt;int32&gt; numberOfIterations, class System.Action`1&lt;class Microsoft.ML.Calibrators.CalibratedModelParametersBase`2&lt;class Microsoft.ML.Trainers.LinearBinaryModelParameters, class Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Calibrators.CalibratedModelParametersBase{Microsoft.ML.Trainers.LinearBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sdca (catalog As BinaryClassificationCatalog.BinaryClassificationTrainers, label As Scalar(Of Boolean), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional l2Regularization As Nullable(Of Single) = null, Optional l1Threshold As Nullable(Of Single) = null, Optional numberOfIterations As Nullable(Of Integer) = null, Optional onFit As Action(Of CalibratedModelParametersBase(Of LinearBinaryModelParameters, PlattCalibrator)) = null) As ValueTuple(Of Scalar(Of Single), Scalar(Of Single), Scalar(Of Boolean))" />
        <MemberSignature Language="F#" Value="static member Sdca : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;int&gt; * Action&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters, Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca (catalog, label, features, weights, l2Regularization, l1Threshold, numberOfIterations, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "probability", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="l2Regularization" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="l1Threshold" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="numberOfIterations" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="l2Regularization">The L2 regularization hyperparameter.</param>
          <param name="l1Threshold">The L1 regularization hyperparameter. Higher values will tend to lead to more sparse model.</param>
          <param name="numberOfIterations">The maximum number of passes to perform over the data.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained, as well as the calibrator on top of that model. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear binary classification model trained with the SDCA trainer, and log-loss.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.SdcaStaticExtensions" Member="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Calibrators.CalibratedModelParametersBase{Microsoft.ML.Trainers.LinearBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="Sdca">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; Sdca (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights, Microsoft.ML.Trainers.SdcaRegressionTrainer.Options options, Action&lt;Microsoft.ML.Trainers.LinearRegressionModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; Sdca(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, class Microsoft.ML.Trainers.SdcaRegressionTrainer/Options options, class System.Action`1&lt;class Microsoft.ML.Trainers.LinearRegressionModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.SdcaRegressionTrainer.Options,System.Action{Microsoft.ML.Trainers.LinearRegressionModelParameters})" />
        <MemberSignature Language="F#" Value="static member Sdca : Microsoft.ML.RegressionCatalog.RegressionTrainers * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.Trainers.SdcaRegressionTrainer.Options * Action&lt;Microsoft.ML.Trainers.LinearRegressionModelParameters&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca (catalog, label, features, weights, options, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.SdcaRegressionTrainer+Options" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.LinearRegressionModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The regression catalog trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="options">Advanced arguments to the algorithm.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained.  Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear regression model trained with the SDCA trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.SdcaStaticExtensions" Member="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.SdcaRegressionTrainer.Options,System.Action{Microsoft.ML.Trainers.LinearRegressionModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="Sdca">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; Sdca (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, Nullable&lt;float&gt; l2Regularization = null, Nullable&lt;float&gt; l1Threshold = null, Nullable&lt;int&gt; numberOfIterations = null, Microsoft.ML.Trainers.ISupportSdcaRegressionLoss lossFunction = null, Action&lt;Microsoft.ML.Trainers.LinearRegressionModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; Sdca(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, valuetype System.Nullable`1&lt;float32&gt; l2Regularization, valuetype System.Nullable`1&lt;float32&gt; l1Threshold, valuetype System.Nullable`1&lt;int32&gt; numberOfIterations, class Microsoft.ML.Trainers.ISupportSdcaRegressionLoss lossFunction, class System.Action`1&lt;class Microsoft.ML.Trainers.LinearRegressionModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},Microsoft.ML.Trainers.ISupportSdcaRegressionLoss,System.Action{Microsoft.ML.Trainers.LinearRegressionModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sdca (catalog As RegressionCatalog.RegressionTrainers, label As Scalar(Of Single), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional l2Regularization As Nullable(Of Single) = null, Optional l1Threshold As Nullable(Of Single) = null, Optional numberOfIterations As Nullable(Of Integer) = null, Optional lossFunction As ISupportSdcaRegressionLoss = null, Optional onFit As Action(Of LinearRegressionModelParameters) = null) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member Sdca : Microsoft.ML.RegressionCatalog.RegressionTrainers * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;int&gt; * Microsoft.ML.Trainers.ISupportSdcaRegressionLoss * Action&lt;Microsoft.ML.Trainers.LinearRegressionModelParameters&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca (catalog, label, features, weights, l2Regularization, l1Threshold, numberOfIterations, lossFunction, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="l2Regularization" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="l1Threshold" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="numberOfIterations" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="lossFunction" Type="Microsoft.ML.Trainers.ISupportSdcaRegressionLoss" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.LinearRegressionModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The regression catalog trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="l2Regularization">The L2 regularization hyperparameter.</param>
          <param name="l1Threshold">The L1 regularization hyperparameter. Higher values will tend to lead to more sparse model.</param>
          <param name="numberOfIterations">The maximum number of passes to perform over the data.</param>
          <param name="lossFunction">The custom loss, if unspecified will be <see cref="T:Microsoft.ML.Trainers.SquaredLoss" />.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained.  Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear regression model trained with the SDCA trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.SdcaStaticExtensions" Member="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},Microsoft.ML.Trainers.ISupportSdcaRegressionLoss,System.Action{Microsoft.ML.Trainers.LinearRegressionModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="Sdca&lt;TVal&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;float&gt;,Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt;&gt; Sdca&lt;TVal&gt; (this Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers catalog, Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights, Microsoft.ML.Trainers.SdcaMaximumEntropyMulticlassTrainer.Options options, Action&lt;Microsoft.ML.Trainers.MaximumEntropyModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt;&gt; Sdca&lt;TVal&gt;(class Microsoft.ML.MulticlassClassificationCatalog/MulticlassClassificationTrainers catalog, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, class Microsoft.ML.Trainers.SdcaMaximumEntropyMulticlassTrainer/Options options, class System.Action`1&lt;class Microsoft.ML.Trainers.MaximumEntropyModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca``1(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.SdcaMaximumEntropyMulticlassTrainer.Options,System.Action{Microsoft.ML.Trainers.MaximumEntropyModelParameters})" />
        <MemberSignature Language="F#" Value="static member Sdca : Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers * Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.Trainers.SdcaMaximumEntropyMulticlassTrainer.Options * Action&lt;Microsoft.ML.Trainers.MaximumEntropyModelParameters&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;single&gt;, Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt;&gt;" Usage="Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca (catalog, label, features, weights, options, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TVal" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.MulticlassClassificationCatalog+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.SdcaMaximumEntropyMulticlassTrainer+Options" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.MaximumEntropyModelParameters&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TVal">To be added.</typeparam>
          <param name="catalog">The multiclass classification catalog trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="options">Advanced arguments to the algorithm.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a maximum entropy classification model trained with the SDCA trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.SdcaStaticExtensions" Member="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca``1(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.SdcaMaximumEntropyMulticlassTrainer.Options,System.Action{Microsoft.ML.Trainers.MaximumEntropyModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="Sdca&lt;TVal&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;float&gt;,Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt;&gt; Sdca&lt;TVal&gt; (this Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers catalog, Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, Nullable&lt;float&gt; l2Regularization = null, Nullable&lt;float&gt; l1Threshold = null, Nullable&lt;int&gt; numberOfIterations = null, Action&lt;Microsoft.ML.Trainers.MaximumEntropyModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt;&gt; Sdca&lt;TVal&gt;(class Microsoft.ML.MulticlassClassificationCatalog/MulticlassClassificationTrainers catalog, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, valuetype System.Nullable`1&lt;float32&gt; l2Regularization, valuetype System.Nullable`1&lt;float32&gt; l1Threshold, valuetype System.Nullable`1&lt;int32&gt; numberOfIterations, class System.Action`1&lt;class Microsoft.ML.Trainers.MaximumEntropyModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca``1(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Trainers.MaximumEntropyModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sdca(Of TVal) (catalog As MulticlassClassificationCatalog.MulticlassClassificationTrainers, label As Key(Of UInteger, TVal), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional l2Regularization As Nullable(Of Single) = null, Optional l1Threshold As Nullable(Of Single) = null, Optional numberOfIterations As Nullable(Of Integer) = null, Optional onFit As Action(Of MaximumEntropyModelParameters) = null) As ValueTuple(Of Vector(Of Single), Key(Of UInteger, TVal))" />
        <MemberSignature Language="F#" Value="static member Sdca : Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers * Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;int&gt; * Action&lt;Microsoft.ML.Trainers.MaximumEntropyModelParameters&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;single&gt;, Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt;&gt;" Usage="Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca (catalog, label, features, weights, l2Regularization, l1Threshold, numberOfIterations, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TVal" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.MulticlassClassificationCatalog+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="l2Regularization" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="l1Threshold" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="numberOfIterations" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.MaximumEntropyModelParameters&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TVal">To be added.</typeparam>
          <param name="catalog">The multiclass classification catalog trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="l2Regularization">The L2 regularization hyperparameter.</param>
          <param name="l1Threshold">The L1 regularization hyperparameter. Higher values will tend to lead to more sparse model.</param>
          <param name="numberOfIterations">The maximum number of passes to perform over the data.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a maximum entropy classification model trained with the SDCA trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.SdcaStaticExtensions" Member="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca``1(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Trainers.MaximumEntropyModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="SdcaNonCalibrated">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; SdcaNonCalibrated (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights, Microsoft.ML.Trainers.ISupportSdcaClassificationLoss lossFunction, Microsoft.ML.Trainers.SdcaNonCalibratedBinaryTrainer.Options options, Action&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; SdcaNonCalibrated(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, class Microsoft.ML.Trainers.ISupportSdcaClassificationLoss lossFunction, class Microsoft.ML.Trainers.SdcaNonCalibratedBinaryTrainer/Options options, class System.Action`1&lt;class Microsoft.ML.Trainers.LinearBinaryModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.SdcaNonCalibrated(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.ISupportSdcaClassificationLoss,Microsoft.ML.Trainers.SdcaNonCalibratedBinaryTrainer.Options,System.Action{Microsoft.ML.Trainers.LinearBinaryModelParameters})" />
        <MemberSignature Language="F#" Value="static member SdcaNonCalibrated : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.Trainers.ISupportSdcaClassificationLoss * Microsoft.ML.Trainers.SdcaNonCalibratedBinaryTrainer.Options * Action&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.SdcaStaticExtensions.SdcaNonCalibrated (catalog, label, features, weights, lossFunction, options, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="lossFunction" Type="Microsoft.ML.Trainers.ISupportSdcaClassificationLoss" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.SdcaNonCalibratedBinaryTrainer+Options" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="lossFunction">The custom loss.</param>
          <param name="options">Advanced arguments to the algorithm.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained, as well as the calibrator on top of that model. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear binary classification model trained with the SDCA trainer, and a custom loss.
            Note that because we cannot be sure that all loss functions will produce naturally calibrated outputs, setting
            a custom loss function will not produce a calibrated probability column.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.SdcaStaticExtensions" Member="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.SdcaNonCalibrated(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.ISupportSdcaClassificationLoss,Microsoft.ML.Trainers.SdcaNonCalibratedBinaryTrainer.Options,System.Action{Microsoft.ML.Trainers.LinearBinaryModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="SdcaNonCalibrated">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; SdcaNonCalibrated (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.Trainers.ISupportSdcaClassificationLoss lossFunction, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, Nullable&lt;float&gt; l2Regularization = null, Nullable&lt;float&gt; l1Threshold = null, Nullable&lt;int&gt; numberOfIterations = null, Action&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; SdcaNonCalibrated(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.Trainers.ISupportSdcaClassificationLoss lossFunction, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, valuetype System.Nullable`1&lt;float32&gt; l2Regularization, valuetype System.Nullable`1&lt;float32&gt; l1Threshold, valuetype System.Nullable`1&lt;int32&gt; numberOfIterations, class System.Action`1&lt;class Microsoft.ML.Trainers.LinearBinaryModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.SdcaNonCalibrated(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.Trainers.ISupportSdcaClassificationLoss,Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Trainers.LinearBinaryModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SdcaNonCalibrated (catalog As BinaryClassificationCatalog.BinaryClassificationTrainers, label As Scalar(Of Boolean), features As Vector(Of Single), lossFunction As ISupportSdcaClassificationLoss, Optional weights As Scalar(Of Single) = null, Optional l2Regularization As Nullable(Of Single) = null, Optional l1Threshold As Nullable(Of Single) = null, Optional numberOfIterations As Nullable(Of Integer) = null, Optional onFit As Action(Of LinearBinaryModelParameters) = null) As ValueTuple(Of Scalar(Of Single), Scalar(Of Boolean))" />
        <MemberSignature Language="F#" Value="static member SdcaNonCalibrated : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.Trainers.ISupportSdcaClassificationLoss * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;int&gt; * Action&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.SdcaStaticExtensions.SdcaNonCalibrated (catalog, label, features, lossFunction, weights, l2Regularization, l1Threshold, numberOfIterations, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="lossFunction" Type="Microsoft.ML.Trainers.ISupportSdcaClassificationLoss" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="l2Regularization" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="l1Threshold" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="numberOfIterations" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="lossFunction">The custom loss.</param>
          <param name="weights">The optional example weights.</param>
          <param name="l2Regularization">The L2 regularization hyperparameter.</param>
          <param name="l1Threshold">The L1 regularization hyperparameter. Higher values will tend to lead to more sparse model.</param>
          <param name="numberOfIterations">The maximum number of passes to perform over the data.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained, as well as the calibrator on top of that model. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear binary classification model trained with the SDCA trainer, and a custom loss.
            Note that because we cannot be sure that all loss functions will produce naturally calibrated outputs, setting
            a custom loss function will not produce a calibrated probability column.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.SdcaStaticExtensions" Member="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.SdcaNonCalibrated(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.Trainers.ISupportSdcaClassificationLoss,Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Trainers.LinearBinaryModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="SdcaNonCalibrated&lt;TVal&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;float&gt;,Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt;&gt; SdcaNonCalibrated&lt;TVal&gt; (this Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers catalog, Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights, Microsoft.ML.Trainers.SdcaNonCalibratedMulticlassTrainer.Options options, Action&lt;Microsoft.ML.Trainers.LinearMulticlassModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt;&gt; SdcaNonCalibrated&lt;TVal&gt;(class Microsoft.ML.MulticlassClassificationCatalog/MulticlassClassificationTrainers catalog, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, class Microsoft.ML.Trainers.SdcaNonCalibratedMulticlassTrainer/Options options, class System.Action`1&lt;class Microsoft.ML.Trainers.LinearMulticlassModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.SdcaNonCalibrated``1(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.SdcaNonCalibratedMulticlassTrainer.Options,System.Action{Microsoft.ML.Trainers.LinearMulticlassModelParameters})" />
        <MemberSignature Language="F#" Value="static member SdcaNonCalibrated : Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers * Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.Trainers.SdcaNonCalibratedMulticlassTrainer.Options * Action&lt;Microsoft.ML.Trainers.LinearMulticlassModelParameters&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;single&gt;, Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt;&gt;" Usage="Microsoft.ML.StaticPipe.SdcaStaticExtensions.SdcaNonCalibrated (catalog, label, features, weights, options, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TVal" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.MulticlassClassificationCatalog+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.SdcaNonCalibratedMulticlassTrainer+Options" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.LinearMulticlassModelParameters&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TVal">To be added.</typeparam>
          <param name="catalog">The multiclass classification catalog trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="options">Advanced arguments to the algorithm.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear multiclass classification model trained with the SDCA trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.SdcaStaticExtensions" Member="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.SdcaNonCalibrated``1(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.SdcaNonCalibratedMulticlassTrainer.Options,System.Action{Microsoft.ML.Trainers.LinearMulticlassModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="SdcaNonCalibrated&lt;TVal&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;float&gt;,Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt;&gt; SdcaNonCalibrated&lt;TVal&gt; (this Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers catalog, Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.Trainers.ISupportSdcaClassificationLoss lossFunction, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, Nullable&lt;float&gt; l2Regularization = null, Nullable&lt;float&gt; l1Threshold = null, Nullable&lt;int&gt; numberOfIterations = null, Action&lt;Microsoft.ML.Trainers.LinearMulticlassModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt;&gt; SdcaNonCalibrated&lt;TVal&gt;(class Microsoft.ML.MulticlassClassificationCatalog/MulticlassClassificationTrainers catalog, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.Trainers.ISupportSdcaClassificationLoss lossFunction, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, valuetype System.Nullable`1&lt;float32&gt; l2Regularization, valuetype System.Nullable`1&lt;float32&gt; l1Threshold, valuetype System.Nullable`1&lt;int32&gt; numberOfIterations, class System.Action`1&lt;class Microsoft.ML.Trainers.LinearMulticlassModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.SdcaNonCalibrated``1(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.Trainers.ISupportSdcaClassificationLoss,Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Trainers.LinearMulticlassModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SdcaNonCalibrated(Of TVal) (catalog As MulticlassClassificationCatalog.MulticlassClassificationTrainers, label As Key(Of UInteger, TVal), features As Vector(Of Single), lossFunction As ISupportSdcaClassificationLoss, Optional weights As Scalar(Of Single) = null, Optional l2Regularization As Nullable(Of Single) = null, Optional l1Threshold As Nullable(Of Single) = null, Optional numberOfIterations As Nullable(Of Integer) = null, Optional onFit As Action(Of LinearMulticlassModelParameters) = null) As ValueTuple(Of Vector(Of Single), Key(Of UInteger, TVal))" />
        <MemberSignature Language="F#" Value="static member SdcaNonCalibrated : Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers * Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.Trainers.ISupportSdcaClassificationLoss * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;int&gt; * Action&lt;Microsoft.ML.Trainers.LinearMulticlassModelParameters&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;single&gt;, Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt;&gt;" Usage="Microsoft.ML.StaticPipe.SdcaStaticExtensions.SdcaNonCalibrated (catalog, label, features, lossFunction, weights, l2Regularization, l1Threshold, numberOfIterations, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TVal" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.MulticlassClassificationCatalog+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="lossFunction" Type="Microsoft.ML.Trainers.ISupportSdcaClassificationLoss" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="l2Regularization" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="l1Threshold" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="numberOfIterations" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.LinearMulticlassModelParameters&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TVal">To be added.</typeparam>
          <param name="catalog">The multiclass classification catalog trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="lossFunction">The custom loss, for example, <see cref="T:Microsoft.ML.Trainers.HingeLoss" />.</param>
          <param name="weights">The optional example weights.</param>
          <param name="l2Regularization">The L2 regularization hyperparameter.</param>
          <param name="l1Threshold">The L1 regularization hyperparameter. Higher values will tend to lead to more sparse model.</param>
          <param name="numberOfIterations">The maximum number of passes to perform over the data.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear multiclass classification model trained with the SDCA trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.SdcaStaticExtensions" Member="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.SdcaNonCalibrated``1(Microsoft.ML.MulticlassClassificationCatalog.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.Trainers.ISupportSdcaClassificationLoss,Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Trainers.LinearMulticlassModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="StochasticGradientDescentClassificationTrainer">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; StochasticGradientDescentClassificationTrainer (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights, Microsoft.ML.Trainers.SgdCalibratedTrainer.Options options, Action&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; StochasticGradientDescentClassificationTrainer(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, class Microsoft.ML.Trainers.SgdCalibratedTrainer/Options options, class System.Action`1&lt;class Microsoft.ML.Calibrators.CalibratedModelParametersBase`2&lt;class Microsoft.ML.Trainers.LinearBinaryModelParameters, class Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.SgdStaticExtensions.StochasticGradientDescentClassificationTrainer(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.SgdCalibratedTrainer.Options,System.Action{Microsoft.ML.Calibrators.CalibratedModelParametersBase{Microsoft.ML.Trainers.LinearBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator}})" />
        <MemberSignature Language="F#" Value="static member StochasticGradientDescentClassificationTrainer : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.Trainers.SgdCalibratedTrainer.Options * Action&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters, Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.SgdStaticExtensions.StochasticGradientDescentClassificationTrainer (catalog, label, features, weights, options, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "probability", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.SgdCalibratedTrainer+Options" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="label">The name of the label column.</param>
          <param name="features">The name of the feature column.</param>
          <param name="weights">The name for the example weight column.</param>
          <param name="options">Advanced arguments to the algorithm.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained.  Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
             Predict a target using logistic regression trained with the <see cref="T:Microsoft.ML.Trainers.SgdCalibratedTrainer" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.SgdStaticExtensions" Member="M:Microsoft.ML.StaticPipe.SgdStaticExtensions.StochasticGradientDescentClassificationTrainer(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.SgdCalibratedTrainer.Options,System.Action{Microsoft.ML.Calibrators.CalibratedModelParametersBase{Microsoft.ML.Trainers.LinearBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="StochasticGradientDescentClassificationTrainer">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; StochasticGradientDescentClassificationTrainer (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, int numberOfIterations = 20, double learningRate = 0.01, float l2Regularization = 1E-06, Action&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; StochasticGradientDescentClassificationTrainer(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, int32 numberOfIterations, float64 learningRate, float32 l2Regularization, class System.Action`1&lt;class Microsoft.ML.Calibrators.CalibratedModelParametersBase`2&lt;class Microsoft.ML.Trainers.LinearBinaryModelParameters, class Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.SgdStaticExtensions.StochasticGradientDescentClassificationTrainer(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Double,System.Single,System.Action{Microsoft.ML.Calibrators.CalibratedModelParametersBase{Microsoft.ML.Trainers.LinearBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function StochasticGradientDescentClassificationTrainer (catalog As BinaryClassificationCatalog.BinaryClassificationTrainers, label As Scalar(Of Boolean), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional numberOfIterations As Integer = 20, Optional learningRate As Double = 0.01, Optional l2Regularization As Single = 1E-06, Optional onFit As Action(Of CalibratedModelParametersBase(Of LinearBinaryModelParameters, PlattCalibrator)) = null) As ValueTuple(Of Scalar(Of Single), Scalar(Of Single), Scalar(Of Boolean))" />
        <MemberSignature Language="F#" Value="static member StochasticGradientDescentClassificationTrainer : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * int * double * single * Action&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters, Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.SgdStaticExtensions.StochasticGradientDescentClassificationTrainer (catalog, label, features, weights, numberOfIterations, learningRate, l2Regularization, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "probability", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="numberOfIterations" Type="System.Int32" />
          <Parameter Name="learningRate" Type="System.Double" />
          <Parameter Name="l2Regularization" Type="System.Single" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="label">The name of the label column.</param>
          <param name="features">The name of the feature column.</param>
          <param name="weights">The name for the example weight column.</param>
          <param name="numberOfIterations">The maximum number of iterations; set to 1 to simulate online learning.</param>
          <param name="learningRate">The initial <a href="tmpurl_lr">learning rate</a> used by SGD.</param>
          <param name="l2Regularization">The L2 weight for <a href="tmpurl_regularization">regularization</a>.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained.  Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
             Predict a target using logistic regression trained with the <see cref="T:Microsoft.ML.Trainers.SgdCalibratedTrainer" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.SgdStaticExtensions" Member="M:Microsoft.ML.StaticPipe.SgdStaticExtensions.StochasticGradientDescentClassificationTrainer(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Double,System.Single,System.Action{Microsoft.ML.Calibrators.CalibratedModelParametersBase{Microsoft.ML.Trainers.LinearBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="StochasticGradientDescentNonCalibratedClassificationTrainer">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; StochasticGradientDescentNonCalibratedClassificationTrainer (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights, Microsoft.ML.Trainers.SgdNonCalibratedTrainer.Options options, Action&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; StochasticGradientDescentNonCalibratedClassificationTrainer(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, class Microsoft.ML.Trainers.SgdNonCalibratedTrainer/Options options, class System.Action`1&lt;class Microsoft.ML.Trainers.LinearBinaryModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.SgdStaticExtensions.StochasticGradientDescentNonCalibratedClassificationTrainer(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.SgdNonCalibratedTrainer.Options,System.Action{Microsoft.ML.Trainers.LinearBinaryModelParameters})" />
        <MemberSignature Language="F#" Value="static member StochasticGradientDescentNonCalibratedClassificationTrainer : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.Trainers.SgdNonCalibratedTrainer.Options * Action&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.SgdStaticExtensions.StochasticGradientDescentNonCalibratedClassificationTrainer (catalog, label, features, weights, options, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.SgdNonCalibratedTrainer+Options" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="label">The name of the label column.</param>
          <param name="features">The name of the feature column.</param>
          <param name="weights">The name for the example weight column.</param>
          <param name="options">Advanced arguments to the algorithm.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained.  Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
             Predict a target using a linear classification model trained with the <see cref="T:Microsoft.ML.Trainers.SgdNonCalibratedTrainer" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.SgdStaticExtensions" Member="M:Microsoft.ML.StaticPipe.SgdStaticExtensions.StochasticGradientDescentNonCalibratedClassificationTrainer(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.SgdNonCalibratedTrainer.Options,System.Action{Microsoft.ML.Trainers.LinearBinaryModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="StochasticGradientDescentNonCalibratedClassificationTrainer">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; StochasticGradientDescentNonCalibratedClassificationTrainer (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, int numberOfIterations = 20, double learningRate = 0.01, float l2Regularization = 1E-06, Microsoft.ML.Trainers.IClassificationLoss lossFunction = null, Action&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; StochasticGradientDescentNonCalibratedClassificationTrainer(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, int32 numberOfIterations, float64 learningRate, float32 l2Regularization, class Microsoft.ML.Trainers.IClassificationLoss lossFunction, class System.Action`1&lt;class Microsoft.ML.Trainers.LinearBinaryModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.SgdStaticExtensions.StochasticGradientDescentNonCalibratedClassificationTrainer(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Double,System.Single,Microsoft.ML.Trainers.IClassificationLoss,System.Action{Microsoft.ML.Trainers.LinearBinaryModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function StochasticGradientDescentNonCalibratedClassificationTrainer (catalog As BinaryClassificationCatalog.BinaryClassificationTrainers, label As Scalar(Of Boolean), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional numberOfIterations As Integer = 20, Optional learningRate As Double = 0.01, Optional l2Regularization As Single = 1E-06, Optional lossFunction As IClassificationLoss = null, Optional onFit As Action(Of LinearBinaryModelParameters) = null) As ValueTuple(Of Scalar(Of Single), Scalar(Of Boolean))" />
        <MemberSignature Language="F#" Value="static member StochasticGradientDescentNonCalibratedClassificationTrainer : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * int * double * single * Microsoft.ML.Trainers.IClassificationLoss * Action&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.SgdStaticExtensions.StochasticGradientDescentNonCalibratedClassificationTrainer (catalog, label, features, weights, numberOfIterations, learningRate, l2Regularization, lossFunction, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="numberOfIterations" Type="System.Int32" />
          <Parameter Name="learningRate" Type="System.Double" />
          <Parameter Name="l2Regularization" Type="System.Single" />
          <Parameter Name="lossFunction" Type="Microsoft.ML.Trainers.IClassificationLoss" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.LinearBinaryModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The binary classification catalog trainer object.</param>
          <param name="label">The name of the label column.</param>
          <param name="features">The name of the feature column.</param>
          <param name="weights">The name for the example weight column.</param>
          <param name="numberOfIterations">The maximum number of iterations; set to 1 to simulate online learning.</param>
          <param name="learningRate">The initial <a href="tmpurl_lr">learning rate</a> used by SGD.</param>
          <param name="l2Regularization">The L2 weight for <a href="tmpurl_regularization">regularization</a>.</param>
          <param name="lossFunction">The loss function to use.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained.  Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
             Predict a target using a linear classification model trained with the <see cref="T:Microsoft.ML.Trainers.SgdNonCalibratedTrainer" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.SgdStaticExtensions" Member="M:Microsoft.ML.StaticPipe.SgdStaticExtensions.StochasticGradientDescentNonCalibratedClassificationTrainer(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Double,System.Single,Microsoft.ML.Trainers.IClassificationLoss,System.Action{Microsoft.ML.Trainers.LinearBinaryModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IDataView" />
      </Targets>
      <Member MemberName="AssertStatic&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.DataView&lt;T&gt; AssertStatic&lt;T&gt; (this Microsoft.ML.IDataView view, Microsoft.ML.Runtime.IHostEnvironment env, Func&lt;Microsoft.ML.StaticPipe.SchemaAssertionContext,T&gt; outputDecl);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt; AssertStatic&lt;T&gt;(class Microsoft.ML.IDataView view, class Microsoft.ML.Runtime.IHostEnvironment env, class System.Func`2&lt;class Microsoft.ML.StaticPipe.SchemaAssertionContext, !!T&gt; outputDecl) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``1(Microsoft.ML.IDataView,Microsoft.ML.Runtime.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.SchemaAssertionContext,``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AssertStatic(Of T) (view As IDataView, env As IHostEnvironment, outputDecl As Func(Of SchemaAssertionContext, T)) As DataView(Of T)" />
        <MemberSignature Language="F#" Value="static member AssertStatic : Microsoft.ML.IDataView * Microsoft.ML.Runtime.IHostEnvironment * Func&lt;Microsoft.ML.StaticPipe.SchemaAssertionContext, 'T&gt; -&gt; Microsoft.ML.StaticPipe.DataView&lt;'T&gt;" Usage="Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic (view, env, outputDecl)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.DataView&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet-preview">
                <AttributeName>Microsoft.ML.StaticPipe.IsShape</AttributeName>
              </Attribute>
            </Attributes>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="view" Type="Microsoft.ML.IDataView" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
          <Parameter Name="outputDecl" Type="System.Func&lt;Microsoft.ML.StaticPipe.SchemaAssertionContext,T&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="T">The type representing the view's schema shape</typeparam>
          <param name="view">The view to assert the static schema on</param>
          <param name="env">The host environment to keep in the statically typed variant</param>
          <param name="outputDecl">The delegate through which we declare the schema, which ought to
            use the input <see cref="T:Microsoft.ML.StaticPipe.SchemaAssertionContext" /> to declare a <see cref="T:System.ValueTuple" />
            of the <see cref="T:Microsoft.ML.StaticPipe.PipelineColumn" /> indices, properly named</param>
          <summary>
            Asserts that a given data view has the indicated schema. If this method returns without
            throwing then the view has been validated to have columns with the indicated names and types.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.StaticPipeExtensions" Member="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``1(Microsoft.ML.IDataView,Microsoft.ML.Runtime.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.SchemaAssertionContext,``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IDataLoader`1" />
      </Targets>
      <Member MemberName="AssertStatic&lt;TIn,T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.DataLoader&lt;TIn,T&gt; AssertStatic&lt;TIn,T&gt; (this Microsoft.ML.IDataLoader&lt;TIn&gt; loader, Microsoft.ML.Runtime.IHostEnvironment env, Func&lt;Microsoft.ML.StaticPipe.SchemaAssertionContext,T&gt; outputDecl);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.DataLoader`2&lt;!!TIn, !!T&gt; AssertStatic&lt;TIn, T&gt;(class Microsoft.ML.IDataLoader`1&lt;!!TIn&gt; loader, class Microsoft.ML.Runtime.IHostEnvironment env, class System.Func`2&lt;class Microsoft.ML.StaticPipe.SchemaAssertionContext, !!T&gt; outputDecl) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``2(Microsoft.ML.IDataLoader{``0},Microsoft.ML.Runtime.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.SchemaAssertionContext,``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AssertStatic(Of TIn, T) (loader As IDataLoader(Of TIn), env As IHostEnvironment, outputDecl As Func(Of SchemaAssertionContext, T)) As DataLoader(Of TIn, T)" />
        <MemberSignature Language="F#" Value="static member AssertStatic : Microsoft.ML.IDataLoader&lt;'In&gt; * Microsoft.ML.Runtime.IHostEnvironment * Func&lt;Microsoft.ML.StaticPipe.SchemaAssertionContext, 'T&gt; -&gt; Microsoft.ML.StaticPipe.DataLoader&lt;'In, 'T&gt;" Usage="Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic (loader, env, outputDecl)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.DataLoader&lt;TIn,T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TIn" />
          <TypeParameter Name="T">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet-preview">
                <AttributeName>Microsoft.ML.StaticPipe.IsShape</AttributeName>
              </Attribute>
            </Attributes>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="loader" Type="Microsoft.ML.IDataLoader&lt;TIn&gt;" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
          <Parameter Name="outputDecl" Type="System.Func&lt;Microsoft.ML.StaticPipe.SchemaAssertionContext,T&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TIn">To be added.</typeparam>
          <typeparam name="T">To be added.</typeparam>
          <param name="loader">To be added.</param>
          <param name="env">To be added.</param>
          <param name="outputDecl">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.StaticPipeExtensions" Member="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``2(Microsoft.ML.IDataLoader{``0},Microsoft.ML.Runtime.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.SchemaAssertionContext,``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.ITransformer" />
      </Targets>
      <Member MemberName="AssertStatic&lt;TIn,TOut,TTrans&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Transformer&lt;TIn,TOut,TTrans&gt; AssertStatic&lt;TIn,TOut,TTrans&gt; (this TTrans transformer, Microsoft.ML.Runtime.IHostEnvironment env, Func&lt;Microsoft.ML.StaticPipe.SchemaAssertionContext,TIn&gt; inputDecl, Func&lt;Microsoft.ML.StaticPipe.SchemaAssertionContext,TOut&gt; outputDecl) where TTrans : class, Microsoft.ML.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Transformer`3&lt;!!TIn, !!TOut, !!TTrans&gt; AssertStatic&lt;TIn, TOut, class (class Microsoft.ML.ITransformer) TTrans&gt;(!!TTrans transformer, class Microsoft.ML.Runtime.IHostEnvironment env, class System.Func`2&lt;class Microsoft.ML.StaticPipe.SchemaAssertionContext, !!TIn&gt; inputDecl, class System.Func`2&lt;class Microsoft.ML.StaticPipe.SchemaAssertionContext, !!TOut&gt; outputDecl) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``3(``2,Microsoft.ML.Runtime.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.SchemaAssertionContext,``0},System.Func{Microsoft.ML.StaticPipe.SchemaAssertionContext,``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AssertStatic(Of TIn, TOut, TTrans) (transformer As TTrans, env As IHostEnvironment, inputDecl As Func(Of SchemaAssertionContext, TIn), outputDecl As Func(Of SchemaAssertionContext, TOut)) As Transformer(Of TIn, TOut, TTrans)" />
        <MemberSignature Language="F#" Value="static member AssertStatic : 'rans * Microsoft.ML.Runtime.IHostEnvironment * Func&lt;Microsoft.ML.StaticPipe.SchemaAssertionContext, 'In&gt; * Func&lt;Microsoft.ML.StaticPipe.SchemaAssertionContext, 'Out&gt; -&gt; Microsoft.ML.StaticPipe.Transformer&lt;'In, 'Out, 'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.ITransformer)&gt; (requires 'rans : null and 'rans :&gt; Microsoft.ML.ITransformer)" Usage="Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic (transformer, env, inputDecl, outputDecl)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Transformer&lt;TIn,TOut,TTrans&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TIn">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet-preview">
                <AttributeName>Microsoft.ML.StaticPipe.IsShape</AttributeName>
              </Attribute>
            </Attributes>
          </TypeParameter>
          <TypeParameter Name="TOut">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet-preview">
                <AttributeName>Microsoft.ML.StaticPipe.IsShape</AttributeName>
              </Attribute>
            </Attributes>
          </TypeParameter>
          <TypeParameter Name="TTrans">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="transformer" Type="TTrans" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
          <Parameter Name="inputDecl" Type="System.Func&lt;Microsoft.ML.StaticPipe.SchemaAssertionContext,TIn&gt;" />
          <Parameter Name="outputDecl" Type="System.Func&lt;Microsoft.ML.StaticPipe.SchemaAssertionContext,TOut&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TIn">To be added.</typeparam>
          <typeparam name="TOut">To be added.</typeparam>
          <typeparam name="TTrans">To be added.</typeparam>
          <param name="transformer">To be added.</param>
          <param name="env">To be added.</param>
          <param name="inputDecl">To be added.</param>
          <param name="outputDecl">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.StaticPipeExtensions" Member="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``3(``2,Microsoft.ML.Runtime.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.SchemaAssertionContext,``0},System.Func{Microsoft.ML.StaticPipe.SchemaAssertionContext,``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IDataLoaderEstimator`2" />
      </Targets>
      <Member MemberName="AssertStatic&lt;TIn,T,TLoader&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.DataLoaderEstimator&lt;TIn,T,TLoader&gt; AssertStatic&lt;TIn,T,TLoader&gt; (this Microsoft.ML.IDataLoaderEstimator&lt;TIn,TLoader&gt; loaderEstimator, Microsoft.ML.Runtime.IHostEnvironment env, Func&lt;Microsoft.ML.StaticPipe.SchemaAssertionContext,T&gt; outputDecl) where TLoader : class, Microsoft.ML.IDataLoader&lt;TIn&gt;;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.DataLoaderEstimator`3&lt;!!TIn, !!T, !!TLoader&gt; AssertStatic&lt;TIn, T, class (class Microsoft.ML.IDataLoader`1&lt;!!TIn&gt;) TLoader&gt;(class Microsoft.ML.IDataLoaderEstimator`2&lt;!!TIn, !!TLoader&gt; loaderEstimator, class Microsoft.ML.Runtime.IHostEnvironment env, class System.Func`2&lt;class Microsoft.ML.StaticPipe.SchemaAssertionContext, !!T&gt; outputDecl) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``3(Microsoft.ML.IDataLoaderEstimator{``0,``2},Microsoft.ML.Runtime.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.SchemaAssertionContext,``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AssertStatic(Of TIn, T, TLoader) (loaderEstimator As IDataLoaderEstimator(Of TIn, TLoader), env As IHostEnvironment, outputDecl As Func(Of SchemaAssertionContext, T)) As DataLoaderEstimator(Of TIn, T, TLoader)" />
        <MemberSignature Language="F#" Value="static member AssertStatic : Microsoft.ML.IDataLoaderEstimator&lt;'In, 'Loader (requires 'Loader : null and 'Loader :&gt; Microsoft.ML.IDataLoader&lt;'In&gt;)&gt; * Microsoft.ML.Runtime.IHostEnvironment * Func&lt;Microsoft.ML.StaticPipe.SchemaAssertionContext, 'T&gt; -&gt; Microsoft.ML.StaticPipe.DataLoaderEstimator&lt;'In, 'T, 'Loader (requires 'Loader : null and 'Loader :&gt; Microsoft.ML.IDataLoader&lt;'In&gt;)&gt; (requires 'Loader : null and 'Loader :&gt; Microsoft.ML.IDataLoader&lt;'In&gt;)" Usage="Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic (loaderEstimator, env, outputDecl)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.DataLoaderEstimator&lt;TIn,T,TLoader&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TIn" />
          <TypeParameter Name="T">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet-preview">
                <AttributeName>Microsoft.ML.StaticPipe.IsShape</AttributeName>
              </Attribute>
            </Attributes>
          </TypeParameter>
          <TypeParameter Name="TLoader">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.IDataLoader&lt;TIn&gt;</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="loaderEstimator" Type="Microsoft.ML.IDataLoaderEstimator&lt;TIn,TLoader&gt;" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
          <Parameter Name="outputDecl" Type="System.Func&lt;Microsoft.ML.StaticPipe.SchemaAssertionContext,T&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TIn">To be added.</typeparam>
          <typeparam name="T">To be added.</typeparam>
          <typeparam name="TLoader">To be added.</typeparam>
          <param name="loaderEstimator">To be added.</param>
          <param name="env">To be added.</param>
          <param name="outputDecl">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.StaticPipeExtensions" Member="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``3(Microsoft.ML.IDataLoaderEstimator{``0,``2},Microsoft.ML.Runtime.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.SchemaAssertionContext,``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IEstimator`1" />
      </Targets>
      <Member MemberName="AssertStatic&lt;TIn,TOut,TTrans&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Estimator&lt;TIn,TOut,TTrans&gt; AssertStatic&lt;TIn,TOut,TTrans&gt; (this Microsoft.ML.IEstimator&lt;TTrans&gt; estimator, Microsoft.ML.Runtime.IHostEnvironment env, Func&lt;Microsoft.ML.StaticPipe.SchemaAssertionContext,TIn&gt; inputDecl, Func&lt;Microsoft.ML.StaticPipe.SchemaAssertionContext,TOut&gt; outputDecl) where TTrans : class, Microsoft.ML.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Estimator`3&lt;!!TIn, !!TOut, !!TTrans&gt; AssertStatic&lt;TIn, TOut, class (class Microsoft.ML.ITransformer) TTrans&gt;(class Microsoft.ML.IEstimator`1&lt;!!TTrans&gt; estimator, class Microsoft.ML.Runtime.IHostEnvironment env, class System.Func`2&lt;class Microsoft.ML.StaticPipe.SchemaAssertionContext, !!TIn&gt; inputDecl, class System.Func`2&lt;class Microsoft.ML.StaticPipe.SchemaAssertionContext, !!TOut&gt; outputDecl) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``3(Microsoft.ML.IEstimator{``2},Microsoft.ML.Runtime.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.SchemaAssertionContext,``0},System.Func{Microsoft.ML.StaticPipe.SchemaAssertionContext,``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AssertStatic(Of TIn, TOut, TTrans) (estimator As IEstimator(Of TTrans), env As IHostEnvironment, inputDecl As Func(Of SchemaAssertionContext, TIn), outputDecl As Func(Of SchemaAssertionContext, TOut)) As Estimator(Of TIn, TOut, TTrans)" />
        <MemberSignature Language="F#" Value="static member AssertStatic : Microsoft.ML.IEstimator&lt;'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.ITransformer)&gt; * Microsoft.ML.Runtime.IHostEnvironment * Func&lt;Microsoft.ML.StaticPipe.SchemaAssertionContext, 'In&gt; * Func&lt;Microsoft.ML.StaticPipe.SchemaAssertionContext, 'Out&gt; -&gt; Microsoft.ML.StaticPipe.Estimator&lt;'In, 'Out, 'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.ITransformer)&gt; (requires 'rans : null and 'rans :&gt; Microsoft.ML.ITransformer)" Usage="Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic (estimator, env, inputDecl, outputDecl)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Estimator&lt;TIn,TOut,TTrans&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TIn">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet-preview">
                <AttributeName>Microsoft.ML.StaticPipe.IsShape</AttributeName>
              </Attribute>
            </Attributes>
          </TypeParameter>
          <TypeParameter Name="TOut">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet-preview">
                <AttributeName>Microsoft.ML.StaticPipe.IsShape</AttributeName>
              </Attribute>
            </Attributes>
          </TypeParameter>
          <TypeParameter Name="TTrans">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="estimator" Type="Microsoft.ML.IEstimator&lt;TTrans&gt;" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
          <Parameter Name="inputDecl" Type="System.Func&lt;Microsoft.ML.StaticPipe.SchemaAssertionContext,TIn&gt;" />
          <Parameter Name="outputDecl" Type="System.Func&lt;Microsoft.ML.StaticPipe.SchemaAssertionContext,TOut&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TIn">To be added.</typeparam>
          <typeparam name="TOut">To be added.</typeparam>
          <typeparam name="TTrans">To be added.</typeparam>
          <param name="estimator">To be added.</param>
          <param name="env">To be added.</param>
          <param name="inputDecl">To be added.</param>
          <param name="outputDecl">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.StaticPipeExtensions" Member="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``3(Microsoft.ML.IEstimator{``2},Microsoft.ML.Runtime.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.SchemaAssertionContext,``0},System.Func{Microsoft.ML.StaticPipe.SchemaAssertionContext,``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="RemoveDefaultStopWords">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;string&gt; RemoveDefaultStopWords (this Microsoft.ML.StaticPipe.VarVector&lt;string&gt; input, Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator.Language language = Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator+Language.English);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;string&gt; RemoveDefaultStopWords(class Microsoft.ML.StaticPipe.VarVector`1&lt;string&gt; input, valuetype Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator/Language language) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.StopwordRemoverStaticExtensions.RemoveDefaultStopWords(Microsoft.ML.StaticPipe.VarVector{System.String},Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator.Language)" />
        <MemberSignature Language="F#" Value="static member RemoveDefaultStopWords : Microsoft.ML.StaticPipe.VarVector&lt;string&gt; * Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator.Language -&gt; Microsoft.ML.StaticPipe.VarVector&lt;string&gt;" Usage="Microsoft.ML.StaticPipe.StopwordRemoverStaticExtensions.RemoveDefaultStopWords (input, language)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.String&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.String&gt;" RefType="this" />
          <Parameter Name="language" Type="Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator+Language" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="language">Langauge of the input text. It will be used to retrieve a built-in stopword list.</param>
          <summary>
            Remove stop words from incoming text.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.StopwordRemoverStaticExtensions" Member="M:Microsoft.ML.StaticPipe.StopwordRemoverStaticExtensions.RemoveDefaultStopWords(Microsoft.ML.StaticPipe.VarVector{System.String},Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator.Language)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,bool&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;bool&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, bool&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;bool&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Boolean})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;bool&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, bool&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Boolean&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Boolean&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Boolean}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,byte&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;byte&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;byte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int8&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;unsigned int8&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;unsigned int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Byte},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Byte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;byte&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;byte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, byte&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Byte&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Byte&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Byte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Byte},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Byte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,double&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;double&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;double&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float64&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;float64&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;float64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Double},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Double})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;double&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;double&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, double&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Double&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Double},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Double}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,short&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;short&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;short&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int16&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;int16&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Int16},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Int16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;int16&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;int16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, int16&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int16&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Int16&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Int16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Int16},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Int16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,int&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;int&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;int&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int32&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;int32&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Int32},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Int32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;int&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;int&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, int&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int32&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Int32&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Int32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Int32},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Int32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,long&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;long&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;long&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int64&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;int64&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Int64},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Int64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;int64&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;int64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, int64&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int64&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Int64&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Int64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Int64},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Int64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,sbyte&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;sbyte&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;sbyte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int8&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;int8&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.SByte},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.SByte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;sbyte&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;sbyte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, sbyte&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.SByte&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.SByte&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.SByte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.SByte},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.SByte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,float&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;float&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;float&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float32&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;float32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Single})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;single&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, single&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Single&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Single}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,string&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, string&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.ReadOnlyMemory{System.Char}})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, string&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.String&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because the empty string is never entered into the dictionary, it will always map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,ushort&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;ushort&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ushort&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int16&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;unsigned int16&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;unsigned int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.UInt16},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.UInt16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;uint16&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;uint16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, uint16&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt16&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.UInt16&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.UInt16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.UInt16},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.UInt16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,uint&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;uint&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;uint&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int32&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;unsigned int32&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;unsigned int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.UInt32},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.UInt32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;uint32&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;uint32&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, uint32&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt32&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.UInt32&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.UInt32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.UInt32},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.UInt32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,ulong&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;ulong&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ulong&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int64&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;unsigned int64&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;unsigned int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.UInt64},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.UInt64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;uint64&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;uint64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, uint64&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt64&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.UInt64&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.UInt64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.UInt64},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.UInt64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,bool&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;bool&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;bool&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, bool&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;bool&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;bool&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Boolean},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Boolean})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;bool&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;bool&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Boolean&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Boolean&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Boolean&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Boolean},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Boolean}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,byte&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;byte&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;byte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int8&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;unsigned int8&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;unsigned int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Byte},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Byte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;byte&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;byte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, byte&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Byte&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Byte&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Byte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Byte},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Byte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,double&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;double&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;double&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float64&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;float64&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;float64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Double},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Double})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;double&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;double&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, double&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Double&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Double&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Double},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Double}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,short&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;short&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;short&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int16&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;int16&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Int16},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Int16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;int16&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;int16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int16&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int16&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Int16&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Int16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Int16},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Int16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,int&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;int&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;int&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int32&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;int32&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Int32},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Int32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;int&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;int&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int32&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Int32&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Int32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Int32},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Int32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,long&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;long&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;long&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int64&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;int64&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Int64},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Int64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;int64&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;int64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int64&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int64&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Int64&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Int64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Int64},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Int64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,sbyte&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;sbyte&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;sbyte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int8&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;int8&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.SByte},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.SByte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;sbyte&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;sbyte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, sbyte&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.SByte&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.SByte&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.SByte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.SByte},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.SByte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,float&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;float&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;float&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float32&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;float32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Single},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Single})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;single&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;single&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, single&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Single&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Single&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Single},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Single}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,string&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;string&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, string&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;string&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.String},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.ReadOnlyMemory{System.Char}})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;string&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, string&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.String&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.String&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because the empty string is never entered into the dictionary, it will always map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.String},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,ushort&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;ushort&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ushort&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int16&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;unsigned int16&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;unsigned int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.UInt16},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.UInt16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;uint16&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;uint16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint16&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt16&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.UInt16&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.UInt16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.UInt16},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.UInt16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,uint&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;uint&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;uint&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int32&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;unsigned int32&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;unsigned int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.UInt32},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.UInt32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;uint32&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;uint32&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint32&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt32&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.UInt32&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.UInt32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.UInt32},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.UInt32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,ulong&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;ulong&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ulong&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int64&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;unsigned int64&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;unsigned int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.UInt64},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.UInt64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;uint64&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;uint64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint64&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt64&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.UInt64&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.UInt64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.UInt64},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.UInt64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,bool&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;bool&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;bool&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, bool&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;bool&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;bool&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Boolean},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Boolean})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;bool&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;bool&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Boolean&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Boolean&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Boolean&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Boolean},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Boolean}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,byte&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;byte&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;byte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int8&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;unsigned int8&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;unsigned int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Byte},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Byte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;byte&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;byte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, byte&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Byte&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Byte&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Byte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Byte},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Byte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,double&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;double&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float64&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;float64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Double},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Double})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;double&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, double&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Double&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Double&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Double},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Double}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,short&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;short&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;short&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int16&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;int16&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Int16},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Int16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;int16&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;int16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int16&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int16&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Int16&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Int16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Int16},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Int16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,int&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;int&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;int&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int32&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;int32&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Int32},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Int32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;int&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;int&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int32&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Int32&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Int32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Int32},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Int32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,long&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;long&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;long&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int64&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;int64&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Int64},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Int64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;int64&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;int64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int64&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int64&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Int64&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Int64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Int64},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Int64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,sbyte&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;sbyte&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;sbyte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int8&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;int8&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.SByte},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.SByte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;sbyte&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;sbyte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, sbyte&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.SByte&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.SByte&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.SByte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.SByte},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.SByte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,float&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;float&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float32&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;float32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Single})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;single&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, single&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Single&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Single&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Single}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,string&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;string&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, string&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;string&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.String},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.ReadOnlyMemory{System.Char}})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;string&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, string&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.String&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.String&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because the empty string is never entered into the dictionary, it will always map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.String},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,ushort&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;ushort&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ushort&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int16&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;unsigned int16&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;unsigned int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.UInt16},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.UInt16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;uint16&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;uint16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint16&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt16&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.UInt16&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.UInt16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.UInt16},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.UInt16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,uint&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;uint&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;uint&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int32&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;unsigned int32&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;unsigned int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.UInt32},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.UInt32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;uint32&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;uint32&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint32&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt32&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.UInt32&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.UInt32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.UInt32},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.UInt32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,ulong&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;ulong&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ulong&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int64&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;unsigned int64&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;unsigned int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.UInt64},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.UInt64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;uint64&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;uint64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint64&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt64&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.UInt64&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.UInt64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.UInt64},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.UInt64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,bool&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,bool&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;bool&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, bool&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, bool&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;bool&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Boolean},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Boolean})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, bool&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;bool&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, bool&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Boolean&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.Boolean&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Boolean&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Boolean},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Boolean}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,byte&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,byte&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;byte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int8&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int8&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;unsigned int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Byte},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Byte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, byte&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;byte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, byte&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Byte&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.Byte&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Byte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Byte},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Byte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,double&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,double&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;double&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float64&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, float64&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;float64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Double},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Double})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, double&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;double&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, double&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Double&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.Double&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Double&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Double},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Double}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,short&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,short&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;short&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int16&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int16&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Int16},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Int16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, int16&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;int16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, int16&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int16&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.Int16&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Int16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Int16},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Int16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,int&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,int&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;int&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int32&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int32&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Int32},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Int32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, int&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;int&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, int&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int32&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.Int32&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Int32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Int32},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Int32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,long&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,long&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;long&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int64&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int64&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Int64},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Int64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, int64&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;int64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, int64&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int64&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.Int64&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Int64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Int64},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Int64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,sbyte&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,sbyte&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;sbyte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int8&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int8&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.SByte},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.SByte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, sbyte&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;sbyte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, sbyte&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.SByte&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.SByte&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.SByte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.SByte},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.SByte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,float&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,float&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;float&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float32&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, float32&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;float32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Single},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Single})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, single&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;single&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, single&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.Single&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Single&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Single},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Single}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,string&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,string&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, string&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, string&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.String},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.ReadOnlyMemory{System.Char}})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, string&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, string&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.String&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.String&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because the empty string is never entered into the dictionary, it will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.String},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,ushort&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,ushort&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ushort&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int16&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int16&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;unsigned int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.UInt16},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.UInt16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, uint16&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;uint16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, uint16&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt16&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.UInt16&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.UInt16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.UInt16},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.UInt16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,uint&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,uint&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;uint&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int32&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int32&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;unsigned int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.UInt32},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.UInt32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, uint32&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;uint32&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, uint32&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt32&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.UInt32&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.UInt32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.UInt32},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.UInt32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,ulong&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,ulong&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ulong&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int64&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int64&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;unsigned int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.UInt64},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.UInt64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, uint64&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;uint64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, uint64&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt64&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.UInt64&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.UInt64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.UInt64},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.UInt64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,bool&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,bool&gt;&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;bool&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, bool&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, bool&gt;&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;bool&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Boolean}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Boolean})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, bool&gt;&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;bool&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Boolean&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Boolean&gt;&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Boolean&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Boolean}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Boolean}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,byte&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,byte&gt;&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;byte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int8&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int8&gt;&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;unsigned int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Byte}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Byte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, byte&gt;&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;byte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, byte&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Byte&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Byte&gt;&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Byte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Byte}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Byte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,double&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,double&gt;&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;double&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float64&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, float64&gt;&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;float64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Double}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Double})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, double&gt;&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;double&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, double&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Double&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Double&gt;&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Double&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Double}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Double}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,short&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,short&gt;&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;short&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int16&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int16&gt;&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Int16}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Int16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, int16&gt;&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;int16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int16&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int16&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Int16&gt;&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Int16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Int16}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Int16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,int&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,int&gt;&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;int&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int32&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int32&gt;&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Int32}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Int32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, int&gt;&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;int&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int32&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Int32&gt;&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Int32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Int32}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Int32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,long&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,long&gt;&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;long&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int64&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int64&gt;&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Int64}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Int64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, int64&gt;&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;int64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int64&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int64&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Int64&gt;&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Int64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Int64}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Int64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,sbyte&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,sbyte&gt;&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;sbyte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int8&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int8&gt;&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.SByte}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.SByte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, sbyte&gt;&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;sbyte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, sbyte&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.SByte&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.SByte&gt;&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.SByte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.SByte}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.SByte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,float&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,float&gt;&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;float&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float32&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, float32&gt;&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;float32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Single}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Single})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, single&gt;&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;single&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, single&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Single&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Single&gt;&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Single&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Single}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Single}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,string&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,string&gt;&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, string&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, string&gt;&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.String}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.ReadOnlyMemory{System.Char}})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, string&gt;&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, string&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.String&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.String&gt;&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because the empty string is never entered into the dictionary, it will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.String}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,ushort&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,ushort&gt;&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ushort&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int16&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int16&gt;&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;unsigned int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.UInt16}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.UInt16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, uint16&gt;&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;uint16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint16&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt16&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.UInt16&gt;&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.UInt16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.UInt16}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.UInt16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,uint&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,uint&gt;&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;uint&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int32&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int32&gt;&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;unsigned int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.UInt32}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.UInt32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, uint32&gt;&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;uint32&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint32&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt32&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.UInt32&gt;&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.UInt32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.UInt32}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.UInt32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,ulong&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,ulong&gt;&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ulong&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int64&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int64&gt;&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;unsigned int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.UInt64}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.UInt64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, uint64&gt;&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;uint64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint64&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt64&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.UInt64&gt;&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.UInt64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.UInt64}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.UInt64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,bool&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,bool&gt;&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;bool&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, bool&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, bool&gt;&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;bool&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Boolean}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Boolean})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, bool&gt;&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;bool&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Boolean&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Boolean&gt;&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Boolean&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Boolean}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Boolean}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,byte&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,byte&gt;&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;byte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int8&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int8&gt;&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;unsigned int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Byte}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Byte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, byte&gt;&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;byte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, byte&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Byte&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Byte&gt;&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Byte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Byte}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Byte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,double&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,double&gt;&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;double&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float64&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, float64&gt;&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;float64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Double}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Double})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, double&gt;&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;double&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, double&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Double&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Double&gt;&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Double&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Double}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Double}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,short&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,short&gt;&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;short&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int16&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int16&gt;&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Int16}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Int16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, int16&gt;&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;int16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int16&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int16&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Int16&gt;&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Int16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Int16}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Int16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,int&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,int&gt;&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;int&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int32&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int32&gt;&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Int32}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Int32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, int&gt;&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;int&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int32&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Int32&gt;&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Int32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Int32}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Int32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,long&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,long&gt;&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;long&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int64&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int64&gt;&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Int64}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Int64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, int64&gt;&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;int64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int64&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int64&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Int64&gt;&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Int64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Int64}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Int64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,sbyte&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,sbyte&gt;&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;sbyte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int8&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int8&gt;&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.SByte}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.SByte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, sbyte&gt;&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;sbyte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, sbyte&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.SByte&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.SByte&gt;&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.SByte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.SByte}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.SByte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,float&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,float&gt;&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;float&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float32&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, float32&gt;&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;float32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Single}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.Single})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, single&gt;&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;single&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, single&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Single&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Single&gt;&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.Single&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Single}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.Single}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,string&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,string&gt;&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, string&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, string&gt;&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.String}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.ReadOnlyMemory{System.Char}})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, string&gt;&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, string&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.String&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.String&gt;&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because the empty string is never entered into the dictionary, it will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.String}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,ushort&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,ushort&gt;&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ushort&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int16&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int16&gt;&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;unsigned int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.UInt16}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.UInt16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, uint16&gt;&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;uint16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint16&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt16&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.UInt16&gt;&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.UInt16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.UInt16}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.UInt16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,uint&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,uint&gt;&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;uint&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int32&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int32&gt;&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;unsigned int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.UInt32}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.UInt32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, uint32&gt;&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;uint32&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint32&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt32&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.UInt32&gt;&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.UInt32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.UInt32}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.UInt32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,ulong&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,ulong&gt;&gt; input, Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality = Microsoft.ML.StaticPipe.KeyOrdinality.Occurence, int maxItems = 1000000, Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;ulong&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int64&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int64&gt;&gt; input, valuetype Microsoft.ML.StaticPipe.KeyOrdinality keyOrdinality, int32 maxItems, class Microsoft.ML.StaticPipe.TermStaticExtensions/ToKeyFitResult`1/OnFit&lt;unsigned int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.UInt64}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult`1.OnFit{System.UInt64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, uint64&gt;&gt; * Microsoft.ML.StaticPipe.KeyOrdinality * int * Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult&lt;uint64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint64&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, keyOrdinality, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt64&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.UInt64&gt;&gt;" RefType="this" />
          <Parameter Name="keyOrdinality" Type="Microsoft.ML.StaticPipe.KeyOrdinality" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.TermStaticExtensions+ToKeyFitResult&lt;System.UInt64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="keyOrdinality">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.UInt64}},Microsoft.ML.StaticPipe.KeyOrdinality,System.Int32,Microsoft.ML.StaticPipe.TermStaticExtensions.ToKeyFitResult{System.UInt64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="FeaturizeText">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; FeaturizeText (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, Microsoft.ML.StaticPipe.Scalar&lt;string&gt;[] otherInputs = null, Microsoft.ML.Transforms.Text.TextFeaturizingEstimator.Options options = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; FeaturizeText(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt;[] otherInputs, class Microsoft.ML.Transforms.Text.TextFeaturizingEstimator/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TextFeaturizerStaticExtensions.FeaturizeText(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.StaticPipe.Scalar{System.String}[],Microsoft.ML.Transforms.Text.TextFeaturizingEstimator.Options)" />
        <MemberSignature Language="F#" Value="static member FeaturizeText : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * Microsoft.ML.StaticPipe.Scalar&lt;string&gt;[] * Microsoft.ML.Transforms.Text.TextFeaturizingEstimator.Options -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.TextFeaturizerStaticExtensions.FeaturizeText (input, otherInputs, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="otherInputs" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;[]" />
          <Parameter Name="options" Type="Microsoft.ML.Transforms.Text.TextFeaturizingEstimator+Options" />
        </Parameters>
        <Docs>
          <param name="input">Input data.</param>
          <param name="otherInputs">Additional data.</param>
          <param name="options">Advanced transform settings.</param>
          <summary>
            Accept text data and converts it to array which represent combinations of ngram/skip-gram token counts.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TextFeaturizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TextFeaturizerStaticExtensions.FeaturizeText(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.StaticPipe.Scalar{System.String}[],Microsoft.ML.Transforms.Text.TextFeaturizingEstimator.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="NormalizeText">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;string&gt; NormalizeText (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, Microsoft.ML.Transforms.Text.TextNormalizingEstimator.CaseMode caseMode = Microsoft.ML.Transforms.Text.TextNormalizingEstimator+CaseMode.Lower, bool keepDiacritics = false, bool keepPunctuations = true, bool keepNumbers = true);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; NormalizeText(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, valuetype Microsoft.ML.Transforms.Text.TextNormalizingEstimator/CaseMode caseMode, bool keepDiacritics, bool keepPunctuations, bool keepNumbers) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TextNormalizerStaticExtensions.NormalizeText(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.Transforms.Text.TextNormalizingEstimator.CaseMode,System.Boolean,System.Boolean,System.Boolean)" />
        <MemberSignature Language="F#" Value="static member NormalizeText : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * Microsoft.ML.Transforms.Text.TextNormalizingEstimator.CaseMode * bool * bool * bool -&gt; Microsoft.ML.StaticPipe.Scalar&lt;string&gt;" Usage="Microsoft.ML.StaticPipe.TextNormalizerStaticExtensions.NormalizeText (input, caseMode, keepDiacritics, keepPunctuations, keepNumbers)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="caseMode" Type="Microsoft.ML.Transforms.Text.TextNormalizingEstimator+CaseMode" />
          <Parameter Name="keepDiacritics" Type="System.Boolean" />
          <Parameter Name="keepPunctuations" Type="System.Boolean" />
          <Parameter Name="keepNumbers" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="caseMode">Casing text using the rules of the invariant culture.</param>
          <param name="keepDiacritics">Whether to keep diacritical marks or remove them.</param>
          <param name="keepPunctuations">Whether to keep punctuation marks or remove them.</param>
          <param name="keepNumbers">Whether to keep numbers or remove them.</param>
          <summary>
            Normalizes input text by changing case, removing diacritical marks, punctuation marks and/or numbers.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TextNormalizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TextNormalizerStaticExtensions.NormalizeText(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.Transforms.Text.TextNormalizingEstimator.CaseMode,System.Boolean,System.Boolean,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog" />
      </Targets>
      <Member MemberName="CrossValidate&lt;TInShape,TOutShape,TTransformer&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.Data.CalibratedBinaryClassificationMetrics,Microsoft.ML.StaticPipe.Transformer&lt;TInShape,TOutShape,TTransformer&gt;,Microsoft.ML.StaticPipe.DataView&lt;TOutShape&gt;&gt;[] CrossValidate&lt;TInShape,TOutShape,TTransformer&gt; (this Microsoft.ML.BinaryClassificationCatalog catalog, Microsoft.ML.StaticPipe.DataView&lt;TInShape&gt; data, Microsoft.ML.StaticPipe.Estimator&lt;TInShape,TOutShape,TTransformer&gt; estimator, Func&lt;TOutShape,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; label, int numFolds = 5, Func&lt;TInShape,Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn = null, Nullable&lt;int&gt; seed = null) where TTransformer : class, Microsoft.ML.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.Data.CalibratedBinaryClassificationMetrics, class Microsoft.ML.StaticPipe.Transformer`3&lt;!!TInShape, !!TOutShape, !!TTransformer&gt;, class Microsoft.ML.StaticPipe.DataView`1&lt;!!TOutShape&gt;&gt;[] CrossValidate&lt;TInShape, TOutShape, class (class Microsoft.ML.ITransformer) TTransformer&gt;(class Microsoft.ML.BinaryClassificationCatalog catalog, class Microsoft.ML.StaticPipe.DataView`1&lt;!!TInShape&gt; data, class Microsoft.ML.StaticPipe.Estimator`3&lt;!!TInShape, !!TOutShape, !!TTransformer&gt; estimator, class System.Func`2&lt;!!TOutShape, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; label, int32 numFolds, class System.Func`2&lt;!!TInShape, class Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn, valuetype System.Nullable`1&lt;int32&gt; seed) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TrainingStaticExtensions.CrossValidate``3(Microsoft.ML.BinaryClassificationCatalog,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn},System.Nullable{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CrossValidate(Of TInShape, TOutShape, TTransformer) (catalog As BinaryClassificationCatalog, data As DataView(Of TInShape), estimator As Estimator(Of TInShape, TOutShape, TTransformer), label As Func(Of TOutShape, Scalar(Of Boolean)), Optional numFolds As Integer = 5, Optional stratificationColumn As Func(Of TInShape, PipelineColumn) = null, Optional seed As Nullable(Of Integer) = null) As ValueTuple(Of CalibratedBinaryClassificationMetrics, Transformer(Of TInShape, TOutShape, TTransformer), DataView(Of TOutShape))()" />
        <MemberSignature Language="F#" Value="static member CrossValidate : Microsoft.ML.BinaryClassificationCatalog * Microsoft.ML.StaticPipe.DataView&lt;'InShape&gt; * Microsoft.ML.StaticPipe.Estimator&lt;'InShape, 'OutShape, 'ransformer (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.ITransformer)&gt; * Func&lt;'OutShape, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; * int * Func&lt;'InShape, Microsoft.ML.StaticPipe.PipelineColumn&gt; * Nullable&lt;int&gt; -&gt; ValueTuple&lt;Microsoft.ML.Data.CalibratedBinaryClassificationMetrics, Microsoft.ML.StaticPipe.Transformer&lt;'InShape, 'OutShape, 'ransformer&gt;, Microsoft.ML.StaticPipe.DataView&lt;'OutShape&gt;&gt;[] (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.ITransformer)" Usage="Microsoft.ML.StaticPipe.TrainingStaticExtensions.CrossValidate (catalog, data, estimator, label, numFolds, stratificationColumn, seed)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.Data.CalibratedBinaryClassificationMetrics,Microsoft.ML.StaticPipe.Transformer&lt;TInShape,TOutShape,TTransformer&gt;,Microsoft.ML.StaticPipe.DataView&lt;TOutShape&gt;&gt;[]</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "metrics", "model", "scoredTestData" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TInShape" />
          <TypeParameter Name="TOutShape" />
          <TypeParameter Name="TTransformer">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;TInShape&gt;" />
          <Parameter Name="estimator" Type="Microsoft.ML.StaticPipe.Estimator&lt;TInShape,TOutShape,TTransformer&gt;" />
          <Parameter Name="label" Type="System.Func&lt;TOutShape,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;" />
          <Parameter Name="numFolds" Type="System.Int32" />
          <Parameter Name="stratificationColumn" Type="System.Func&lt;TInShape,Microsoft.ML.StaticPipe.PipelineColumn&gt;" />
          <Parameter Name="seed" Type="System.Nullable&lt;System.Int32&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TInShape">The input schema shape.</typeparam>
          <typeparam name="TOutShape">The output schema shape.</typeparam>
          <typeparam name="TTransformer">The type of the trained model.</typeparam>
          <param name="catalog">The training catalog.</param>
          <param name="data">The data to run cross-validation on.</param>
          <param name="estimator">The estimator to fit.</param>
          <param name="label">The label column (for evaluation).</param>
          <param name="numFolds">Number of cross-validation folds.</param>
          <param name="stratificationColumn">Optional selector for the column to use as a stratification column. If two examples share the same value of the <paramref name="stratificationColumn" />
            (if provided), they are guaranteed to appear in the same subset (train or test). Use this to make sure there is no label leakage from train to the test set.
            If this optional parameter is not provided, a stratification columns will be generated, and its values will be random numbers .</param>
          <param name="seed">Optional parameter used in combination with the <paramref name="stratificationColumn" />.
            If the <paramref name="stratificationColumn" /> is not provided, the random numbers generated to create it, will use this seed as value.
            And if it is not provided, the default value will be used.</param>
          <summary>
            Run cross-validation over <paramref name="numFolds" /> folds of <paramref name="data" />, by fitting <paramref name="estimator" />,
            and respecting <paramref name="stratificationColumn" /> if provided.
            Then evaluate each sub-model against <paramref name="label" /> and return metrics.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TrainingStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TrainingStaticExtensions.CrossValidate``3(Microsoft.ML.BinaryClassificationCatalog,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn},System.Nullable{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationCatalog" />
      </Targets>
      <Member MemberName="CrossValidate&lt;TInShape,TOutShape,TTransformer&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.Data.MulticlassClassificationMetrics,Microsoft.ML.StaticPipe.Transformer&lt;TInShape,TOutShape,TTransformer&gt;,Microsoft.ML.StaticPipe.DataView&lt;TOutShape&gt;&gt;[] CrossValidate&lt;TInShape,TOutShape,TTransformer&gt; (this Microsoft.ML.MulticlassClassificationCatalog catalog, Microsoft.ML.StaticPipe.DataView&lt;TInShape&gt; data, Microsoft.ML.StaticPipe.Estimator&lt;TInShape,TOutShape,TTransformer&gt; estimator, Func&lt;TOutShape,Microsoft.ML.StaticPipe.Key&lt;uint&gt;&gt; label, int numFolds = 5, Func&lt;TInShape,Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn = null, Nullable&lt;int&gt; seed = null) where TTransformer : class, Microsoft.ML.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.Data.MulticlassClassificationMetrics, class Microsoft.ML.StaticPipe.Transformer`3&lt;!!TInShape, !!TOutShape, !!TTransformer&gt;, class Microsoft.ML.StaticPipe.DataView`1&lt;!!TOutShape&gt;&gt;[] CrossValidate&lt;TInShape, TOutShape, class (class Microsoft.ML.ITransformer) TTransformer&gt;(class Microsoft.ML.MulticlassClassificationCatalog catalog, class Microsoft.ML.StaticPipe.DataView`1&lt;!!TInShape&gt; data, class Microsoft.ML.StaticPipe.Estimator`3&lt;!!TInShape, !!TOutShape, !!TTransformer&gt; estimator, class System.Func`2&lt;!!TOutShape, class Microsoft.ML.StaticPipe.Key`1&lt;unsigned int32&gt;&gt; label, int32 numFolds, class System.Func`2&lt;!!TInShape, class Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn, valuetype System.Nullable`1&lt;int32&gt; seed) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TrainingStaticExtensions.CrossValidate``3(Microsoft.ML.MulticlassClassificationCatalog,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Key{System.UInt32}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn},System.Nullable{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CrossValidate(Of TInShape, TOutShape, TTransformer) (catalog As MulticlassClassificationCatalog, data As DataView(Of TInShape), estimator As Estimator(Of TInShape, TOutShape, TTransformer), label As Func(Of TOutShape, Key(Of UInteger)), Optional numFolds As Integer = 5, Optional stratificationColumn As Func(Of TInShape, PipelineColumn) = null, Optional seed As Nullable(Of Integer) = null) As ValueTuple(Of MulticlassClassificationMetrics, Transformer(Of TInShape, TOutShape, TTransformer), DataView(Of TOutShape))()" />
        <MemberSignature Language="F#" Value="static member CrossValidate : Microsoft.ML.MulticlassClassificationCatalog * Microsoft.ML.StaticPipe.DataView&lt;'InShape&gt; * Microsoft.ML.StaticPipe.Estimator&lt;'InShape, 'OutShape, 'ransformer (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.ITransformer)&gt; * Func&lt;'OutShape, Microsoft.ML.StaticPipe.Key&lt;uint32&gt;&gt; * int * Func&lt;'InShape, Microsoft.ML.StaticPipe.PipelineColumn&gt; * Nullable&lt;int&gt; -&gt; ValueTuple&lt;Microsoft.ML.Data.MulticlassClassificationMetrics, Microsoft.ML.StaticPipe.Transformer&lt;'InShape, 'OutShape, 'ransformer&gt;, Microsoft.ML.StaticPipe.DataView&lt;'OutShape&gt;&gt;[] (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.ITransformer)" Usage="Microsoft.ML.StaticPipe.TrainingStaticExtensions.CrossValidate (catalog, data, estimator, label, numFolds, stratificationColumn, seed)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.Data.MulticlassClassificationMetrics,Microsoft.ML.StaticPipe.Transformer&lt;TInShape,TOutShape,TTransformer&gt;,Microsoft.ML.StaticPipe.DataView&lt;TOutShape&gt;&gt;[]</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "metrics", "model", "scoredTestData" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TInShape" />
          <TypeParameter Name="TOutShape" />
          <TypeParameter Name="TTransformer">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.MulticlassClassificationCatalog" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;TInShape&gt;" />
          <Parameter Name="estimator" Type="Microsoft.ML.StaticPipe.Estimator&lt;TInShape,TOutShape,TTransformer&gt;" />
          <Parameter Name="label" Type="System.Func&lt;TOutShape,Microsoft.ML.StaticPipe.Key&lt;System.UInt32&gt;&gt;" />
          <Parameter Name="numFolds" Type="System.Int32" />
          <Parameter Name="stratificationColumn" Type="System.Func&lt;TInShape,Microsoft.ML.StaticPipe.PipelineColumn&gt;" />
          <Parameter Name="seed" Type="System.Nullable&lt;System.Int32&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TInShape">The input schema shape.</typeparam>
          <typeparam name="TOutShape">The output schema shape.</typeparam>
          <typeparam name="TTransformer">The type of the trained model.</typeparam>
          <param name="catalog">The training catalog.</param>
          <param name="data">The data to run cross-validation on.</param>
          <param name="estimator">The estimator to fit.</param>
          <param name="label">The label column (for evaluation).</param>
          <param name="numFolds">Number of cross-validation folds.</param>
          <param name="stratificationColumn">Optional selector for the column to use as a stratification column. If two examples share the same value of the <paramref name="stratificationColumn" />
            (if provided), they are guaranteed to appear in the same subset (train or test). Use this to make sure there is no label leakage from train to the test set.
            If this optional parameter is not provided, a stratification columns will be generated, and its values will be random numbers .</param>
          <param name="seed">Optional parameter used in combination with the <paramref name="stratificationColumn" />.
            If the <paramref name="stratificationColumn" /> is not provided, the random numbers generated to create it, will use this seed as value.
            And if it is not provided, the default value will be used.</param>
          <summary>
            Run cross-validation over <paramref name="numFolds" /> folds of <paramref name="data" />, by fitting <paramref name="estimator" />,
            and respecting <paramref name="stratificationColumn" /> if provided.
            Then evaluate each sub-model against <paramref name="label" /> and return metrics.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TrainingStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TrainingStaticExtensions.CrossValidate``3(Microsoft.ML.MulticlassClassificationCatalog,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Key{System.UInt32}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn},System.Nullable{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog" />
      </Targets>
      <Member MemberName="CrossValidate&lt;TInShape,TOutShape,TTransformer&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.Data.RegressionMetrics,Microsoft.ML.StaticPipe.Transformer&lt;TInShape,TOutShape,TTransformer&gt;,Microsoft.ML.StaticPipe.DataView&lt;TOutShape&gt;&gt;[] CrossValidate&lt;TInShape,TOutShape,TTransformer&gt; (this Microsoft.ML.RegressionCatalog catalog, Microsoft.ML.StaticPipe.DataView&lt;TInShape&gt; data, Microsoft.ML.StaticPipe.Estimator&lt;TInShape,TOutShape,TTransformer&gt; estimator, Func&lt;TOutShape,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;&gt; label, int numFolds = 5, Func&lt;TInShape,Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn = null, Nullable&lt;int&gt; seed = null) where TTransformer : class, Microsoft.ML.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.Data.RegressionMetrics, class Microsoft.ML.StaticPipe.Transformer`3&lt;!!TInShape, !!TOutShape, !!TTransformer&gt;, class Microsoft.ML.StaticPipe.DataView`1&lt;!!TOutShape&gt;&gt;[] CrossValidate&lt;TInShape, TOutShape, class (class Microsoft.ML.ITransformer) TTransformer&gt;(class Microsoft.ML.RegressionCatalog catalog, class Microsoft.ML.StaticPipe.DataView`1&lt;!!TInShape&gt; data, class Microsoft.ML.StaticPipe.Estimator`3&lt;!!TInShape, !!TOutShape, !!TTransformer&gt; estimator, class System.Func`2&lt;!!TOutShape, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;&gt; label, int32 numFolds, class System.Func`2&lt;!!TInShape, class Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn, valuetype System.Nullable`1&lt;int32&gt; seed) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TrainingStaticExtensions.CrossValidate``3(Microsoft.ML.RegressionCatalog,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{System.Single}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn},System.Nullable{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CrossValidate(Of TInShape, TOutShape, TTransformer) (catalog As RegressionCatalog, data As DataView(Of TInShape), estimator As Estimator(Of TInShape, TOutShape, TTransformer), label As Func(Of TOutShape, Scalar(Of Single)), Optional numFolds As Integer = 5, Optional stratificationColumn As Func(Of TInShape, PipelineColumn) = null, Optional seed As Nullable(Of Integer) = null) As ValueTuple(Of RegressionMetrics, Transformer(Of TInShape, TOutShape, TTransformer), DataView(Of TOutShape))()" />
        <MemberSignature Language="F#" Value="static member CrossValidate : Microsoft.ML.RegressionCatalog * Microsoft.ML.StaticPipe.DataView&lt;'InShape&gt; * Microsoft.ML.StaticPipe.Estimator&lt;'InShape, 'OutShape, 'ransformer (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.ITransformer)&gt; * Func&lt;'OutShape, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;&gt; * int * Func&lt;'InShape, Microsoft.ML.StaticPipe.PipelineColumn&gt; * Nullable&lt;int&gt; -&gt; ValueTuple&lt;Microsoft.ML.Data.RegressionMetrics, Microsoft.ML.StaticPipe.Transformer&lt;'InShape, 'OutShape, 'ransformer&gt;, Microsoft.ML.StaticPipe.DataView&lt;'OutShape&gt;&gt;[] (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.ITransformer)" Usage="Microsoft.ML.StaticPipe.TrainingStaticExtensions.CrossValidate (catalog, data, estimator, label, numFolds, stratificationColumn, seed)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.Data.RegressionMetrics,Microsoft.ML.StaticPipe.Transformer&lt;TInShape,TOutShape,TTransformer&gt;,Microsoft.ML.StaticPipe.DataView&lt;TOutShape&gt;&gt;[]</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "metrics", "model", "scoredTestData" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TInShape" />
          <TypeParameter Name="TOutShape" />
          <TypeParameter Name="TTransformer">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;TInShape&gt;" />
          <Parameter Name="estimator" Type="Microsoft.ML.StaticPipe.Estimator&lt;TInShape,TOutShape,TTransformer&gt;" />
          <Parameter Name="label" Type="System.Func&lt;TOutShape,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;&gt;" />
          <Parameter Name="numFolds" Type="System.Int32" />
          <Parameter Name="stratificationColumn" Type="System.Func&lt;TInShape,Microsoft.ML.StaticPipe.PipelineColumn&gt;" />
          <Parameter Name="seed" Type="System.Nullable&lt;System.Int32&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TInShape">The input schema shape.</typeparam>
          <typeparam name="TOutShape">The output schema shape.</typeparam>
          <typeparam name="TTransformer">The type of the trained model.</typeparam>
          <param name="catalog">The training catalog.</param>
          <param name="data">The data to run cross-validation on.</param>
          <param name="estimator">The estimator to fit.</param>
          <param name="label">The label column (for evaluation).</param>
          <param name="numFolds">Number of cross-validation folds.</param>
          <param name="stratificationColumn">Optional selector for the column to use as a stratification column. If two examples share the same value of the <paramref name="stratificationColumn" />
            (if provided), they are guaranteed to appear in the same subset (train or test). Use this to make sure there is no label leakage from train to the test set.
            If this optional parameter is not provided, a stratification columns will be generated, and its values will be random numbers .</param>
          <param name="seed">Optional parameter used in combination with the <paramref name="stratificationColumn" />.
            If the <paramref name="stratificationColumn" /> is not provided, the random numbers generated to create it, will use this seed as value.
            And if it is not provided, the default value will be used.</param>
          <summary>
            Run cross-validation over <paramref name="numFolds" /> folds of <paramref name="data" />, by fitting <paramref name="estimator" />,
            and respecting <paramref name="stratificationColumn" /> if provided.
            Then evaluate each sub-model against <paramref name="label" /> and return metrics.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TrainingStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TrainingStaticExtensions.CrossValidate``3(Microsoft.ML.RegressionCatalog,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{System.Single}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn},System.Nullable{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog" />
      </Targets>
      <Member MemberName="CrossValidateNonCalibrated&lt;TInShape,TOutShape,TTransformer&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.Data.BinaryClassificationMetrics,Microsoft.ML.StaticPipe.Transformer&lt;TInShape,TOutShape,TTransformer&gt;,Microsoft.ML.StaticPipe.DataView&lt;TOutShape&gt;&gt;[] CrossValidateNonCalibrated&lt;TInShape,TOutShape,TTransformer&gt; (this Microsoft.ML.BinaryClassificationCatalog catalog, Microsoft.ML.StaticPipe.DataView&lt;TInShape&gt; data, Microsoft.ML.StaticPipe.Estimator&lt;TInShape,TOutShape,TTransformer&gt; estimator, Func&lt;TOutShape,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; label, int numFolds = 5, Func&lt;TInShape,Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn = null, Nullable&lt;int&gt; seed = null) where TTransformer : class, Microsoft.ML.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.Data.BinaryClassificationMetrics, class Microsoft.ML.StaticPipe.Transformer`3&lt;!!TInShape, !!TOutShape, !!TTransformer&gt;, class Microsoft.ML.StaticPipe.DataView`1&lt;!!TOutShape&gt;&gt;[] CrossValidateNonCalibrated&lt;TInShape, TOutShape, class (class Microsoft.ML.ITransformer) TTransformer&gt;(class Microsoft.ML.BinaryClassificationCatalog catalog, class Microsoft.ML.StaticPipe.DataView`1&lt;!!TInShape&gt; data, class Microsoft.ML.StaticPipe.Estimator`3&lt;!!TInShape, !!TOutShape, !!TTransformer&gt; estimator, class System.Func`2&lt;!!TOutShape, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; label, int32 numFolds, class System.Func`2&lt;!!TInShape, class Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn, valuetype System.Nullable`1&lt;int32&gt; seed) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TrainingStaticExtensions.CrossValidateNonCalibrated``3(Microsoft.ML.BinaryClassificationCatalog,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn},System.Nullable{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CrossValidateNonCalibrated(Of TInShape, TOutShape, TTransformer) (catalog As BinaryClassificationCatalog, data As DataView(Of TInShape), estimator As Estimator(Of TInShape, TOutShape, TTransformer), label As Func(Of TOutShape, Scalar(Of Boolean)), Optional numFolds As Integer = 5, Optional stratificationColumn As Func(Of TInShape, PipelineColumn) = null, Optional seed As Nullable(Of Integer) = null) As ValueTuple(Of BinaryClassificationMetrics, Transformer(Of TInShape, TOutShape, TTransformer), DataView(Of TOutShape))()" />
        <MemberSignature Language="F#" Value="static member CrossValidateNonCalibrated : Microsoft.ML.BinaryClassificationCatalog * Microsoft.ML.StaticPipe.DataView&lt;'InShape&gt; * Microsoft.ML.StaticPipe.Estimator&lt;'InShape, 'OutShape, 'ransformer (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.ITransformer)&gt; * Func&lt;'OutShape, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; * int * Func&lt;'InShape, Microsoft.ML.StaticPipe.PipelineColumn&gt; * Nullable&lt;int&gt; -&gt; ValueTuple&lt;Microsoft.ML.Data.BinaryClassificationMetrics, Microsoft.ML.StaticPipe.Transformer&lt;'InShape, 'OutShape, 'ransformer&gt;, Microsoft.ML.StaticPipe.DataView&lt;'OutShape&gt;&gt;[] (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.ITransformer)" Usage="Microsoft.ML.StaticPipe.TrainingStaticExtensions.CrossValidateNonCalibrated (catalog, data, estimator, label, numFolds, stratificationColumn, seed)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.Data.BinaryClassificationMetrics,Microsoft.ML.StaticPipe.Transformer&lt;TInShape,TOutShape,TTransformer&gt;,Microsoft.ML.StaticPipe.DataView&lt;TOutShape&gt;&gt;[]</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "metrics", "model", "scoredTestData" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TInShape" />
          <TypeParameter Name="TOutShape" />
          <TypeParameter Name="TTransformer">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;TInShape&gt;" />
          <Parameter Name="estimator" Type="Microsoft.ML.StaticPipe.Estimator&lt;TInShape,TOutShape,TTransformer&gt;" />
          <Parameter Name="label" Type="System.Func&lt;TOutShape,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;" />
          <Parameter Name="numFolds" Type="System.Int32" />
          <Parameter Name="stratificationColumn" Type="System.Func&lt;TInShape,Microsoft.ML.StaticPipe.PipelineColumn&gt;" />
          <Parameter Name="seed" Type="System.Nullable&lt;System.Int32&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TInShape">The input schema shape.</typeparam>
          <typeparam name="TOutShape">The output schema shape.</typeparam>
          <typeparam name="TTransformer">The type of the trained model.</typeparam>
          <param name="catalog">The training catalog.</param>
          <param name="data">The data to run cross-validation on.</param>
          <param name="estimator">The estimator to fit.</param>
          <param name="label">The label column (for evaluation).</param>
          <param name="numFolds">Number of cross-validation folds.</param>
          <param name="stratificationColumn">Optional selector for the column to use as a stratification column. If two examples share the same value of the <paramref name="stratificationColumn" />
            (if provided), they are guaranteed to appear in the same subset (train or test). Use this to make sure there is no label leakage from train to the test set.
            If this optional parameter is not provided, a stratification columns will be generated, and its values will be random numbers .</param>
          <param name="seed">Optional parameter used in combination with the <paramref name="stratificationColumn" />.
            If the <paramref name="stratificationColumn" /> is not provided, the random numbers generated to create it, will use this seed as value.
            And if it is not provided, the default value will be used.</param>
          <summary>
            Run cross-validation over <paramref name="numFolds" /> folds of <paramref name="data" />, by fitting <paramref name="estimator" />,
            and respecting <paramref name="stratificationColumn" /> if provided.
            Then evaluate each sub-model against <paramref name="label" /> and return metrics.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TrainingStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TrainingStaticExtensions.CrossValidateNonCalibrated``3(Microsoft.ML.BinaryClassificationCatalog,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn},System.Nullable{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataOperationsCatalog" />
      </Targets>
      <Member MemberName="TrainTestSplit&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.DataView&lt;T&gt;,Microsoft.ML.StaticPipe.DataView&lt;T&gt;&gt; TrainTestSplit&lt;T&gt; (this Microsoft.ML.DataOperationsCatalog catalog, Microsoft.ML.StaticPipe.DataView&lt;T&gt; data, double testFraction = 0.1, Func&lt;T,Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn = null, Nullable&lt;int&gt; seed = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt;, class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt;&gt; TrainTestSplit&lt;T&gt;(class Microsoft.ML.DataOperationsCatalog catalog, class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt; data, float64 testFraction, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn, valuetype System.Nullable`1&lt;int32&gt; seed) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TrainingStaticExtensions.TrainTestSplit``1(Microsoft.ML.DataOperationsCatalog,Microsoft.ML.StaticPipe.DataView{``0},System.Double,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn},System.Nullable{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrainTestSplit(Of T) (catalog As DataOperationsCatalog, data As DataView(Of T), Optional testFraction As Double = 0.1, Optional stratificationColumn As Func(Of T, PipelineColumn) = null, Optional seed As Nullable(Of Integer) = null) As ValueTuple(Of DataView(Of T), DataView(Of T))" />
        <MemberSignature Language="F#" Value="static member TrainTestSplit : Microsoft.ML.DataOperationsCatalog * Microsoft.ML.StaticPipe.DataView&lt;'T&gt; * double * Func&lt;'T, Microsoft.ML.StaticPipe.PipelineColumn&gt; * Nullable&lt;int&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.DataView&lt;'T&gt;, Microsoft.ML.StaticPipe.DataView&lt;'T&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TrainingStaticExtensions.TrainTestSplit (catalog, data, testFraction, stratificationColumn, seed)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.DataView&lt;T&gt;,Microsoft.ML.StaticPipe.DataView&lt;T&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "trainSet", "testSet" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.DataOperationsCatalog" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;T&gt;" />
          <Parameter Name="testFraction" Type="System.Double" />
          <Parameter Name="stratificationColumn" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.PipelineColumn&gt;" />
          <Parameter Name="seed" Type="System.Nullable&lt;System.Int32&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="T">The tuple describing the data schema.</typeparam>
          <param name="catalog">The training catalog.</param>
          <param name="data">The dataset to split.</param>
          <param name="testFraction">The fraction of data to go into the test set.</param>
          <param name="stratificationColumn">Optional selector for the column to use as a stratification column. If two examples share the same value of the <paramref name="stratificationColumn" />
            (if provided), they are guaranteed to appear in the same subset (train or test). Use this to make sure there is no label leakage from train to the test set.
            If this optional parameter is not provided, a stratification columns will be generated, and its values will be random numbers .</param>
          <param name="seed">Optional parameter used in combination with the <paramref name="stratificationColumn" />.
            If the <paramref name="stratificationColumn" /> is not provided, the random numbers generated to create it, will use this seed as value.
            And if it is not provided, the default value will be used.</param>
          <summary>
            Split the dataset into the train set and test set according to the given fraction.
            Respects the <paramref name="stratificationColumn" /> if provided.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TrainingStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TrainingStaticExtensions.TrainTestSplit``1(Microsoft.ML.DataOperationsCatalog,Microsoft.ML.StaticPipe.DataView{``0},System.Double,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn},System.Nullable{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="FastTree">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; FastTree (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights, Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer.Options options, Action&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;Microsoft.ML.Trainers.FastTree.FastTreeBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; FastTree(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, class Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer/Options options, class System.Action`1&lt;class Microsoft.ML.Calibrators.CalibratedModelParametersBase`2&lt;class Microsoft.ML.Trainers.FastTree.FastTreeBinaryModelParameters, class Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer.Options,System.Action{Microsoft.ML.Calibrators.CalibratedModelParametersBase{Microsoft.ML.Trainers.FastTree.FastTreeBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator}})" />
        <MemberSignature Language="F#" Value="static member FastTree : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer.Options * Action&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;Microsoft.ML.Trainers.FastTree.FastTreeBinaryModelParameters, Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree (catalog, label, features, weights, options, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "probability", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer+Options" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;Microsoft.ML.Trainers.FastTree.FastTreeBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.BinaryClassificationCatalog" />.</param>
          <param name="label">The label column.</param>
          <param name="features">The features column.</param>
          <param name="weights">The optional weights column.</param>
          <param name="options">Algorithm advanced settings.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained. Note that this action cannot change the result in any way;
            it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            FastTree <see cref="T:Microsoft.ML.BinaryClassificationCatalog" /> extension method.
            Predict a target using a decision tree binary classification model trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TreeRegressionExtensions" Member="M:Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer.Options,System.Action{Microsoft.ML.Calibrators.CalibratedModelParametersBase{Microsoft.ML.Trainers.FastTree.FastTreeBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="FastTree">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; FastTree (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, int numberOfLeaves = 20, int numberOfTrees = 100, int minimumExampleCountPerLeaf = 10, double learningRate = 0.2, Action&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;Microsoft.ML.Trainers.FastTree.FastTreeBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; FastTree(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, int32 numberOfLeaves, int32 numberOfTrees, int32 minimumExampleCountPerLeaf, float64 learningRate, class System.Action`1&lt;class Microsoft.ML.Calibrators.CalibratedModelParametersBase`2&lt;class Microsoft.ML.Trainers.FastTree.FastTreeBinaryModelParameters, class Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Calibrators.CalibratedModelParametersBase{Microsoft.ML.Trainers.FastTree.FastTreeBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FastTree (catalog As BinaryClassificationCatalog.BinaryClassificationTrainers, label As Scalar(Of Boolean), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional numberOfLeaves As Integer = 20, Optional numberOfTrees As Integer = 100, Optional minimumExampleCountPerLeaf As Integer = 10, Optional learningRate As Double = 0.2, Optional onFit As Action(Of CalibratedModelParametersBase(Of FastTreeBinaryModelParameters, PlattCalibrator)) = null) As ValueTuple(Of Scalar(Of Single), Scalar(Of Single), Scalar(Of Boolean))" />
        <MemberSignature Language="F#" Value="static member FastTree : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * int * int * int * double * Action&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;Microsoft.ML.Trainers.FastTree.FastTreeBinaryModelParameters, Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree (catalog, label, features, weights, numberOfLeaves, numberOfTrees, minimumExampleCountPerLeaf, learningRate, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute FrameworkAlternate="ml-dotnet-preview">
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "probability", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="numberOfLeaves" Type="System.Int32" />
          <Parameter Name="numberOfTrees" Type="System.Int32" />
          <Parameter Name="minimumExampleCountPerLeaf" Type="System.Int32" />
          <Parameter Name="learningRate" Type="System.Double" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Calibrators.CalibratedModelParametersBase&lt;Microsoft.ML.Trainers.FastTree.FastTreeBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.BinaryClassificationCatalog" />.</param>
          <param name="label">The label column.</param>
          <param name="features">The features column.</param>
          <param name="weights">The optional weights column.</param>
          <param name="numberOfLeaves">The maximum number of leaves per decision tree.</param>
          <param name="numberOfTrees">Total number of decision trees to create in the ensemble.</param>
          <param name="minimumExampleCountPerLeaf">The minimal number of data points allowed in a leaf of the tree, out of the subsampled data.</param>
          <param name="learningRate">The learning rate.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained. Note that this action cannot change the result in any way;
            it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            FastTree <see cref="T:Microsoft.ML.BinaryClassificationCatalog" /> extension method.
            Predict a target using a decision tree binary classification model trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TreeRegressionExtensions" Member="M:Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Calibrators.CalibratedModelParametersBase{Microsoft.ML.Trainers.FastTree.FastTreeBinaryModelParameters,Microsoft.ML.Calibrators.PlattCalibrator}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="FastTree">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; FastTree (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights, Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer.Options options, Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRegressionModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; FastTree(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, class Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer/Options options, class System.Action`1&lt;class Microsoft.ML.Trainers.FastTree.FastTreeRegressionModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer.Options,System.Action{Microsoft.ML.Trainers.FastTree.FastTreeRegressionModelParameters})" />
        <MemberSignature Language="F#" Value="static member FastTree : Microsoft.ML.RegressionCatalog.RegressionTrainers * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer.Options * Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRegressionModelParameters&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree (catalog, label, features, weights, options, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer+Options" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRegressionModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.RegressionCatalog" />.</param>
          <param name="label">The label column.</param>
          <param name="features">The features column.</param>
          <param name="weights">The optional weights column.</param>
          <param name="options">Algorithm advanced settings.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained. Note that this action cannot change the result in any way;
            it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            FastTree <see cref="T:Microsoft.ML.RegressionCatalog" /> extension method.
            Predicts a target using a decision tree regression model trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TreeRegressionExtensions" Member="M:Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer.Options,System.Action{Microsoft.ML.Trainers.FastTree.FastTreeRegressionModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="FastTree">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; FastTree (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, int numberOfLeaves = 20, int numberOfTrees = 100, int minimumExampleCountPerLeaf = 10, double learningRate = 0.2, Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRegressionModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; FastTree(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, int32 numberOfLeaves, int32 numberOfTrees, int32 minimumExampleCountPerLeaf, float64 learningRate, class System.Action`1&lt;class Microsoft.ML.Trainers.FastTree.FastTreeRegressionModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Trainers.FastTree.FastTreeRegressionModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FastTree (catalog As RegressionCatalog.RegressionTrainers, label As Scalar(Of Single), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional numberOfLeaves As Integer = 20, Optional numberOfTrees As Integer = 100, Optional minimumExampleCountPerLeaf As Integer = 10, Optional learningRate As Double = 0.2, Optional onFit As Action(Of FastTreeRegressionModelParameters) = null) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member FastTree : Microsoft.ML.RegressionCatalog.RegressionTrainers * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * int * int * int * double * Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRegressionModelParameters&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree (catalog, label, features, weights, numberOfLeaves, numberOfTrees, minimumExampleCountPerLeaf, learningRate, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="numberOfLeaves" Type="System.Int32" />
          <Parameter Name="numberOfTrees" Type="System.Int32" />
          <Parameter Name="minimumExampleCountPerLeaf" Type="System.Int32" />
          <Parameter Name="learningRate" Type="System.Double" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRegressionModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.RegressionCatalog" />.</param>
          <param name="label">The label column.</param>
          <param name="features">The features column.</param>
          <param name="weights">The optional weights column.</param>
          <param name="numberOfLeaves">The maximum number of leaves per decision tree.</param>
          <param name="numberOfTrees">Total number of decision trees to create in the ensemble.</param>
          <param name="minimumExampleCountPerLeaf">The minimal number of data points allowed in a leaf of a regression tree, out of the subsampled data.</param>
          <param name="learningRate">The learning rate.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained. Note that this action cannot change the result in any way;
            it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            FastTree <see cref="T:Microsoft.ML.RegressionCatalog" /> extension method.
            Predicts a target using a decision tree regression model trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TreeRegressionExtensions" Member="M:Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Trainers.FastTree.FastTreeRegressionModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RankingCatalog.RankingTrainers" />
      </Targets>
      <Member MemberName="FastTree&lt;TVal&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; FastTree&lt;TVal&gt; (this Microsoft.ML.RankingCatalog.RankingTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt; groupId, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights, Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer.Options options, Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRankingModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; FastTree&lt;TVal&gt;(class Microsoft.ML.RankingCatalog/RankingTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt; groupId, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, class Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer/Options options, class System.Action`1&lt;class Microsoft.ML.Trainers.FastTree.FastTreeRankingModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree``1(Microsoft.ML.RankingCatalog.RankingTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer.Options,System.Action{Microsoft.ML.Trainers.FastTree.FastTreeRankingModelParameters})" />
        <MemberSignature Language="F#" Value="static member FastTree : Microsoft.ML.RankingCatalog.RankingTrainers * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer.Options * Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRankingModelParameters&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree (catalog, label, features, groupId, weights, options, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TVal" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RankingCatalog+RankingTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="groupId" Type="Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer+Options" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRankingModelParameters&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TVal">To be added.</typeparam>
          <param name="catalog">The <see cref="T:Microsoft.ML.RegressionCatalog" />.</param>
          <param name="label">The label column.</param>
          <param name="features">The features column.</param>
          <param name="groupId">The groupId column.</param>
          <param name="weights">The optional weights column.</param>
          <param name="options">Algorithm advanced settings.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained. Note that this action cannot change the result in any way;
            it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            FastTree <see cref="T:Microsoft.ML.RankingCatalog" />.
            Ranks a series of inputs based on their relevance, training a decision tree ranking model through the <see cref="T:Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TreeRegressionExtensions" Member="M:Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree``1(Microsoft.ML.RankingCatalog.RankingTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer.Options,System.Action{Microsoft.ML.Trainers.FastTree.FastTreeRankingModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RankingCatalog.RankingTrainers" />
      </Targets>
      <Member MemberName="FastTree&lt;TVal&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; FastTree&lt;TVal&gt; (this Microsoft.ML.RankingCatalog.RankingTrainers catalog, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt; groupId, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, int numberOfLeaves = 20, int numberOfTrees = 100, int minimumExampleCountPerLeaf = 10, double learningRate = 0.2, Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRankingModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; FastTree&lt;TVal&gt;(class Microsoft.ML.RankingCatalog/RankingTrainers catalog, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt; groupId, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, int32 numberOfLeaves, int32 numberOfTrees, int32 minimumExampleCountPerLeaf, float64 learningRate, class System.Action`1&lt;class Microsoft.ML.Trainers.FastTree.FastTreeRankingModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree``1(Microsoft.ML.RankingCatalog.RankingTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Trainers.FastTree.FastTreeRankingModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FastTree(Of TVal) (catalog As RankingCatalog.RankingTrainers, label As Scalar(Of Single), features As Vector(Of Single), groupId As Key(Of UInteger, TVal), Optional weights As Scalar(Of Single) = null, Optional numberOfLeaves As Integer = 20, Optional numberOfTrees As Integer = 100, Optional minimumExampleCountPerLeaf As Integer = 10, Optional learningRate As Double = 0.2, Optional onFit As Action(Of FastTreeRankingModelParameters) = null) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member FastTree : Microsoft.ML.RankingCatalog.RankingTrainers * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * int * int * int * double * Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRankingModelParameters&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree (catalog, label, features, groupId, weights, numberOfLeaves, numberOfTrees, minimumExampleCountPerLeaf, learningRate, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TVal" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RankingCatalog+RankingTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="groupId" Type="Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="numberOfLeaves" Type="System.Int32" />
          <Parameter Name="numberOfTrees" Type="System.Int32" />
          <Parameter Name="minimumExampleCountPerLeaf" Type="System.Int32" />
          <Parameter Name="learningRate" Type="System.Double" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRankingModelParameters&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TVal">To be added.</typeparam>
          <param name="catalog">The <see cref="T:Microsoft.ML.RegressionCatalog" />.</param>
          <param name="label">The label column.</param>
          <param name="features">The features column.</param>
          <param name="groupId">The groupId column.</param>
          <param name="weights">The optional weights column.</param>
          <param name="numberOfLeaves">The maximum number of leaves per decision tree.</param>
          <param name="numberOfTrees">Total number of decision trees to create in the ensemble.</param>
          <param name="minimumExampleCountPerLeaf">The minimal number of data points allowed in a leaf of a regression tree, out of the subsampled data.</param>
          <param name="learningRate">The learning rate.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained. Note that this action cannot change the result in any way;
            it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            FastTree <see cref="T:Microsoft.ML.RankingCatalog" />.
            Ranks a series of inputs based on their relevance, training a decision tree ranking model through the <see cref="T:Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TreeRegressionExtensions" Member="M:Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree``1(Microsoft.ML.RankingCatalog.RankingTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Trainers.FastTree.FastTreeRankingModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ProduceWordBags">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ProduceWordBags (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, int ngramLength = 1, int skipLength = 0, bool useAllLengths = true, int maximumNgramsCount = 10000000, Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria weighting = Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria.Tf);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ProduceWordBags(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, int32 ngramLength, int32 skipLength, bool useAllLengths, int32 maximumNgramsCount, valuetype Microsoft.ML.Transforms.Text.NgramExtractingEstimator/WeightingCriteria weighting) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.WordBagEstimatorStaticExtensions.ProduceWordBags(Microsoft.ML.StaticPipe.Scalar{System.String},System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProduceWordBags (input As Scalar(Of String), Optional ngramLength As Integer = 1, Optional skipLength As Integer = 0, Optional useAllLengths As Boolean = true, Optional maximumNgramsCount As Integer = 10000000, Optional weighting As NgramExtractingEstimator.WeightingCriteria = Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria.Tf) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ProduceWordBags : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * int * int * bool * int * Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.WordBagEstimatorStaticExtensions.ProduceWordBags (input, ngramLength, skipLength, useAllLengths, maximumNgramsCount, weighting)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="useAllLengths" Type="System.Boolean" />
          <Parameter Name="maximumNgramsCount" Type="System.Int32" />
          <Parameter Name="weighting" Type="Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="useAllLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="maximumNgramsCount">Maximum number of ngrams to store in the dictionary.</param>
          <param name="weighting">Statistical measure used to evaluate how important a word is to a document in a corpus.</param>
          <summary>
            Produces a bag of counts of ngrams (sequences of consecutive words ) in a given text.
            It does so by building a dictionary of ngrams and using the id in the dictionary as the index in the bag.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.WordBagEstimatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.WordBagEstimatorStaticExtensions.ProduceWordBags(Microsoft.ML.StaticPipe.Scalar{System.String},System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="WordEmbeddings">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; WordEmbeddings (this Microsoft.ML.StaticPipe.VarVector&lt;string&gt; input, Microsoft.ML.Transforms.Text.WordEmbeddingEstimator.PretrainedModelKind modelKind = Microsoft.ML.Transforms.Text.WordEmbeddingEstimator+PretrainedModelKind.SentimentSpecificWordEmbedding);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; WordEmbeddings(class Microsoft.ML.StaticPipe.VarVector`1&lt;string&gt; input, valuetype Microsoft.ML.Transforms.Text.WordEmbeddingEstimator/PretrainedModelKind modelKind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.WordEmbeddingsStaticExtensions.WordEmbeddings(Microsoft.ML.StaticPipe.VarVector{System.String},Microsoft.ML.Transforms.Text.WordEmbeddingEstimator.PretrainedModelKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WordEmbeddings (input As VarVector(Of String), Optional modelKind As WordEmbeddingEstimator.PretrainedModelKind = Microsoft.ML.Transforms.Text.WordEmbeddingEstimator+PretrainedModelKind.SentimentSpecificWordEmbedding) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member WordEmbeddings : Microsoft.ML.StaticPipe.VarVector&lt;string&gt; * Microsoft.ML.Transforms.Text.WordEmbeddingEstimator.PretrainedModelKind -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.WordEmbeddingsStaticExtensions.WordEmbeddings (input, modelKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.String&gt;" RefType="this" />
          <Parameter Name="modelKind" Type="Microsoft.ML.Transforms.Text.WordEmbeddingEstimator+PretrainedModelKind" />
        </Parameters>
        <Docs>
          <param name="input">Vector of tokenized text.</param>
          <param name="modelKind">The pretrained word embedding model.</param>
          <summary>
        Word Embeddings transform is a text featurizer which converts vectors of text tokens into sentence vectors using a pre-trained model.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.WordEmbeddingsStaticExtensions" Member="M:Microsoft.ML.StaticPipe.WordEmbeddingsStaticExtensions.WordEmbeddings(Microsoft.ML.StaticPipe.VarVector{System.String},Microsoft.ML.Transforms.Text.WordEmbeddingEstimator.PretrainedModelKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="WordEmbeddings">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; WordEmbeddings (this Microsoft.ML.StaticPipe.VarVector&lt;string&gt; input, string customModelFile);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; WordEmbeddings(class Microsoft.ML.StaticPipe.VarVector`1&lt;string&gt; input, string customModelFile) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.WordEmbeddingsStaticExtensions.WordEmbeddings(Microsoft.ML.StaticPipe.VarVector{System.String},System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WordEmbeddings (input As VarVector(Of String), customModelFile As String) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member WordEmbeddings : Microsoft.ML.StaticPipe.VarVector&lt;string&gt; * string -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.WordEmbeddingsStaticExtensions.WordEmbeddings (input, customModelFile)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.String&gt;" RefType="this" />
          <Parameter Name="customModelFile" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="input">Vector of tokenized text.</param>
          <param name="customModelFile">The custom word embedding model file.</param>
          <summary>
        Word Embeddings transform is a text featurizer which converts vectors of text tokens into sentence vectors using a pre-trained model.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.WordEmbeddingsStaticExtensions" Member="M:Microsoft.ML.StaticPipe.WordEmbeddingsStaticExtensions.WordEmbeddings(Microsoft.ML.StaticPipe.VarVector{System.String},System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ProduceHashedWordBags">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ProduceHashedWordBags (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, int numberOfBits = 16, int ngramLength = 1, int skipLength = 0, bool useAllLengths = true, uint seed = 314489979, bool useOrderedHashing = true, int maximumNumberOfInverts = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ProduceHashedWordBags(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, int32 numberOfBits, int32 ngramLength, int32 skipLength, bool useAllLengths, unsigned int32 seed, bool useOrderedHashing, int32 maximumNumberOfInverts) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.WordHashBagEstimatorStaticExtensions.ProduceHashedWordBags(Microsoft.ML.StaticPipe.Scalar{System.String},System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProduceHashedWordBags (input As Scalar(Of String), Optional numberOfBits As Integer = 16, Optional ngramLength As Integer = 1, Optional skipLength As Integer = 0, Optional useAllLengths As Boolean = true, Optional seed As UInteger = 314489979, Optional useOrderedHashing As Boolean = true, Optional maximumNumberOfInverts As Integer = 0) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ProduceHashedWordBags : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * int * int * int * bool * uint32 * bool * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.WordHashBagEstimatorStaticExtensions.ProduceHashedWordBags (input, numberOfBits, ngramLength, skipLength, useAllLengths, seed, useOrderedHashing, maximumNumberOfInverts)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="numberOfBits" Type="System.Int32" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="useAllLengths" Type="System.Boolean" />
          <Parameter Name="seed" Type="System.UInt32" />
          <Parameter Name="useOrderedHashing" Type="System.Boolean" />
          <Parameter Name="maximumNumberOfInverts" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="numberOfBits">Number of bits to hash into. Must be between 1 and 30, inclusive.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="useAllLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="seed">Hashing seed.</param>
          <param name="useOrderedHashing">Whether the position of each source column should be included in the hash (when there are multiple source columns).</param>
          <param name="maximumNumberOfInverts">During hashing we constuct mappings between original values and the produced hash values.
            Text representation of original values are stored in the slot names of the  metadata for the new column.Hashing, as such, can map many initial values to one.
            <paramref name="maximumNumberOfInverts" /> specifies the upper bound of the number of distinct input values mapping to a hash that should be retained.
            <value>0</value> does not retain any input values. <value>-1</value> retains all input values mapping to each hash.</param>
          <summary>
            Produces a bag of counts of ngrams (sequences of consecutive words of length 1-n) in a given text.
            It does so by hashing each ngram and using the hash value as the index in the bag.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.WordHashBagEstimatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.WordHashBagEstimatorStaticExtensions.ProduceHashedWordBags(Microsoft.ML.StaticPipe.Scalar{System.String},System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="TokenizeIntoWords">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;string&gt; TokenizeIntoWords (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, char[] separators = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;string&gt; TokenizeIntoWords(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, char[] separators) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.WordTokenizerStaticExtensions.TokenizeIntoWords(Microsoft.ML.StaticPipe.Scalar{System.String},System.Char[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TokenizeIntoWords (input As Scalar(Of String), Optional separators As Char() = null) As VarVector(Of String)" />
        <MemberSignature Language="F#" Value="static member TokenizeIntoWords : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * char[] -&gt; Microsoft.ML.StaticPipe.VarVector&lt;string&gt;" Usage="Microsoft.ML.StaticPipe.WordTokenizerStaticExtensions.TokenizeIntoWords (input, separators)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.String&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="separators" Type="System.Char[]" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="separators">The separators to use (uses space character by default).</param>
          <summary>
            Tokenize incoming text using <paramref name="separators" /> and output the tokens.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.WordTokenizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.WordTokenizerStaticExtensions.TokenizeIntoWords(Microsoft.ML.StaticPipe.Scalar{System.String},System.Char[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.ModelOperationsCatalog" />
      </Targets>
      <Member MemberName="LoadTensorFlowModel">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.TensorFlowModel LoadTensorFlowModel (this Microsoft.ML.ModelOperationsCatalog catalog, string modelLocation);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.TensorFlowModel LoadTensorFlowModel(class Microsoft.ML.ModelOperationsCatalog catalog, string modelLocation) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TensorflowCatalog.LoadTensorFlowModel(Microsoft.ML.ModelOperationsCatalog,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LoadTensorFlowModel (catalog As ModelOperationsCatalog, modelLocation As String) As TensorFlowModel" />
        <MemberSignature Language="F#" Value="static member LoadTensorFlowModel : Microsoft.ML.ModelOperationsCatalog * string -&gt; Microsoft.ML.Transforms.TensorFlowModel" Usage="Microsoft.ML.TensorflowCatalog.LoadTensorFlowModel (catalog, modelLocation)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.TensorFlowModel</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.ModelOperationsCatalog" RefType="this" />
          <Parameter Name="modelLocation" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="modelLocation">Location of the TensorFlow model.</param>
          <summary>
            Load TensorFlow model into memory. This is the convenience method that allows the model to be loaded once and subsequently use it for querying schema and creation of
            <see cref="T:Microsoft.ML.Transforms.TensorFlowEstimator" /> using <see cref="M:Microsoft.ML.Transforms.TensorFlowModel.ScoreTensorFlowModel(System.String,System.String,System.Boolean)" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TensorflowCatalog" Member="M:Microsoft.ML.TensorflowCatalog.LoadTensorFlowModel(Microsoft.ML.ModelOperationsCatalog,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="ApplyWordEmbedding">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.WordEmbeddingEstimator ApplyWordEmbedding (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string outputColumnName, string inputColumnName = null, Microsoft.ML.Transforms.Text.WordEmbeddingEstimator.PretrainedModelKind modelKind = Microsoft.ML.Transforms.Text.WordEmbeddingEstimator+PretrainedModelKind.SentimentSpecificWordEmbedding);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.WordEmbeddingEstimator ApplyWordEmbedding(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string outputColumnName, string inputColumnName, valuetype Microsoft.ML.Transforms.Text.WordEmbeddingEstimator/PretrainedModelKind modelKind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.ApplyWordEmbedding(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,Microsoft.ML.Transforms.Text.WordEmbeddingEstimator.PretrainedModelKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ApplyWordEmbedding (catalog As TransformsCatalog.TextTransforms, outputColumnName As String, Optional inputColumnName As String = null, Optional modelKind As WordEmbeddingEstimator.PretrainedModelKind = Microsoft.ML.Transforms.Text.WordEmbeddingEstimator+PretrainedModelKind.SentimentSpecificWordEmbedding) As WordEmbeddingEstimator" />
        <MemberSignature Language="F#" Value="static member ApplyWordEmbedding : Microsoft.ML.TransformsCatalog.TextTransforms * string * string * Microsoft.ML.Transforms.Text.WordEmbeddingEstimator.PretrainedModelKind -&gt; Microsoft.ML.Transforms.Text.WordEmbeddingEstimator" Usage="Microsoft.ML.TextCatalog.ApplyWordEmbedding (catalog, outputColumnName, inputColumnName, modelKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.WordEmbeddingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="modelKind" Type="Microsoft.ML.Transforms.Text.WordEmbeddingEstimator+PretrainedModelKind" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="modelKind">The embeddings <see cref="T:Microsoft.ML.Transforms.Text.WordEmbeddingEstimator.PretrainedModelKind" /> to use. </param>
          <summary>
        Word Embeddings transform is a text featurizer which converts vectors of text tokens into sentence vectors using a pre-trained model.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.ApplyWordEmbedding(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,Microsoft.ML.Transforms.Text.WordEmbeddingEstimator.PretrainedModelKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="ApplyWordEmbedding">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.WordEmbeddingEstimator ApplyWordEmbedding (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string outputColumnName, string customModelFile, string inputColumnName = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.WordEmbeddingEstimator ApplyWordEmbedding(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string outputColumnName, string customModelFile, string inputColumnName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.ApplyWordEmbedding(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ApplyWordEmbedding (catalog As TransformsCatalog.TextTransforms, outputColumnName As String, customModelFile As String, Optional inputColumnName As String = null) As WordEmbeddingEstimator" />
        <MemberSignature Language="F#" Value="static member ApplyWordEmbedding : Microsoft.ML.TransformsCatalog.TextTransforms * string * string * string -&gt; Microsoft.ML.Transforms.Text.WordEmbeddingEstimator" Usage="Microsoft.ML.TextCatalog.ApplyWordEmbedding (catalog, outputColumnName, customModelFile, inputColumnName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.WordEmbeddingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="customModelFile" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="customModelFile">The path of the pre-trained embeedings model to use. </param>
          <param name="inputColumnName">Name of the column to transform.</param>
          <summary>
        Word Embeddings transform is a text featurizer which converts vectors of text tokens into sentence vectors using a pre-trained model.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.ApplyWordEmbedding(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="FeaturizeText">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.TextFeaturizingEstimator FeaturizeText (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string outputColumnName, Microsoft.ML.Transforms.Text.TextFeaturizingEstimator.Options options, params string[] inputColumnNames);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.TextFeaturizingEstimator FeaturizeText(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string outputColumnName, class Microsoft.ML.Transforms.Text.TextFeaturizingEstimator/Options options, string[] inputColumnNames) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.FeaturizeText(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,Microsoft.ML.Transforms.Text.TextFeaturizingEstimator.Options,System.String[])" />
        <MemberSignature Language="F#" Value="static member FeaturizeText : Microsoft.ML.TransformsCatalog.TextTransforms * string * Microsoft.ML.Transforms.Text.TextFeaturizingEstimator.Options * string[] -&gt; Microsoft.ML.Transforms.Text.TextFeaturizingEstimator" Usage="Microsoft.ML.TextCatalog.FeaturizeText (catalog, outputColumnName, options, inputColumnNames)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.TextFeaturizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="options" Type="Microsoft.ML.Transforms.Text.TextFeaturizingEstimator+Options" />
          <Parameter Name="inputColumnNames" Type="System.String[]">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet">
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnNames" />.</param>
          <param name="options">Advanced options to the algorithm.</param>
          <param name="inputColumnNames">Name of the columns to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <summary>
            Transform several text columns into featurized float array that represents counts of ngrams and char-grams.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.FeaturizeText(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,Microsoft.ML.Transforms.Text.TextFeaturizingEstimator.Options,System.String[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="FeaturizeText">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.TextFeaturizingEstimator FeaturizeText (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string outputColumnName, string inputColumnName = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.TextFeaturizingEstimator FeaturizeText(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string outputColumnName, string inputColumnName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.FeaturizeText(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FeaturizeText (catalog As TransformsCatalog.TextTransforms, outputColumnName As String, Optional inputColumnName As String = null) As TextFeaturizingEstimator" />
        <MemberSignature Language="F#" Value="static member FeaturizeText : Microsoft.ML.TransformsCatalog.TextTransforms * string * string -&gt; Microsoft.ML.Transforms.Text.TextFeaturizingEstimator" Usage="Microsoft.ML.TextCatalog.FeaturizeText (catalog, outputColumnName, inputColumnName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.TextFeaturizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <summary>
            Transform a text column into featurized float array that represents counts of ngrams and char-grams.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.FeaturizeText(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="LatentDirichletAllocation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.LatentDirichletAllocationEstimator LatentDirichletAllocation (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string outputColumnName, string inputColumnName = null, int numberOfTopics = 100, float alphaSum = 100, float beta = 0.01, int samplingStepCount = 4, int maximumNumberOfIterations = 200, int likelihoodInterval = 5, int numberOfThreads = 0, int maximumTokenCountPerDocument = 512, int numberOfSummaryTermsPerTopic = 10, int numberOfBurninIterations = 10, bool resetRandomGenerator = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.LatentDirichletAllocationEstimator LatentDirichletAllocation(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string outputColumnName, string inputColumnName, int32 numberOfTopics, float32 alphaSum, float32 beta, int32 samplingStepCount, int32 maximumNumberOfIterations, int32 likelihoodInterval, int32 numberOfThreads, int32 maximumTokenCountPerDocument, int32 numberOfSummaryTermsPerTopic, int32 numberOfBurninIterations, bool resetRandomGenerator) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.LatentDirichletAllocation(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Int32,System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LatentDirichletAllocation (catalog As TransformsCatalog.TextTransforms, outputColumnName As String, Optional inputColumnName As String = null, Optional numberOfTopics As Integer = 100, Optional alphaSum As Single = 100, Optional beta As Single = 0.01, Optional samplingStepCount As Integer = 4, Optional maximumNumberOfIterations As Integer = 200, Optional likelihoodInterval As Integer = 5, Optional numberOfThreads As Integer = 0, Optional maximumTokenCountPerDocument As Integer = 512, Optional numberOfSummaryTermsPerTopic As Integer = 10, Optional numberOfBurninIterations As Integer = 10, Optional resetRandomGenerator As Boolean = false) As LatentDirichletAllocationEstimator" />
        <MemberSignature Language="F#" Value="static member LatentDirichletAllocation : Microsoft.ML.TransformsCatalog.TextTransforms * string * string * int * single * single * int * int * int * int * int * int * int * bool -&gt; Microsoft.ML.Transforms.Text.LatentDirichletAllocationEstimator" Usage="Microsoft.ML.TextCatalog.LatentDirichletAllocation (catalog, outputColumnName, inputColumnName, numberOfTopics, alphaSum, beta, samplingStepCount, maximumNumberOfIterations, likelihoodInterval, numberOfThreads, maximumTokenCountPerDocument, numberOfSummaryTermsPerTopic, numberOfBurninIterations, resetRandomGenerator)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.LatentDirichletAllocationEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="numberOfTopics" Type="System.Int32" />
          <Parameter Name="alphaSum" Type="System.Single" />
          <Parameter Name="beta" Type="System.Single" />
          <Parameter Name="samplingStepCount" Type="System.Int32" />
          <Parameter Name="maximumNumberOfIterations" Type="System.Int32" />
          <Parameter Name="likelihoodInterval" Type="System.Int32" />
          <Parameter Name="numberOfThreads" Type="System.Int32" />
          <Parameter Name="maximumTokenCountPerDocument" Type="System.Int32" />
          <Parameter Name="numberOfSummaryTermsPerTopic" Type="System.Int32" />
          <Parameter Name="numberOfBurninIterations" Type="System.Int32" />
          <Parameter Name="resetRandomGenerator" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="numberOfTopics">The number of topics.</param>
          <param name="alphaSum">Dirichlet prior on document-topic vectors.</param>
          <param name="beta">Dirichlet prior on vocab-topic vectors.</param>
          <param name="samplingStepCount">Number of Metropolis Hasting step.</param>
          <param name="maximumNumberOfIterations">Number of iterations.</param>
          <param name="likelihoodInterval">Compute log likelihood over local dataset on this iteration interval.</param>
          <param name="numberOfThreads">The number of training threads. Default value depends on number of logical processors.</param>
          <param name="maximumTokenCountPerDocument">The threshold of maximum count of tokens per doc.</param>
          <param name="numberOfSummaryTermsPerTopic">The number of words to summarize the topic.</param>
          <param name="numberOfBurninIterations">The number of burn-in iterations.</param>
          <param name="resetRandomGenerator">Reset the random number generator for each document.</param>
          <summary>
            Uses <a href="https://arxiv.org/abs/1412.1576">LightLDA</a> to transform a document (represented as a vector of floats)
            into a vector of floats over a set of topics.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.LatentDirichletAllocation(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Int32,System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="NormalizeText">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.TextNormalizingEstimator NormalizeText (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string outputColumnName, string inputColumnName = null, Microsoft.ML.Transforms.Text.TextNormalizingEstimator.CaseMode caseMode = Microsoft.ML.Transforms.Text.TextNormalizingEstimator+CaseMode.Lower, bool keepDiacritics = false, bool keepPunctuations = true, bool keepNumbers = true);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.TextNormalizingEstimator NormalizeText(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string outputColumnName, string inputColumnName, valuetype Microsoft.ML.Transforms.Text.TextNormalizingEstimator/CaseMode caseMode, bool keepDiacritics, bool keepPunctuations, bool keepNumbers) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.NormalizeText(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,Microsoft.ML.Transforms.Text.TextNormalizingEstimator.CaseMode,System.Boolean,System.Boolean,System.Boolean)" />
        <MemberSignature Language="F#" Value="static member NormalizeText : Microsoft.ML.TransformsCatalog.TextTransforms * string * string * Microsoft.ML.Transforms.Text.TextNormalizingEstimator.CaseMode * bool * bool * bool -&gt; Microsoft.ML.Transforms.Text.TextNormalizingEstimator" Usage="Microsoft.ML.TextCatalog.NormalizeText (catalog, outputColumnName, inputColumnName, caseMode, keepDiacritics, keepPunctuations, keepNumbers)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.TextNormalizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="caseMode" Type="Microsoft.ML.Transforms.Text.TextNormalizingEstimator+CaseMode" />
          <Parameter Name="keepDiacritics" Type="System.Boolean" />
          <Parameter Name="keepPunctuations" Type="System.Boolean" />
          <Parameter Name="keepNumbers" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="caseMode">Casing text using the rules of the invariant culture.</param>
          <param name="keepDiacritics">Whether to keep diacritical marks or remove them.</param>
          <param name="keepPunctuations">Whether to keep punctuation marks or remove them.</param>
          <param name="keepNumbers">Whether to keep numbers or remove them.</param>
          <summary>
            Normalizes incoming text in <paramref name="inputColumnName" /> by changing case, removing diacritical marks, punctuation marks and/or numbers
            and outputs new text as <paramref name="outputColumnName" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.NormalizeText(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,Microsoft.ML.Transforms.Text.TextNormalizingEstimator.CaseMode,System.Boolean,System.Boolean,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="ProduceHashedNgrams">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.NgramHashingEstimator ProduceHashedNgrams (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string outputColumnName, string inputColumnName = null, int numberOfBits = 16, int ngramLength = 2, int skipLength = 0, bool useAllLengths = true, uint seed = 314489979, bool useOrderedHashing = true, int maximumNumberOfInverts = 0, bool rehashUnigrams = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.NgramHashingEstimator ProduceHashedNgrams(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string outputColumnName, string inputColumnName, int32 numberOfBits, int32 ngramLength, int32 skipLength, bool useAllLengths, unsigned int32 seed, bool useOrderedHashing, int32 maximumNumberOfInverts, bool rehashUnigrams) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.ProduceHashedNgrams(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProduceHashedNgrams (catalog As TransformsCatalog.TextTransforms, outputColumnName As String, Optional inputColumnName As String = null, Optional numberOfBits As Integer = 16, Optional ngramLength As Integer = 2, Optional skipLength As Integer = 0, Optional useAllLengths As Boolean = true, Optional seed As UInteger = 314489979, Optional useOrderedHashing As Boolean = true, Optional maximumNumberOfInverts As Integer = 0, Optional rehashUnigrams As Boolean = false) As NgramHashingEstimator" />
        <MemberSignature Language="F#" Value="static member ProduceHashedNgrams : Microsoft.ML.TransformsCatalog.TextTransforms * string * string * int * int * int * bool * uint32 * bool * int * bool -&gt; Microsoft.ML.Transforms.Text.NgramHashingEstimator" Usage="Microsoft.ML.TextCatalog.ProduceHashedNgrams (catalog, outputColumnName, inputColumnName, numberOfBits, ngramLength, skipLength, useAllLengths, seed, useOrderedHashing, maximumNumberOfInverts, rehashUnigrams)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.NgramHashingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="numberOfBits" Type="System.Int32" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="useAllLengths" Type="System.Boolean" />
          <Parameter Name="seed" Type="System.UInt32" />
          <Parameter Name="useOrderedHashing" Type="System.Boolean" />
          <Parameter Name="maximumNumberOfInverts" Type="System.Int32" />
          <Parameter Name="rehashUnigrams" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="numberOfBits">Number of bits to hash into. Must be between 1 and 30, inclusive.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="useAllLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="seed">Hashing seed.</param>
          <param name="useOrderedHashing">Whether the position of each source column should be included in the hash (when there are multiple source columns).</param>
          <param name="maximumNumberOfInverts">During hashing we constuct mappings between original values and the produced hash values.
             Text representation of original values are stored in the slot names of the  metadata for the new column.Hashing, as such, can map many initial values to one.
             <paramref name="maximumNumberOfInverts" /> specifies the upper bound of the number of distinct input values mapping to a hash that should be retained.
             <value>0</value> does not retain any input values. <value>-1</value> retains all input values mapping to each hash.</param>
          <param name="rehashUnigrams">Whether to rehash unigrams.</param>
          <summary>
             Produces a bag of counts of hashed ngrams in <paramref name="inputColumnName" />
             and outputs ngram vector as <paramref name="outputColumnName" /><see cref="T:Microsoft.ML.Transforms.Text.NgramHashingEstimator" /> is different from <see cref="T:Microsoft.ML.Transforms.Text.WordHashBagEstimator" /> in a way that <see cref="T:Microsoft.ML.Transforms.Text.NgramHashingEstimator" />
             takes tokenized text as input while <see cref="T:Microsoft.ML.Transforms.Text.WordHashBagEstimator" /> tokenizes text internally.
             </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.ProduceHashedNgrams(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="ProduceHashedNgrams">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.NgramHashingEstimator ProduceHashedNgrams (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string outputColumnName, string[] inputColumnNames = null, int numberOfBits = 16, int ngramLength = 2, int skipLength = 0, bool useAllLengths = true, uint seed = 314489979, bool useOrderedHashing = true, int maximumNumberOfInverts = 0, bool rehashUnigrams = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.NgramHashingEstimator ProduceHashedNgrams(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string outputColumnName, string[] inputColumnNames, int32 numberOfBits, int32 ngramLength, int32 skipLength, bool useAllLengths, unsigned int32 seed, bool useOrderedHashing, int32 maximumNumberOfInverts, bool rehashUnigrams) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.ProduceHashedNgrams(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String[],System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProduceHashedNgrams (catalog As TransformsCatalog.TextTransforms, outputColumnName As String, Optional inputColumnNames As String() = null, Optional numberOfBits As Integer = 16, Optional ngramLength As Integer = 2, Optional skipLength As Integer = 0, Optional useAllLengths As Boolean = true, Optional seed As UInteger = 314489979, Optional useOrderedHashing As Boolean = true, Optional maximumNumberOfInverts As Integer = 0, Optional rehashUnigrams As Boolean = false) As NgramHashingEstimator" />
        <MemberSignature Language="F#" Value="static member ProduceHashedNgrams : Microsoft.ML.TransformsCatalog.TextTransforms * string * string[] * int * int * int * bool * uint32 * bool * int * bool -&gt; Microsoft.ML.Transforms.Text.NgramHashingEstimator" Usage="Microsoft.ML.TextCatalog.ProduceHashedNgrams (catalog, outputColumnName, inputColumnNames, numberOfBits, ngramLength, skipLength, useAllLengths, seed, useOrderedHashing, maximumNumberOfInverts, rehashUnigrams)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.NgramHashingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnNames" Type="System.String[]" />
          <Parameter Name="numberOfBits" Type="System.Int32" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="useAllLengths" Type="System.Boolean" />
          <Parameter Name="seed" Type="System.UInt32" />
          <Parameter Name="useOrderedHashing" Type="System.Boolean" />
          <Parameter Name="maximumNumberOfInverts" Type="System.Int32" />
          <Parameter Name="rehashUnigrams" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnNames" />.</param>
          <param name="inputColumnNames">Names of the columns to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="numberOfBits">Number of bits to hash into. Must be between 1 and 30, inclusive.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="useAllLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="seed">Hashing seed.</param>
          <param name="useOrderedHashing">Whether the position of each source column should be included in the hash (when there are multiple source columns).</param>
          <param name="maximumNumberOfInverts">During hashing we constuct mappings between original values and the produced hash values.
             Text representation of original values are stored in the slot names of the  metadata for the new column.Hashing, as such, can map many initial values to one.
             <paramref name="maximumNumberOfInverts" /> specifies the upper bound of the number of distinct input values mapping to a hash that should be retained.
             <value>0</value> does not retain any input values. <value>-1</value> retains all input values mapping to each hash.</param>
          <param name="rehashUnigrams">Whether to rehash unigrams.</param>
          <summary>
             Produces a bag of counts of hashed ngrams in <paramref name="inputColumnNames" />
             and outputs ngram vector as <paramref name="outputColumnName" /><see cref="T:Microsoft.ML.Transforms.Text.NgramHashingEstimator" /> is different from <see cref="T:Microsoft.ML.Transforms.Text.WordHashBagEstimator" /> in a way that <see cref="T:Microsoft.ML.Transforms.Text.NgramHashingEstimator" />
             takes tokenized text as input while <see cref="T:Microsoft.ML.Transforms.Text.WordHashBagEstimator" /> tokenizes text internally.
             </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.ProduceHashedNgrams(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String[],System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="ProduceHashedWordBags">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.WordHashBagEstimator ProduceHashedWordBags (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string outputColumnName, string inputColumnName = null, int numberOfBits = 16, int ngramLength = 1, int skipLength = 0, bool useAllLengths = true, uint seed = 314489979, bool useOrderedHashing = true, int maximumNumberOfInverts = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.WordHashBagEstimator ProduceHashedWordBags(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string outputColumnName, string inputColumnName, int32 numberOfBits, int32 ngramLength, int32 skipLength, bool useAllLengths, unsigned int32 seed, bool useOrderedHashing, int32 maximumNumberOfInverts) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.ProduceHashedWordBags(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProduceHashedWordBags (catalog As TransformsCatalog.TextTransforms, outputColumnName As String, Optional inputColumnName As String = null, Optional numberOfBits As Integer = 16, Optional ngramLength As Integer = 1, Optional skipLength As Integer = 0, Optional useAllLengths As Boolean = true, Optional seed As UInteger = 314489979, Optional useOrderedHashing As Boolean = true, Optional maximumNumberOfInverts As Integer = 0) As WordHashBagEstimator" />
        <MemberSignature Language="F#" Value="static member ProduceHashedWordBags : Microsoft.ML.TransformsCatalog.TextTransforms * string * string * int * int * int * bool * uint32 * bool * int -&gt; Microsoft.ML.Transforms.Text.WordHashBagEstimator" Usage="Microsoft.ML.TextCatalog.ProduceHashedWordBags (catalog, outputColumnName, inputColumnName, numberOfBits, ngramLength, skipLength, useAllLengths, seed, useOrderedHashing, maximumNumberOfInverts)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.WordHashBagEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="numberOfBits" Type="System.Int32" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="useAllLengths" Type="System.Boolean" />
          <Parameter Name="seed" Type="System.UInt32" />
          <Parameter Name="useOrderedHashing" Type="System.Boolean" />
          <Parameter Name="maximumNumberOfInverts" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="numberOfBits">Number of bits to hash into. Must be between 1 and 30, inclusive.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="useAllLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="seed">Hashing seed.</param>
          <param name="useOrderedHashing">Whether the position of each source column should be included in the hash (when there are multiple source columns).</param>
          <param name="maximumNumberOfInverts">During hashing we constuct mappings between original values and the produced hash values.
            Text representation of original values are stored in the slot names of the  metadata for the new column.Hashing, as such, can map many initial values to one.
            <paramref name="maximumNumberOfInverts" /> specifies the upper bound of the number of distinct input values mapping to a hash that should be retained.
            <value>0</value> does not retain any input values. <value>-1</value> retains all input values mapping to each hash.</param>
          <summary>
            Produces a bag of counts of hashed ngrams in <paramref name="inputColumnName" />
            and outputs bag of word vector as <paramref name="outputColumnName" /></summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.ProduceHashedWordBags(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="ProduceHashedWordBags">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.WordHashBagEstimator ProduceHashedWordBags (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string outputColumnName, string[] inputColumnNames, int numberOfBits = 16, int ngramLength = 1, int skipLength = 0, bool useAllLengths = true, uint seed = 314489979, bool useOrderedHashing = true, int maximumNumberOfInverts = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.WordHashBagEstimator ProduceHashedWordBags(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string outputColumnName, string[] inputColumnNames, int32 numberOfBits, int32 ngramLength, int32 skipLength, bool useAllLengths, unsigned int32 seed, bool useOrderedHashing, int32 maximumNumberOfInverts) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.ProduceHashedWordBags(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String[],System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProduceHashedWordBags (catalog As TransformsCatalog.TextTransforms, outputColumnName As String, inputColumnNames As String(), Optional numberOfBits As Integer = 16, Optional ngramLength As Integer = 1, Optional skipLength As Integer = 0, Optional useAllLengths As Boolean = true, Optional seed As UInteger = 314489979, Optional useOrderedHashing As Boolean = true, Optional maximumNumberOfInverts As Integer = 0) As WordHashBagEstimator" />
        <MemberSignature Language="F#" Value="static member ProduceHashedWordBags : Microsoft.ML.TransformsCatalog.TextTransforms * string * string[] * int * int * int * bool * uint32 * bool * int -&gt; Microsoft.ML.Transforms.Text.WordHashBagEstimator" Usage="Microsoft.ML.TextCatalog.ProduceHashedWordBags (catalog, outputColumnName, inputColumnNames, numberOfBits, ngramLength, skipLength, useAllLengths, seed, useOrderedHashing, maximumNumberOfInverts)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.WordHashBagEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnNames" Type="System.String[]" />
          <Parameter Name="numberOfBits" Type="System.Int32" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="useAllLengths" Type="System.Boolean" />
          <Parameter Name="seed" Type="System.UInt32" />
          <Parameter Name="useOrderedHashing" Type="System.Boolean" />
          <Parameter Name="maximumNumberOfInverts" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnNames" />.</param>
          <param name="inputColumnNames">Name of the columns to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="numberOfBits">Number of bits to hash into. Must be between 1 and 30, inclusive.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="useAllLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="seed">Hashing seed.</param>
          <param name="useOrderedHashing">Whether the position of each source column should be included in the hash (when there are multiple source columns).</param>
          <param name="maximumNumberOfInverts">During hashing we constuct mappings between original values and the produced hash values.
            Text representation of original values are stored in the slot names of the  metadata for the new column.Hashing, as such, can map many initial values to one.
            <paramref name="maximumNumberOfInverts" /> specifies the upper bound of the number of distinct input values mapping to a hash that should be retained.
            <value>0</value> does not retain any input values. <value>-1</value> retains all input values mapping to each hash.</param>
          <summary>
            Produces a bag of counts of hashed ngrams in <paramref name="inputColumnNames" />
            and outputs bag of word vector as <paramref name="outputColumnName" /></summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.ProduceHashedWordBags(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String[],System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="ProduceNgrams">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.NgramExtractingEstimator ProduceNgrams (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string outputColumnName, string inputColumnName = null, int ngramLength = 2, int skipLength = 0, bool useAllLengths = true, int maximumNgramsCount = 10000000, Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria weighting = Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria.Tf);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.NgramExtractingEstimator ProduceNgrams(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string outputColumnName, string inputColumnName, int32 ngramLength, int32 skipLength, bool useAllLengths, int32 maximumNgramsCount, valuetype Microsoft.ML.Transforms.Text.NgramExtractingEstimator/WeightingCriteria weighting) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.ProduceNgrams(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProduceNgrams (catalog As TransformsCatalog.TextTransforms, outputColumnName As String, Optional inputColumnName As String = null, Optional ngramLength As Integer = 2, Optional skipLength As Integer = 0, Optional useAllLengths As Boolean = true, Optional maximumNgramsCount As Integer = 10000000, Optional weighting As NgramExtractingEstimator.WeightingCriteria = Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria.Tf) As NgramExtractingEstimator" />
        <MemberSignature Language="F#" Value="static member ProduceNgrams : Microsoft.ML.TransformsCatalog.TextTransforms * string * string * int * int * bool * int * Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria -&gt; Microsoft.ML.Transforms.Text.NgramExtractingEstimator" Usage="Microsoft.ML.TextCatalog.ProduceNgrams (catalog, outputColumnName, inputColumnName, ngramLength, skipLength, useAllLengths, maximumNgramsCount, weighting)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.NgramExtractingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="useAllLengths" Type="System.Boolean" />
          <Parameter Name="maximumNgramsCount" Type="System.Int32" />
          <Parameter Name="weighting" Type="Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="useAllLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="maximumNgramsCount">Maximum number of n-grams to store in the dictionary.</param>
          <param name="weighting">Statistical measure used to evaluate how important a word is to a document in a corpus.</param>
          <summary>
            Produces a bag of counts of ngrams (sequences of consecutive words) in <paramref name="inputColumnName" />
            and outputs bag of word vector as <paramref name="outputColumnName" /></summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.ProduceNgrams(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="ProduceWordBags">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.WordBagEstimator ProduceWordBags (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string outputColumnName, string inputColumnName = null, int ngramLength = 2, int skipLength = 0, bool useAllLengths = true, int maximumNgramsCount = 10000000, Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria weighting = Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria.Tf);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.WordBagEstimator ProduceWordBags(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string outputColumnName, string inputColumnName, int32 ngramLength, int32 skipLength, bool useAllLengths, int32 maximumNgramsCount, valuetype Microsoft.ML.Transforms.Text.NgramExtractingEstimator/WeightingCriteria weighting) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.ProduceWordBags(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProduceWordBags (catalog As TransformsCatalog.TextTransforms, outputColumnName As String, Optional inputColumnName As String = null, Optional ngramLength As Integer = 2, Optional skipLength As Integer = 0, Optional useAllLengths As Boolean = true, Optional maximumNgramsCount As Integer = 10000000, Optional weighting As NgramExtractingEstimator.WeightingCriteria = Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria.Tf) As WordBagEstimator" />
        <MemberSignature Language="F#" Value="static member ProduceWordBags : Microsoft.ML.TransformsCatalog.TextTransforms * string * string * int * int * bool * int * Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria -&gt; Microsoft.ML.Transforms.Text.WordBagEstimator" Usage="Microsoft.ML.TextCatalog.ProduceWordBags (catalog, outputColumnName, inputColumnName, ngramLength, skipLength, useAllLengths, maximumNgramsCount, weighting)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.WordBagEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="useAllLengths" Type="System.Boolean" />
          <Parameter Name="maximumNgramsCount" Type="System.Int32" />
          <Parameter Name="weighting" Type="Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="useAllLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="maximumNgramsCount">Maximum number of ngrams to store in the dictionary.</param>
          <param name="weighting">Statistical measure used to evaluate how important a word is to a document in a corpus.</param>
          <summary>
            Produces a bag of counts of ngrams (sequences of consecutive words) in <paramref name="inputColumnName" />
            and outputs bag of word vector as <paramref name="outputColumnName" /></summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.ProduceWordBags(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="ProduceWordBags">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.WordBagEstimator ProduceWordBags (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string outputColumnName, string[] inputColumnNames, int ngramLength = 2, int skipLength = 0, bool useAllLengths = true, int maximumNgramsCount = 10000000, Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria weighting = Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria.Tf);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.WordBagEstimator ProduceWordBags(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string outputColumnName, string[] inputColumnNames, int32 ngramLength, int32 skipLength, bool useAllLengths, int32 maximumNgramsCount, valuetype Microsoft.ML.Transforms.Text.NgramExtractingEstimator/WeightingCriteria weighting) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.ProduceWordBags(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String[],System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProduceWordBags (catalog As TransformsCatalog.TextTransforms, outputColumnName As String, inputColumnNames As String(), Optional ngramLength As Integer = 2, Optional skipLength As Integer = 0, Optional useAllLengths As Boolean = true, Optional maximumNgramsCount As Integer = 10000000, Optional weighting As NgramExtractingEstimator.WeightingCriteria = Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria.Tf) As WordBagEstimator" />
        <MemberSignature Language="F#" Value="static member ProduceWordBags : Microsoft.ML.TransformsCatalog.TextTransforms * string * string[] * int * int * bool * int * Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria -&gt; Microsoft.ML.Transforms.Text.WordBagEstimator" Usage="Microsoft.ML.TextCatalog.ProduceWordBags (catalog, outputColumnName, inputColumnNames, ngramLength, skipLength, useAllLengths, maximumNgramsCount, weighting)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.WordBagEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnNames" Type="System.String[]" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="useAllLengths" Type="System.Boolean" />
          <Parameter Name="maximumNgramsCount" Type="System.Int32" />
          <Parameter Name="weighting" Type="Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnNames" />.</param>
          <param name="inputColumnNames">Name of the columns to transform.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="useAllLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="maximumNgramsCount">Maximum number of ngrams to store in the dictionary.</param>
          <param name="weighting">Statistical measure used to evaluate how important a word is to a document in a corpus.</param>
          <summary>
            Produces a bag of counts of ngrams (sequences of consecutive words) in <paramref name="inputColumnNames" />
            and outputs bag of word vector as <paramref name="outputColumnName" /></summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.ProduceWordBags(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String[],System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="RemoveDefaultStopWords">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator RemoveDefaultStopWords (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string outputColumnName, string inputColumnName = null, Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator.Language language = Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator+Language.English);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator RemoveDefaultStopWords(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string outputColumnName, string inputColumnName, valuetype Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator/Language language) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.RemoveDefaultStopWords(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator.Language)" />
        <MemberSignature Language="F#" Value="static member RemoveDefaultStopWords : Microsoft.ML.TransformsCatalog.TextTransforms * string * string * Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator.Language -&gt; Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator" Usage="Microsoft.ML.TextCatalog.RemoveDefaultStopWords (catalog, outputColumnName, inputColumnName, language)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="language" Type="Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator+Language" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="outputColumnName">The column containing output text. Null means <paramref name="inputColumnName" /> is replaced.</param>
          <param name="inputColumnName">The column containing text to remove stop words on.</param>
          <param name="language">Langauge of the input text column <paramref name="inputColumnName" />.</param>
          <summary>
            Removes stop words from incoming token streams in <paramref name="inputColumnName" />
            and outputs the token streams without stopwords as <paramref name="outputColumnName" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.RemoveDefaultStopWords(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator.Language)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="RemoveStopWords">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.CustomStopWordsRemovingEstimator RemoveStopWords (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string outputColumnName, string inputColumnName = null, params string[] stopwords);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.CustomStopWordsRemovingEstimator RemoveStopWords(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string outputColumnName, string inputColumnName, string[] stopwords) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.RemoveStopWords(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.String[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function RemoveStopWords (catalog As TransformsCatalog.TextTransforms, outputColumnName As String, Optional inputColumnName As String = null, ParamArray stopwords As String()) As CustomStopWordsRemovingEstimator" />
        <MemberSignature Language="F#" Value="static member RemoveStopWords : Microsoft.ML.TransformsCatalog.TextTransforms * string * string * string[] -&gt; Microsoft.ML.Transforms.Text.CustomStopWordsRemovingEstimator" Usage="Microsoft.ML.TextCatalog.RemoveStopWords (catalog, outputColumnName, inputColumnName, stopwords)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.CustomStopWordsRemovingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="stopwords" Type="System.String[]">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet">
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="outputColumnName">The column containing output text. Null means <paramref name="inputColumnName" /> is replaced.</param>
          <param name="inputColumnName">The column containing text to remove stop words on.</param>
          <param name="stopwords">Array of words to remove.</param>
          <summary>
            Removes stop words from incoming token streams in <paramref name="inputColumnName" />
            and outputs the token streams without stopwords as <paramref name="outputColumnName" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.RemoveStopWords(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.String[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="TokenizeIntoCharactersAsKeys">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.TokenizingByCharactersEstimator TokenizeIntoCharactersAsKeys (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string outputColumnName, string inputColumnName = null, bool useMarkerCharacters = true);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.TokenizingByCharactersEstimator TokenizeIntoCharactersAsKeys(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string outputColumnName, string inputColumnName, bool useMarkerCharacters) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.TokenizeIntoCharactersAsKeys(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TokenizeIntoCharactersAsKeys (catalog As TransformsCatalog.TextTransforms, outputColumnName As String, Optional inputColumnName As String = null, Optional useMarkerCharacters As Boolean = true) As TokenizingByCharactersEstimator" />
        <MemberSignature Language="F#" Value="static member TokenizeIntoCharactersAsKeys : Microsoft.ML.TransformsCatalog.TextTransforms * string * string * bool -&gt; Microsoft.ML.Transforms.Text.TokenizingByCharactersEstimator" Usage="Microsoft.ML.TextCatalog.TokenizeIntoCharactersAsKeys (catalog, outputColumnName, inputColumnName, useMarkerCharacters)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.TokenizingByCharactersEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="useMarkerCharacters" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="useMarkerCharacters">Whether to prepend a marker character, <see langword="0x02" />, to the beginning,
            and append another marker character, <see langword="0x03" />, to the end of the output vector of characters.</param>
          <summary>
            Tokenize incoming text in <paramref name="inputColumnName" /> and output the tokens as <paramref name="outputColumnName" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.TokenizeIntoCharactersAsKeys(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="TokenizeIntoWords">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.WordTokenizingEstimator TokenizeIntoWords (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string outputColumnName, string inputColumnName = null, char[] separators = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.WordTokenizingEstimator TokenizeIntoWords(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string outputColumnName, string inputColumnName, char[] separators) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.TokenizeIntoWords(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Char[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TokenizeIntoWords (catalog As TransformsCatalog.TextTransforms, outputColumnName As String, Optional inputColumnName As String = null, Optional separators As Char() = null) As WordTokenizingEstimator" />
        <MemberSignature Language="F#" Value="static member TokenizeIntoWords : Microsoft.ML.TransformsCatalog.TextTransforms * string * string * char[] -&gt; Microsoft.ML.Transforms.Text.WordTokenizingEstimator" Usage="Microsoft.ML.TextCatalog.TokenizeIntoWords (catalog, outputColumnName, inputColumnName, separators)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.WordTokenizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="separators" Type="System.Char[]" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of the column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="separators">The separators to use (uses space character by default).</param>
          <summary>
            Tokenizes incoming text in <paramref name="inputColumnName" />, using <paramref name="separators" /> as separators,
            and outputs the tokens as <paramref name="outputColumnName" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.TokenizeIntoWords(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Char[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataOperationsCatalog" />
      </Targets>
      <Member MemberName="CreateTextLoader">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.TextLoader CreateTextLoader (this Microsoft.ML.DataOperationsCatalog catalog, Microsoft.ML.Data.TextLoader.Column[] columns, char separatorChar = '\t', bool hasHeader = false, Microsoft.ML.Data.IMultiStreamSource dataSample = null, bool allowQuoting = false, bool trimWhitespace = false, bool allowSparse = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.TextLoader CreateTextLoader(class Microsoft.ML.DataOperationsCatalog catalog, class Microsoft.ML.Data.TextLoader/Column[] columns, char separatorChar, bool hasHeader, class Microsoft.ML.Data.IMultiStreamSource dataSample, bool allowQuoting, bool trimWhitespace, bool allowSparse) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextLoaderSaverCatalog.CreateTextLoader(Microsoft.ML.DataOperationsCatalog,Microsoft.ML.Data.TextLoader.Column[],System.Char,System.Boolean,Microsoft.ML.Data.IMultiStreamSource,System.Boolean,System.Boolean,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateTextLoader (catalog As DataOperationsCatalog, columns As TextLoader.Column(), Optional separatorChar As Char = '\t', Optional hasHeader As Boolean = false, Optional dataSample As IMultiStreamSource = null, Optional allowQuoting As Boolean = false, Optional trimWhitespace As Boolean = false, Optional allowSparse As Boolean = false) As TextLoader" />
        <MemberSignature Language="F#" Value="static member CreateTextLoader : Microsoft.ML.DataOperationsCatalog * Microsoft.ML.Data.TextLoader.Column[] * char * bool * Microsoft.ML.Data.IMultiStreamSource * bool * bool * bool -&gt; Microsoft.ML.Data.TextLoader" Usage="Microsoft.ML.TextLoaderSaverCatalog.CreateTextLoader (catalog, columns, separatorChar, hasHeader, dataSample, allowQuoting, trimWhitespace, allowSparse)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.TextLoader</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.DataOperationsCatalog" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.Data.TextLoader+Column[]" />
          <Parameter Name="separatorChar" Type="System.Char" />
          <Parameter Name="hasHeader" Type="System.Boolean" />
          <Parameter Name="dataSample" Type="Microsoft.ML.Data.IMultiStreamSource" />
          <Parameter Name="allowQuoting" Type="System.Boolean" />
          <Parameter Name="trimWhitespace" Type="System.Boolean" />
          <Parameter Name="allowSparse" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.DataOperationsCatalog" /> catalog.</param>
          <param name="columns">Array of columns <see cref="T:Microsoft.ML.Data.TextLoader.Column" /> defining the schema.</param>
          <param name="separatorChar">The character used as separator between data points in a row. By default the tab character is used as separator.</param>
          <param name="hasHeader">Whether the file has a header.</param>
          <param name="dataSample">The optional location of a data sample. The sample can be used to infer column names and number of slots in each column.</param>
          <param name="allowQuoting">Whether the file can contain column defined by a quoted string.</param>
          <param name="trimWhitespace">Remove trailing whitespace from lines</param>
          <param name="allowSparse">Whether the file can contain numerical vectors in sparse format.</param>
          <summary>
            Create a text loader <see cref="T:Microsoft.ML.Data.TextLoader" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextLoaderSaverCatalog" Member="M:Microsoft.ML.TextLoaderSaverCatalog.CreateTextLoader(Microsoft.ML.DataOperationsCatalog,Microsoft.ML.Data.TextLoader.Column[],System.Char,System.Boolean,Microsoft.ML.Data.IMultiStreamSource,System.Boolean,System.Boolean,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataOperationsCatalog" />
      </Targets>
      <Member MemberName="CreateTextLoader">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.TextLoader CreateTextLoader (this Microsoft.ML.DataOperationsCatalog catalog, Microsoft.ML.Data.TextLoader.Options options, Microsoft.ML.Data.IMultiStreamSource dataSample = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.TextLoader CreateTextLoader(class Microsoft.ML.DataOperationsCatalog catalog, class Microsoft.ML.Data.TextLoader/Options options, class Microsoft.ML.Data.IMultiStreamSource dataSample) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextLoaderSaverCatalog.CreateTextLoader(Microsoft.ML.DataOperationsCatalog,Microsoft.ML.Data.TextLoader.Options,Microsoft.ML.Data.IMultiStreamSource)" />
        <MemberSignature Language="F#" Value="static member CreateTextLoader : Microsoft.ML.DataOperationsCatalog * Microsoft.ML.Data.TextLoader.Options * Microsoft.ML.Data.IMultiStreamSource -&gt; Microsoft.ML.Data.TextLoader" Usage="Microsoft.ML.TextLoaderSaverCatalog.CreateTextLoader (catalog, options, dataSample)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.TextLoader</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.DataOperationsCatalog" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Data.TextLoader+Options" />
          <Parameter Name="dataSample" Type="Microsoft.ML.Data.IMultiStreamSource" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.DataOperationsCatalog" /> catalog.</param>
          <param name="options">Defines the settings of the load operation.</param>
          <param name="dataSample">The optional location of a data sample. The sample can be used to infer column names and number of slots in each column.</param>
          <summary>
            Create a text loader <see cref="T:Microsoft.ML.Data.TextLoader" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextLoaderSaverCatalog" Member="M:Microsoft.ML.TextLoaderSaverCatalog.CreateTextLoader(Microsoft.ML.DataOperationsCatalog,Microsoft.ML.Data.TextLoader.Options,Microsoft.ML.Data.IMultiStreamSource)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataOperationsCatalog" />
      </Targets>
      <Member MemberName="CreateTextLoader&lt;TInput&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.TextLoader CreateTextLoader&lt;TInput&gt; (this Microsoft.ML.DataOperationsCatalog catalog, char separatorChar = '\t', bool hasHeader = false, Microsoft.ML.Data.IMultiStreamSource dataSample = null, bool allowQuoting = false, bool trimWhitespace = false, bool allowSparse = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.TextLoader CreateTextLoader&lt;TInput&gt;(class Microsoft.ML.DataOperationsCatalog catalog, char separatorChar, bool hasHeader, class Microsoft.ML.Data.IMultiStreamSource dataSample, bool allowQuoting, bool trimWhitespace, bool allowSparse) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextLoaderSaverCatalog.CreateTextLoader``1(Microsoft.ML.DataOperationsCatalog,System.Char,System.Boolean,Microsoft.ML.Data.IMultiStreamSource,System.Boolean,System.Boolean,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateTextLoader(Of TInput) (catalog As DataOperationsCatalog, Optional separatorChar As Char = '\t', Optional hasHeader As Boolean = false, Optional dataSample As IMultiStreamSource = null, Optional allowQuoting As Boolean = false, Optional trimWhitespace As Boolean = false, Optional allowSparse As Boolean = false) As TextLoader" />
        <MemberSignature Language="F#" Value="static member CreateTextLoader : Microsoft.ML.DataOperationsCatalog * char * bool * Microsoft.ML.Data.IMultiStreamSource * bool * bool * bool -&gt; Microsoft.ML.Data.TextLoader" Usage="Microsoft.ML.TextLoaderSaverCatalog.CreateTextLoader (catalog, separatorChar, hasHeader, dataSample, allowQuoting, trimWhitespace, allowSparse)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.TextLoader</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TInput" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.DataOperationsCatalog" RefType="this" />
          <Parameter Name="separatorChar" Type="System.Char" />
          <Parameter Name="hasHeader" Type="System.Boolean" />
          <Parameter Name="dataSample" Type="Microsoft.ML.Data.IMultiStreamSource" />
          <Parameter Name="allowQuoting" Type="System.Boolean" />
          <Parameter Name="trimWhitespace" Type="System.Boolean" />
          <Parameter Name="allowSparse" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <typeparam name="TInput">To be added.</typeparam>
          <param name="catalog">The <see cref="T:Microsoft.ML.DataOperationsCatalog" /> catalog.</param>
          <param name="separatorChar">Column separator character. Default is '\t'</param>
          <param name="hasHeader">Does the file contains header?</param>
          <param name="dataSample">The optional location of a data sample. The sample can be used to infer column names and number of slots in each column.</param>
          <param name="allowQuoting">Whether the input may include quoted values,
            which can contain separator characters, colons,
            and distinguish empty values from missing values. When true, consecutive separators
            denote a missing value and an empty value is denoted by \"\".
            When false, consecutive separators denote an empty value.</param>
          <param name="trimWhitespace">Remove trailing whitespace from lines</param>
          <param name="allowSparse">Whether the input may include sparse representations for example,
            if one of the row contains "5 2:6 4:3" that's mean there are 5 columns all zero
            except for 3rd and 5th columns which have values 6 and 3</param>
          <summary>
            Create a text loader <see cref="T:Microsoft.ML.Data.TextLoader" /> by inferencing the dataset schema from a data model type.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextLoaderSaverCatalog" Member="M:Microsoft.ML.TextLoaderSaverCatalog.CreateTextLoader``1(Microsoft.ML.DataOperationsCatalog,System.Char,System.Boolean,Microsoft.ML.Data.IMultiStreamSource,System.Boolean,System.Boolean,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataOperationsCatalog" />
      </Targets>
      <Member MemberName="LoadFromTextFile">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.IDataView LoadFromTextFile (this Microsoft.ML.DataOperationsCatalog catalog, string path, Microsoft.ML.Data.TextLoader.Column[] columns, char separatorChar = '\t', bool hasHeader = false, bool allowQuoting = false, bool trimWhitespace = false, bool allowSparse = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.IDataView LoadFromTextFile(class Microsoft.ML.DataOperationsCatalog catalog, string path, class Microsoft.ML.Data.TextLoader/Column[] columns, char separatorChar, bool hasHeader, bool allowQuoting, bool trimWhitespace, bool allowSparse) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextLoaderSaverCatalog.LoadFromTextFile(Microsoft.ML.DataOperationsCatalog,System.String,Microsoft.ML.Data.TextLoader.Column[],System.Char,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LoadFromTextFile (catalog As DataOperationsCatalog, path As String, columns As TextLoader.Column(), Optional separatorChar As Char = '\t', Optional hasHeader As Boolean = false, Optional allowQuoting As Boolean = false, Optional trimWhitespace As Boolean = false, Optional allowSparse As Boolean = false) As IDataView" />
        <MemberSignature Language="F#" Value="static member LoadFromTextFile : Microsoft.ML.DataOperationsCatalog * string * Microsoft.ML.Data.TextLoader.Column[] * char * bool * bool * bool * bool -&gt; Microsoft.ML.IDataView" Usage="Microsoft.ML.TextLoaderSaverCatalog.LoadFromTextFile (catalog, path, columns, separatorChar, hasHeader, allowQuoting, trimWhitespace, allowSparse)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.IDataView</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.DataOperationsCatalog" RefType="this" />
          <Parameter Name="path" Type="System.String" />
          <Parameter Name="columns" Type="Microsoft.ML.Data.TextLoader+Column[]" />
          <Parameter Name="separatorChar" Type="System.Char" />
          <Parameter Name="hasHeader" Type="System.Boolean" />
          <Parameter Name="allowQuoting" Type="System.Boolean" />
          <Parameter Name="trimWhitespace" Type="System.Boolean" />
          <Parameter Name="allowSparse" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.DataOperationsCatalog" /> catalog.</param>
          <param name="path">The path to the file.</param>
          <param name="columns">The columns of the schema.</param>
          <param name="separatorChar">The character used as separator between data points in a row. By default the tab character is used as separator.</param>
          <param name="hasHeader">Whether the file has a header.</param>
          <param name="allowQuoting">Whether the file can contain column defined by a quoted string.</param>
          <param name="trimWhitespace">Remove trailing whitespace from lines</param>
          <param name="allowSparse">Whether the file can contain numerical vectors in sparse format.</param>
          <summary>
            Load a <see cref="T:Microsoft.ML.IDataView" /> from a text file using <see cref="T:Microsoft.ML.Data.TextLoader" />.
            Note that <see cref="T:Microsoft.ML.IDataView" />'s are lazy, so no actual loading happens here, just schema validation.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextLoaderSaverCatalog" Member="M:Microsoft.ML.TextLoaderSaverCatalog.LoadFromTextFile(Microsoft.ML.DataOperationsCatalog,System.String,Microsoft.ML.Data.TextLoader.Column[],System.Char,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataOperationsCatalog" />
      </Targets>
      <Member MemberName="LoadFromTextFile">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.IDataView LoadFromTextFile (this Microsoft.ML.DataOperationsCatalog catalog, string path, Microsoft.ML.Data.TextLoader.Options options = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.IDataView LoadFromTextFile(class Microsoft.ML.DataOperationsCatalog catalog, string path, class Microsoft.ML.Data.TextLoader/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextLoaderSaverCatalog.LoadFromTextFile(Microsoft.ML.DataOperationsCatalog,System.String,Microsoft.ML.Data.TextLoader.Options)" />
        <MemberSignature Language="F#" Value="static member LoadFromTextFile : Microsoft.ML.DataOperationsCatalog * string * Microsoft.ML.Data.TextLoader.Options -&gt; Microsoft.ML.IDataView" Usage="Microsoft.ML.TextLoaderSaverCatalog.LoadFromTextFile (catalog, path, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.IDataView</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.DataOperationsCatalog" RefType="this" />
          <Parameter Name="path" Type="System.String" />
          <Parameter Name="options" Type="Microsoft.ML.Data.TextLoader+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.DataOperationsCatalog" /> catalog.</param>
          <param name="path">Specifies a file from which to load.</param>
          <param name="options">Defines the settings of the load operation.</param>
          <summary>
            Load a <see cref="T:Microsoft.ML.IDataView" /> from a text file using <see cref="T:Microsoft.ML.Data.TextLoader" />.
            Note that <see cref="T:Microsoft.ML.IDataView" />'s are lazy, so no actual loading happens here, just schema validation.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextLoaderSaverCatalog" Member="M:Microsoft.ML.TextLoaderSaverCatalog.LoadFromTextFile(Microsoft.ML.DataOperationsCatalog,System.String,Microsoft.ML.Data.TextLoader.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataOperationsCatalog" />
      </Targets>
      <Member MemberName="LoadFromTextFile&lt;TInput&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.IDataView LoadFromTextFile&lt;TInput&gt; (this Microsoft.ML.DataOperationsCatalog catalog, string path, char separatorChar = '\t', bool hasHeader = false, bool allowQuoting = false, bool trimWhitespace = false, bool allowSparse = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.IDataView LoadFromTextFile&lt;TInput&gt;(class Microsoft.ML.DataOperationsCatalog catalog, string path, char separatorChar, bool hasHeader, bool allowQuoting, bool trimWhitespace, bool allowSparse) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextLoaderSaverCatalog.LoadFromTextFile``1(Microsoft.ML.DataOperationsCatalog,System.String,System.Char,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LoadFromTextFile(Of TInput) (catalog As DataOperationsCatalog, path As String, Optional separatorChar As Char = '\t', Optional hasHeader As Boolean = false, Optional allowQuoting As Boolean = false, Optional trimWhitespace As Boolean = false, Optional allowSparse As Boolean = false) As IDataView" />
        <MemberSignature Language="F#" Value="static member LoadFromTextFile : Microsoft.ML.DataOperationsCatalog * string * char * bool * bool * bool * bool -&gt; Microsoft.ML.IDataView" Usage="Microsoft.ML.TextLoaderSaverCatalog.LoadFromTextFile (catalog, path, separatorChar, hasHeader, allowQuoting, trimWhitespace, allowSparse)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.IDataView</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TInput" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.DataOperationsCatalog" RefType="this" />
          <Parameter Name="path" Type="System.String" />
          <Parameter Name="separatorChar" Type="System.Char" />
          <Parameter Name="hasHeader" Type="System.Boolean" />
          <Parameter Name="allowQuoting" Type="System.Boolean" />
          <Parameter Name="trimWhitespace" Type="System.Boolean" />
          <Parameter Name="allowSparse" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <typeparam name="TInput">To be added.</typeparam>
          <param name="catalog">The <see cref="T:Microsoft.ML.DataOperationsCatalog" /> catalog.</param>
          <param name="path">The path to the file.</param>
          <param name="separatorChar">Column separator character. Default is '\t'</param>
          <param name="hasHeader">Does the file contains header?</param>
          <param name="allowQuoting">Whether the input may include quoted values,
            which can contain separator characters, colons,
            and distinguish empty values from missing values. When true, consecutive separators
            denote a missing value and an empty value is denoted by \"\".
            When false, consecutive separators denote an empty value.</param>
          <param name="trimWhitespace">Remove trailing whitespace from lines</param>
          <param name="allowSparse">Whether the input may include sparse representations for example,
            if one of the row contains "5 2:6 4:3" that's mean there are 5 columns all zero
            except for 3rd and 5th columns which have values 6 and 3</param>
          <summary>
            Load a <see cref="T:Microsoft.ML.IDataView" /> from a text file using <see cref="T:Microsoft.ML.Data.TextLoader" />.
            Note that <see cref="T:Microsoft.ML.IDataView" />'s are lazy, so no actual loading happens here, just schema validation.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextLoaderSaverCatalog" Member="M:Microsoft.ML.TextLoaderSaverCatalog.LoadFromTextFile``1(Microsoft.ML.DataOperationsCatalog,System.String,System.Char,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataOperationsCatalog" />
      </Targets>
      <Member MemberName="SaveAsText">
        <MemberSignature Language="C#" Value="public static void SaveAsText (this Microsoft.ML.DataOperationsCatalog catalog, Microsoft.ML.IDataView data, System.IO.Stream stream, char separatorChar = '\t', bool headerRow = true, bool schema = true, bool keepHidden = false, bool forceDense = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SaveAsText(class Microsoft.ML.DataOperationsCatalog catalog, class Microsoft.ML.IDataView data, class System.IO.Stream stream, char separatorChar, bool headerRow, bool schema, bool keepHidden, bool forceDense) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextLoaderSaverCatalog.SaveAsText(Microsoft.ML.DataOperationsCatalog,Microsoft.ML.IDataView,System.IO.Stream,System.Char,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
        <MemberSignature Language="F#" Value="static member SaveAsText : Microsoft.ML.DataOperationsCatalog * Microsoft.ML.IDataView * System.IO.Stream * char * bool * bool * bool * bool -&gt; unit" Usage="Microsoft.ML.TextLoaderSaverCatalog.SaveAsText (catalog, data, stream, separatorChar, headerRow, schema, keepHidden, forceDense)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.DataOperationsCatalog" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.IDataView" />
          <Parameter Name="stream" Type="System.IO.Stream" />
          <Parameter Name="separatorChar" Type="System.Char" />
          <Parameter Name="headerRow" Type="System.Boolean" />
          <Parameter Name="schema" Type="System.Boolean" />
          <Parameter Name="keepHidden" Type="System.Boolean" />
          <Parameter Name="forceDense" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.DataOperationsCatalog" /> catalog.</param>
          <param name="data">The data view to save.</param>
          <param name="stream">The stream to write to.</param>
          <param name="separatorChar">The column separator.</param>
          <param name="headerRow">Whether to write the header row.</param>
          <param name="schema">Whether to write the header comment with the schema.</param>
          <param name="keepHidden">Whether to keep hidden columns in the dataset.</param>
          <param name="forceDense">Whether to save columns in dense format even if they are sparse vectors.</param>
          <summary>
            Save the <see cref="T:Microsoft.ML.IDataView" /> as text.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextLoaderSaverCatalog" Member="M:Microsoft.ML.TextLoaderSaverCatalog.SaveAsText(Microsoft.ML.DataOperationsCatalog,Microsoft.ML.IDataView,System.IO.Stream,System.Char,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="DetectChangePointBySsa">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.TimeSeries.SsaChangePointEstimator DetectChangePointBySsa (this Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName, int confidence, int changeHistoryLength, int trainingWindowSize, int seasonalityWindowSize, Microsoft.ML.Transforms.TimeSeries.ErrorFunction errorFunction = Microsoft.ML.Transforms.TimeSeries.ErrorFunction.SignedDifference, Microsoft.ML.Transforms.TimeSeries.MartingaleType martingale = Microsoft.ML.Transforms.TimeSeries.MartingaleType.Power, double eps = 0.1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.TimeSeries.SsaChangePointEstimator DetectChangePointBySsa(class Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName, int32 confidence, int32 changeHistoryLength, int32 trainingWindowSize, int32 seasonalityWindowSize, valuetype Microsoft.ML.Transforms.TimeSeries.ErrorFunction errorFunction, valuetype Microsoft.ML.Transforms.TimeSeries.MartingaleType martingale, float64 eps) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TimeSeriesCatalog.DetectChangePointBySsa(Microsoft.ML.TransformsCatalog,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,Microsoft.ML.Transforms.TimeSeries.ErrorFunction,Microsoft.ML.Transforms.TimeSeries.MartingaleType,System.Double)" />
        <MemberSignature Language="F#" Value="static member DetectChangePointBySsa : Microsoft.ML.TransformsCatalog * string * string * int * int * int * int * Microsoft.ML.Transforms.TimeSeries.ErrorFunction * Microsoft.ML.Transforms.TimeSeries.MartingaleType * double -&gt; Microsoft.ML.Transforms.TimeSeries.SsaChangePointEstimator" Usage="Microsoft.ML.TimeSeriesCatalog.DetectChangePointBySsa (catalog, outputColumnName, inputColumnName, confidence, changeHistoryLength, trainingWindowSize, seasonalityWindowSize, errorFunction, martingale, eps)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.TimeSeries.SsaChangePointEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="confidence" Type="System.Int32" />
          <Parameter Name="changeHistoryLength" Type="System.Int32" />
          <Parameter Name="trainingWindowSize" Type="System.Int32" />
          <Parameter Name="seasonalityWindowSize" Type="System.Int32" />
          <Parameter Name="errorFunction" Type="Microsoft.ML.Transforms.TimeSeries.ErrorFunction" />
          <Parameter Name="martingale" Type="Microsoft.ML.Transforms.TimeSeries.MartingaleType" />
          <Parameter Name="eps" Type="System.Double" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.
            Column is a vector of type double and size 4. The vector contains Alert, Raw Score, P-Value and Martingale score as first four values.</param>
          <param name="inputColumnName">Name of column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="confidence">The confidence for change point detection in the range [0, 100].</param>
          <param name="changeHistoryLength">The size of the sliding window for computing the p-value.</param>
          <param name="trainingWindowSize">The number of points from the beginning of the sequence used for training.</param>
          <param name="seasonalityWindowSize">An upper bound on the largest relevant seasonality in the input time-series.</param>
          <param name="errorFunction">The function used to compute the error between the expected and the observed value.</param>
          <param name="martingale">The martingale used for scoring.</param>
          <param name="eps">The epsilon parameter for the Power martingale.</param>
          <summary>
            Create a new instance of <see cref="T:Microsoft.ML.Transforms.TimeSeries.SsaChangePointEstimator" /> for detecting a change in a time series signal
            using <a href="https://en.wikipedia.org/wiki/Singular_spectrum_analysis">Singular Spectrum Analysis (SSA)</a>.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TimeSeriesCatalog" Member="M:Microsoft.ML.TimeSeriesCatalog.DetectChangePointBySsa(Microsoft.ML.TransformsCatalog,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,Microsoft.ML.Transforms.TimeSeries.ErrorFunction,Microsoft.ML.Transforms.TimeSeries.MartingaleType,System.Double)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="DetectIidChangePoint">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.TimeSeries.IidChangePointEstimator DetectIidChangePoint (this Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName, int confidence, int changeHistoryLength, Microsoft.ML.Transforms.TimeSeries.MartingaleType martingale = Microsoft.ML.Transforms.TimeSeries.MartingaleType.Power, double eps = 0.1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.TimeSeries.IidChangePointEstimator DetectIidChangePoint(class Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName, int32 confidence, int32 changeHistoryLength, valuetype Microsoft.ML.Transforms.TimeSeries.MartingaleType martingale, float64 eps) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TimeSeriesCatalog.DetectIidChangePoint(Microsoft.ML.TransformsCatalog,System.String,System.String,System.Int32,System.Int32,Microsoft.ML.Transforms.TimeSeries.MartingaleType,System.Double)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DetectIidChangePoint (catalog As TransformsCatalog, outputColumnName As String, inputColumnName As String, confidence As Integer, changeHistoryLength As Integer, Optional martingale As MartingaleType = Microsoft.ML.Transforms.TimeSeries.MartingaleType.Power, Optional eps As Double = 0.1) As IidChangePointEstimator" />
        <MemberSignature Language="F#" Value="static member DetectIidChangePoint : Microsoft.ML.TransformsCatalog * string * string * int * int * Microsoft.ML.Transforms.TimeSeries.MartingaleType * double -&gt; Microsoft.ML.Transforms.TimeSeries.IidChangePointEstimator" Usage="Microsoft.ML.TimeSeriesCatalog.DetectIidChangePoint (catalog, outputColumnName, inputColumnName, confidence, changeHistoryLength, martingale, eps)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.TimeSeries.IidChangePointEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="confidence" Type="System.Int32" />
          <Parameter Name="changeHistoryLength" Type="System.Int32" />
          <Parameter Name="martingale" Type="Microsoft.ML.Transforms.TimeSeries.MartingaleType" />
          <Parameter Name="eps" Type="System.Double" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.
            Column is a vector of type double and size 4. The vector contains Alert, Raw Score, P-Value and Martingale score as first four values.</param>
          <param name="inputColumnName">Name of column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="confidence">The confidence for change point detection in the range [0, 100].</param>
          <param name="changeHistoryLength">The length of the sliding window on p-values for computing the martingale score.</param>
          <param name="martingale">The martingale used for scoring.</param>
          <param name="eps">The epsilon parameter for the Power martingale.</param>
          <summary>
            Create a new instance of <see cref="T:Microsoft.ML.Transforms.TimeSeries.IidChangePointEstimator" /> that detects a change of in an
            <a href="https://en.wikipedia.org/wiki/Independent_and_identically_distributed_random_variables"> independent identically distributed (i.i.d.)</a> time series.
            Detection is based on adaptive kernel density estimations and martingale scores.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TimeSeriesCatalog" Member="M:Microsoft.ML.TimeSeriesCatalog.DetectIidChangePoint(Microsoft.ML.TransformsCatalog,System.String,System.String,System.Int32,System.Int32,Microsoft.ML.Transforms.TimeSeries.MartingaleType,System.Double)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="DetectIidSpike">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.TimeSeries.IidSpikeEstimator DetectIidSpike (this Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName, int confidence, int pvalueHistoryLength, Microsoft.ML.Transforms.TimeSeries.AnomalySide side = Microsoft.ML.Transforms.TimeSeries.AnomalySide.TwoSided);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.TimeSeries.IidSpikeEstimator DetectIidSpike(class Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName, int32 confidence, int32 pvalueHistoryLength, valuetype Microsoft.ML.Transforms.TimeSeries.AnomalySide side) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TimeSeriesCatalog.DetectIidSpike(Microsoft.ML.TransformsCatalog,System.String,System.String,System.Int32,System.Int32,Microsoft.ML.Transforms.TimeSeries.AnomalySide)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DetectIidSpike (catalog As TransformsCatalog, outputColumnName As String, inputColumnName As String, confidence As Integer, pvalueHistoryLength As Integer, Optional side As AnomalySide = Microsoft.ML.Transforms.TimeSeries.AnomalySide.TwoSided) As IidSpikeEstimator" />
        <MemberSignature Language="F#" Value="static member DetectIidSpike : Microsoft.ML.TransformsCatalog * string * string * int * int * Microsoft.ML.Transforms.TimeSeries.AnomalySide -&gt; Microsoft.ML.Transforms.TimeSeries.IidSpikeEstimator" Usage="Microsoft.ML.TimeSeriesCatalog.DetectIidSpike (catalog, outputColumnName, inputColumnName, confidence, pvalueHistoryLength, side)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.TimeSeries.IidSpikeEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="confidence" Type="System.Int32" />
          <Parameter Name="pvalueHistoryLength" Type="System.Int32" />
          <Parameter Name="side" Type="Microsoft.ML.Transforms.TimeSeries.AnomalySide" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" /></param>
          <param name="inputColumnName">Name of column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.</param>
          <param name="confidence">The confidence for spike detection in the range [0, 100].</param>
          <param name="pvalueHistoryLength">The size of the sliding window for computing the p-value.</param>
          <param name="side">The argument that determines whether to detect positive or negative anomalies, or both.</param>
          <summary>
            Create a new instance of <see cref="T:Microsoft.ML.Transforms.TimeSeries.IidSpikeEstimator" /> that detects a spike in an
            <a href="https://en.wikipedia.org/wiki/Independent_and_identically_distributed_random_variables">independent identically distributed (i.i.d.)</a> time series.
            Detection is based on adaptive kernel density estimations and martingale scores.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TimeSeriesCatalog" Member="M:Microsoft.ML.TimeSeriesCatalog.DetectIidSpike(Microsoft.ML.TransformsCatalog,System.String,System.String,System.Int32,System.Int32,Microsoft.ML.Transforms.TimeSeries.AnomalySide)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="DetectSpikeBySsa">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.TimeSeries.SsaSpikeEstimator DetectSpikeBySsa (this Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName, int confidence, int pvalueHistoryLength, int trainingWindowSize, int seasonalityWindowSize, Microsoft.ML.Transforms.TimeSeries.AnomalySide side = Microsoft.ML.Transforms.TimeSeries.AnomalySide.TwoSided, Microsoft.ML.Transforms.TimeSeries.ErrorFunction errorFunction = Microsoft.ML.Transforms.TimeSeries.ErrorFunction.SignedDifference);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.TimeSeries.SsaSpikeEstimator DetectSpikeBySsa(class Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName, int32 confidence, int32 pvalueHistoryLength, int32 trainingWindowSize, int32 seasonalityWindowSize, valuetype Microsoft.ML.Transforms.TimeSeries.AnomalySide side, valuetype Microsoft.ML.Transforms.TimeSeries.ErrorFunction errorFunction) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TimeSeriesCatalog.DetectSpikeBySsa(Microsoft.ML.TransformsCatalog,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,Microsoft.ML.Transforms.TimeSeries.AnomalySide,Microsoft.ML.Transforms.TimeSeries.ErrorFunction)" />
        <MemberSignature Language="F#" Value="static member DetectSpikeBySsa : Microsoft.ML.TransformsCatalog * string * string * int * int * int * int * Microsoft.ML.Transforms.TimeSeries.AnomalySide * Microsoft.ML.Transforms.TimeSeries.ErrorFunction -&gt; Microsoft.ML.Transforms.TimeSeries.SsaSpikeEstimator" Usage="Microsoft.ML.TimeSeriesCatalog.DetectSpikeBySsa (catalog, outputColumnName, inputColumnName, confidence, pvalueHistoryLength, trainingWindowSize, seasonalityWindowSize, side, errorFunction)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.TimeSeries.SsaSpikeEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
          <Parameter Name="confidence" Type="System.Int32" />
          <Parameter Name="pvalueHistoryLength" Type="System.Int32" />
          <Parameter Name="trainingWindowSize" Type="System.Int32" />
          <Parameter Name="seasonalityWindowSize" Type="System.Int32" />
          <Parameter Name="side" Type="Microsoft.ML.Transforms.TimeSeries.AnomalySide" />
          <Parameter Name="errorFunction" Type="Microsoft.ML.Transforms.TimeSeries.ErrorFunction" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of column to transform. If set to <see langword="null" />, the value of the <paramref name="outputColumnName" /> will be used as source.
            <param name="confidence">The confidence for spike detection in the range [0, 100].</param><param name="pvalueHistoryLength">The size of the sliding window for computing the p-value.</param><param name="trainingWindowSize">The number of points from the beginning of the sequence used for training.</param><param name="seasonalityWindowSize">An upper bound on the largest relevant seasonality in the input time-series.</param>
            The vector contains Alert, Raw Score, P-Value as first three values.</param>
          <param name="confidence">To be added.</param>
          <param name="pvalueHistoryLength">To be added.</param>
          <param name="trainingWindowSize">To be added.</param>
          <param name="seasonalityWindowSize">To be added.</param>
          <param name="side">The argument that determines whether to detect positive or negative anomalies, or both.</param>
          <param name="errorFunction">The function used to compute the error between the expected and the observed value.</param>
          <summary>
            Create a new instance of <see cref="T:Microsoft.ML.Transforms.TimeSeries.SsaSpikeEstimator" /> for detecting a spike in a time series signal
            using <a href="https://en.wikipedia.org/wiki/Singular_spectrum_analysis">Singular Spectrum Analysis (SSA)</a>.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TimeSeriesCatalog" Member="M:Microsoft.ML.TimeSeriesCatalog.DetectSpikeBySsa(Microsoft.ML.TransformsCatalog,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,Microsoft.ML.Transforms.TimeSeries.AnomalySide,Microsoft.ML.Transforms.TimeSeries.ErrorFunction)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="Concatenate">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.ColumnConcatenatingEstimator Concatenate (this Microsoft.ML.TransformsCatalog catalog, string outputColumnName, params string[] inputColumnNames);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.ColumnConcatenatingEstimator Concatenate(class Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string[] inputColumnNames) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TransformExtensionsCatalog.Concatenate(Microsoft.ML.TransformsCatalog,System.String,System.String[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Concatenate (catalog As TransformsCatalog, outputColumnName As String, ParamArray inputColumnNames As String()) As ColumnConcatenatingEstimator" />
        <MemberSignature Language="F#" Value="static member Concatenate : Microsoft.ML.TransformsCatalog * string * string[] -&gt; Microsoft.ML.Transforms.ColumnConcatenatingEstimator" Usage="Microsoft.ML.TransformExtensionsCatalog.Concatenate (catalog, outputColumnName, inputColumnNames)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.ColumnConcatenatingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnNames" Type="System.String[]">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet">
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnNames" />.</param>
          <param name="inputColumnNames">Name of the columns to transform.</param>
          <summary>
            Concatenates columns together.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TransformExtensionsCatalog" Member="M:Microsoft.ML.TransformExtensionsCatalog.Concatenate(Microsoft.ML.TransformsCatalog,System.String,System.String[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="CopyColumns">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.ColumnCopyingEstimator CopyColumns (this Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.ColumnCopyingEstimator CopyColumns(class Microsoft.ML.TransformsCatalog catalog, string outputColumnName, string inputColumnName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TransformExtensionsCatalog.CopyColumns(Microsoft.ML.TransformsCatalog,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CopyColumns (catalog As TransformsCatalog, outputColumnName As String, inputColumnName As String) As ColumnCopyingEstimator" />
        <MemberSignature Language="F#" Value="static member CopyColumns : Microsoft.ML.TransformsCatalog * string * string -&gt; Microsoft.ML.Transforms.ColumnCopyingEstimator" Usage="Microsoft.ML.TransformExtensionsCatalog.CopyColumns (catalog, outputColumnName, inputColumnName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.ColumnCopyingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumnName" Type="System.String" />
          <Parameter Name="inputColumnName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="outputColumnName">Name of the column resulting from the transformation of <paramref name="inputColumnName" />.</param>
          <param name="inputColumnName">Name of the columns to transform.</param>
          <summary>
            Copies the input column to another column named as specified in <paramref name="outputColumnName" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TransformExtensionsCatalog" Member="M:Microsoft.ML.TransformExtensionsCatalog.CopyColumns(Microsoft.ML.TransformsCatalog,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="DropColumns">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.ColumnSelectingEstimator DropColumns (this Microsoft.ML.TransformsCatalog catalog, params string[] columnNames);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.ColumnSelectingEstimator DropColumns(class Microsoft.ML.TransformsCatalog catalog, string[] columnNames) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TransformExtensionsCatalog.DropColumns(Microsoft.ML.TransformsCatalog,System.String[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DropColumns (catalog As TransformsCatalog, ParamArray columnNames As String()) As ColumnSelectingEstimator" />
        <MemberSignature Language="F#" Value="static member DropColumns : Microsoft.ML.TransformsCatalog * string[] -&gt; Microsoft.ML.Transforms.ColumnSelectingEstimator" Usage="Microsoft.ML.TransformExtensionsCatalog.DropColumns (catalog, columnNames)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.ColumnSelectingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="columnNames" Type="System.String[]">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet">
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="columnNames">The array of column names to drop.</param>
          <summary>
            DropColumns is used to select a list of columns that user wants to drop from a given input. Any column not specified will
            be maintained in the output schema.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TransformExtensionsCatalog" Member="M:Microsoft.ML.TransformExtensionsCatalog.DropColumns(Microsoft.ML.TransformsCatalog,System.String[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="SelectColumns">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.ColumnSelectingEstimator SelectColumns (this Microsoft.ML.TransformsCatalog catalog, params string[] columnNames);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.ColumnSelectingEstimator SelectColumns(class Microsoft.ML.TransformsCatalog catalog, string[] columnNames) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TransformExtensionsCatalog.SelectColumns(Microsoft.ML.TransformsCatalog,System.String[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectColumns (catalog As TransformsCatalog, ParamArray columnNames As String()) As ColumnSelectingEstimator" />
        <MemberSignature Language="F#" Value="static member SelectColumns : Microsoft.ML.TransformsCatalog * string[] -&gt; Microsoft.ML.Transforms.ColumnSelectingEstimator" Usage="Microsoft.ML.TransformExtensionsCatalog.SelectColumns (catalog, columnNames)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.ColumnSelectingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="columnNames" Type="System.String[]">
            <Attributes>
              <Attribute FrameworkAlternate="ml-dotnet">
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="columnNames">The array of column names to keep.</param>
          <summary>
            Select a list of columns to keep in a given <see cref="T:Microsoft.ML.IDataView" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TransformExtensionsCatalog" Member="M:Microsoft.ML.TransformExtensionsCatalog.SelectColumns(Microsoft.ML.TransformsCatalog,System.String[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="SelectColumns">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.ColumnSelectingEstimator SelectColumns (this Microsoft.ML.TransformsCatalog catalog, string[] columnNames, bool keepHidden);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.ColumnSelectingEstimator SelectColumns(class Microsoft.ML.TransformsCatalog catalog, string[] columnNames, bool keepHidden) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TransformExtensionsCatalog.SelectColumns(Microsoft.ML.TransformsCatalog,System.String[],System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectColumns (catalog As TransformsCatalog, columnNames As String(), keepHidden As Boolean) As ColumnSelectingEstimator" />
        <MemberSignature Language="F#" Value="static member SelectColumns : Microsoft.ML.TransformsCatalog * string[] * bool -&gt; Microsoft.ML.Transforms.ColumnSelectingEstimator" Usage="Microsoft.ML.TransformExtensionsCatalog.SelectColumns (catalog, columnNames, keepHidden)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.ColumnSelectingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="columnNames" Type="System.String[]" />
          <Parameter Name="keepHidden" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="columnNames">The array of column names to keep.</param>
          <param name="keepHidden">If <see langword="true" /> will keep hidden columns and <see langword="false" /> will remove hidden columns.</param>
          <summary>
            Select a list of columns to keep in a given <see cref="T:Microsoft.ML.IDataView" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TransformExtensionsCatalog" Member="M:Microsoft.ML.TransformExtensionsCatalog.SelectColumns(Microsoft.ML.TransformsCatalog,System.String[],System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.ITransformer" />
      </Targets>
      <Member MemberName="CreateTimeSeriesPredictionFunction&lt;TSrc,TDst&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.TimeSeries.TimeSeriesPredictionFunction&lt;TSrc,TDst&gt; CreateTimeSeriesPredictionFunction&lt;TSrc,TDst&gt; (this Microsoft.ML.ITransformer transformer, Microsoft.ML.Runtime.IHostEnvironment env, bool ignoreMissingColumns = false, Microsoft.ML.Data.SchemaDefinition inputSchemaDefinition = null, Microsoft.ML.Data.SchemaDefinition outputSchemaDefinition = null) where TSrc : class where TDst : class, new();" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.TimeSeries.TimeSeriesPredictionFunction`2&lt;!!TSrc, !!TDst&gt; CreateTimeSeriesPredictionFunction&lt;class TSrc, class .ctor TDst&gt;(class Microsoft.ML.ITransformer transformer, class Microsoft.ML.Runtime.IHostEnvironment env, bool ignoreMissingColumns, class Microsoft.ML.Data.SchemaDefinition inputSchemaDefinition, class Microsoft.ML.Data.SchemaDefinition outputSchemaDefinition) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.TimeSeries.PredictionFunctionExtensions.CreateTimeSeriesPredictionFunction``2(Microsoft.ML.ITransformer,Microsoft.ML.Runtime.IHostEnvironment,System.Boolean,Microsoft.ML.Data.SchemaDefinition,Microsoft.ML.Data.SchemaDefinition)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateTimeSeriesPredictionFunction(Of TSrc As Class, TDst As Class) (transformer As ITransformer, env As IHostEnvironment, Optional ignoreMissingColumns As Boolean = false, Optional inputSchemaDefinition As SchemaDefinition = null, Optional outputSchemaDefinition As SchemaDefinition = null) As TimeSeriesPredictionFunction(Of TSrc, TDst)" />
        <MemberSignature Language="F#" Value="static member CreateTimeSeriesPredictionFunction : Microsoft.ML.ITransformer * Microsoft.ML.Runtime.IHostEnvironment * bool * Microsoft.ML.Data.SchemaDefinition * Microsoft.ML.Data.SchemaDefinition -&gt; Microsoft.ML.Transforms.TimeSeries.TimeSeriesPredictionFunction&lt;'Src, 'Dst (requires 'Src : null and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))&gt; (requires 'Src : null and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))" Usage="Microsoft.ML.Transforms.TimeSeries.PredictionFunctionExtensions.CreateTimeSeriesPredictionFunction (transformer, env, ignoreMissingColumns, inputSchemaDefinition, outputSchemaDefinition)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.TimeSeries.TimeSeriesPredictionFunction&lt;TSrc,TDst&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSrc">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
          <TypeParameter Name="TDst">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="transformer" Type="Microsoft.ML.ITransformer" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
          <Parameter Name="ignoreMissingColumns" Type="System.Boolean" />
          <Parameter Name="inputSchemaDefinition" Type="Microsoft.ML.Data.SchemaDefinition" />
          <Parameter Name="outputSchemaDefinition" Type="Microsoft.ML.Data.SchemaDefinition" />
        </Parameters>
        <Docs>
          <typeparam name="TSrc">Class describing input schema to the model.</typeparam>
          <typeparam name="TDst">Class describing the output schema of the prediction.</typeparam>
          <param name="transformer">The time series pipeline in the form of a <see cref="T:Microsoft.ML.ITransformer" />.</param>
          <param name="env">Usually <see cref="T:Microsoft.ML.MLContext" /></param>
          <param name="ignoreMissingColumns">To ignore missing columns. Default is false.</param>
          <param name="inputSchemaDefinition">Input schema definition. Default is null.</param>
          <param name="outputSchemaDefinition">Output schema definition. Default is null.</param>
          <summary>
            <see cref="T:Microsoft.ML.Transforms.TimeSeries.TimeSeriesPredictionFunction`2" /> creates a prediction function/engine for a time series pipeline
            It updates the state of time series model with observations seen at prediction phase and allows checkpointing the model.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.TimeSeries.PredictionFunctionExtensions" Member="M:Microsoft.ML.Transforms.TimeSeries.PredictionFunctionExtensions.CreateTimeSeriesPredictionFunction``2(Microsoft.ML.ITransformer,Microsoft.ML.Runtime.IHostEnvironment,System.Boolean,Microsoft.ML.Data.SchemaDefinition,Microsoft.ML.Data.SchemaDefinition)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="FastForest">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.FastForestBinaryTrainer FastForest (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.Trainers.FastTree.FastForestBinaryTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FastTree.FastForestBinaryTrainer FastForest(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.Trainers.FastTree.FastForestBinaryTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TreeExtensions.FastForest(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.FastTree.FastForestBinaryTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member FastForest : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.Trainers.FastTree.FastForestBinaryTrainer.Options -&gt; Microsoft.ML.Trainers.FastTree.FastForestBinaryTrainer" Usage="Microsoft.ML.TreeExtensions.FastForest (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.FastForestBinaryTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.FastTree.FastForestBinaryTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.BinaryClassificationCatalog" />.</param>
          <param name="options">Trainer options.</param>
          <summary>
            Predict a target using a decision tree regression model trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.FastForestBinaryTrainer" /> and advanced options.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TreeExtensions" Member="M:Microsoft.ML.TreeExtensions.FastForest(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.FastTree.FastForestBinaryTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="FastForest">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.FastForestBinaryTrainer FastForest (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, string exampleWeightColumnName = null, int numberOfLeaves = 20, int numberOfTrees = 100, int minimumExampleCountPerLeaf = 10);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FastTree.FastForestBinaryTrainer FastForest(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, string labelColumnName, string featureColumnName, string exampleWeightColumnName, int32 numberOfLeaves, int32 numberOfTrees, int32 minimumExampleCountPerLeaf) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TreeExtensions.FastForest(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FastForest (catalog As BinaryClassificationCatalog.BinaryClassificationTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional exampleWeightColumnName As String = null, Optional numberOfLeaves As Integer = 20, Optional numberOfTrees As Integer = 100, Optional minimumExampleCountPerLeaf As Integer = 10) As FastForestBinaryTrainer" />
        <MemberSignature Language="F#" Value="static member FastForest : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * string * string * string * int * int * int -&gt; Microsoft.ML.Trainers.FastTree.FastForestBinaryTrainer" Usage="Microsoft.ML.TreeExtensions.FastForest (catalog, labelColumnName, featureColumnName, exampleWeightColumnName, numberOfLeaves, numberOfTrees, minimumExampleCountPerLeaf)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.FastForestBinaryTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="numberOfLeaves" Type="System.Int32" />
          <Parameter Name="numberOfTrees" Type="System.Int32" />
          <Parameter Name="minimumExampleCountPerLeaf" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.BinaryClassificationCatalog" />.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="numberOfLeaves">The maximum number of leaves per decision tree.</param>
          <param name="numberOfTrees">Total number of decision trees to create in the ensemble.</param>
          <param name="minimumExampleCountPerLeaf">The minimal number of data points required to form a new tree leaf.</param>
          <summary>
            Predict a target using a decision tree regression model trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.FastForestBinaryTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TreeExtensions" Member="M:Microsoft.ML.TreeExtensions.FastForest(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="FastForest">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.FastForestRegressionTrainer FastForest (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, Microsoft.ML.Trainers.FastTree.FastForestRegressionTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FastTree.FastForestRegressionTrainer FastForest(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, class Microsoft.ML.Trainers.FastTree.FastForestRegressionTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TreeExtensions.FastForest(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.Trainers.FastTree.FastForestRegressionTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member FastForest : Microsoft.ML.RegressionCatalog.RegressionTrainers * Microsoft.ML.Trainers.FastTree.FastForestRegressionTrainer.Options -&gt; Microsoft.ML.Trainers.FastTree.FastForestRegressionTrainer" Usage="Microsoft.ML.TreeExtensions.FastForest (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.FastForestRegressionTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.FastTree.FastForestRegressionTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.RegressionCatalog" />.</param>
          <param name="options">Trainer options.</param>
          <summary>
            Predict a target using a decision tree regression model trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.FastForestRegressionTrainer" /> and advanced options.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TreeExtensions" Member="M:Microsoft.ML.TreeExtensions.FastForest(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.Trainers.FastTree.FastForestRegressionTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="FastForest">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.FastForestRegressionTrainer FastForest (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, string exampleWeightColumnName = null, int numberOfLeaves = 20, int numberOfTrees = 100, int minimumExampleCountPerLeaf = 10);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FastTree.FastForestRegressionTrainer FastForest(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, string labelColumnName, string featureColumnName, string exampleWeightColumnName, int32 numberOfLeaves, int32 numberOfTrees, int32 minimumExampleCountPerLeaf) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TreeExtensions.FastForest(Microsoft.ML.RegressionCatalog.RegressionTrainers,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FastForest (catalog As RegressionCatalog.RegressionTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional exampleWeightColumnName As String = null, Optional numberOfLeaves As Integer = 20, Optional numberOfTrees As Integer = 100, Optional minimumExampleCountPerLeaf As Integer = 10) As FastForestRegressionTrainer" />
        <MemberSignature Language="F#" Value="static member FastForest : Microsoft.ML.RegressionCatalog.RegressionTrainers * string * string * string * int * int * int -&gt; Microsoft.ML.Trainers.FastTree.FastForestRegressionTrainer" Usage="Microsoft.ML.TreeExtensions.FastForest (catalog, labelColumnName, featureColumnName, exampleWeightColumnName, numberOfLeaves, numberOfTrees, minimumExampleCountPerLeaf)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.FastForestRegressionTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="numberOfLeaves" Type="System.Int32" />
          <Parameter Name="numberOfTrees" Type="System.Int32" />
          <Parameter Name="minimumExampleCountPerLeaf" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.RegressionCatalog" />.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="numberOfLeaves">The maximum number of leaves per decision tree.</param>
          <param name="numberOfTrees">Total number of decision trees to create in the ensemble.</param>
          <param name="minimumExampleCountPerLeaf">The minimal number of data points required to form a new tree leaf.</param>
          <summary>
            Predict a target using a decision tree regression model trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.FastForestRegressionTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TreeExtensions" Member="M:Microsoft.ML.TreeExtensions.FastForest(Microsoft.ML.RegressionCatalog.RegressionTrainers,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="FastTree">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer FastTree (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer FastTree(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TreeExtensions.FastTree(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member FastTree : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer.Options -&gt; Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer" Usage="Microsoft.ML.TreeExtensions.FastTree (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.BinaryClassificationCatalog" />.</param>
          <param name="options">Trainer options.</param>
          <summary>
            Predict a target using a decision tree binary classification model trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer" /> and advanced options.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TreeExtensions" Member="M:Microsoft.ML.TreeExtensions.FastTree(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="FastTree">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer FastTree (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, string exampleWeightColumnName = null, int numberOfLeaves = 20, int numberOfTrees = 100, int minimumExampleCountPerLeaf = 10, double learningRate = 0.2);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer FastTree(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, string labelColumnName, string featureColumnName, string exampleWeightColumnName, int32 numberOfLeaves, int32 numberOfTrees, int32 minimumExampleCountPerLeaf, float64 learningRate) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TreeExtensions.FastTree(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FastTree (catalog As BinaryClassificationCatalog.BinaryClassificationTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional exampleWeightColumnName As String = null, Optional numberOfLeaves As Integer = 20, Optional numberOfTrees As Integer = 100, Optional minimumExampleCountPerLeaf As Integer = 10, Optional learningRate As Double = 0.2) As FastTreeBinaryTrainer" />
        <MemberSignature Language="F#" Value="static member FastTree : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * string * string * string * int * int * int * double -&gt; Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer" Usage="Microsoft.ML.TreeExtensions.FastTree (catalog, labelColumnName, featureColumnName, exampleWeightColumnName, numberOfLeaves, numberOfTrees, minimumExampleCountPerLeaf, learningRate)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="numberOfLeaves" Type="System.Int32" />
          <Parameter Name="numberOfTrees" Type="System.Int32" />
          <Parameter Name="minimumExampleCountPerLeaf" Type="System.Int32" />
          <Parameter Name="learningRate" Type="System.Double" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.BinaryClassificationCatalog" />.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="numberOfLeaves">The maximum number of leaves per decision tree.</param>
          <param name="numberOfTrees">Total number of decision trees to create in the ensemble.</param>
          <param name="minimumExampleCountPerLeaf">The minimal number of data points required to form a new tree leaf.</param>
          <param name="learningRate">The learning rate.</param>
          <summary>
            Predict a target using a decision tree binary classification model trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.FastTreeBinaryTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TreeExtensions" Member="M:Microsoft.ML.TreeExtensions.FastTree(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RankingCatalog.RankingTrainers" />
      </Targets>
      <Member MemberName="FastTree">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer FastTree (this Microsoft.ML.RankingCatalog.RankingTrainers catalog, Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer FastTree(class Microsoft.ML.RankingCatalog/RankingTrainers catalog, class Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TreeExtensions.FastTree(Microsoft.ML.RankingCatalog.RankingTrainers,Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member FastTree : Microsoft.ML.RankingCatalog.RankingTrainers * Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer.Options -&gt; Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer" Usage="Microsoft.ML.TreeExtensions.FastTree (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RankingCatalog+RankingTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.RankingCatalog" />.</param>
          <param name="options">Trainer options.</param>
          <summary>
            Ranks a series of inputs based on their relevance, training a decision tree ranking model with the <see cref="T:Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer" /> and advanced options.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TreeExtensions" Member="M:Microsoft.ML.TreeExtensions.FastTree(Microsoft.ML.RankingCatalog.RankingTrainers,Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RankingCatalog.RankingTrainers" />
      </Targets>
      <Member MemberName="FastTree">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer FastTree (this Microsoft.ML.RankingCatalog.RankingTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, string rowGroupColumnName = &quot;GroupId&quot;, string exampleWeightColumnName = null, int numberOfLeaves = 20, int numberOfTrees = 100, int minimumExampleCountPerLeaf = 10, double learningRate = 0.2);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer FastTree(class Microsoft.ML.RankingCatalog/RankingTrainers catalog, string labelColumnName, string featureColumnName, string rowGroupColumnName, string exampleWeightColumnName, int32 numberOfLeaves, int32 numberOfTrees, int32 minimumExampleCountPerLeaf, float64 learningRate) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TreeExtensions.FastTree(Microsoft.ML.RankingCatalog.RankingTrainers,System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FastTree (catalog As RankingCatalog.RankingTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional rowGroupColumnName As String = &quot;GroupId&quot;, Optional exampleWeightColumnName As String = null, Optional numberOfLeaves As Integer = 20, Optional numberOfTrees As Integer = 100, Optional minimumExampleCountPerLeaf As Integer = 10, Optional learningRate As Double = 0.2) As FastTreeRankingTrainer" />
        <MemberSignature Language="F#" Value="static member FastTree : Microsoft.ML.RankingCatalog.RankingTrainers * string * string * string * string * int * int * int * double -&gt; Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer" Usage="Microsoft.ML.TreeExtensions.FastTree (catalog, labelColumnName, featureColumnName, rowGroupColumnName, exampleWeightColumnName, numberOfLeaves, numberOfTrees, minimumExampleCountPerLeaf, learningRate)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RankingCatalog+RankingTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="rowGroupColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="numberOfLeaves" Type="System.Int32" />
          <Parameter Name="numberOfTrees" Type="System.Int32" />
          <Parameter Name="minimumExampleCountPerLeaf" Type="System.Int32" />
          <Parameter Name="learningRate" Type="System.Double" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.RankingCatalog" />.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="rowGroupColumnName">The name of the group column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="numberOfLeaves">The maximum number of leaves per decision tree.</param>
          <param name="numberOfTrees">Total number of decision trees to create in the ensemble.</param>
          <param name="minimumExampleCountPerLeaf">The minimal number of data points required to form a new tree leaf.</param>
          <param name="learningRate">The learning rate.</param>
          <summary>
            Ranks a series of inputs based on their relevance, training a decision tree ranking model with the <see cref="T:Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TreeExtensions" Member="M:Microsoft.ML.TreeExtensions.FastTree(Microsoft.ML.RankingCatalog.RankingTrainers,System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="FastTree">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer FastTree (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer FastTree(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, class Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TreeExtensions.FastTree(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member FastTree : Microsoft.ML.RegressionCatalog.RegressionTrainers * Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer.Options -&gt; Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer" Usage="Microsoft.ML.TreeExtensions.FastTree (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.RegressionCatalog" />.</param>
          <param name="options">Trainer options.</param>
          <summary>
            Predict a target using a decision tree regression model trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TreeExtensions" Member="M:Microsoft.ML.TreeExtensions.FastTree(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="FastTree">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer FastTree (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, string exampleWeightColumnName = null, int numberOfLeaves = 20, int numberOfTrees = 100, int minimumExampleCountPerLeaf = 10, double learningRate = 0.2);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer FastTree(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, string labelColumnName, string featureColumnName, string exampleWeightColumnName, int32 numberOfLeaves, int32 numberOfTrees, int32 minimumExampleCountPerLeaf, float64 learningRate) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TreeExtensions.FastTree(Microsoft.ML.RegressionCatalog.RegressionTrainers,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FastTree (catalog As RegressionCatalog.RegressionTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional exampleWeightColumnName As String = null, Optional numberOfLeaves As Integer = 20, Optional numberOfTrees As Integer = 100, Optional minimumExampleCountPerLeaf As Integer = 10, Optional learningRate As Double = 0.2) As FastTreeRegressionTrainer" />
        <MemberSignature Language="F#" Value="static member FastTree : Microsoft.ML.RegressionCatalog.RegressionTrainers * string * string * string * int * int * int * double -&gt; Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer" Usage="Microsoft.ML.TreeExtensions.FastTree (catalog, labelColumnName, featureColumnName, exampleWeightColumnName, numberOfLeaves, numberOfTrees, minimumExampleCountPerLeaf, learningRate)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="numberOfLeaves" Type="System.Int32" />
          <Parameter Name="numberOfTrees" Type="System.Int32" />
          <Parameter Name="minimumExampleCountPerLeaf" Type="System.Int32" />
          <Parameter Name="learningRate" Type="System.Double" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.RegressionCatalog" />.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="numberOfLeaves">The maximum number of leaves per decision tree.</param>
          <param name="numberOfTrees">Total number of decision trees to create in the ensemble.</param>
          <param name="minimumExampleCountPerLeaf">The minimal number of data points required to form a new tree leaf.</param>
          <param name="learningRate">The learning rate.</param>
          <summary>
            Predict a target using a decision tree regression model trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TreeExtensions" Member="M:Microsoft.ML.TreeExtensions.FastTree(Microsoft.ML.RegressionCatalog.RegressionTrainers,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="FastTreeTweedie">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer FastTreeTweedie (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer FastTreeTweedie(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, class Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TreeExtensions.FastTreeTweedie(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member FastTreeTweedie : Microsoft.ML.RegressionCatalog.RegressionTrainers * Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer.Options -&gt; Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer" Usage="Microsoft.ML.TreeExtensions.FastTreeTweedie (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.RegressionCatalog" />.</param>
          <param name="options">Trainer options.</param>
          <summary>
            Predict a target using a decision tree regression model trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer" /> and advanced options.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TreeExtensions" Member="M:Microsoft.ML.TreeExtensions.FastTreeTweedie(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="FastTreeTweedie">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer FastTreeTweedie (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, string exampleWeightColumnName = null, int numberOfLeaves = 20, int numberOfTrees = 100, int minimumExampleCountPerLeaf = 10, double learningRate = 0.2);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer FastTreeTweedie(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, string labelColumnName, string featureColumnName, string exampleWeightColumnName, int32 numberOfLeaves, int32 numberOfTrees, int32 minimumExampleCountPerLeaf, float64 learningRate) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TreeExtensions.FastTreeTweedie(Microsoft.ML.RegressionCatalog.RegressionTrainers,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FastTreeTweedie (catalog As RegressionCatalog.RegressionTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional exampleWeightColumnName As String = null, Optional numberOfLeaves As Integer = 20, Optional numberOfTrees As Integer = 100, Optional minimumExampleCountPerLeaf As Integer = 10, Optional learningRate As Double = 0.2) As FastTreeTweedieTrainer" />
        <MemberSignature Language="F#" Value="static member FastTreeTweedie : Microsoft.ML.RegressionCatalog.RegressionTrainers * string * string * string * int * int * int * double -&gt; Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer" Usage="Microsoft.ML.TreeExtensions.FastTreeTweedie (catalog, labelColumnName, featureColumnName, exampleWeightColumnName, numberOfLeaves, numberOfTrees, minimumExampleCountPerLeaf, learningRate)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="numberOfLeaves" Type="System.Int32" />
          <Parameter Name="numberOfTrees" Type="System.Int32" />
          <Parameter Name="minimumExampleCountPerLeaf" Type="System.Int32" />
          <Parameter Name="learningRate" Type="System.Double" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.RegressionCatalog" />.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="numberOfLeaves">The maximum number of leaves per decision tree.</param>
          <param name="numberOfTrees">Total number of decision trees to create in the ensemble.</param>
          <param name="minimumExampleCountPerLeaf">The minimal number of data points required to form a new tree leaf.</param>
          <param name="learningRate">The learning rate.</param>
          <summary>
            Predict a target using a decision tree regression model trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TreeExtensions" Member="M:Microsoft.ML.TreeExtensions.FastTreeTweedie(Microsoft.ML.RegressionCatalog.RegressionTrainers,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="Gam">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.GamBinaryTrainer Gam (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, Microsoft.ML.Trainers.FastTree.GamBinaryTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FastTree.GamBinaryTrainer Gam(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, class Microsoft.ML.Trainers.FastTree.GamBinaryTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TreeExtensions.Gam(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.FastTree.GamBinaryTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member Gam : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * Microsoft.ML.Trainers.FastTree.GamBinaryTrainer.Options -&gt; Microsoft.ML.Trainers.FastTree.GamBinaryTrainer" Usage="Microsoft.ML.TreeExtensions.Gam (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.GamBinaryTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.FastTree.GamBinaryTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.BinaryClassificationCatalog" />.</param>
          <param name="options">Trainer options.</param>
          <summary>
            Predict a target using generalized additive models (GAM) trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.GamBinaryTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TreeExtensions" Member="M:Microsoft.ML.TreeExtensions.Gam(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,Microsoft.ML.Trainers.FastTree.GamBinaryTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="Gam">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.GamBinaryTrainer Gam (this Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, string exampleWeightColumnName = null, int numberOfIterations = 9500, int maximumBinCountPerFeature = 255, double learningRate = 0.002);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FastTree.GamBinaryTrainer Gam(class Microsoft.ML.BinaryClassificationCatalog/BinaryClassificationTrainers catalog, string labelColumnName, string featureColumnName, string exampleWeightColumnName, int32 numberOfIterations, int32 maximumBinCountPerFeature, float64 learningRate) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TreeExtensions.Gam(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,System.String,System.Int32,System.Int32,System.Double)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Gam (catalog As BinaryClassificationCatalog.BinaryClassificationTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional exampleWeightColumnName As String = null, Optional numberOfIterations As Integer = 9500, Optional maximumBinCountPerFeature As Integer = 255, Optional learningRate As Double = 0.002) As GamBinaryTrainer" />
        <MemberSignature Language="F#" Value="static member Gam : Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers * string * string * string * int * int * double -&gt; Microsoft.ML.Trainers.FastTree.GamBinaryTrainer" Usage="Microsoft.ML.TreeExtensions.Gam (catalog, labelColumnName, featureColumnName, exampleWeightColumnName, numberOfIterations, maximumBinCountPerFeature, learningRate)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.GamBinaryTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.BinaryClassificationCatalog+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="numberOfIterations" Type="System.Int32" />
          <Parameter Name="maximumBinCountPerFeature" Type="System.Int32" />
          <Parameter Name="learningRate" Type="System.Double" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.BinaryClassificationCatalog" />.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="numberOfIterations">The number of iterations to use in learning the features.</param>
          <param name="maximumBinCountPerFeature">The maximum number of bins to use to approximate features.</param>
          <param name="learningRate">The learning rate. GAMs work best with a small learning rate.</param>
          <summary>
            Predict a target using generalized additive models (GAM) trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.GamBinaryTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TreeExtensions" Member="M:Microsoft.ML.TreeExtensions.Gam(Microsoft.ML.BinaryClassificationCatalog.BinaryClassificationTrainers,System.String,System.String,System.String,System.Int32,System.Int32,System.Double)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="Gam">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.GamRegressionTrainer Gam (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, Microsoft.ML.Trainers.FastTree.GamRegressionTrainer.Options options);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FastTree.GamRegressionTrainer Gam(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, class Microsoft.ML.Trainers.FastTree.GamRegressionTrainer/Options options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TreeExtensions.Gam(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.Trainers.FastTree.GamRegressionTrainer.Options)" />
        <MemberSignature Language="F#" Value="static member Gam : Microsoft.ML.RegressionCatalog.RegressionTrainers * Microsoft.ML.Trainers.FastTree.GamRegressionTrainer.Options -&gt; Microsoft.ML.Trainers.FastTree.GamRegressionTrainer" Usage="Microsoft.ML.TreeExtensions.Gam (catalog, options)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.GamRegressionTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="options" Type="Microsoft.ML.Trainers.FastTree.GamRegressionTrainer+Options" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.RegressionCatalog" />.</param>
          <param name="options">Trainer options.</param>
          <summary>
            Predict a target using generalized additive models (GAM) trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.GamRegressionTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TreeExtensions" Member="M:Microsoft.ML.TreeExtensions.Gam(Microsoft.ML.RegressionCatalog.RegressionTrainers,Microsoft.ML.Trainers.FastTree.GamRegressionTrainer.Options)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionCatalog.RegressionTrainers" />
      </Targets>
      <Member MemberName="Gam">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.GamRegressionTrainer Gam (this Microsoft.ML.RegressionCatalog.RegressionTrainers catalog, string labelColumnName = &quot;Label&quot;, string featureColumnName = &quot;Features&quot;, string exampleWeightColumnName = null, int numberOfIterations = 9500, int maximumBinCountPerFeature = 255, double learningRate = 0.002);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FastTree.GamRegressionTrainer Gam(class Microsoft.ML.RegressionCatalog/RegressionTrainers catalog, string labelColumnName, string featureColumnName, string exampleWeightColumnName, int32 numberOfIterations, int32 maximumBinCountPerFeature, float64 learningRate) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TreeExtensions.Gam(Microsoft.ML.RegressionCatalog.RegressionTrainers,System.String,System.String,System.String,System.Int32,System.Int32,System.Double)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Gam (catalog As RegressionCatalog.RegressionTrainers, Optional labelColumnName As String = &quot;Label&quot;, Optional featureColumnName As String = &quot;Features&quot;, Optional exampleWeightColumnName As String = null, Optional numberOfIterations As Integer = 9500, Optional maximumBinCountPerFeature As Integer = 255, Optional learningRate As Double = 0.002) As GamRegressionTrainer" />
        <MemberSignature Language="F#" Value="static member Gam : Microsoft.ML.RegressionCatalog.RegressionTrainers * string * string * string * int * int * double -&gt; Microsoft.ML.Trainers.FastTree.GamRegressionTrainer" Usage="Microsoft.ML.TreeExtensions.Gam (catalog, labelColumnName, featureColumnName, exampleWeightColumnName, numberOfIterations, maximumBinCountPerFeature, learningRate)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.GamRegressionTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.RegressionCatalog+RegressionTrainers" RefType="this" />
          <Parameter Name="labelColumnName" Type="System.String" />
          <Parameter Name="featureColumnName" Type="System.String" />
          <Parameter Name="exampleWeightColumnName" Type="System.String" />
          <Parameter Name="numberOfIterations" Type="System.Int32" />
          <Parameter Name="maximumBinCountPerFeature" Type="System.Int32" />
          <Parameter Name="learningRate" Type="System.Double" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.RegressionCatalog" />.</param>
          <param name="labelColumnName">The name of the label column.</param>
          <param name="featureColumnName">The name of the feature column.</param>
          <param name="exampleWeightColumnName">The name of the example weight column (optional).</param>
          <param name="numberOfIterations">The number of iterations to use in learning the features.</param>
          <param name="maximumBinCountPerFeature">The maximum number of bins to use to approximate features.</param>
          <param name="learningRate">The learning rate. GAMs work best with a small learning rate.</param>
          <summary>
            Predict a target using generalized additive models (GAM) trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.GamRegressionTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TreeExtensions" Member="M:Microsoft.ML.TreeExtensions.Gam(Microsoft.ML.RegressionCatalog.RegressionTrainers,System.String,System.String,System.String,System.Int32,System.Int32,System.Double)" />
      </Member>
    </ExtensionMethod>
  </ExtensionMethods>
</Overview>
