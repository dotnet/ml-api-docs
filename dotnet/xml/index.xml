<Overview>
  <Assemblies>
    <Assembly Name="Microsoft.ML.InternalStreams" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyConfiguration("Release")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation.  All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.InternalStreams")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.3.26703.12")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.3.26703.12 @BuiltBy: dlab14-DDVSOWINAGE101 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/41d59a194914674369f6a49684b768985cb4bd0f")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.UniversalModelFormat" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyConfiguration("Release")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation.  All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.UniversalModelFormat")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.3.26703.12")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.3.26703.12 @BuiltBy: dlab14-DDVSOWINAGE101 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/41d59a194914674369f6a49684b768985cb4bd0f")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.EntryPoints.CodeGen.ModuleGenerator), typeof(Microsoft.ML.Runtime.EntryPoints.CodeGen.ModuleGenerator/Arguments), typeof(Microsoft.ML.Runtime.Tools.SignatureModuleGenerator), "Module generator", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.CrossValidationBinaryMacro), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "CrossValidationBinaryMacro", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.CrossValidationMacro), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "CrossValidationMacro", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.CVSplit), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "CVSplit", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.DataViewReference), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "DataViewReference", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.FeatureCombiner), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "FeatureCombiner", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.ImportTextData), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "ImportTextData", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.EntryPoints.JsonUtils.ExecuteGraphCommand), typeof(Microsoft.ML.Runtime.EntryPoints.JsonUtils.ExecuteGraphCommand/Arguments), typeof(Microsoft.ML.Runtime.Command.SignatureCommand), "", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.ModelOperations), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "ModelOperations", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.OneVersusAllMacro), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "OneVersusAllMacro", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.TrainTestBinaryMacro), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "TrainTestBinaryMacro", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.TrainTestMacro), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "TrainTestMacro", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.TrainTestSplit), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "TrainTestSplit", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Internal.Tools.CSharpApiGenerator), typeof(Microsoft.ML.Runtime.Internal.Tools.CSharpApiGenerator/Arguments), typeof(Microsoft.ML.Runtime.Tools.SignatureModuleGenerator), "CSharp API generator", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.5.26905.7")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.5.26905.7 @BuiltBy: dlab14-DDVSOWINAGE101 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/769a9c958f8267c904f9e85eabea535d7848051f+769a9c958f8267c904f9e85eabea535d7848051f")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.PipelineInference" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.PipelineInference.AutoInference/AutoMlMlState/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.PipelineInference.AutoInference/ISupportAutoMlStateFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.PipelineInference.DefaultsEngine/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.PipelineInference.RocketEngine/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.PipelineInference.UniformRandomEngine/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.PipelineInference.ISupportIPipelineOptimizerFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.PipelineInference.IterationTerminator/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.PipelineInference.ISupportITerminatorFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.PipelineInference")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.PipelineInference")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.PipelineSweeperMacro), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "PipelineSweeperMacro", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.7.27106.9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.7.27106.9 @BuiltBy: dlab14-DDVSOWINAGE056 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/abba48a15e604a0a98a373d5db2a283c96419e02+abba48a15e604a0a98a373d5db2a283c96419e02")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.Api" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.Api")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.Api")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Api.GenerateCodeCommand), typeof(Microsoft.ML.Runtime.Api.GenerateCodeCommand/Arguments), typeof(Microsoft.ML.Runtime.Command.SignatureCommand), "Generate Sample Prediction Code", new System.String[] { "GenerateSamplePredictionCode", "codegen" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Allows the definition of convenient user defined transforms", typeof(Microsoft.ML.Runtime.Data.ITransformTemplate), typeof(Microsoft.ML.Runtime.Api.SerializableLambdaTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "", new System.String[] { "UserLambdaMapTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Core.Data.ITransformer), typeof(Microsoft.ML.Runtime.Api.LambdaTransform), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "", new System.String[] { "CustomTransformer" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.WantsToBeBestFriends</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.8.27204.2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.8.27204.2 @BuiltBy: dlab14-DDVSOWINAGE100 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/51ea627fbc618120c7d63ab984b1b13c6d80b4a0+51ea627fbc618120c7d63ab984b1b13c6d80b4a0")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TimeSeries, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.Legacy" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.EntryPoints.CodeGen.ModuleGenerator), typeof(Microsoft.ML.Runtime.EntryPoints.CodeGen.ModuleGenerator/Arguments), typeof(Microsoft.ML.Runtime.Tools.SignatureModuleGenerator), "Module generator", new System.String[] { "ModuleGenerator", "Module" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.CrossValidationBinaryMacro), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "CrossValidationBinaryMacro", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.CrossValidationMacro), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "CrossValidationMacro", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.CVSplit), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "CVSplit", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.DataViewReference), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "DataViewReference", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.FeatureCombiner), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "FeatureCombiner", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.ImportTextData), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "ImportTextData", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.EntryPoints.JsonUtils.ExecuteGraphCommand), typeof(Microsoft.ML.Runtime.EntryPoints.JsonUtils.ExecuteGraphCommand/Arguments), typeof(Microsoft.ML.Runtime.Command.SignatureCommand), "", new System.String[] { "ExecGraph" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.ModelOperations), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "ModelOperations", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.OneVersusAllMacro), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "OneVersusAllMacro", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.TrainTestBinaryMacro), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "TrainTestBinaryMacro", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.TrainTestMacro), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "TrainTestMacro", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.TrainTestSplit), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "TrainTestSplit", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Internal.Tools.CSharpApiGenerator), typeof(Microsoft.ML.Runtime.Internal.Tools.CSharpApiGenerator/Arguments), typeof(Microsoft.ML.Runtime.Tools.SignatureModuleGenerator), "CSharp API generator", new System.String[] { "CSGenerator", "CS" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.Legacy")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.Legacy")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.8.27204.2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.8.27204.2 @BuiltBy: dlab14-DDVSOWINAGE100 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/51ea627fbc618120c7d63ab984b1b13c6d80b4a0+51ea627fbc618120c7d63ab984b1b13c6d80b4a0")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Core.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.Runtime.ImageAnalytics" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.ImageAnalytics.EntryPoints.ImageAnalytics), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "ImageAnalytics", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Convert image into grayscale.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.ImageAnalytics.ImageGrayscaleTransform), typeof(Microsoft.ML.Runtime.ImageAnalytics.ImageGrayscaleTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Image Greyscale Transform", new System.String[] { "ImageGrayscaleTransform", "ImageGrayscale" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Convert image into grayscale.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.ImageAnalytics.ImageGrayscaleTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Image Greyscale Transform", new System.String[] { "ImageGrayscaleTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.ImageAnalytics.ImageGrayscaleTransform), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Image Greyscale Transform", new System.String[] { "ImageGrayscaleTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.IRowMapper), typeof(Microsoft.ML.Runtime.ImageAnalytics.ImageGrayscaleTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadRowMapper), "Image Greyscale Transform", new System.String[] { "ImageGrayscaleTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Load images from files.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.ImageAnalytics.ImageLoaderTransform), typeof(Microsoft.ML.Runtime.ImageAnalytics.ImageLoaderTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Image Loader Transform", new System.String[] { "ImageLoaderTransform", "ImageLoader" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Load images from files.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.ImageAnalytics.ImageLoaderTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Image Loader Transform", new System.String[] { "ImageLoaderTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.ImageAnalytics.ImageLoaderTransform), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "", new System.String[] { "ImageLoaderTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.IRowMapper), typeof(Microsoft.ML.Runtime.ImageAnalytics.ImageLoaderTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadRowMapper), "", new System.String[] { "ImageLoaderTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Extract color plane(s) from an image. Options include scaling, offset and conversion to floating point.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.ImageAnalytics.ImagePixelExtractorTransform), typeof(Microsoft.ML.Runtime.ImageAnalytics.ImagePixelExtractorTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Image Pixel Extractor Transform", new System.String[] { "ImagePixelExtractorTransform", "ImagePixelExtractor" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Extract color plane(s) from an image. Options include scaling, offset and conversion to floating point.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.ImageAnalytics.ImagePixelExtractorTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Image Pixel Extractor Transform", new System.String[] { "ImagePixelExtractor" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.ImageAnalytics.ImagePixelExtractorTransform), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Image Pixel Extractor Transform", new System.String[] { "ImagePixelExtractor" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.IRowMapper), typeof(Microsoft.ML.Runtime.ImageAnalytics.ImagePixelExtractorTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadRowMapper), "Image Pixel Extractor Transform", new System.String[] { "ImagePixelExtractor" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Scales an image to specified dimensions using one of the three scale types: isotropic with padding, isotropic with cropping or anisotropic. In case of isotropic padding, transparent color is used to pad resulting image.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.ImageAnalytics.ImageResizerTransform), typeof(Microsoft.ML.Runtime.ImageAnalytics.ImageResizerTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Image Resizer Transform", new System.String[] { "ImageResizerTransform", "ImageResizer" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Scales an image to specified dimensions using one of the three scale types: isotropic with padding, isotropic with cropping or anisotropic. In case of isotropic padding, transparent color is used to pad resulting image.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.ImageAnalytics.ImageResizerTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Image Resizer Transform", new System.String[] { "ImageScalerTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.ImageAnalytics.ImageResizerTransform), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Image Resizer Transform", new System.String[] { "ImageScalerTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.IRowMapper), typeof(Microsoft.ML.Runtime.ImageAnalytics.ImageResizerTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadRowMapper), "Image Resizer Transform", new System.String[] { "ImageScalerTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Converts vector array into image type.", typeof(Microsoft.ML.Runtime.ImageAnalytics.VectorToImageTransform), typeof(Microsoft.ML.Runtime.ImageAnalytics.VectorToImageTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Vector To Image Transform", new System.String[] { "VectorToImageTransform", "VectorToImage" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Converts vector array into image type.", typeof(Microsoft.ML.Runtime.ImageAnalytics.VectorToImageTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Vector To Image Transform", new System.String[] { "VectorToImageConverter" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.Runtime.ImageAnalytics")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.Runtime.ImageAnalytics")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.8.27204.2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.8.27204.2 @BuiltBy: dlab14-DDVSOWINAGE100 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/51ea627fbc618120c7d63ab984b1b13c6d80b4a0+51ea627fbc618120c7d63ab984b1b13c6d80b4a0")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.Core" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.Core")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TestFramework, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.Core")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Core.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Predictor.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.InferenceTesting, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StaticPipelineTesting, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.OnnxTransformTest, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Maml, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.ResultProcessor, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.CpuMath, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Data, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Api, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Ensemble, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.FastTree, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.HalLearners, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.KMeansClustering, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.LightGBM, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Onnx, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.OnnxTransform, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Parquet, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.PCA, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.PipelineInference, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Recommender, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Scoring, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StandardLearners, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Sweeper, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TensorFlow, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TimeSeries, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Transforms, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Sweeper.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.EntryPoints, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.ImageAnalytics, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TensorFlow.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.HalLearners.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.OnnxTransform.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.LightGBM.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Internal.MetaLinearLearner, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("TreeVisualizer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("TMSNlearnPrediction, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.CntkWrapper, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.DssmFeaturizer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.DssmTrigram, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.EdgeML, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("ExperimentVisualization, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Internal.FastTree, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.Garage, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.HelperCommands, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.Internal.ImageAnalytics, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("ImageNetClientSample, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.InferNetWrapper, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TlcTesting.Inference, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Internal.RecipeInference, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.LDSVM, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("LibSvmWrapper, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("maml, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("TLCTelemetry, PublicKey=0024000004800000940000000602000000240000525341310004000001000100edfd1aca74f2e8d6d7fd53d6f0bf77982ea38a5d2dc462f2f9f01f0734d87a8480279e02c42df82024ea146bf9721a86c50740b9809e4f379a848e1c5168bbfc2b3969aacec1822b3a29db0a23dce5502d764bc0d6ca68f5e4a53ad5212c427567545ec7027402b908460476bcc690a730d25532399e9ce5de32bfdc2211f7e0")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Internal.Api, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.PyTrainer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("ParameterMixer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.OcrTransform, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.RServerScoring.TextAnalytics, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.TextAnalytics, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("StratoLearner, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.SequencePrediction, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.Internal.Opencv, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.Sar, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.NeuralNetworks, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.PowerShellIntegration, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.RServerScoring.NeuralNetworks, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("TMSNStreams, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.TlcAzurePublish, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.VowpalWabbit, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.XGBoost, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.SLib, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTestsMore, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.RServerScoring, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.Sweeper, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.TlcCustomModule, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.SweeperHpc, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.Scope, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("NeuralNetworksTest, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunEndToEnd, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTestsAzurePublish, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("SseTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("TLC, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.CpuMath" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.CpuMath")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StandardLearners, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.CpuMath")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.CpuMath.PerformanceTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.CpuMath.UnitTests.netstandard, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.CpuMath.UnitTests.netcoreapp, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Data, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.FastTree, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.HalLearners, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.KMeansClustering, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.PCA, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Sweeper, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TimeSeries, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Transforms, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Benchmarks.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Internal.CpuMath, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.Internal.MklMath, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("LibSvmWrapper, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.NeuralNetworks, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.RServerScoring.NeuralNetworks, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("SseTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.Data" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TestFramework, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.WantsToBeBestFriends</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.InferenceTesting, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.OnnxTransformTest, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Maml, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.ResultProcessor, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Api, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Ensemble, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.FastTree, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.HalLearners, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.KMeansClustering, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.LightGBM, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Onnx, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.OnnxTransform, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Parquet, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.PCA, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.PipelineInference, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Recommender, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Scoring, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StandardLearners, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Sweeper, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TensorFlow, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TimeSeries, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Transforms, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Data.SimplePartitionedPathParser/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Data.ParquetPartitionedPathParserFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.EntryPoints.SelectRows))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.EntryPoints.SummarizePredictor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Internal.Calibration.FixedPlattCalibratorTrainer/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Internal.Calibration.NaiveCalibratorTrainerFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Internal.Calibration.PavCalibratorTrainerFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Internal.Calibration.PlattCalibratorTrainerFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Internal.Internallearn.TolerantEarlyStoppingCriterion))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Internal.Internallearn.GLEarlyStoppingCriterion))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Internal.Internallearn.LPEarlyStoppingCriterion))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Internal.Internallearn.PQEarlyStoppingCriterion))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Internal.Internallearn.UPEarlyStoppingCriterion))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.RandomNumberGenerator))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.Conversions.TypeConversion))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.ExpLoss/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.LogLossFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.HingeLoss/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.PoissonLossFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.SmoothedHingeLoss/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.SquaredLossFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.TweedieLoss/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.CrossValidationCommand), typeof(Microsoft.ML.Data.CrossValidationCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Cross Validation", new System.String[] { "CV" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Runs a previously trained predictor on the data.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Data.EvaluateTransform), typeof(Microsoft.ML.Data.EvaluateTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Evaluate Predictor", new System.String[] { "Evaluate" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Evaluates the metrics for a scored data file.", typeof(Microsoft.ML.Data.EvaluateCommand), typeof(Microsoft.ML.Data.EvaluateCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Evaluate Predictor", new System.String[] { "Evaluate" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Given input data, a loader, and possibly transforms, save the data to a new file as parameterized by a saver.", typeof(Microsoft.ML.Data.SaveDataCommand), typeof(Microsoft.ML.Data.SaveDataCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Save Data", new System.String[] { "SaveData", "save" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Given input data, a loader, and possibly transforms, display a sample of the data file.", typeof(Microsoft.ML.Data.ShowDataCommand), typeof(Microsoft.ML.Data.ShowDataCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Show Data", new System.String[] { "ShowData", "show" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Given a TLC model file with a predictor, we can output this same predictor in multiple export formats.", typeof(Microsoft.ML.Tools.SavePredictorCommand), typeof(Microsoft.ML.Tools.SavePredictorCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Save Predictor As", new System.String[] { "SavePredictorAs", "SavePredictor", "SaveAs", "SaveModel" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Scores a data file.", typeof(Microsoft.ML.Data.ScoreCommand), typeof(Microsoft.ML.Data.ScoreCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Score Predictor", new System.String[] { "Score" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Given input data, a loader, and possibly transforms, display the schema.", typeof(Microsoft.ML.Data.ShowSchemaCommand), typeof(Microsoft.ML.Data.ShowSchemaCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Show Schema", new System.String[] { "ShowSchema", "schema" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Scores and evaluates a data file.", typeof(Microsoft.ML.Data.TestCommand), typeof(Microsoft.ML.Data.TestCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Test Predictor", new System.String[] { "Test" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Trains a predictor.", typeof(Microsoft.ML.Data.TrainCommand), typeof(Microsoft.ML.Data.TrainCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Train Predictor", new System.String[] { "Train" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Trains a predictor using the train file and then scores and evaluates the predictor using the test file.", typeof(Microsoft.ML.Data.TrainTestCommand), typeof(Microsoft.ML.Data.TrainTestCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Train Test", new System.String[] { "TrainTest" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.Commands.TypeInfoCommand), typeof(Microsoft.ML.Data.Commands.TypeInfoCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "", new System.String[] { "TypeInfo" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Loads native Binary IDV data file.", typeof(Microsoft.ML.Data.IO.BinaryLoader), typeof(Microsoft.ML.Data.IO.BinaryLoader/Arguments), typeof(Microsoft.ML.Data.SignatureDataLoader), "Binary Loader", new System.String[] { "BinaryLoader", "Binary", "Bin" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Loads native Binary IDV data file.", typeof(Microsoft.ML.Data.IO.BinaryLoader), null, typeof(Microsoft.ML.Data.SignatureLoadDataLoader), "Binary Data View Loader", new System.String[] { "BinaryLoader" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IO.BinaryLoader/InfoCommand), typeof(Microsoft.ML.Data.IO.BinaryLoader/InfoCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "", new System.String[] { "IdvInfo", "idv" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Writes data into a native binary IDV file.", typeof(Microsoft.ML.Data.IO.BinarySaver), typeof(Microsoft.ML.Data.IO.BinarySaver/Arguments), typeof(Microsoft.ML.Data.SignatureDataSaver), "Binary Saver", new System.String[] { "BinarySaver", "Binary" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IDataLoader), typeof(Microsoft.ML.Data.CompositeDataLoader), typeof(Microsoft.ML.Data.CompositeDataLoader/Arguments), typeof(Microsoft.ML.Data.SignatureDataLoader), "Composite Data Loader", new System.String[] { "CompositeDataLoader", "Composite", "PipeData", "Pipe", "PipeDataLoader" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IDataLoader), typeof(Microsoft.ML.Data.CompositeDataLoader), null, typeof(Microsoft.ML.Data.SignatureLoadDataLoader), "Pipe DataL Loader", new System.String[] { "PipeDataLoader" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Loads a horizontally partitioned file set.", typeof(Microsoft.ML.Data.PartitionedFileLoader), typeof(Microsoft.ML.Data.PartitionedFileLoader/Arguments), typeof(Microsoft.ML.Data.SignatureDataLoader), "Partitioned Loader", new System.String[] { "PartitionedLoader", "Part" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Loads a horizontally partitioned file set.", typeof(Microsoft.ML.Data.PartitionedFileLoader), null, typeof(Microsoft.ML.Data.SignatureLoadDataLoader), "Partitioned Loader", new System.String[] { "PartitionedLoader", "Part" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("A simple parser that extracts directory names as column values. Column names are defined as arguments.", typeof(Microsoft.ML.Data.SimplePartitionedPathParser), typeof(Microsoft.ML.Data.SimplePartitionedPathParser/Arguments), typeof(Microsoft.ML.Data.PartitionedPathParser), "Simple Partitioned Path Parser", new System.String[] { "SimplePathParser", "SmplPP" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Extract name/value pairs from Parquet formatted directory names. Example path: Year=2018/Month=12/data1.parquet", typeof(Microsoft.ML.Data.ParquetPartitionedPathParser), null, typeof(Microsoft.ML.Data.PartitionedPathParser), "Parquet Partitioned Path Parser", new System.String[] { "ParquetPathParser", "ParqPP" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("A simple parser that extracts directory names as column values. Column names are defined as arguments.", typeof(Microsoft.ML.Data.SimplePartitionedPathParser), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Simple Partitioned Path Parser", new System.String[] { "SimplePathParser", "SmplPP" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Extract name/value pairs from Parquet formatted directory names. Example path: Year=2018/Month=12/data1.parquet", typeof(Microsoft.ML.Data.ParquetPartitionedPathParser), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Parquet Partitioned Path Parser", new System.String[] { "ParquetPathParser", "ParqPP" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Loads text data file.", typeof(Microsoft.ML.Data.IDataLoader), typeof(Microsoft.ML.Data.TextLoader), typeof(Microsoft.ML.Data.TextLoader/Arguments), typeof(Microsoft.ML.Data.SignatureDataLoader), "Text Loader", new System.String[] { "TextLoader", "Text" }, DocName="loader/TextLoader.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Loads text data file.", typeof(Microsoft.ML.Data.IDataLoader), typeof(Microsoft.ML.Data.TextLoader), null, typeof(Microsoft.ML.Data.SignatureLoadDataLoader), "Text Loader", new System.String[] { "TextLoader" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Writes data into a text file.", typeof(Microsoft.ML.Data.IO.TextSaver), typeof(Microsoft.ML.Data.IO.TextSaver/Arguments), typeof(Microsoft.ML.Data.SignatureDataSaver), "Text Saver", new System.String[] { "TextSaver", "Text" }, DocName="saver/TextSaver.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.TransformerChain`1&lt;Microsoft.ML.Core.Data.ITransformer&gt;), typeof(Microsoft.ML.Data.TransformerChain), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Transformer chain", new System.String[] { "TransformerChain" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.TransformWrapper), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Transform wrapper", new System.String[] { "TransformWrapper" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Loads a binary transposed data file.", typeof(Microsoft.ML.Data.IO.TransposeLoader), typeof(Microsoft.ML.Data.IO.TransposeLoader/Arguments), typeof(Microsoft.ML.Data.SignatureDataLoader), "Transpose Loader", new System.String[] { "TransposeLoader", "Transpose", "trans" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Loads a binary transposed data file.", typeof(Microsoft.ML.Data.IO.TransposeLoader), null, typeof(Microsoft.ML.Data.SignatureLoadDataLoader), "Transpose Data View Loader", new System.String[] { "TransposeLoader" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Writes data into a transposed binary TDV file.", typeof(Microsoft.ML.Data.IO.TransposeSaver), typeof(Microsoft.ML.Data.IO.TransposeSaver/Arguments), typeof(Microsoft.ML.Data.SignatureDataSaver), "Transpose Saver", new System.String[] { "TransposeSaver", "TransposedSaver", "Transpose", "Transposed", "trans" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.RowToRowMapperTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "", new System.String[] { "RowToRowMapper" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ChooseColumnsByIndexTransform), typeof(Microsoft.ML.Data.ChooseColumnsByIndexTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "", new System.String[] { "ChooseColumnsByIndexTransform", "ChooseColumnsByIndex" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ChooseColumnsByIndexTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "", new System.String[] { "ChooseColumnsIdxTrans", "ChooseColumnsIdxFunc" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.EntryPoints.Cache), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "Cache", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.EntryPoints.SchemaManipulation), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "SchemaManipulation", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.EntryPoints.ScoreModel), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "ScoreModel", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.AnomalyDetectionEvaluator), typeof(Microsoft.ML.Data.AnomalyDetectionEvaluator), typeof(Microsoft.ML.Data.AnomalyDetectionEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureEvaluator), "Anomaly Detection Evaluator", new System.String[] { "AnomalyDetectionEvaluator", "AnomalyDetection", "Anomaly" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.AnomalyDetectionMamlEvaluator), typeof(Microsoft.ML.Data.AnomalyDetectionMamlEvaluator), typeof(Microsoft.ML.Data.AnomalyDetectionMamlEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureMamlEvaluator), "Anomaly Detection Evaluator", new System.String[] { "AnomalyDetectionEvaluator", "AnomalyDetection", "Anomaly" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.BinaryClassifierEvaluator), typeof(Microsoft.ML.Data.BinaryClassifierEvaluator), typeof(Microsoft.ML.Data.BinaryClassifierEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureEvaluator), "Binary Classifier Evaluator", new System.String[] { "BinaryClassifierEvaluator", "BinaryClassifier", "Binary", "bin" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.BinaryClassifierMamlEvaluator), typeof(Microsoft.ML.Data.BinaryClassifierMamlEvaluator), typeof(Microsoft.ML.Data.BinaryClassifierMamlEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureMamlEvaluator), "Binary Classifier Evaluator", new System.String[] { "BinaryClassifierEvaluator", "BinaryClassifier", "Binary", "bin" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.BinaryPerInstanceEvaluator), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "", new System.String[] { "BinaryPerInstance" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Data.Evaluate), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "Evaluators", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ClusteringEvaluator), typeof(Microsoft.ML.Data.ClusteringEvaluator), typeof(Microsoft.ML.Data.ClusteringEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureEvaluator), "Clustering Evaluator", new System.String[] { "ClusteringEvaluator", "Clustering" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ClusteringMamlEvaluator), typeof(Microsoft.ML.Data.ClusteringMamlEvaluator), typeof(Microsoft.ML.Data.ClusteringMamlEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureMamlEvaluator), "Clustering Evaluator", new System.String[] { "ClusteringEvaluator", "Clustering" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ClusteringPerInstanceEvaluator), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "", new System.String[] { "ClusteringPerInstance" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.MultiClassClassifierEvaluator), typeof(Microsoft.ML.Data.MultiClassClassifierEvaluator), typeof(Microsoft.ML.Data.MultiClassClassifierEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureEvaluator), "Multi-Class Classifier Evaluator", new System.String[] { "MultiClassClassifierEvaluator", "MultiClassClassifier", "MultiClass" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.MultiClassMamlEvaluator), typeof(Microsoft.ML.Data.MultiClassMamlEvaluator), typeof(Microsoft.ML.Data.MultiClassMamlEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureMamlEvaluator), "Multi-Class Classifier Evaluator", new System.String[] { "MultiClassClassifierEvaluator", "MultiClassClassifier", "MultiClass" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.MultiClassPerInstanceEvaluator), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "", new System.String[] { "MulticlassPerInstance" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.MultiOutputRegressionEvaluator), typeof(Microsoft.ML.Data.MultiOutputRegressionEvaluator), typeof(Microsoft.ML.Data.MultiOutputRegressionEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureEvaluator), "Multi Output Regression Evaluator", new System.String[] { "MultiRegressionEvaluator", "MultiOutputRegression", "MRE" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.MultiOutputRegressionMamlEvaluator), typeof(Microsoft.ML.Data.MultiOutputRegressionMamlEvaluator), typeof(Microsoft.ML.Data.MultiOutputRegressionMamlEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureMamlEvaluator), "Multi Output Regression Evaluator", new System.String[] { "MultiRegressionEvaluator", "MultiOutputRegression", "MRE" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.MultiOutputRegressionPerInstanceEvaluator), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "", new System.String[] { "MultiRegPerInstance" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.QuantileRegressionEvaluator), typeof(Microsoft.ML.Data.QuantileRegressionEvaluator), typeof(Microsoft.ML.Data.QuantileRegressionEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureEvaluator), "Quantile Regression Evaluator", new System.String[] { "QuantileRegressionEvaluator", "QuantileRegression" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.QuantileRegressionMamlEvaluator), typeof(Microsoft.ML.Data.QuantileRegressionMamlEvaluator), typeof(Microsoft.ML.Data.QuantileRegressionMamlEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureMamlEvaluator), "Quantile Regression Evaluator", new System.String[] { "QuantileRegressionEvaluator", "QuantileRegression" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.QuantileRegressionPerInstanceEvaluator), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "", new System.String[] { "QuantileRegPerInstance" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.RankerEvaluator), typeof(Microsoft.ML.Data.RankerEvaluator), typeof(Microsoft.ML.Data.RankerEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureEvaluator), "Ranking Evaluator", new System.String[] { "RankingEvaluator", "Ranking", "rank" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.RankerMamlEvaluator), typeof(Microsoft.ML.Data.RankerMamlEvaluator), typeof(Microsoft.ML.Data.RankerMamlEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureMamlEvaluator), "Ranking Evaluator", new System.String[] { "RankingEvaluator", "Ranking", "rank" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.RankerPerInstanceTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "", new System.String[] { "RankerPerInstTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.RegressionEvaluator), typeof(Microsoft.ML.Data.RegressionEvaluator), typeof(Microsoft.ML.Data.RegressionEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureEvaluator), "Regression Evaluator", new System.String[] { "RegressionEvaluator", "Regression" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.RegressionMamlEvaluator), typeof(Microsoft.ML.Data.RegressionMamlEvaluator), typeof(Microsoft.ML.Data.RegressionMamlEvaluator/Arguments), typeof(Microsoft.ML.Data.SignatureMamlEvaluator), "Regression Evaluator", new System.String[] { "RegressionEvaluator", "Regression" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.RegressionPerInstanceEvaluator), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "", new System.String[] { "RegressionPerInstance" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Given a data model, write out the corresponding PFA.", typeof(Microsoft.ML.Model.Pfa.SavePfaCommand), typeof(Microsoft.ML.Model.Pfa.SavePfaCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Save PFA", new System.String[] { "SavePfa" }, DocName="command/SavePfa.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("This model was introduced by Platt in the paper Probabilistic Outputs for Support Vector Machines and Comparisons to Regularized Likelihood Methods", typeof(Microsoft.ML.Internal.Calibration.PlattCalibratorTrainer), null, typeof(Microsoft.ML.Internal.Calibration.SignatureCalibrator), "Sigmoid Calibration", new System.String[] { "PlattCalibration", "SigmoidCalibration" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Sigmoid calibrator with configurable slope and offset.", typeof(Microsoft.ML.Internal.Calibration.FixedPlattCalibratorTrainer), typeof(Microsoft.ML.Internal.Calibration.FixedPlattCalibratorTrainer/Arguments), typeof(Microsoft.ML.Internal.Calibration.SignatureCalibrator), "Fixed Sigmoid Calibration", new System.String[] { "FixedPlattCalibration", "FixedSigmoidCalibration" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Piecewise linear calibrator.", typeof(Microsoft.ML.Internal.Calibration.PavCalibratorTrainer), null, typeof(Microsoft.ML.Internal.Calibration.SignatureCalibrator), "PAV Calibration", new System.String[] { "PAVCalibration", "PAV" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Naive calibrator divides the range of the outputs into equally sized bins. In each bin, the probability of belonging to class 1 is the number of class 1 instances in the bin, divided by the total number of instances in the bin.", typeof(Microsoft.ML.Internal.Calibration.NaiveCalibratorTrainer), null, typeof(Microsoft.ML.Internal.Calibration.SignatureCalibrator), "Naive Calibrator", new System.String[] { "NaiveCalibrator", "Naive", "NaiveCalibration" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Internal.Calibration.PlattCalibrator), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Platt Calibration Executor", new System.String[] { "PlattCaliExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Internal.Calibration.PavCalibrator), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "PAV Calibration Executor", new System.String[] { "PAVCaliExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Internal.Calibration.NaiveCalibrator), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Naive Calibration Executor", new System.String[] { "NaiveCaliExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Internal.Calibration.CalibratedPredictor), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Calibrated Predictor Executor", new System.String[] { "CaliPredExec", "BulkCaliPredExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Internal.Calibration.FeatureWeightsCalibratedPredictor), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Feature Weights Calibrated Predictor Executor", new System.String[] { "FeatWCaliPredExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Internal.Calibration.ParameterMixingCalibratedPredictor), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Parameter Mixing Calibrated Predictor Executor", new System.String[] { "PMixCaliPredExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Internal.Calibration.SchemaBindableCalibratedPredictor), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Schema Bindable Calibrated Predictor", new System.String[] { "SchemaBindableCalibrated" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Internal.Calibration.Calibrate), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "Calibrate", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Calibrator.CalibratorTransformer`1&lt;Microsoft.ML.Internal.Calibration.PlattCalibrator&gt;), typeof(Microsoft.ML.Calibrator.PlattCalibratorTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "", new System.String[] { "PlattCalibratTransf" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Calibrator.CalibratorTransformer`1&lt;Microsoft.ML.Internal.Calibration.NaiveCalibrator&gt;), typeof(Microsoft.ML.Calibrator.NaiveCalibratorTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "", new System.String[] { "NaiveCalibratTransf" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Calibrator.CalibratorTransformer`1&lt;Microsoft.ML.Internal.Calibration.PavCalibrator&gt;), typeof(Microsoft.ML.Calibrator.PavCalibratorTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "", new System.String[] { "PavCalibratTransf" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.BinaryClassifierScorer), typeof(Microsoft.ML.Data.BinaryClassifierScorer/Arguments), typeof(Microsoft.ML.Data.SignatureDataScorer), "Binary Classifier Scorer", new System.String[] { "BinaryClassifierScorer", "BinaryClassifier", "Binary", "bin", "BinaryClassification" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.BinaryClassifierScorer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Binary Classifier Scorer", new System.String[] { "BinClassScoreTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ClusteringScorer), typeof(Microsoft.ML.Data.ClusteringScorer/Arguments), typeof(Microsoft.ML.Data.SignatureDataScorer), "Clustering Scorer", new System.String[] { "ClusteringScorer", "Clustering" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ClusteringScorer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Clustering Scorer", new System.String[] { "ClusteringScoreTrans" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IDataScorerTransform), typeof(Microsoft.ML.Data.FeatureContributionScorer), typeof(Microsoft.ML.Data.FeatureContributionScorer/Arguments), typeof(Microsoft.ML.Data.SignatureDataScorer), "Feature Contribution Scorer", new System.String[] { "fcc", "wtf", "fct", "FeatureContributionCalculationScorer", "FeatureContribution" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ISchemaBindableMapper), typeof(Microsoft.ML.Data.FeatureContributionScorer), typeof(Microsoft.ML.Data.FeatureContributionScorer/Arguments), typeof(Microsoft.ML.Data.SignatureBindableMapper), "Feature Contribution Mapper", new System.String[] { "fcc", "wtf", "fct", "FeatureContribution" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ISchemaBindableMapper), typeof(Microsoft.ML.Data.FeatureContributionScorer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Feature Contribution Mapper", new System.String[] { "WTFBindable" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.GenericScorer), typeof(Microsoft.ML.Data.GenericScorer/Arguments), typeof(Microsoft.ML.Data.SignatureDataScorer), "Generic Scorer", new System.String[] { "GenericScorer", "Generic" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.GenericScorer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Generic Scorer", new System.String[] { "GenericScoreTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.MultiClassClassifierScorer), typeof(Microsoft.ML.Data.MultiClassClassifierScorer/Arguments), typeof(Microsoft.ML.Data.SignatureDataScorer), "Multi-Class Classifier Scorer", new System.String[] { "MultiClassClassifierScorer", "MultiClassClassifier", "MultiClass", "MultiClassClassification" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.MultiClassClassifierScorer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Multi-Class Classifier Scorer", new System.String[] { "MultiClassScoreTrans" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ISchemaBindableMapper), typeof(Microsoft.ML.Data.MultiClassClassifierScorer/LabelNameBindableMapper), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Multi-Class Label-Name Mapper", new System.String[] { "LabelSlotNameMapper" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.BinaryPredictionTransformer`1&lt;Microsoft.ML.IPredictorProducing`1&lt;System.Single&gt;&gt;), typeof(Microsoft.ML.Data.BinaryPredictionTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "", new System.String[] { "BinaryPredXfer" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.MulticlassPredictionTransformer`1&lt;Microsoft.ML.IPredictorProducing`1&lt;Microsoft.ML.Data.VBuffer`1&lt;System.Single&gt;&gt;&gt;), typeof(Microsoft.ML.Data.MulticlassPredictionTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "", new System.String[] { "MulticlassPredXfer" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.RegressionPredictionTransformer`1&lt;Microsoft.ML.IPredictorProducing`1&lt;System.Single&gt;&gt;), typeof(Microsoft.ML.Data.RegressionPredictionTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "", new System.String[] { "RegressionPredXfer" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.RankingPredictionTransformer`1&lt;Microsoft.ML.IPredictorProducing`1&lt;System.Single&gt;&gt;), typeof(Microsoft.ML.Data.RankingPredictionTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "", new System.String[] { "RankingPredXfer" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.AnomalyPredictionTransformer`1&lt;Microsoft.ML.IPredictorProducing`1&lt;System.Single&gt;&gt;), typeof(Microsoft.ML.Data.AnomalyPredictionTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "", new System.String[] { "AnomalyPredXfer" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ClusteringPredictionTransformer`1&lt;Microsoft.ML.IPredictorProducing`1&lt;Microsoft.ML.Data.VBuffer`1&lt;System.Single&gt;&gt;&gt;), typeof(Microsoft.ML.Data.ClusteringPredictionTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "", new System.String[] { "ClusteringPredXfer" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IDataScorerTransform), typeof(Microsoft.ML.Data.QuantileRegressionScorerTransform), typeof(Microsoft.ML.Data.QuantileRegressionScorerTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataScorer), "Quantile Regression Scorer", new System.String[] { "QuantileRegressionScorer", "QuantileRegression" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ISchemaBindableMapper), typeof(Microsoft.ML.Data.QuantileRegressionScorerTransform), typeof(Microsoft.ML.Data.QuantileRegressionScorerTransform/Arguments), typeof(Microsoft.ML.Data.SignatureBindableMapper), "Quantile Regression Mapper", new System.String[] { "QuantileRegressionScorer", "QuantileRegression" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.SchemaBindablePredictorWrapper), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Bindable Mapper", new System.String[] { "SchemaBindableWrapper" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.SchemaBindableQuantileRegressionPredictor), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Regression Bindable Mapper", new System.String[] { "QuantileSchemaBindable" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.SchemaBindableBinaryPredictorWrapper), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Binary Classification Bindable Mapper", new System.String[] { "BinarySchemaBindable" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Internal.Internallearn.TolerantEarlyStoppingCriterion), typeof(Microsoft.ML.Internal.Internallearn.TolerantEarlyStoppingCriterion/Arguments), typeof(Microsoft.ML.Internal.Internallearn.SignatureEarlyStoppingCriterion), "Tolerant (TR)", new System.String[] { "tr" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Internal.Internallearn.GLEarlyStoppingCriterion), typeof(Microsoft.ML.Internal.Internallearn.GLEarlyStoppingCriterion/Arguments), typeof(Microsoft.ML.Internal.Internallearn.SignatureEarlyStoppingCriterion), "Loss of Generality (GL)", new System.String[] { "gl" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Internal.Internallearn.LPEarlyStoppingCriterion), typeof(Microsoft.ML.Internal.Internallearn.LPEarlyStoppingCriterion/Arguments), typeof(Microsoft.ML.Internal.Internallearn.SignatureEarlyStoppingCriterion), "Low Progress (LP)", new System.String[] { "lp" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Internal.Internallearn.PQEarlyStoppingCriterion), typeof(Microsoft.ML.Internal.Internallearn.PQEarlyStoppingCriterion/Arguments), typeof(Microsoft.ML.Internal.Internallearn.SignatureEarlyStoppingCriterion), "Generality to Progress Ratio (PQ)", new System.String[] { "pq" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Internal.Internallearn.UPEarlyStoppingCriterion), typeof(Microsoft.ML.Internal.Internallearn.UPEarlyStoppingCriterion/Arguments), typeof(Microsoft.ML.Internal.Internallearn.SignatureEarlyStoppingCriterion), "Consecutive Loss in Generality (UP)", new System.String[] { "up" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Concatenates one or more columns of the same item type.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Data.ColumnConcatenatingTransformer), typeof(Microsoft.ML.Data.ColumnConcatenatingTransformer/TaggedArguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Concat Transform", new System.String[] { "Concat", "ConcatTransform" }, DocName="transform/ConcatTransform.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Concatenates one or more columns of the same item type.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Data.ColumnConcatenatingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Concat Transform", new System.String[] { "ConcatTransform", "ConcatFunction" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ColumnConcatenatingTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Concat Transform", new System.String[] { "ConcatTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Data.ColumnConcatenatingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Concat Transform", new System.String[] { "ConcatTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Copy a source column to a new column.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.ColumnCopyingTransformer), typeof(Microsoft.ML.Transforms.ColumnCopyingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Copy Columns Transform", new System.String[] { "CopyColumns", "CopyColumnsTransform", "Copy" }, DocName="transform/CopyColumnsTransformer.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Copy a source column to a new column.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.ColumnCopyingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Copy Columns Transform", new System.String[] { "CopyTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Copy a source column to a new column.", typeof(Microsoft.ML.Transforms.ColumnCopyingTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Copy Columns Transform", new System.String[] { "CopyTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.ColumnCopyingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Copy Columns Transform", new System.String[] { "CopyTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Selects which columns from the dataset to keep.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.ColumnSelectingTransformer), typeof(Microsoft.ML.Transforms.ColumnSelectingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Select Columns Transform", new System.String[] { "SelectColumns", "SelectColumnsTransform", "Select" }, DocName="transform/SelectTransforms.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Selects which columns from the dataset to keep.", typeof(Microsoft.ML.Data.IDataView), typeof(Microsoft.ML.Transforms.ColumnSelectingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Select Columns Transform", new System.String[] { "SelectColumnsTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Selects which columns from the dataset to keep.", typeof(Microsoft.ML.Transforms.ColumnSelectingTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Select Columns Transform", new System.String[] { "SelectColumnsTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("", typeof(Microsoft.ML.Data.IDataView), typeof(Microsoft.ML.Transforms.ColumnSelectingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "", new System.String[] { "DropColumnsTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("", typeof(Microsoft.ML.Data.IDataView), typeof(Microsoft.ML.Transforms.ColumnSelectingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "", new System.String[] { "ChooseColumnsTransform", "ChooseColumnsFunction" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Removes the selected slots from the column.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.FeatureSelection.SlotsDroppingTransformer), typeof(Microsoft.ML.Transforms.FeatureSelection.SlotsDroppingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Drop Slots Transform", new System.String[] { "DropSlotsTransform", "DropSlots" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Removes the selected slots from the column.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.FeatureSelection.SlotsDroppingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Drop Slots Transform", new System.String[] { "DropSlotsTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Removes the selected slots from the column.", typeof(Microsoft.ML.Transforms.FeatureSelection.SlotsDroppingTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Drop Slots Transform", new System.String[] { "DropSlotsTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.FeatureSelection.SlotsDroppingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Drop Slots Transform", new System.String[] { "DropSlotsTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("For each data point, calculates the contribution of individual features to the model prediction.", typeof(Microsoft.ML.Data.FeatureContributionCalculatingTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Feature Contribution Calculation", new System.String[] { "FeatureContribution" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Data.FeatureContributionCalculatingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Feature Contribution Calculation", new System.String[] { "FeatureContribution" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Data.FeatureContributionEntryPoint), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "FeatureContribution", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Adds a column with a generated number sequence.", typeof(Microsoft.ML.Transforms.GenerateNumberTransform), typeof(Microsoft.ML.Transforms.GenerateNumberTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Generate Number Transform", new System.String[] { "GenerateNumberTransform", "GenerateNumber", "Generate" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Adds a column with a generated number sequence.", typeof(Microsoft.ML.Transforms.GenerateNumberTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Generate Number Transform", new System.String[] { "GenNumTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Converts column values into hashes. This transform accepts text and keys as inputs. It works on single- and vector-valued columns, and hashes each slot in a vector separately.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Conversions.HashingTransformer), typeof(Microsoft.ML.Transforms.Conversions.HashingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Hash Transform", new System.String[] { "HashTransform", "Hash" }, DocName="transform/HashTransform.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Converts column values into hashes. This transform accepts text and keys as inputs. It works on single- and vector-valued columns, and hashes each slot in a vector separately.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Conversions.HashingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Hash Transform", new System.String[] { "HashTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Converts column values into hashes. This transform accepts text and keys as inputs. It works on single- and vector-valued columns, and hashes each slot in a vector separately.", typeof(Microsoft.ML.Transforms.Conversions.HashingTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Hash Transform", new System.String[] { "HashTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Conversions.HashingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Hash Transform", new System.String[] { "HashTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Conversions.KeyToValueMappingTransformer), typeof(Microsoft.ML.Transforms.Conversions.KeyToValueMappingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Key To Value Transform", new System.String[] { "KeyToValueTransform", "KeyToValue", "KeyToVal", "Unterm" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Conversions.KeyToValueMappingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Key To Value Transform", new System.String[] { "KeyToValueTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.Conversions.KeyToValueMappingTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Key To Value Transform", new System.String[] { "KeyToValueTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Conversions.KeyToValueMappingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Key To Value Transform", new System.String[] { "KeyToValueTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Converts a key column to an indicator vector.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Conversions.KeyToVectorMappingTransformer), typeof(Microsoft.ML.Transforms.Conversions.KeyToVectorMappingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Key To Vector Transform", new System.String[] { "KeyToVectorTransform", "KeyToVector", "ToVector" }, DocName="transform/KeyToVectorTransform.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Converts a key column to an indicator vector.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Conversions.KeyToVectorMappingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Key To Vector Transform", new System.String[] { "KeyToVectorTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Converts a key column to an indicator vector.", typeof(Microsoft.ML.Transforms.Conversions.KeyToVectorMappingTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "KeyToVectorTransform", new System.String[] { "KeyToVectorTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Conversions.KeyToVectorMappingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "KeyToVectorTransform", new System.String[] { "KeyToVectorTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Convert a label column into a standard floating point representation.", typeof(Microsoft.ML.Transforms.LabelConvertTransform), typeof(Microsoft.ML.Transforms.LabelConvertTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "", new System.String[] { "LabelConvert", "LabelConvertTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Convert a label column into a standard floating point representation.", typeof(Microsoft.ML.Transforms.LabelConvertTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Label Convert Transform", new System.String[] { "LabelConvertTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.LabelIndicatorTransform), typeof(Microsoft.ML.Transforms.LabelIndicatorTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Label Indicator Transform", new System.String[] { "LabelIndicatorTransform", "LabelIndicator" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.LabelIndicatorTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Label Indicator Transform", new System.String[] { "LabelIndicatorTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Transforms.LabelIndicatorTransform), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "LabelIndicatorTransform", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Filters out rows that contain missing values.", typeof(Microsoft.ML.Transforms.NAFilter), typeof(Microsoft.ML.Transforms.NAFilter/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "NA Filter", new System.String[] { "NAFilter", "MissingValueFilter", "MissingFilter" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Filters out rows that contain missing values.", typeof(Microsoft.ML.Transforms.NAFilter), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "NA Filter", new System.String[] { "MissingValueFilter", "MissingFeatureFilter" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Does nothing.", typeof(Microsoft.ML.Data.NopTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "", new System.String[] { "NopTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Data.NopTransform), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "NopTransform", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Normalizes the data based on the observed minimum and maximum values of the data.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Normalizers.NormalizeTransform), typeof(Microsoft.ML.Transforms.Normalizers.NormalizeTransform/MinMaxArguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Min-Max Normalizer", new System.String[] { "MinMaxNormalizer", "MinMax" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Normalizes the data based on the computed mean and variance of the data.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Normalizers.NormalizeTransform), typeof(Microsoft.ML.Transforms.Normalizers.NormalizeTransform/MeanVarArguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "MeanVar Normalizer", new System.String[] { "MeanVarNormalizer", "MeanVar", "ZScoreNormalizer", "ZScore", "GaussianNormalizer", "Gaussian" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Normalizes the data based on the computed mean and variance of the logarithm of the data.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Normalizers.NormalizeTransform), typeof(Microsoft.ML.Transforms.Normalizers.NormalizeTransform/LogMeanVarArguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "LogMeanVar Normalizer", new System.String[] { "LogMeanVarNormalizer", "LogMeanVar", "LogNormalNormalizer", "LogNormal" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("The values are assigned into equidensity bins and a value is mapped to its bin_number/number_of_bins.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Normalizers.NormalizeTransform), typeof(Microsoft.ML.Transforms.Normalizers.NormalizeTransform/BinArguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Binning Normalizer", new System.String[] { "BinNormalizer", "Bin" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.Normalizers.NormalizeTransform/AffineColumnFunction), null, typeof(Microsoft.ML.Data.SignatureLoadColumnFunction), "Affine Normalizer", new System.String[] { "AffineNormExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.Normalizers.NormalizeTransform/CdfColumnFunction), null, typeof(Microsoft.ML.Data.SignatureLoadColumnFunction), "CDF Normalizer", new System.String[] { "CdfNormalizeFunction" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("The values are assigned into equidensity bins and a value is mapped to its bin_number/number_of_bins.", typeof(Microsoft.ML.Transforms.Normalizers.NormalizeTransform/BinColumnFunction), null, typeof(Microsoft.ML.Data.SignatureLoadColumnFunction), "Bin Normalizer", new System.String[] { "BinNormalizeFunction" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.Normalizers.NormalizingTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "", new System.String[] { "Normalizer" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Normalizers.NormalizingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "", new System.String[] { "Normalizer" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Normalizers.NormalizingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "", new System.String[] { "Normalizer", "NormalizeTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Data.Normalize), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "Normalize", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Filters a dataview on a column of type Single, Double or Key (contiguous). Keeps the values that are in the specified min/max range. NaNs are always filtered out. If the input is a Key type, the min/max are considered percentages of the number of values.", typeof(Microsoft.ML.Transforms.RangeFilter), typeof(Microsoft.ML.Transforms.RangeFilter/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Range Filter", new System.String[] { "RangeFilter" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Filters a dataview on a column of type Single, Double or Key (contiguous). Keeps the values that are in the specified min/max range. NaNs are always filtered out. If the input is a Key type, the min/max are considered percentages of the number of values.", typeof(Microsoft.ML.Transforms.RangeFilter), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Range Filter", new System.String[] { "RangeFilter" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Reorders rows in the dataset by pseudo-random shuffling.", typeof(Microsoft.ML.Transforms.RowShufflingTransformer), typeof(Microsoft.ML.Transforms.RowShufflingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Shuffle Transform", new System.String[] { "ShuffleTransform", "Shuffle", "shuf" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Reorders rows in the dataset by pseudo-random shuffling.", typeof(Microsoft.ML.Transforms.RowShufflingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Shuffle Transform", new System.String[] { "ShuffleTrans" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Allows limiting input to a subset of rows at an optional offset.  Can be used to implement data paging.", typeof(Microsoft.ML.Transforms.SkipTakeFilter), typeof(Microsoft.ML.Transforms.SkipTakeFilter/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Skip and Take Filter", new System.String[] { "SkipTakeFilter", "SkipTake" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Allows limiting input to a subset of rows by skipping a number of rows.", typeof(Microsoft.ML.Transforms.SkipTakeFilter), typeof(Microsoft.ML.Transforms.SkipTakeFilter/SkipArguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Skip Filter", new System.String[] { "SkipFilter", "Skip" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Allows limiting input to a subset of rows by taking N first rows.", typeof(Microsoft.ML.Transforms.SkipTakeFilter), typeof(Microsoft.ML.Transforms.SkipTakeFilter/TakeArguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Take Filter", new System.String[] { "TakeFilter", "Take" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Allows limiting input to a subset of rows at an optional offset.  Can be used to implement data paging.", typeof(Microsoft.ML.Transforms.SkipTakeFilter), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Skip and Take Filter", new System.String[] { "SkipTakeFilter" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Runs a previously trained predictor on the data.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.ScoringTransformer), typeof(Microsoft.ML.Transforms.ScoringTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Score Predictor", new System.String[] { "Score" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Trains a predictor, or loads it from a file, and runs it on the data.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.TrainAndScoreTransformer), typeof(Microsoft.ML.Transforms.TrainAndScoreTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Train and Score Predictor", new System.String[] { "TrainScore" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Converts a column to a different type, using standard conversions.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Conversions.TypeConvertingTransformer), typeof(Microsoft.ML.Transforms.Conversions.TypeConvertingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Convert Transform", new System.String[] { "Convert", "ConvertTransform" }, DocName="transform/ConvertTransform.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Converts a column to a different type, using standard conversions.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Conversions.TypeConvertingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Convert Transform", new System.String[] { "ConvertTransform", "ConvertFunction" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Converts a column to a different type, using standard conversions.", typeof(Microsoft.ML.Transforms.Conversions.TypeConvertingTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Convert Transform", new System.String[] { "ConvertTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Converts a column to a different type, using standard conversions.", typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Conversions.TypeConvertingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Convert Transform", new System.String[] { "ConvertTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Maps text values columns to new columns using a map dataset.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Conversions.ValueMappingTransformer), typeof(Microsoft.ML.Transforms.Conversions.ValueMappingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Value Mapping Transform", new System.String[] { "ValueMapping", "ValueMappingTransformer", "ValueMap", "TermLookup", "Lookup", "LookupTransform" }, DocName="transform/ValueMappingTransformer.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Maps text values columns to new columns using a map dataset.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Conversions.ValueMappingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Value Mapping Transform", new System.String[] { "ValueMappingTransformer", "TermLookupTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Maps text values columns to new columns using a map dataset.", typeof(Microsoft.ML.Transforms.Conversions.ValueMappingTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Value Mapping Transform", new System.String[] { "ValueMappingTransformer" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Conversions.ValueMappingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Value Mapping Transform", new System.String[] { "ValueMappingTransformer" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Converts input values (words, numbers, etc.) to index in a dictionary.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Conversions.ValueToKeyMappingTransformer), typeof(Microsoft.ML.Transforms.Conversions.ValueToKeyMappingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Term Transform", new System.String[] { "Term", "AutoLabel", "TermTransform", "AutoLabelTransform" }, DocName="transform/TermTransform.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Converts input values (words, numbers, etc.) to index in a dictionary.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Conversions.ValueToKeyMappingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Term Transform", new System.String[] { "TermTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Converts input values (words, numbers, etc.) to index in a dictionary.", typeof(Microsoft.ML.Transforms.Conversions.ValueToKeyMappingTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Term Transform", new System.String[] { "TermTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Conversions.ValueToKeyMappingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Term Transform", new System.String[] { "TermTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("The log loss function for classification. Supported by SDCA.", typeof(Microsoft.ML.LogLoss), null, typeof(Microsoft.ML.SignatureClassificationLoss), "Log Loss", new System.String[] { "LogLoss", "Logistic", "CrossEntropy" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("The Hinge loss function for classification. Supported by SDCA.", typeof(Microsoft.ML.HingeLoss), typeof(Microsoft.ML.HingeLoss/Arguments), typeof(Microsoft.ML.SignatureClassificationLoss), "Hinge Loss", new System.String[] { "HingeLoss", "Hinge" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("The smooth Hinge loss function for classification. Supported by SDCA.", typeof(Microsoft.ML.SmoothedHingeLoss), typeof(Microsoft.ML.SmoothedHingeLoss/Arguments), typeof(Microsoft.ML.SignatureClassificationLoss), "Smoothed Hinge Loss", new System.String[] { "SmoothedHingeLoss", "SmoothedHinge" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("The exponential loss function for classification.", typeof(Microsoft.ML.ExpLoss), typeof(Microsoft.ML.ExpLoss/Arguments), typeof(Microsoft.ML.SignatureClassificationLoss), "Exponential Loss", new System.String[] { "ExpLoss", "Exp" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("The squared loss function for regression.", typeof(Microsoft.ML.SquaredLoss), null, typeof(Microsoft.ML.SignatureRegressionLoss), "Squared Loss", new System.String[] { "SquaredLoss", "L2" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("The Poisson loss function for regression.", typeof(Microsoft.ML.PoissonLoss), null, typeof(Microsoft.ML.SignatureRegressionLoss), "Poisson Loss", new System.String[] { "PoissonLoss", "Poisson" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("The Tweedie loss function for regression.", typeof(Microsoft.ML.TweedieLoss), typeof(Microsoft.ML.TweedieLoss/Arguments), typeof(Microsoft.ML.SignatureRegressionLoss), "Tweedie Loss", new System.String[] { "TweedieLoss", "Tweedie", "Tw" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Core.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Predictor.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TimeSeries.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.EntryPoints, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.ImageAnalytics, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Internal.MetaLinearLearner, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("TMSNlearnPrediction, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.CntkWrapper, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.DssmFeaturizer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.DssmTrigram, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.EdgeML, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Internal.FastTree, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.Garage, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.HelperCommands, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.Internal.ImageAnalytics, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.InferNetWrapper, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.LDSVM, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("LibSvmWrapper, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Internal.RecipeInference, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.PyTrainer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("ParameterMixer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Internal.Api, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.TextAnalytics, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("StratoLearner, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.SequencePrediction, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.RServerScoring.TextAnalytics, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.NeuralNetworks, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.RServerScoring.NeuralNetworks, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.Sar, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.OcrTransform, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("TreeVisualizer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.TlcAzurePublish, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.XGBoost, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.SLib, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.VowpalWabbit, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.RServerScoring, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.TlcCustomModule, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.Scope, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("TLC, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTestsMore, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.DnnImageFeaturizer.AlexNet" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.DnnImageFeaturizer.AlexNet")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.DnnImageFeaturizer.AlexNet")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.DnnImageFeaturizer.ResNet101" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.DnnImageFeaturizer.ResNet101")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.DnnImageFeaturizer.ResNet101")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.DnnImageFeaturizer.ResNet18" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.DnnImageFeaturizer.ResNet18")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.DnnImageFeaturizer.ResNet18")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.DnnImageFeaturizer.ResNet50" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.DnnImageFeaturizer.ResNet50")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.DnnImageFeaturizer.ResNet50")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.Ensemble" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.Ensemble")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.Ensemble")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.EntryPoints.DisagreementDiversityFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.EntryPoints.RegressionDisagreementDiversityFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.EntryPoints.MultiDisagreementDiversityFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.EntryPoints.AllFeatureSelectorFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.Selector.FeatureSelector.RandomFeatureSelector))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.EntryPoints.AverageFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.EntryPoints.MedianFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.OutputCombiners.MultiAverage))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.OutputCombiners.MultiMedian))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.OutputCombiners.MultiStacking))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.EntryPoints.MultiVotingFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.OutputCombiners.MultiWeightedAverage))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.OutputCombiners.RegressionStacking))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.OutputCombiners.Stacking))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.EntryPoints.VotingFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.OutputCombiners.WeightedAverage))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.EntryPoints.PipelineEnsemble))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.EntryPoints.AllSelectorFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.EntryPoints.AllSelectorMultiClassFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.Selector.SubModelSelector.BestDiverseSelectorBinary))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.Selector.SubModelSelector.BestDiverseSelectorMultiClass))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.Selector.SubModelSelector.BestDiverseSelectorRegression))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.Selector.SubModelSelector.BestPerformanceRegressionSelector))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.Selector.SubModelSelector.BestPerformanceSelector))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.Selector.SubModelSelector.BestPerformanceSelectorMultiClass))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.Selector.SubsetSelector.AllInstanceSelector))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.Selector.SubsetSelector.BootstrapSelector))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.Selector.SubsetSelector.RandomPartitionSelector))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Ensemble.EnsembleModelParameters))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.EntryPoints.EnsembleCreator), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "CreateEnsemble", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Ensemble.EntryPoints.Ensemble), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "TrainEnsemble", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.OutputCombiners.Average), null, typeof(Microsoft.ML.Ensemble.OutputCombiners.SignatureCombiner), "Average", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.OutputCombiners.Average), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Average", new System.String[] { "AverageCombiner" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.OutputCombiners.Median), null, typeof(Microsoft.ML.Ensemble.OutputCombiners.SignatureCombiner), "Median", new System.String[] { "Median" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.OutputCombiners.Median), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Median", new System.String[] { "MedianCombiner" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.OutputCombiners.MultiAverage), typeof(Microsoft.ML.Ensemble.OutputCombiners.MultiAverage/Arguments), typeof(Microsoft.ML.Ensemble.OutputCombiners.SignatureCombiner), "Average", new System.String[] { "MultiAverage" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.OutputCombiners.MultiAverage), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Average", new System.String[] { "MultiAverage", "MultiAverageCombiner" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.OutputCombiners.MultiMedian), typeof(Microsoft.ML.Ensemble.OutputCombiners.MultiMedian/Arguments), typeof(Microsoft.ML.Ensemble.OutputCombiners.SignatureCombiner), "Median", new System.String[] { "MultiMedian" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.OutputCombiners.MultiMedian), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Median", new System.String[] { "MultiMedianCombiner" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.OutputCombiners.MultiStacking), typeof(Microsoft.ML.Ensemble.OutputCombiners.MultiStacking/Arguments), typeof(Microsoft.ML.Ensemble.OutputCombiners.SignatureCombiner), "Stacking", new System.String[] { "MultiStacking" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.OutputCombiners.MultiStacking), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Stacking", new System.String[] { "MultiStackingCombiner" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.OutputCombiners.MultiVoting), null, typeof(Microsoft.ML.Ensemble.OutputCombiners.SignatureCombiner), "Voting", new System.String[] { "MultiVoting" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.OutputCombiners.MultiVoting), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Voting", new System.String[] { "MultiVotingCombiner" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.OutputCombiners.MultiWeightedAverage), typeof(Microsoft.ML.Ensemble.OutputCombiners.MultiWeightedAverage/Arguments), typeof(Microsoft.ML.Ensemble.OutputCombiners.SignatureCombiner), "Multi Weighted Average", new System.String[] { "MultiWeightedAverage" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.OutputCombiners.MultiWeightedAverage), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Multi Weighted Average", new System.String[] { "MultiWeightedAverageComb" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.OutputCombiners.RegressionStacking), typeof(Microsoft.ML.Ensemble.OutputCombiners.RegressionStacking/Arguments), typeof(Microsoft.ML.Ensemble.OutputCombiners.SignatureCombiner), "Stacking", new System.String[] { "RegressionStacking" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.OutputCombiners.RegressionStacking), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Stacking", new System.String[] { "RegressionStacking" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.OutputCombiners.Stacking), typeof(Microsoft.ML.Ensemble.OutputCombiners.Stacking/Arguments), typeof(Microsoft.ML.Ensemble.OutputCombiners.SignatureCombiner), "Stacking", new System.String[] { "Stacking" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.OutputCombiners.Stacking), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Stacking", new System.String[] { "StackingCombiner" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.OutputCombiners.Voting), null, typeof(Microsoft.ML.Ensemble.OutputCombiners.SignatureCombiner), "Voting", new System.String[] { "Voting" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.OutputCombiners.Voting), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Voting", new System.String[] { "VotingCombiner" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.OutputCombiners.WeightedAverage), typeof(Microsoft.ML.Ensemble.OutputCombiners.WeightedAverage/Arguments), typeof(Microsoft.ML.Ensemble.OutputCombiners.SignatureCombiner), "Weighted Average", new System.String[] { "WeightedAverage" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.OutputCombiners.WeightedAverage), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Weighted Average", new System.String[] { "WeightedAverageCombiner" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.SchemaBindablePipelineEnsembleBase), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Pipeline Ensemble", new System.String[] { "PipelineEnsemble" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.Selector.DiversityMeasure.DisagreementDiversityMeasure), null, typeof(Microsoft.ML.Ensemble.Selector.SignatureEnsembleDiversityMeasure), "Disagreement Diversity Measure", new System.String[] { "DisagreementDiversityMeasure" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.Selector.DiversityMeasure.MultiDisagreementDiversityMeasure), null, typeof(Microsoft.ML.Ensemble.Selector.SignatureEnsembleDiversityMeasure), "Disagreement Diversity Measure", new System.String[] { "MultiDisagreementDiversityMeasure" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.Selector.DiversityMeasure.RegressionDisagreementDiversityMeasure), null, typeof(Microsoft.ML.Ensemble.Selector.SignatureEnsembleDiversityMeasure), "Disagreement Diversity Measure", new System.String[] { "RegressionDisagreementDiversityMeasure" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.Selector.FeatureSelector.AllFeatureSelector), null, typeof(Microsoft.ML.Ensemble.Selector.SignatureEnsembleFeatureSelector), "All Feature Selector", new System.String[] { "AllFeatureSelector" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.Selector.FeatureSelector.RandomFeatureSelector), typeof(Microsoft.ML.Ensemble.Selector.FeatureSelector.RandomFeatureSelector/Arguments), typeof(Microsoft.ML.Ensemble.Selector.SignatureEnsembleFeatureSelector), "Random Feature Selector", new System.String[] { "RandomFeatureSelector" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.Selector.SubModelSelector.AllSelector), null, typeof(Microsoft.ML.Ensemble.Selector.SignatureEnsembleSubModelSelector), "All Selector", new System.String[] { "AllSelector" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.Selector.SubModelSelector.AllSelectorMultiClass), null, typeof(Microsoft.ML.Ensemble.Selector.SignatureEnsembleSubModelSelector), "All Selector", new System.String[] { "AllSelectorMultiClass" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.Selector.SubModelSelector.BestDiverseSelectorBinary), typeof(Microsoft.ML.Ensemble.Selector.SubModelSelector.BestDiverseSelectorBinary/Arguments), typeof(Microsoft.ML.Ensemble.Selector.SignatureEnsembleSubModelSelector), "Best Diverse Selector", new System.String[] { "BestDiverseSelector" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.Selector.SubModelSelector.BestDiverseSelectorMultiClass), typeof(Microsoft.ML.Ensemble.Selector.SubModelSelector.BestDiverseSelectorMultiClass/Arguments), typeof(Microsoft.ML.Ensemble.Selector.SignatureEnsembleSubModelSelector), "Best Diverse Selector", new System.String[] { "BestDiverseSelectorMultiClass" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.Selector.SubModelSelector.BestDiverseSelectorRegression), typeof(Microsoft.ML.Ensemble.Selector.SubModelSelector.BestDiverseSelectorRegression/Arguments), typeof(Microsoft.ML.Ensemble.Selector.SignatureEnsembleSubModelSelector), "Best Diverse Selector", new System.String[] { "BestDiverseSelectorRegression" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.Selector.SubModelSelector.BestPerformanceRegressionSelector), typeof(Microsoft.ML.Ensemble.Selector.SubModelSelector.BestPerformanceRegressionSelector/Arguments), typeof(Microsoft.ML.Ensemble.Selector.SignatureEnsembleSubModelSelector), "Best Performance Selector", new System.String[] { "BestPerformanceRegressionSelector" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.Selector.SubModelSelector.BestPerformanceSelector), typeof(Microsoft.ML.Ensemble.Selector.SubModelSelector.BestPerformanceSelector/Arguments), typeof(Microsoft.ML.Ensemble.Selector.SignatureEnsembleSubModelSelector), "Best Performance Selector", new System.String[] { "BestPerformanceSelector" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.Selector.SubModelSelector.BestPerformanceSelectorMultiClass), typeof(Microsoft.ML.Ensemble.Selector.SubModelSelector.BestPerformanceSelectorMultiClass/Arguments), typeof(Microsoft.ML.Ensemble.Selector.SignatureEnsembleSubModelSelector), "Best Performance Selector", new System.String[] { "BestPerformanceSelectorMultiClass" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.Selector.SubsetSelector.AllInstanceSelector), typeof(Microsoft.ML.Ensemble.Selector.SubsetSelector.AllInstanceSelector/Arguments), typeof(Microsoft.ML.Ensemble.Selector.SignatureEnsembleDataSelector), "All Instance Selector", new System.String[] { "AllInstanceSelector" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.Selector.SubsetSelector.BootstrapSelector), typeof(Microsoft.ML.Ensemble.Selector.SubsetSelector.BootstrapSelector/Arguments), typeof(Microsoft.ML.Ensemble.Selector.SignatureEnsembleDataSelector), "Bootstrap Selector", new System.String[] { "BootstrapSelector" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.Selector.SubsetSelector.RandomPartitionSelector), typeof(Microsoft.ML.Ensemble.Selector.SubsetSelector.RandomPartitionSelector/Arguments), typeof(Microsoft.ML.Ensemble.Selector.SignatureEnsembleDataSelector), "Random Partition Selector", new System.String[] { "RandomPartitionSelector" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("A generic ensemble classifier for binary classification.", typeof(Microsoft.ML.Ensemble.EnsembleTrainer), typeof(Microsoft.ML.Ensemble.EnsembleTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer) }, "Parallel Ensemble (bagging, stacking, etc)", new System.String[] { "WeightedEnsemble", "pe", "ParallelEnsemble" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.EnsembleTrainer), typeof(Microsoft.ML.Ensemble.EnsembleTrainer/Arguments), typeof(Microsoft.ML.Ensemble.SignatureModelCombiner), "Binary Classification Ensemble Model Combiner", new System.String[] { "WeightedEnsemble", "pe", "ParallelEnsemble" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.EnsembleDistributionModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Ensemble Distribution Executor", new System.String[] { "EnsemDbExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.EnsembleModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Ensemble Executor", new System.String[] { "EnsembleFloatExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.EnsembleMultiClassModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Ensemble Multiclass Executor", new System.String[] { "EnsemMcExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("A generic ensemble classifier for multi-class classification.", typeof(Microsoft.ML.Ensemble.MulticlassDataPartitionEnsembleTrainer), typeof(Microsoft.ML.Ensemble.MulticlassDataPartitionEnsembleTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureMultiClassClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer) }, "Multi-class Parallel Ensemble (bagging, stacking, etc)", new System.String[] { "WeightedEnsembleMulticlass" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.MulticlassDataPartitionEnsembleTrainer), typeof(Microsoft.ML.Ensemble.MulticlassDataPartitionEnsembleTrainer/Arguments), typeof(Microsoft.ML.Ensemble.SignatureModelCombiner), "Multiclass Classification Ensemble Model Combiner", new System.String[] { "WeightedEnsembleMulticlass" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.RegressionEnsembleTrainer), typeof(Microsoft.ML.Ensemble.RegressionEnsembleTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureRegressorTrainer), typeof(Microsoft.ML.SignatureTrainer) }, "Regression Ensemble (bagging, stacking, etc)", new System.String[] { "EnsembleRegression" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Ensemble.RegressionEnsembleTrainer), typeof(Microsoft.ML.Ensemble.RegressionEnsembleTrainer/Arguments), typeof(Microsoft.ML.Ensemble.SignatureModelCombiner), "Regression Ensemble Model Combiner", new System.String[] { "EnsembleRegression" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.Scope, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.FastTree" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.FastTree")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.FastTree")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.WantsToBeBestFriends</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Core.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.FastTree.FastTreeBinaryClassificationTrainer/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.FastTree.SingleTrainerFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Uses a logit-boost boosted tree learner to perform binary classification.", typeof(Microsoft.ML.Trainers.FastTree.FastTreeBinaryClassificationTrainer), typeof(Microsoft.ML.Trainers.FastTree.FastTreeBinaryClassificationTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Trainers.FastTree.SignatureTreeEnsembleTrainer), typeof(Microsoft.ML.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "FastTree (Boosted Trees) Classification", new System.String[] { "FastTreeBinaryClassification", "FastTreeClassification", "FastTree", "ft", "ftc", "FastRankBinaryClassification", "FastRankBinaryClassificationWrapper", "FastRankClassification", "fr", "btc", "frc", "fastrank", "fastrankwrapper" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.IPredictorProducing`1&lt;System.Single&gt;), typeof(Microsoft.ML.Trainers.FastTree.FastTreeBinaryModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "FastTree Binary Executor", new System.String[] { "FastTreeBinaryExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Trains gradient boosted decision trees to the LambdaRank quasi-gradient.", typeof(Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer), typeof(Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureRankerTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Trainers.FastTree.SignatureTreeEnsembleTrainer), typeof(Microsoft.ML.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "FastTree (Boosted Trees) Ranking", new System.String[] { "FastTreeRanking", "ftrank", "FastRankRanking", "FastRankRankingWrapper", "rank", "frrank", "btrank" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.FastTree.FastTreeRankingModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "FastTree Ranking Executor", new System.String[] { "FastTreeRankerExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.FastTree.FastTree), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "FastTree", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Trains gradient boosted decision trees to fit target values using least-squares.", typeof(Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer), typeof(Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureRegressorTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Trainers.FastTree.SignatureTreeEnsembleTrainer), typeof(Microsoft.ML.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "FastTree (Boosted Trees) Regression", new System.String[] { "FastTreeRegression", "ftr", "FastRankRegression", "FastRankRegressionWrapper", "frr", "btr" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.FastTree.FastTreeRegressionModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "FastTree Regression Executor", new System.String[] { "FastTreeRegressionExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Trains gradient boosted decision trees to fit target values using a Tweedie loss function. This learner is a generalization of Poisson, compound Poisson, and gamma regression.", typeof(Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer), typeof(Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureRegressorTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Trainers.FastTree.SignatureTreeEnsembleTrainer), typeof(Microsoft.ML.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "FastTree (Boosted Trees) Tweedie Regression", new System.String[] { "FastTreeTweedieRegression", "fttweedie" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.FastTree.FastTreeTweedieModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "FastTree Tweedie Regression Executor", new System.String[] { "FastTreeTweedieExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Trains a gradient boosted stump per feature, on all features simultaneously, to fit target values using least-squares. It mantains no interactions between features.", typeof(Microsoft.ML.Trainers.FastTree.BinaryClassificationGamTrainer), typeof(Microsoft.ML.Trainers.FastTree.BinaryClassificationGamTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Generalized Additive Model for Binary Classification", new System.String[] { "BinaryClassificationGamTrainer", "gam" }, DocName="trainer/GAM.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.IPredictorProducing`1&lt;System.Single&gt;), typeof(Microsoft.ML.Trainers.FastTree.BinaryClassificationGamModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "GAM Binary Class Predictor", new System.String[] { "BinaryClassGamPredictor" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Trains a gradient boosted stump per feature, on all features simultaneously, to fit target values using least-squares. It mantains no interactions between features.", typeof(Microsoft.ML.Trainers.FastTree.RegressionGamTrainer), typeof(Microsoft.ML.Trainers.FastTree.RegressionGamTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureRegressorTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Generalized Additive Model for Regression", new System.String[] { "RegressionGamTrainer", "gamr" }, DocName="trainer/GAM.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.FastTree.RegressionGamModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "GAM Regression Predictor", new System.String[] { "RegressionGamPredictor" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.FastTree.GamModelParametersBase/VisualizationCommand), typeof(Microsoft.ML.Trainers.FastTree.GamModelParametersBase/VisualizationCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "GAM Vizualization Command", new System.String[] { "GamVisualization", "gamviz" }, DocName="command/GamViz.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.FastTree.Gam), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "GAM", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Uses a random forest learner to perform binary classification.", typeof(Microsoft.ML.Trainers.FastTree.FastForestClassification), typeof(Microsoft.ML.Trainers.FastTree.FastForestClassification/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Trainers.FastTree.SignatureTreeEnsembleTrainer), typeof(Microsoft.ML.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Fast Forest Classification", new System.String[] { "FastForestClassification", "FastForest", "ff", "ffc" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.IPredictorProducing`1&lt;System.Single&gt;), typeof(Microsoft.ML.Trainers.FastTree.FastForestClassificationModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "FastForest Binary Executor", new System.String[] { "FastForestBinaryExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.FastTree.FastForest), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "FastForest", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Trains a random forest to fit target values using least-squares.", typeof(Microsoft.ML.Trainers.FastTree.FastForestRegression), typeof(Microsoft.ML.Trainers.FastTree.FastForestRegression/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureRegressorTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Trainers.FastTree.SignatureTreeEnsembleTrainer), typeof(Microsoft.ML.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Fast Forest Regression", new System.String[] { "FastForestRegression", "ffr" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.FastTree.FastForestRegressionModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "FastForest Regression Executor", new System.String[] { "FastForestRegressionExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.FastTree.SumupPerformanceCommand), typeof(Microsoft.ML.Trainers.FastTree.SumupPerformanceCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "", new System.String[] { "FastTreeSumupPerformance", "ftsumup" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.FastTree.SingleTrainer), null, typeof(Microsoft.ML.Trainers.FastTree.SignatureParallelTrainer), "single", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ISchemaBindableMapper), typeof(Microsoft.ML.Data.TreeEnsembleFeaturizerTransform), typeof(Microsoft.ML.Data.TreeEnsembleFeaturizerBindableMapper/Arguments), typeof(Microsoft.ML.Data.SignatureBindableMapper), "Tree Ensemble Featurizer Mapper", new System.String[] { "TreeFeat" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IDataScorerTransform), typeof(Microsoft.ML.Data.TreeEnsembleFeaturizerTransform), typeof(Microsoft.ML.Data.TreeEnsembleFeaturizerBindableMapper/Arguments), typeof(Microsoft.ML.Data.SignatureDataScorer), "Tree Ensemble Featurizer Scorer", new System.String[] { "TreeFeat" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.ISchemaBindableMapper), typeof(Microsoft.ML.Data.TreeEnsembleFeaturizerTransform), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Tree Ensemble Featurizer Mapper", new System.String[] { "TreeEnsembleMapper" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Trains a tree ensemble, or loads it from a file, then maps a numeric feature vector to three outputs: 1. A vector containing the individual tree outputs of the tree ensemble. 2. A vector indicating the leaves that the feature vector falls on in the tree ensemble. 3. A vector indicating the paths that the feature vector falls on in the tree ensemble. If a both a model file and a trainer are specified - will use the model file. If neither are specified, will train a default FastTree model. This can handle key labels by training a regression model towards their optionally permuted indices.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Data.TreeEnsembleFeaturizerTransform), typeof(Microsoft.ML.Data.TreeEnsembleFeaturizerTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Tree Ensemble Featurization Transform", new System.String[] { "TreeFeat", "TreeFeaturizationTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Data.TreeFeaturize), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "TreeFeaturize", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.FastTree.Internal.TreeEnsembleCombiner), null, typeof(Microsoft.ML.Ensemble.SignatureModelCombiner), "Fast Tree Model Combiner", new System.String[] { "FastTreeCombiner" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.LightGBM, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Sweeper, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Internal.FastTree, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.HalLearners" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.HalLearners")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.HalLearners")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("The ordinary least square regression fits the target function as a linear function of the numerical features that minimizes the square loss function.", typeof(Microsoft.ML.Trainers.HalLearners.OlsLinearRegressionTrainer), typeof(Microsoft.ML.Trainers.HalLearners.OlsLinearRegressionTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureRegressorTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Ordinary Least Squares (Regression)", new System.String[] { "OLSLinearRegression", "ols" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.HalLearners.OlsLinearRegressionModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "OLS Linear Regression Executor", new System.String[] { "OlsLinearRegressionExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.HalLearners.OlsLinearRegressionTrainer), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "OLSLinearRegression", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.SymSgd.SymSgdClassificationTrainer), typeof(Microsoft.ML.Trainers.SymSgd.SymSgdClassificationTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Symbolic SGD (binary)", new System.String[] { "SymbolicSGD", "SymSGD" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.SymSgd.SymSgdClassificationTrainer), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "SymbolicSGD", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Apply PCA or ZCA whitening algorithm to the input.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Projections.VectorWhiteningTransformer), typeof(Microsoft.ML.Transforms.Projections.VectorWhiteningTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Whitening Transform", new System.String[] { "WhiteningTransform", "Whitening" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Apply PCA or ZCA whitening algorithm to the input.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Projections.VectorWhiteningTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Whitening Transform", new System.String[] { "WhiteningTransform", "WhiteningFunction" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Apply PCA or ZCA whitening algorithm to the input.", typeof(Microsoft.ML.Transforms.Projections.VectorWhiteningTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Whitening Transform", new System.String[] { "WhiteningTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Projections.VectorWhiteningTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Whitening Transform", new System.String[] { "WhiteningTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.WantsToBeBestFriends</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.HalLearners.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.ImageAnalytics" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.ImageAnalytics.EntryPoints.ImageAnalytics), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "ImageAnalytics", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Convert image into grayscale.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.ImageAnalytics.ImageGrayscaleTransform), typeof(Microsoft.ML.ImageAnalytics.ImageGrayscaleTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Image Greyscale Transform", new System.String[] { "ImageGrayscaleTransform", "ImageGrayscale" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Convert image into grayscale.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.ImageAnalytics.ImageGrayscaleTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Image Greyscale Transform", new System.String[] { "ImageGrayscaleTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.ImageAnalytics.ImageGrayscaleTransform), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Image Greyscale Transform", new System.String[] { "ImageGrayscaleTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.ImageAnalytics.ImageGrayscaleTransform), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Image Greyscale Transform", new System.String[] { "ImageGrayscaleTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Load images from files.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.ImageAnalytics.ImageLoaderTransform), typeof(Microsoft.ML.ImageAnalytics.ImageLoaderTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Image Loader Transform", new System.String[] { "ImageLoaderTransform", "ImageLoader" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Load images from files.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.ImageAnalytics.ImageLoaderTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Image Loader Transform", new System.String[] { "ImageLoaderTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.ImageAnalytics.ImageLoaderTransform), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "", new System.String[] { "ImageLoaderTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.ImageAnalytics.ImageLoaderTransform), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "", new System.String[] { "ImageLoaderTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Extract color plane(s) from an image. Options include scaling, offset and conversion to floating point.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.ImageAnalytics.ImagePixelExtractorTransform), typeof(Microsoft.ML.ImageAnalytics.ImagePixelExtractorTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Image Pixel Extractor Transform", new System.String[] { "ImagePixelExtractorTransform", "ImagePixelExtractor" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Extract color plane(s) from an image. Options include scaling, offset and conversion to floating point.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.ImageAnalytics.ImagePixelExtractorTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Image Pixel Extractor Transform", new System.String[] { "ImagePixelExtractor" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.ImageAnalytics.ImagePixelExtractorTransform), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Image Pixel Extractor Transform", new System.String[] { "ImagePixelExtractor" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.ImageAnalytics.ImagePixelExtractorTransform), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Image Pixel Extractor Transform", new System.String[] { "ImagePixelExtractor" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Scales an image to specified dimensions using one of the three scale types: isotropic with padding, isotropic with cropping or anisotropic. In case of isotropic padding, transparent color is used to pad resulting image.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.ImageAnalytics.ImageResizerTransform), typeof(Microsoft.ML.ImageAnalytics.ImageResizerTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Image Resizer Transform", new System.String[] { "ImageResizerTransform", "ImageResizer" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Scales an image to specified dimensions using one of the three scale types: isotropic with padding, isotropic with cropping or anisotropic. In case of isotropic padding, transparent color is used to pad resulting image.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.ImageAnalytics.ImageResizerTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Image Resizer Transform", new System.String[] { "ImageScalerTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.ImageAnalytics.ImageResizerTransform), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Image Resizer Transform", new System.String[] { "ImageScalerTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.ImageAnalytics.ImageResizerTransform), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Image Resizer Transform", new System.String[] { "ImageScalerTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Converts vector array into image type.", typeof(Microsoft.ML.ImageAnalytics.VectorToImageTransform), typeof(Microsoft.ML.ImageAnalytics.VectorToImageTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Vector To Image Transform", new System.String[] { "VectorToImageTransform", "VectorToImage" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Converts vector array into image type.", typeof(Microsoft.ML.ImageAnalytics.VectorToImageTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Vector To Image Transform", new System.String[] { "VectorToImageConverter" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.WantsToBeBestFriends</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.ImageAnalytics")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.ImageAnalytics")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.KMeansClustering" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.KMeansClustering")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.KMeansClustering")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.KMeans.KMeansModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "KMeans predictor", new System.String[] { "KMeansPredictor" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("K-means is a popular clustering algorithm. With K-means, the data is clustered into a specified number of clusters in order to minimize the within-cluster sum of squares. K-means++ improves upon K-means by using a better method for choosing the initial cluster centers.", typeof(Microsoft.ML.Trainers.KMeans.KMeansPlusPlusTrainer), typeof(Microsoft.ML.Trainers.KMeans.KMeansPlusPlusTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureClusteringTrainer), typeof(Microsoft.ML.SignatureTrainer) }, "KMeans++ Clustering", new System.String[] { "KMeansPlusPlus", "KM", "KMeans" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.KMeans.KMeansPlusPlusTrainer), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "KMeans", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.WantsToBeBestFriends</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.LightGBM" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.LightGBM")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.LightGBM")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.LightGBM.LightGbmArguments/TreeBooster/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.LightGBM.LightGbmArguments/DartBooster/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.LightGBM.LightGbmArguments/GossBooster/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.LightGBM.SingleTrainerFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.LightGBM.LightGbmArguments/TreeBooster), typeof(Microsoft.ML.LightGBM.LightGbmArguments/TreeBooster/Arguments), typeof(Microsoft.ML.LightGBM.SignatureLightGBMBooster), "Tree Booster", new System.String[] { "gbdt" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.LightGBM.LightGbmArguments/DartBooster), typeof(Microsoft.ML.LightGBM.LightGbmArguments/DartBooster/Arguments), typeof(Microsoft.ML.LightGBM.SignatureLightGBMBooster), "Tree Dropout Tree Booster", new System.String[] { "dart" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.LightGBM.LightGbmArguments/GossBooster), typeof(Microsoft.ML.LightGBM.LightGbmArguments/GossBooster/Arguments), typeof(Microsoft.ML.LightGBM.SignatureLightGBMBooster), "Gradient-based One-Size Sampling", new System.String[] { "goss" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Train a LightGBM binary classification model.", typeof(Microsoft.ML.LightGBM.LightGbmBinaryTrainer), typeof(Microsoft.ML.LightGBM.LightGbmArguments), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Trainers.FastTree.SignatureTreeEnsembleTrainer) }, "LightGBM Binary Classifier", new System.String[] { "LightGBMBinary", "LightGBM" }, DocName="trainer/LightGBM.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.IPredictorProducing`1&lt;System.Single&gt;), typeof(Microsoft.ML.LightGBM.LightGbmBinaryModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "LightGBM Binary Executor", new System.String[] { "LightGBMBinaryExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.LightGBM.LightGbm), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "LightGBM", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("LightGBM Multi Class Classifier", typeof(Microsoft.ML.LightGBM.LightGbmMulticlassTrainer), typeof(Microsoft.ML.LightGBM.LightGbmArguments), new System.Type[] { typeof(Microsoft.ML.SignatureMultiClassClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer) }, "LightGBM Multi-class Classifier", new System.String[] { "LightGBMMulticlass", "LightGBMMC" }, DocName="trainer/LightGBM.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("LightGBM Ranking", typeof(Microsoft.ML.LightGBM.LightGbmRankingTrainer), typeof(Microsoft.ML.LightGBM.LightGbmArguments), new System.Type[] { typeof(Microsoft.ML.SignatureRankerTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Trainers.FastTree.SignatureTreeEnsembleTrainer) }, "LightGBM Ranking", new System.String[] { "LightGBMRanking", "LightGBMRank" }, DocName="trainer/LightGBM.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.LightGBM.LightGbmRankingModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "LightGBM Ranking Executor", new System.String[] { "LightGBMRankerExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("LightGBM Regression", typeof(Microsoft.ML.LightGBM.LightGbmRegressorTrainer), typeof(Microsoft.ML.LightGBM.LightGbmArguments), new System.Type[] { typeof(Microsoft.ML.SignatureRegressorTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Trainers.FastTree.SignatureTreeEnsembleTrainer) }, "LightGBM Regressor", new System.String[] { "LightGBMRegression", "LightGBMR" }, DocName="trainer/LightGBM.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.LightGBM.LightGbmRegressionModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "LightGBM Regression Executor", new System.String[] { "LightGBMRegressionExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.LightGBM.SingleTrainer), null, typeof(Microsoft.ML.LightGBM.SignatureParallelTrainer), "single", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.WantsToBeBestFriends</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.LightGBM.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.Maml" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.Maml")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TestFramework, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.Maml")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Benchmarks, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.ResultProcessor, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("A command that chains multiple other commands.", typeof(Microsoft.ML.Tools.ChainCommand), typeof(Microsoft.ML.Tools.ChainCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Chain Command", new System.String[] { "Chain" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Prints command line help.", typeof(Microsoft.ML.Tools.HelpCommand), typeof(Microsoft.ML.Tools.HelpCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "MAML Help Command", new System.String[] { "Help", "?" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Tools.XmlGenerator), typeof(Microsoft.ML.Tools.XmlGenerator/Arguments), typeof(Microsoft.ML.Tools.SignatureModuleGenerator), "Xml generator", new System.String[] { "XmlGenerator", "Xml" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Prints the TLC version.", typeof(Microsoft.ML.Tools.VersionCommand), null, typeof(Microsoft.ML.Command.SignatureCommand), "Version Command", new System.String[] { "Version" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("TLC, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.Onnx" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.Onnx")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.Onnx")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Core.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Given a data model, write out the corresponding ONNX.", typeof(Microsoft.ML.Model.Onnx.SaveOnnxCommand), typeof(Microsoft.ML.Model.Onnx.SaveOnnxCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Save ONNX", new System.String[] { "SaveOnnx" }, DocName="command/SaveOnnx.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Model.Onnx.SaveOnnxCommand), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "SaveOnnx", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.OnnxTransform" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.OnnxTransform")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.OnnxTransform")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.OnnxTransform))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Transforms the data using the Onnx model.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.OnnxTransform), typeof(Microsoft.ML.Transforms.OnnxTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "ONNX Scoring Transform", new System.String[] { "Onnx", "OnnxTransform", "OnnxScorer" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Transforms the data using the Onnx model.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.OnnxTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "ONNX Scoring Transform", new System.String[] { "OnnxTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.OnnxTransform), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "ONNX Scoring Transform", new System.String[] { "OnnxTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.OnnxTransform), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "ONNX Scoring Transform", new System.String[] { "OnnxTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.PCA" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.PCA")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.PCA")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("This algorithm trains an approximate PCA using Randomized SVD algorithm. This PCA can be made into Kernel PCA by using Random Fourier Features transform.", typeof(Microsoft.ML.Trainers.PCA.RandomizedPcaTrainer), typeof(Microsoft.ML.Trainers.PCA.RandomizedPcaTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureAnomalyDetectorTrainer), typeof(Microsoft.ML.SignatureTrainer) }, "PCA Anomaly Detector", new System.String[] { "pcaAnomaly", "pcaAnom" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.PCA.PcaModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "PCA Anomaly Executor", new System.String[] { "pcaAnomExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.PCA.RandomizedPcaTrainer), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "pcaAnomaly", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("PCA is a dimensionality-reduction transform which computes the projection of a numeric vector onto a low-rank subspace.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Projections.PcaTransform), typeof(Microsoft.ML.Transforms.Projections.PcaTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Principal Component Analysis Transform", new System.String[] { "PcaTransform", "Pca" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("PCA is a dimensionality-reduction transform which computes the projection of a numeric vector onto a low-rank subspace.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Projections.PcaTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Principal Component Analysis Transform", new System.String[] { "PcaTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("PCA is a dimensionality-reduction transform which computes the projection of a numeric vector onto a low-rank subspace.", typeof(Microsoft.ML.Transforms.Projections.PcaTransform), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Principal Component Analysis Transform", new System.String[] { "PcaTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Projections.PcaTransform), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Principal Component Analysis Transform", new System.String[] { "PcaTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Transforms.Projections.PcaTransform), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "PcaTransform", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.WantsToBeBestFriends</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.Recommender" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.Recommender")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.Recommender")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.Recommender.MatrixFactorizationPredictor), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Matrix Factorization Predictor Executor", new System.String[] { "MFPredictor" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.Recommender.MatrixFactorizationPredictionTransformer), typeof(Microsoft.ML.Trainers.Recommender.MatrixFactorizationPredictionTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "", new System.String[] { "MaFactPredXf" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("From pairs of row/column indices and a value of a matrix, this trains a predictor capable of filling in unknown entries of the matrix, using a low-rank matrix factorization. This technique is often used in recommender system, where the row and column indices indicate users and items, and the values of the matrix are ratings. ", typeof(Microsoft.ML.Trainers.MatrixFactorizationTrainer), typeof(Microsoft.ML.Trainers.MatrixFactorizationTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.SignatureMatrixRecommendingTrainer) }, "Matrix Factorization", new System.String[] { "MatrixFactorization", "libmf", "mf" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.WantsToBeBestFriends</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.ResultProcessor" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.ResultProcessor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.ResultProcessor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("TLC, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.SamplesUtils" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.SamplesUtils")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.SamplesUtils")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.StandardLearners" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.StandardLearners")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.StandardLearners")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.WantsToBeBestFriends</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.HalLearners, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Trainers.OvaModelParameters))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Train a field-aware factorization machine for binary classification", typeof(Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineTrainer), typeof(Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer) }, "Field-aware Factorization Machine", new System.String[] { "FieldAwareFactorizationMachine", "ffm" }, DocName="trainer/FactorizationMachine.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineTrainer), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "FieldAwareFactorizationMachine", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Field Aware Factorization Machine", new System.String[] { "FieldAwareFactMacPredict" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachinePredictionTransformer), typeof(Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachinePredictionTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "", new System.String[] { "FAFMPredXfer" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.IPredictorProducing`1&lt;System.Single&gt;), typeof(Microsoft.ML.Learners.LinearBinaryModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Linear Binary Executor", new System.String[] { "Linear2CExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Learners.LinearRegressionModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Linear Regression Executor", new System.String[] { "LinearRegressionExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Learners.PoissonRegressionModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Poisson Regression Executor", new System.String[] { "PoissonRegressionExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Logistic Regression is a method in statistics used to predict the probability of occurrence of an event and can be used as a classification algorithm. The algorithm predicts the probability of occurrence of an event by fitting data to a logistical function.", typeof(Microsoft.ML.Learners.LogisticRegression), typeof(Microsoft.ML.Learners.LogisticRegression/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Logistic Regression", new System.String[] { "LogisticRegression", "lr", "logisticregressionwrapper" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Learners.LogisticRegression), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "LogisticRegression", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Learners.MulticlassLogisticRegression), typeof(Microsoft.ML.Learners.MulticlassLogisticRegression/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureMultiClassClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer) }, "Multi-class Logistic Regression", new System.String[] { "MultiClassLogisticRegression", "MulticlassLogisticRegressionPredictorNew", "mlr", "multilr" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Learners.MulticlassLogisticRegressionModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Multiclass LR Executor", new System.String[] { "MultiClassLRExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Learners.LinearModelStatistics), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Linear Model Statistics", new System.String[] { "LinearModelStats" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Trains a multiclass Naive Bayes predictor that supports binary feature values.", typeof(Microsoft.ML.Trainers.MultiClassNaiveBayesTrainer), typeof(Microsoft.ML.Trainers.MultiClassNaiveBayesTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureMultiClassClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer) }, "Multiclass Naive Bayes", new System.String[] { "MultiClassNaiveBayes", "MNB" }, DocName="trainer/NaiveBayes.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.MultiClassNaiveBayesModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Multi Class Naive Bayes predictor", new System.String[] { "MultiClassNaiveBayesPred" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.MultiClassNaiveBayesTrainer), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "MultiClassNaiveBayes", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("In this strategy, a binary classification algorithm is used to train one classifier for each class, which distinguishes that class from all other classes. Prediction is then performed by running these binary classifiers, and choosing the prediction with the highest confidence score.", typeof(Microsoft.ML.Trainers.Ova), typeof(Microsoft.ML.Trainers.Ova/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureMultiClassClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer) }, "One-vs-All", new System.String[] { "OVA" }, DocName="trainer/OvaPkpd.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.OvaModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "OVA Executor", new System.String[] { "OVAExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("In this strategy, a binary classification algorithm is used to train one classifier for each pair of classes. Prediction is then performed by running these binary classifiers, and computing a score for each class by counting how many of the binary classifiers predicted it. The prediction is the class with the highest score.", typeof(Microsoft.ML.Trainers.Pkpd), typeof(Microsoft.ML.Trainers.Pkpd/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureMultiClassClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer) }, "Pairwise coupling (PKPD)", new System.String[] { "PKPD" }, DocName="trainer/OvaPkpd.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.PkpdModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "PKPD Executor", new System.String[] { "PKPDExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Averaged Perceptron Binary Classifier.", typeof(Microsoft.ML.Trainers.Online.AveragedPerceptronTrainer), typeof(Microsoft.ML.Trainers.Online.AveragedPerceptronTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Averaged Perceptron", new System.String[] { "AveragedPerceptron", "avgper", "ap" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.Online.AveragedPerceptronTrainer), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "AP", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("The idea behind support vector machines, is to map the instances into a high dimensional space in which instances of the two classes are linearly separable, i.e., there exists a hyperplane such that all the positive examples are on one side of it, and all the negative examples are on the other. After this mapping, quadratic programming is used to find the separating hyperplane that maximizes the margin, i.e., the minimal distance between it and the instances.", typeof(Microsoft.ML.Trainers.Online.LinearSvmTrainer), typeof(Microsoft.ML.Trainers.Online.LinearSvmTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "SVM (Pegasos-Linear)", new System.String[] { "LinearSVM", "svm" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.Online.LinearSvmTrainer), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "LinearSvm", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Stochastic gradient descent is an optimization method used to train a wide range of models in machine learning. In the TLC implementation of OGD, it is for linear regression.", typeof(Microsoft.ML.Trainers.Online.OnlineGradientDescentTrainer), typeof(Microsoft.ML.Trainers.Online.OnlineGradientDescentTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureRegressorTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Stochastic Gradient Descent (Regression)", new System.String[] { "OnlineGradientDescent", "ogd", "sgdr", "stochasticgradientdescentregression" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.Online.OnlineGradientDescentTrainer), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "OGD", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Poisson Regression assumes the unknown function, denoted Y has a Poisson distribution.", typeof(Microsoft.ML.Trainers.PoissonRegression), typeof(Microsoft.ML.Trainers.PoissonRegression/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureRegressorTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Poisson Regression", new System.String[] { "PoissonRegression", "PoissonRegressionNew", "Poisson", "PR" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.PoissonRegression), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "PoissonRegression", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.SdcaBinaryTrainer), typeof(Microsoft.ML.Trainers.SdcaBinaryTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Fast Linear (SA-SDCA)", new System.String[] { "SDCA", "LinearClassifier", "lc", "sasdca" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.StochasticGradientDescentClassificationTrainer), typeof(Microsoft.ML.Trainers.StochasticGradientDescentClassificationTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Hogwild SGD (binary)", new System.String[] { "BinarySGD", "sgd" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.Sdca), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "SDCA", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Trainers.StochasticGradientDescentClassificationTrainer), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "HogwildSGD", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("The SDCA linear multi-class classification trainer.", typeof(Microsoft.ML.Trainers.SdcaMultiClassTrainer), typeof(Microsoft.ML.Trainers.SdcaMultiClassTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureMultiClassClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Fast Linear Multi-class Classification (SA-SDCA)", new System.String[] { "SDCAMC", "sasdcamc" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("The SDCA linear regression trainer.", typeof(Microsoft.ML.Trainers.SdcaRegressionTrainer), typeof(Microsoft.ML.Trainers.SdcaRegressionTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureRegressorTrainer), typeof(Microsoft.ML.SignatureTrainer), typeof(Microsoft.ML.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Fast Linear Regression (SA-SDCA)", new System.String[] { "SDCAR", "sasdcar" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("A toy predictor that returns a random value.", typeof(Microsoft.ML.Trainers.RandomTrainer), typeof(Microsoft.ML.Trainers.RandomTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer) }, "Random Predictor", new System.String[] { "RandomPredictor", "random" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("A toy predictor that returns a random value.", typeof(Microsoft.ML.Trainers.PriorTrainer), typeof(Microsoft.ML.Trainers.PriorTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.SignatureTrainer) }, "Prior Predictor", new System.String[] { "PriorPredictor", "prior", "constant" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.RandomModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Random predictor", new System.String[] { "RandomPredictor" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Trainers.PriorModelParameters), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Prior predictor", new System.String[] { "PriorPredictor" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.EntryPoints, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.LightGBM, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.StaticPipe" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.StaticPipe")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.StaticPipe")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.Sweeper" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.Sweeper")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.Sweeper")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.PipelineInference, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Sweeper.RandomGridSweeper), typeof(Microsoft.ML.Sweeper.RandomGridSweeper/Arguments), typeof(Microsoft.ML.SignatureSweeper), "Random Grid Sweeper", new System.String[] { "RandomGridSweeper", "RandomGrid" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Sweeper.RandomGridSweeper), typeof(Microsoft.ML.Sweeper.RandomGridSweeper/Arguments), typeof(Microsoft.ML.Sweeper.SignatureSweeperFromParameterList), "Random Grid Sweeper", new System.String[] { "RandomGridSweeperParamList", "RandomGridpl" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Sweeper.Algorithms.KdoSweeper), typeof(Microsoft.ML.Sweeper.Algorithms.KdoSweeper/Arguments), typeof(Microsoft.ML.SignatureSweeper), "KDO Sweeper", new System.String[] { "KDOSweeper", "KDO" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Sweeper.NelderMeadSweeper), typeof(Microsoft.ML.Sweeper.NelderMeadSweeper/Arguments), typeof(Microsoft.ML.SignatureSweeper), "Nelder Mead Sweeper", new System.String[] { "NelderMeadSweeper", "NelderMead", "NM" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Sweeper.UniformRandomSweeper), typeof(Microsoft.ML.Sweeper.SweeperBase/ArgumentsBase), typeof(Microsoft.ML.SignatureSweeper), "Uniform Random Sweeper", new System.String[] { "UniformRandomSweeper", "UniformRandom" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Sweeper.UniformRandomSweeper), typeof(Microsoft.ML.Sweeper.SweeperBase/ArgumentsBase), typeof(Microsoft.ML.Sweeper.SignatureSweeperFromParameterList), "Uniform Random Sweeper", new System.String[] { "UniformRandomSweeperParamList", "UniformRandompl" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Sweeper.SmacSweeper), typeof(Microsoft.ML.Sweeper.SmacSweeper/Arguments), typeof(Microsoft.ML.SignatureSweeper), "SMAC Sweeper", new System.String[] { "SMACSweeper", "SMAC" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Sweeper.SimpleAsyncSweeper), typeof(Microsoft.ML.Sweeper.SweeperBase/ArgumentsBase), typeof(Microsoft.ML.Sweeper.SignatureAsyncSweeper), "Asynchronous Uniform Random Sweeper", new System.String[] { "UniformRandomSweeper", "UniformRandom" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Sweeper.SimpleAsyncSweeper), typeof(Microsoft.ML.Sweeper.RandomGridSweeper/Arguments), typeof(Microsoft.ML.Sweeper.SignatureAsyncSweeper), "Asynchronous Random Grid Sweeper", new System.String[] { "RandomGridSweeper", "RandomGrid" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Sweeper.DeterministicSweeperAsync), typeof(Microsoft.ML.Sweeper.DeterministicSweeperAsync/Arguments), typeof(Microsoft.ML.Sweeper.SignatureAsyncSweeper), "Asynchronous and Deterministic Sweeper", new System.String[] { "DeterministicSweeper", "Deterministic" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Sweeper.LocalExeConfigRunner), typeof(Microsoft.ML.Sweeper.LocalExeConfigRunner/Arguments), typeof(Microsoft.ML.Sweeper.SignatureConfigRunner), "Local Sweep Config Runner", new System.String[] { "Local" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Sweeper.LongValueGenerator), typeof(Microsoft.ML.Sweeper.LongParamArguments), typeof(Microsoft.ML.Sweeper.SignatureSweeperParameter), "Long parameter", new System.String[] { "lp" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Sweeper.FloatValueGenerator), typeof(Microsoft.ML.Sweeper.FloatParamArguments), typeof(Microsoft.ML.Sweeper.SignatureSweeperParameter), "Float parameter", new System.String[] { "fp" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Sweeper.DiscreteValueGenerator), typeof(Microsoft.ML.Sweeper.DiscreteParamArguments), typeof(Microsoft.ML.Sweeper.SignatureSweeperParameter), "Discrete parameter", new System.String[] { "dp" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Given a command line template and sweep ranges, creates and runs a sweep.", typeof(Microsoft.ML.Sweeper.SweepCommand), typeof(Microsoft.ML.Sweeper.SweepCommand/Arguments), typeof(Microsoft.ML.Command.SignatureCommand), "Sweep", new System.String[] { "Sweep" }, DocName="command/Sweep.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Sweeper.InternalSweepResultEvaluator), typeof(Microsoft.ML.Sweeper.InternalSweepResultEvaluator/Arguments), typeof(Microsoft.ML.SignatureSweepResultEvaluator), "TLC Sweep Result Evaluator", new System.String[] { "TlcEvaluator", "Tlc" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Sweeper.SynthConfigRunner), typeof(Microsoft.ML.Sweeper.SynthConfigRunner/Arguments), typeof(Microsoft.ML.Sweeper.SignatureConfigRunner), "", new System.String[] { "Synth" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.TensorFlow" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.TensorFlow")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.TensorFlow")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.TensorFlowTransform))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Transforms the data using the TensorFlow model.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.TensorFlowTransform), typeof(Microsoft.ML.Transforms.TensorFlowTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "TensorFlowTransform", new System.String[] { "TFTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Transforms the data using the TensorFlow model.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.TensorFlowTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "TensorFlowTransform", new System.String[] { "TensorFlowTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.TensorFlowTransform), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "TensorFlowTransform", new System.String[] { "TensorFlowTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.TensorFlowTransform), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "TensorFlowTransform", new System.String[] { "TensorFlowTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.TimeSeries" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.TimeSeries")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.TimeSeries")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.TimeSeriesProcessing.TimeSeriesProcessingEntryPoints))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.TimeSeriesProcessing.AdaptiveSingularSpectrumSequenceModeler), typeof(Microsoft.ML.TimeSeriesProcessing.AdaptiveSingularSpectrumSequenceModeler), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "SSA Sequence Modeler", new System.String[] { "SSAModel" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Applies a Exponential average on a time series.", typeof(Microsoft.ML.TimeSeriesProcessing.ExponentialAverageTransform), typeof(Microsoft.ML.TimeSeriesProcessing.ExponentialAverageTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Exponential Average Transform", new System.String[] { "ExpAverageTransform", "ExpAvg" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Applies a Exponential average on a time series.", typeof(Microsoft.ML.TimeSeriesProcessing.ExponentialAverageTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Exponential Average Transform", new System.String[] { "ExpAverageTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("This transform detects the change-points in an i.i.d. sequence using adaptive kernel density estimation and martingales.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.TimeSeriesProcessing.IidChangePointDetector), typeof(Microsoft.ML.TimeSeriesProcessing.IidChangePointDetector/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "IID Change Point Detection", new System.String[] { "IidChangePointDetector", "ichgpnt" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("This transform detects the change-points in an i.i.d. sequence using adaptive kernel density estimation and martingales.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.TimeSeriesProcessing.IidChangePointDetector), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "IID Change Point Detection", new System.String[] { "IidChangePointDetector" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("This transform detects the change-points in an i.i.d. sequence using adaptive kernel density estimation and martingales.", typeof(Microsoft.ML.TimeSeriesProcessing.IidChangePointDetector), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "IID Change Point Detection", new System.String[] { "IidChangePointDetector" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.TimeSeriesProcessing.IidChangePointDetector), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "IID Change Point Detection", new System.String[] { "IidChangePointDetector" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("This transform detects the spikes in a i.i.d. sequence using adaptive kernel density estimation.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.TimeSeriesProcessing.IidSpikeDetector), typeof(Microsoft.ML.TimeSeriesProcessing.IidSpikeDetector/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "IID Spike Detection", new System.String[] { "IidSpikeDetector", "ispike" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("This transform detects the spikes in a i.i.d. sequence using adaptive kernel density estimation.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.TimeSeriesProcessing.IidSpikeDetector), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "IID Spike Detection", new System.String[] { "IidSpikeDetector" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("This transform detects the spikes in a i.i.d. sequence using adaptive kernel density estimation.", typeof(Microsoft.ML.TimeSeriesProcessing.IidSpikeDetector), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "IID Spike Detection", new System.String[] { "IidSpikeDetector" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.TimeSeriesProcessing.IidSpikeDetector), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "IID Spike Detection", new System.String[] { "IidSpikeDetector" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Applies a moving average on a time series. Only finite values are taken into account.", typeof(Microsoft.ML.TimeSeriesProcessing.MovingAverageTransform), typeof(Microsoft.ML.TimeSeriesProcessing.MovingAverageTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Moving Average Transform", new System.String[] { "MovingAverageTransform", "MoAv" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Applies a moving average on a time series. Only finite values are taken into account.", typeof(Microsoft.ML.TimeSeriesProcessing.MovingAverageTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Moving Average Transform", new System.String[] { "MovingAverageTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Detects the values of time-series that are in the top percentile of the sliding window.", typeof(Microsoft.ML.TimeSeriesProcessing.PercentileThresholdTransform), typeof(Microsoft.ML.TimeSeriesProcessing.PercentileThresholdTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Percentile Threshold Transform", new System.String[] { "PercentThrTransform", "TopPcnt" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Detects the values of time-series that are in the top percentile of the sliding window.", typeof(Microsoft.ML.TimeSeriesProcessing.PercentileThresholdTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Percentile Threshold Transform", new System.String[] { "PercentThrTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("This P-Value transform calculates the p-value of the current input in the sequence with regard to the values in the sliding window.", typeof(Microsoft.ML.TimeSeriesProcessing.PValueTransform), typeof(Microsoft.ML.TimeSeriesProcessing.PValueTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "p-Value Transform", new System.String[] { "PValueTransform", "PVal" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("This P-Value transform calculates the p-value of the current input in the sequence with regard to the values in the sliding window.", typeof(Microsoft.ML.TimeSeriesProcessing.PValueTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "p-Value Transform", new System.String[] { "PValueTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Returns the last values for a time series [y(t-d-l+1), y(t-d-l+2), ..., y(t-l-1), y(t-l)] where d is the size of the window, l the lag and y is a Float.", typeof(Microsoft.ML.TimeSeriesProcessing.SlidingWindowTransform), typeof(Microsoft.ML.TimeSeriesProcessing.SlidingWindowTransformBase`1/Arguments&lt;System.Single&gt;), typeof(Microsoft.ML.Data.SignatureDataTransform), "Sliding Window Transform", new System.String[] { "SlideWinTransform", "SlideWin" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Returns the last values for a time series [y(t-d-l+1), y(t-d-l+2), ..., y(t-l-1), y(t-l)] where d is the size of the window, l the lag and y is a Float.", typeof(Microsoft.ML.TimeSeriesProcessing.SlidingWindowTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Sliding Window Transform", new System.String[] { "SlideWinTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("This transform detects the change-points in a seasonal time-series using Singular Spectrum Analysis (SSA).", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.TimeSeriesProcessing.SsaChangePointDetector), typeof(Microsoft.ML.TimeSeriesProcessing.SsaChangePointDetector/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "SSA Change Point Detection", new System.String[] { "SsaChangePointDetector", "chgpnt" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("This transform detects the change-points in a seasonal time-series using Singular Spectrum Analysis (SSA).", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.TimeSeriesProcessing.SsaChangePointDetector), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "SSA Change Point Detection", new System.String[] { "SsaChangePointDetector" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("This transform detects the change-points in a seasonal time-series using Singular Spectrum Analysis (SSA).", typeof(Microsoft.ML.TimeSeriesProcessing.SsaChangePointDetector), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "SSA Change Point Detection", new System.String[] { "SsaChangePointDetector" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.TimeSeriesProcessing.SsaChangePointDetector), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "SSA Change Point Detection", new System.String[] { "SsaChangePointDetector" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("This transform detects the spikes in a seasonal time-series using Singular Spectrum Analysis (SSA).", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.TimeSeriesProcessing.SsaSpikeDetector), typeof(Microsoft.ML.TimeSeriesProcessing.SsaSpikeDetector/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "SSA Spike Detection", new System.String[] { "SsaSpikeDetector", "spike" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("This transform detects the spikes in a seasonal time-series using Singular Spectrum Analysis (SSA).", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.TimeSeriesProcessing.SsaSpikeDetector), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "SSA Spike Detection", new System.String[] { "SsaSpikeDetector" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("This transform detects the spikes in a seasonal time-series using Singular Spectrum Analysis (SSA).", typeof(Microsoft.ML.TimeSeriesProcessing.SsaSpikeDetector), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "SSA Spike Detection", new System.String[] { "SsaSpikeDetector" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.TimeSeriesProcessing.SsaSpikeDetector), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "SSA Spike Detection", new System.String[] { "SsaSpikeDetector" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.Transforms" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.Transforms")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.Transforms")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.BootstrapSample))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.Projections.LpNormalization))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.GroupingOperations))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.Conversions.HashJoin))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.NAHandling))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.OptionalColumnTransform))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.Text.PredefinedStopWordsRemoverFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.Text.CustomStopWordsRemovingTransform/LoaderArguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.Text.NgramExtractorTransform/NgramExtractorArguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.Text.NgramHashExtractingTransformer/NgramHashExtractorArguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Approximate bootstrap sampling.", typeof(Microsoft.ML.Transforms.BootstrapSamplingTransformer), typeof(Microsoft.ML.Transforms.BootstrapSamplingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Bootstrap Sample Transform", new System.String[] { "BootstrapSampleTransform", "BootstrapSample" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Approximate bootstrap sampling.", typeof(Microsoft.ML.Transforms.BootstrapSamplingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Bootstrap Sample Transform", new System.String[] { "BootstrapSampleTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.CompositeTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Composite Transform", new System.String[] { "CompositeRowFunction" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Selects the slots for which the count of non-default values is greater than or equal to a threshold.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.FeatureSelection.CountFeatureSelectingEstimator), typeof(Microsoft.ML.Transforms.FeatureSelection.CountFeatureSelectingEstimator/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Count Feature Selection Transform", new System.String[] { "CountFeatureSelectionTransform", "CountFeatureSelection" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Transforms.SelectFeatures), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "SelectFeatures", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Transforms.Text.TextAnalytics), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "TextAnalytics", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.GaussianFourierSampler), typeof(Microsoft.ML.Transforms.GaussianFourierSampler/Arguments), typeof(Microsoft.ML.Transforms.SignatureFourierDistributionSampler), "Gaussian Kernel", new System.String[] { "GaussianRandom", "Gaussian" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.LaplacianFourierSampler), typeof(Microsoft.ML.Transforms.LaplacianFourierSampler/Arguments), typeof(Microsoft.ML.Transforms.SignatureFourierDistributionSampler), "Laplacian Kernel", new System.String[] { "LaplacianRandom", "Laplacian" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.GaussianFourierSampler), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Gaussian Fourier Sampler Executor", new System.String[] { "GaussianSamplerExecutor", "RandGaussFourierExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.LaplacianFourierSampler), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Laplacian Fourier Sampler Executor", new System.String[] { "LaplacianSamplerExecutor", "RandLaplacianFourierExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Performs a global contrast normalization on input values: Y = (s * X - M) / D, where s is a scale, M is mean and D is either L2 norm or standard deviation.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Projections.LpNormalizingTransformer), typeof(Microsoft.ML.Transforms.Projections.LpNormalizingTransformer/GcnArguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Global Contrast Normalization Transform", new System.String[] { "GcnTransform", "Gcn" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Performs a global contrast normalization on input values: Y = (s * X - M) / D, where s is a scale, M is mean and D is either L2 norm or standard deviation.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Projections.LpNormalizingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Global Contrast Normalization Transform", new System.String[] { "GcnTransform", "GcnFunction" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Normalize vectors (rows) individually by rescaling them to unit norm (L2, L1 or LInf). Performs the following operation on a vector X: Y = (X - M) / D, where M is mean and D is either L2 norm, L1 norm or LInf norm.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Projections.LpNormalizingTransformer), typeof(Microsoft.ML.Transforms.Projections.LpNormalizingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Lp-Norm Normalizer", new System.String[] { "LpNormNormalizer", "lpnorm" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Normalize vectors (rows) individually by rescaling them to unit norm (L2, L1 or LInf). Performs the following operation on a vector X: Y = (X - M) / D, where M is mean and D is either L2 norm, L1 norm or LInf norm.", typeof(Microsoft.ML.Transforms.Projections.LpNormalizingTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Global Contrast Normalization Transform", new System.String[] { "GcnTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Projections.LpNormalizingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Global Contrast Normalization Transform", new System.String[] { "GcnTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Groups values of a scalar column into a vector, by a contiguous group ID", typeof(Microsoft.ML.Transforms.GroupTransform), typeof(Microsoft.ML.Transforms.GroupTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Group Transform", new System.String[] { "Group" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Groups values of a scalar column into a vector, by a contiguous group ID", typeof(Microsoft.ML.Transforms.GroupTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Group Transform", new System.String[] { "GroupTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Converts column values into hashes. This transform accepts both numeric and text inputs, both single and vector-valued columns. ", typeof(Microsoft.ML.Transforms.Conversions.HashJoiningTransform), typeof(Microsoft.ML.Transforms.Conversions.HashJoiningTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Hash Join Transform", new System.String[] { "HashJoinTransform", "HashJoin" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Converts column values into hashes. This transform accepts both numeric and text inputs, both single and vector-valued columns. ", typeof(Microsoft.ML.Transforms.Conversions.HashJoiningTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Hash Join Transform", new System.String[] { "HashJoinTransform", "HashJoinFunction" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Converts a key column to a binary encoded vector.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Conversions.KeyToBinaryVectorMappingTransformer), typeof(Microsoft.ML.Transforms.Conversions.KeyToBinaryVectorMappingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Key To Binary Vector Transform", new System.String[] { "KeyToBinaryVectorTransform", "KeyToBinary", "ToBinaryVector" }, DocName="transform/KeyToBinaryVectorTransform.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Converts a key column to a binary encoded vector.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Conversions.KeyToBinaryVectorMappingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Key To Binary Vector Transform", new System.String[] { "KeyToBinaryTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Converts a key column to a binary encoded vector.", typeof(Microsoft.ML.Transforms.Conversions.KeyToBinaryVectorMappingTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "KeyToBinaryVectorTransform", new System.String[] { "KeyToBinaryTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Conversions.KeyToBinaryVectorMappingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "KeyToBinaryVectorTransform", new System.String[] { "KeyToBinaryTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Core.Data.ITransformer), typeof(Microsoft.ML.Transforms.LambdaTransform), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "", new System.String[] { "CustomTransformer" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Selects the slots for which the absolute value of the corresponding weight in a linear learner is greater than a threshold.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.LearnerFeatureSelectionTransform), typeof(Microsoft.ML.Transforms.LearnerFeatureSelectionTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Learner Feature Selection Transform", new System.String[] { "LearnerFeatureSelectionTransform", "LearnerFeatureSelection" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Loads specified transforms from the model file and applies them to current data.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.LoadTransform), typeof(Microsoft.ML.Transforms.LoadTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Load Transform", new System.String[] { "LoadTransform", "Load" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Removes NAs from vector columns.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.MissingValueDroppingTransformer), typeof(Microsoft.ML.Transforms.MissingValueDroppingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "NA Drop Transform", new System.String[] { "NADrop", "NADropTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Removes NAs from vector columns.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.MissingValueDroppingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "NA Drop Transform", new System.String[] { "NADropTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Removes NAs from vector columns.", typeof(Microsoft.ML.Transforms.MissingValueDroppingTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "NA Drop Transform", new System.String[] { "NADropTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.MissingValueDroppingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "NA Drop Transform", new System.String[] { "NADropTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Handle missing values by replacing them with either the default value or the mean/min/max value (for non-text columns only). An indicator column can optionally be concatenated, if theinput column type is numeric.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.MissingValueHandlingTransformer), typeof(Microsoft.ML.Transforms.MissingValueHandlingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "NA Handle Transform", new System.String[] { "NAHandleTransform", "NAHandle", "NA" }, DocName="transform/NAHandle.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.MissingValueIndicatorTransform), typeof(Microsoft.ML.Transforms.MissingValueIndicatorTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "", new System.String[] { "MissingValueIndicatorTransform", "MissingValueTransform", "MissingTransform", "Missing" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.MissingValueIndicatorTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Missing Value Indicator Transform", new System.String[] { "MissingIndicatorFunction", "MissingFeatureFunction" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Create a boolean output column with the same number of slots as the input column, where the output value is true if the value in the input column is missing.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.MissingValueIndicatorTransformer), typeof(Microsoft.ML.Transforms.MissingValueIndicatorTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "NA Indicator Transform", new System.String[] { "NaIndicatorTransform", "NAIndicator", "NAInd" }, DocName="transform/NAHandle.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Create a boolean output column with the same number of slots as the input column, where the output value is true if the value in the input column is missing.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.MissingValueIndicatorTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "NA Indicator Transform", new System.String[] { "NaIndicatorTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Create a boolean output column with the same number of slots as the input column, where the output value is true if the value in the input column is missing.", typeof(Microsoft.ML.Transforms.MissingValueIndicatorTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "NA Indicator Transform", new System.String[] { "NaIndicatorTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.MissingValueIndicatorTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "NA Indicator Transform", new System.String[] { "NaIndicatorTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Create an output column of the same type and size of the input column, where missing values are replaced with either the default value or the mean/min/max value (for non-text columns only).", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.MissingValueReplacingTransformer), typeof(Microsoft.ML.Transforms.MissingValueReplacingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "NA Replace Transform", new System.String[] { "NAReplaceTransform", "NAReplace", "NARep" }, DocName="transform/NAHandle.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Create an output column of the same type and size of the input column, where missing values are replaced with either the default value or the mean/min/max value (for non-text columns only).", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.MissingValueReplacingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "NA Replace Transform", new System.String[] { "NAReplaceTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Create an output column of the same type and size of the input column, where missing values are replaced with either the default value or the mean/min/max value (for non-text columns only).", typeof(Microsoft.ML.Transforms.MissingValueReplacingTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "NA Replace Transform", new System.String[] { "NAReplaceTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.MissingValueReplacingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "NA Replace Transform", new System.String[] { "NAReplaceTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Selects the top k slots across all specified columns ordered by their mutual information with the label column.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.FeatureSelection.MutualInformationFeatureSelectingEstimator), typeof(Microsoft.ML.Transforms.FeatureSelection.MutualInformationFeatureSelectingEstimator/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Mutual Information Feature Selection Transform", new System.String[] { "MutualInformationFeatureSelection", "MutualInformationFeatureSelectionTransform", "MIFeatureSelection" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Converts the categorical value into an indicator array by building a dictionary of categories based on the data and using the id in the dictionary as the index in the array.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Categorical.OneHotEncodingTransformer), typeof(Microsoft.ML.Transforms.Categorical.OneHotEncodingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Categorical Transform", new System.String[] { "CategoricalTransform", "CatTransform", "Categorical", "Cat" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Transforms.Categorical.Categorical), null, typeof(Microsoft.ML.EntryPoints.SignatureEntryPointModule), "Categorical", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Converts the categorical value into an indicator array by hashing the value and using the hash as an index in the bag. If the input column is a vector, a single indicator bag is returned for it.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Categorical.OneHotHashEncoding), typeof(Microsoft.ML.Transforms.Categorical.OneHotHashEncoding/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Categorical Hash Transform", new System.String[] { "CategoricalHashTransform", "CatHashTransform", "CategoricalHash", "CatHash" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("If the source column does not exist after deserialization, create a column with the right type and default values.", typeof(Microsoft.ML.Transforms.OptionalColumnTransform), typeof(Microsoft.ML.Transforms.OptionalColumnTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Optional Column Transform", new System.String[] { "OptColTransform", "optional" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.OptionalColumnTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Optional Column Transform", new System.String[] { "OptColTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Produces a new column with the row ID.", typeof(Microsoft.ML.Transforms.ProduceIdTransform), typeof(Microsoft.ML.Transforms.ProduceIdTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "", new System.String[] { "ProduceIdTransform", "ProduceId" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Produces a new column with the row ID.", typeof(Microsoft.ML.Transforms.ProduceIdTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Produce ID Transform", new System.String[] { "ProduceIdTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("This transform maps numeric vectors to a random low-dimensional feature space. It is useful when data has non-linear features, since the transform is designed so that the inner products of the transformed data are approximately equal to those in the feature space of a user specified shift-invariant kernel.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Projections.RandomFourierFeaturizingTransformer), typeof(Microsoft.ML.Transforms.Projections.RandomFourierFeaturizingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Random Fourier Features Transform", new System.String[] { "RffTransform", "Rff" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("This transform maps numeric vectors to a random low-dimensional feature space. It is useful when data has non-linear features, since the transform is designed so that the inner products of the transformed data are approximately equal to those in the feature space of a user specified shift-invariant kernel.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Projections.RandomFourierFeaturizingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Random Fourier Features Transform", new System.String[] { "RffTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("This transform maps numeric vectors to a random low-dimensional feature space. It is useful when data has non-linear features, since the transform is designed so that the inner products of the transformed data are approximately equal to those in the feature space of a user specified shift-invariant kernel.", typeof(Microsoft.ML.Transforms.Projections.RandomFourierFeaturizingTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Random Fourier Features Transform", new System.String[] { "RffTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Projections.RandomFourierFeaturizingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Random Fourier Features Transform", new System.String[] { "RffTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Allows the definition of convenient user defined transforms", typeof(Microsoft.ML.Data.ITransformTemplate), typeof(Microsoft.ML.Transforms.SerializableLambdaTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "", new System.String[] { "UserLambdaMapTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("The LDA transform implements LightLDA, a state-of-the-art implementation of Latent Dirichlet Allocation.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.LatentDirichletAllocationTransformer), typeof(Microsoft.ML.Transforms.Text.LatentDirichletAllocationTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Latent Dirichlet Allocation Transform", new System.String[] { "LdaTransform", "Lda" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("The LDA transform implements LightLDA, a state-of-the-art implementation of Latent Dirichlet Allocation.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.LatentDirichletAllocationTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Latent Dirichlet Allocation Transform", new System.String[] { "LdaTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("The LDA transform implements LightLDA, a state-of-the-art implementation of Latent Dirichlet Allocation.", typeof(Microsoft.ML.Transforms.Text.LatentDirichletAllocationTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Latent Dirichlet Allocation Transform", new System.String[] { "LdaTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Text.LatentDirichletAllocationTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Latent Dirichlet Allocation Transform", new System.String[] { "LdaTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Produces a bag of counts of ngrams (sequences of consecutive values of length 1-n) in a given vector of keys. It does so by hashing each ngram and using the hash value as the index in the bag.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.NgramHashingTransformer), typeof(Microsoft.ML.Transforms.Text.NgramHashingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Ngram Hash Transform", new System.String[] { "NgramHashTransform", "NgramHash" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Produces a bag of counts of ngrams (sequences of consecutive values of length 1-n) in a given vector of keys. It does so by hashing each ngram and using the hash value as the index in the bag.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.NgramHashingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Ngram Hash Transform", new System.String[] { "NgramHashTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Produces a bag of counts of ngrams (sequences of consecutive values of length 1-n) in a given vector of keys. It does so by hashing each ngram and using the hash value as the index in the bag.", typeof(Microsoft.ML.Transforms.Text.NgramHashingTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Ngram Hash Transform", new System.String[] { "NgramHashTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Text.NgramHashingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Ngram Hash Transform", new System.String[] { "NgramHashTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Produces a bag of counts of ngrams (sequences of consecutive values of length 1-n) in a given vector of keys. It does so by building a dictionary of ngrams and using the id in the dictionary as the index in the bag.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.NgramExtractingTransformer), typeof(Microsoft.ML.Transforms.Text.NgramExtractingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Ngram Transform", new System.String[] { "NgramTransform", "Ngram" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Produces a bag of counts of ngrams (sequences of consecutive values of length 1-n) in a given vector of keys. It does so by building a dictionary of ngrams and using the id in the dictionary as the index in the bag.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.NgramExtractingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Ngram Transform", new System.String[] { "NgramTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Produces a bag of counts of ngrams (sequences of consecutive values of length 1-n) in a given vector of keys. It does so by building a dictionary of ngrams and using the id in the dictionary as the index in the bag.", typeof(Microsoft.ML.Transforms.Text.NgramExtractingTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Ngram Transform", new System.String[] { "NgramTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Text.NgramExtractingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Ngram Transform", new System.String[] { "NgramTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("A transform that turns a collection of text documents into numerical feature vectors. The feature vectors are normalized counts of (word and/or character) ngrams in a given tokenized text.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.SentimentAnalyzingTransformer), typeof(Microsoft.ML.Transforms.Text.SentimentAnalyzingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Sentiment Analyzing Transform", new System.String[] { "SentimentAnalyzingTransform", "SentimentAnalyzer", "Senti" }, DocName="transform/SentimentAnalyzingTransform.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("A Stopword remover transform based on language-specific lists of stop words (most common words) from Office Named Entity Recognition project. The transform is usually applied after tokenizing text, so it compares individual tokens (case-insensitive comparison) to the stopwords.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.StopWordsRemovingTransformer), typeof(Microsoft.ML.Transforms.Text.StopWordsRemovingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Stopwords Remover Transform", new System.String[] { "StopWordsRemoverTransform", "StopWordsRemover", "StopWords" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("A Stopword remover transform based on language-specific lists of stop words (most common words) from Office Named Entity Recognition project. The transform is usually applied after tokenizing text, so it compares individual tokens (case-insensitive comparison) to the stopwords.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.StopWordsRemovingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Stopwords Remover Transform", new System.String[] { "StopWordsTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("A Stopword remover transform based on language-specific lists of stop words (most common words) from Office Named Entity Recognition project. The transform is usually applied after tokenizing text, so it compares individual tokens (case-insensitive comparison) to the stopwords.", typeof(Microsoft.ML.Transforms.Text.StopWordsRemovingTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Stopwords Remover Transform", new System.String[] { "StopWordsTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Text.StopWordsRemovingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Stopwords Remover Transform", new System.String[] { "StopWordsTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("A Stopword remover transform based on a user-defined list of stopwords. The transform is usually applied after tokenizing text, so it compares individual tokens (case-insensitive comparison) to the stopwords.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.CustomStopWordsRemovingTransform), typeof(Microsoft.ML.Transforms.Text.CustomStopWordsRemovingTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Custom Stopwords Remover Transform", new System.String[] { "CustomStopWordsRemoverTransform", "CustomStopWords" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("A Stopword remover transform based on a user-defined list of stopwords. The transform is usually applied after tokenizing text, so it compares individual tokens (case-insensitive comparison) to the stopwords.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.CustomStopWordsRemovingTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Custom Stopwords Remover Transform", new System.String[] { "CustomStopWords" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("A Stopword remover transform based on a user-defined list of stopwords. The transform is usually applied after tokenizing text, so it compares individual tokens (case-insensitive comparison) to the stopwords.", typeof(Microsoft.ML.Transforms.Text.CustomStopWordsRemovingTransform), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Custom Stopwords Remover Transform", new System.String[] { "CustomStopWords" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Text.CustomStopWordsRemovingTransform), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Custom Stopwords Remover Transform", new System.String[] { "CustomStopWords" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("A transform that turns a collection of text documents into numerical feature vectors. The feature vectors are normalized counts of (word and/or character) ngrams in a given tokenized text.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.TextFeaturizingEstimator), typeof(Microsoft.ML.Transforms.Text.TextFeaturizingEstimator/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Text Transform", new System.String[] { "TextTransform", "Text" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("A transform that turns a collection of text documents into numerical feature vectors. The feature vectors are normalized counts of (word and/or character) ngrams in a given tokenized text.", typeof(Microsoft.ML.Core.Data.ITransformer), typeof(Microsoft.ML.Transforms.Text.TextFeaturizingEstimator), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Text Transform", new System.String[] { "TextTransform", "Text" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("A text normalization transform that allows normalizing text case, removing diacritical marks, punctuation marks and/or numbers. The transform operates on text input as well as vector of tokens/text (vector of ReadOnlyMemory).", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.TextNormalizingTransformer), typeof(Microsoft.ML.Transforms.Text.TextNormalizingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Text Normalizer Transform", new System.String[] { "TextNormalizerTransform", "TextNormalizer", "TextNorm" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("A text normalization transform that allows normalizing text case, removing diacritical marks, punctuation marks and/or numbers. The transform operates on text input as well as vector of tokens/text (vector of ReadOnlyMemory).", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.TextNormalizingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Text Normalizer Transform", new System.String[] { "TextNormalizerTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("A text normalization transform that allows normalizing text case, removing diacritical marks, punctuation marks and/or numbers. The transform operates on text input as well as vector of tokens/text (vector of ReadOnlyMemory).", typeof(Microsoft.ML.Transforms.Text.TextNormalizingTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Text Normalizer Transform", new System.String[] { "TextNormalizerTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Text.TextNormalizingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Text Normalizer Transform", new System.String[] { "TextNormalizerTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Character-oriented tokenizer where text is considered a sequence of characters.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.TokenizingByCharactersTransformer), typeof(Microsoft.ML.Transforms.Text.TokenizingByCharactersTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Character Tokenizer Transform", new System.String[] { "CharTokenize", "CharToken" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.TokenizingByCharactersTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Character Tokenizer Transform", new System.String[] { "CharToken" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Character-oriented tokenizer where text is considered a sequence of characters.", typeof(Microsoft.ML.Transforms.Text.TokenizingByCharactersTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Character Tokenizer Transform", new System.String[] { "CharToken" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Text.TokenizingByCharactersTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Character Tokenizer Transform", new System.String[] { "CharToken" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Produces a bag of counts of ngrams (sequences of consecutive words of length 1-n) in a given text. It does so by building a dictionary of ngrams and using the id in the dictionary as the index in the bag.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.WordBagBuildingTransformer), typeof(Microsoft.ML.Transforms.Text.WordBagBuildingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Word Bag Transform", new System.String[] { "WordBagTransform", "WordBag" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("A transform that turns a collection of tokenized text ReadOnlyMemory, or vectors of keys into numerical feature vectors. The feature vectors are counts of ngrams (sequences of consecutive *tokens* -words or keys- of length 1-n).", typeof(Microsoft.ML.Transforms.Text.INgramExtractorFactory), typeof(Microsoft.ML.Transforms.Text.NgramExtractorTransform), typeof(Microsoft.ML.Transforms.Text.NgramExtractorTransform/NgramExtractorArguments), typeof(Microsoft.ML.Transforms.Text.SignatureNgramExtractorFactory), "Ngram Extractor Transform", new System.String[] { "NgramExtractorTransform", "Ngram", "NgramExtractor" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Word Embeddings transform is a text featurizer which converts vectors of text tokens into sentence vectors using a pre-trained model", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer), typeof(Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Word Embeddings Transform", new System.String[] { "WordEmbeddingsTransform", "WordEmbeddings" }, DocName="transform/WordEmbeddingsTransform.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Word Embeddings transform is a text featurizer which converts vectors of text tokens into sentence vectors using a pre-trained model", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Word Embeddings Transform", new System.String[] { "WordEmbeddingsTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Word Embeddings Transform", new System.String[] { "WordEmbeddingsTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Word Embeddings Transform", new System.String[] { "WordEmbeddingsTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Produces a bag of counts of ngrams (sequences of consecutive words of length 1-n) in a given text. It does so by hashing each ngram and using the hash value as the index in the bag.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.WordHashBagProducingTransformer), typeof(Microsoft.ML.Transforms.Text.WordHashBagProducingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Word Hash Bag Transform", new System.String[] { "WordHashBagTransform", "WordHashBag" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("A transform that turns a collection of tokenized text (vector of ReadOnlyMemory) into numerical feature vectors using the hashing trick.", typeof(Microsoft.ML.Transforms.Text.INgramExtractorFactory), typeof(Microsoft.ML.Transforms.Text.NgramHashExtractingTransformer), typeof(Microsoft.ML.Transforms.Text.NgramHashExtractingTransformer/NgramHashExtractorArguments), typeof(Microsoft.ML.Transforms.Text.SignatureNgramExtractorFactory), "Ngram Hash Extractor Transform", new System.String[] { "NgramHashExtractorTransform", "NgramHash", "NgramHashExtractor" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("The input to this transform is text, and the output is a vector of text containing the words (tokens) in the original text. The separator is space, but can be specified as any other character (or multiple characters) if needed.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.WordTokenizingTransformer), typeof(Microsoft.ML.Transforms.Text.WordTokenizingTransformer/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Word Tokenizer Transform", new System.String[] { "WordTokenizeTransform", "DelimitedTokenizeTransform", "WordToken", "DelimitedTokenize", "Token" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("The input to this transform is text, and the output is a vector of text containing the words (tokens) in the original text. The separator is space, but can be specified as any other character (or multiple characters) if needed.", typeof(Microsoft.ML.Data.IDataTransform), typeof(Microsoft.ML.Transforms.Text.WordTokenizingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Word Tokenizer Transform", new System.String[] { "TokenizeTextTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("The input to this transform is text, and the output is a vector of text containing the words (tokens) in the original text. The separator is space, but can be specified as any other character (or multiple characters) if needed.", typeof(Microsoft.ML.Transforms.Text.WordTokenizingTransformer), null, typeof(Microsoft.ML.Model.SignatureLoadModel), "Word Tokenizer Transform", new System.String[] { "TokenizeTextTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass(typeof(Microsoft.ML.Data.IRowMapper), typeof(Microsoft.ML.Transforms.Text.WordTokenizingTransformer), null, typeof(Microsoft.ML.Data.SignatureLoadRowMapper), "Word Tokenizer Transform", new System.String[] { "TokenizeTextTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Un-groups vector columns into sequences of rows, inverse of Group transform", typeof(Microsoft.ML.Transforms.UngroupTransform), typeof(Microsoft.ML.Transforms.UngroupTransform/Arguments), typeof(Microsoft.ML.Data.SignatureDataTransform), "Un-group Transform", new System.String[] { "Ungroup" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.LoadableClass("Un-groups vector columns into sequences of rows, inverse of Group transform", typeof(Microsoft.ML.Transforms.UngroupTransform), null, typeof(Microsoft.ML.Data.SignatureLoadDataTransform), "Un-group Transform", new System.String[] { "UngroupTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.WantsToBeBestFriends</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.9.27308.8")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.9.27308.8 @BuiltBy: dlab14-DDVSOWINAGE084 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/941d9fc2af04da08c3d430a018b553225777db4a+941d9fc2af04da08c3d430a018b553225777db4a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StaticPipe, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RunTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.NeuralNetworks, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.RServerScoring.NeuralNetworks, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Runtime.TextAnalytics, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.RServerScoring.TextAnalytics, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
  </Assemblies>
  <Remarks>To be added.</Remarks>
  <Copyright>To be added.</Copyright>
  <Types>
    <Namespace Name="LotusIR">
    </Namespace>
    <Namespace Name="Microsoft.ML">
      <Type Name="BinaryClassificationContext" Kind="Class" />
      <Type Name="BinaryClassificationContext+BinaryClassificationTrainers" Kind="Class" />
      <Type Name="BinaryClassificationMetricsStatistics" Kind="Class" />
      <Type Name="BinaryLoaderSaverCatalog" Kind="Class" />
      <Type Name="CategoricalCatalog" Kind="Class" />
      <Type Name="ChannelMessage" Kind="Structure" />
      <Type Name="ChannelMessageKind" Kind="Enumeration" />
      <Type Name="ClusteringContext" Kind="Class" />
      <Type Name="ClusteringContext+ClusteringTrainers" Kind="Class" />
      <Type Name="ComponentCatalog" Kind="Class" />
      <Type Name="ConversionsCatalog" Kind="Class" />
      <Type Name="ConversionsExtensionsCatalog" Kind="Class" />
      <Type Name="CustomMappingCatalog" Kind="Class" />
      <Type Name="DataOperations" Kind="Class" />
      <Type Name="DebuggerExtensions" Kind="Class" />
      <Type Name="ExplainabilityCatalog" Kind="Class" />
      <Type Name="ExpLoss" Kind="Class" />
      <Type Name="ExpLoss+Arguments" Kind="Class" />
      <Type Name="ExtensionsCatalog" Kind="Class" />
      <Type Name="FactorizationMachineExtensions" Kind="Class" />
      <Type Name="FeatureSelectionCatalog" Kind="Class" />
      <Type Name="HalLearnersCatalog" Kind="Class" />
      <Type Name="HingeLoss" Kind="Class" />
      <Type Name="HingeLoss+Arguments" Kind="Class" />
      <Type Name="IChannel" Kind="Interface" />
      <Type Name="IChannelProvider" Kind="Interface" />
      <Type Name="IClassificationLoss" Kind="Interface" />
      <Type Name="IComponentFactory" Kind="Interface" />
      <Type Name="IComponentFactory`1" DisplayName="IComponentFactory&lt;TComponent&gt;" Kind="Interface" />
      <Type Name="IComponentFactory`2" DisplayName="IComponentFactory&lt;TArg1,TComponent&gt;" Kind="Interface" />
      <Type Name="IComponentFactory`3" DisplayName="IComponentFactory&lt;TArg1,TArg2,TComponent&gt;" Kind="Interface" />
      <Type Name="IComponentFactory`4" DisplayName="IComponentFactory&lt;TArg1,TArg2,TArg3,TComponent&gt;" Kind="Interface" />
      <Type Name="IDistPredictorProducing`2" DisplayName="IDistPredictorProducing&lt;TResult,TResultDistribution&gt;" Kind="Interface" />
      <Type Name="IExceptionContext" Kind="Interface" />
      <Type Name="IFileHandle" Kind="Interface" />
      <Type Name="IHost" Kind="Interface" />
      <Type Name="IHostEnvironment" Kind="Interface" />
      <Type Name="ILossFunction`2" DisplayName="ILossFunction&lt;TOutput,TLabel&gt;" Kind="Interface" />
      <Type Name="ImageEstimatorsCatalog" Kind="Class" />
      <Type Name="IParameterValue" Kind="Interface" />
      <Type Name="IParameterValue`1" DisplayName="IParameterValue&lt;TValue&gt;" Kind="Interface" />
      <Type Name="IPipe`1" DisplayName="IPipe&lt;TMessage&gt;" Kind="Interface" />
      <Type Name="IPredictionTransformer`1" DisplayName="IPredictionTransformer&lt;TModel&gt;" Kind="Interface" />
      <Type Name="IPredictor" Kind="Interface" />
      <Type Name="IPredictor`2" DisplayName="IPredictor&lt;TFeatures,TResult&gt;" Kind="Interface" />
      <Type Name="IPredictorProducing`1" DisplayName="IPredictorProducing&lt;TResult&gt;" Kind="Interface" />
      <Type Name="IProgressChannel" Kind="Interface" />
      <Type Name="IProgressChannelProvider" Kind="Interface" />
      <Type Name="IProgressEntry" Kind="Interface" />
      <Type Name="IRegressionLoss" Kind="Interface" />
      <Type Name="IRunResult" Kind="Interface" />
      <Type Name="IRunResult`1" DisplayName="IRunResult&lt;T&gt;" Kind="Interface" />
      <Type Name="IScalarOutputLoss" Kind="Interface" />
      <Type Name="ISingleFeaturePredictionTransformer`1" DisplayName="ISingleFeaturePredictionTransformer&lt;TModel&gt;" Kind="Interface" />
      <Type Name="ISupportClassificationLossFactory" Kind="Interface" />
      <Type Name="ISupportRegressionLossFactory" Kind="Interface" />
      <Type Name="ISupportSdcaClassificationLoss" Kind="Interface" />
      <Type Name="ISupportSdcaClassificationLossFactory" Kind="Interface" />
      <Type Name="ISupportSdcaLoss" Kind="Interface" />
      <Type Name="ISupportSdcaRegressionLoss" Kind="Interface" />
      <Type Name="ISupportSdcaRegressionLossFactory" Kind="Interface" />
      <Type Name="ISweeper" Kind="Interface" />
      <Type Name="ISweepResultEvaluator`1" DisplayName="ISweepResultEvaluator&lt;TResults&gt;" Kind="Interface" />
      <Type Name="IValueGenerator" Kind="Interface" />
      <Type Name="KMeansClusteringExtensions" Kind="Class" />
      <Type Name="LearningPipelineExtensions" Kind="Class" />
      <Type Name="LightGbmExtensions" Kind="Class" />
      <Type Name="LogLoss" Kind="Class" />
      <Type Name="LogLossFactory" Kind="Class" />
      <Type Name="MessageSensitivity" Kind="Enumeration" />
      <Type Name="MetricsStatisticsBase`1" DisplayName="MetricsStatisticsBase&lt;T&gt;" Kind="Class" />
      <Type Name="MetricStatistics" Kind="Class" />
      <Type Name="MLContext" Kind="Class" />
      <Type Name="ModelOperationsCatalog" Kind="Class" />
      <Type Name="ModelOperationsCatalog+ExplainabilityTransforms" Kind="Class" />
      <Type Name="ModelOperationsCatalog+SubCatalogBase" Kind="Class" />
      <Type Name="MulticlassClassificationContext" Kind="Class" />
      <Type Name="MulticlassClassificationContext+MulticlassClassificationTrainers" Kind="Class" />
      <Type Name="MultiClassClassifierMetricsStatistics" Kind="Class" />
      <Type Name="NormalizerCatalog" Kind="Class" />
      <Type Name="OnnxCatalog" Kind="Class" />
      <Type Name="OnnxExportExtensions" Kind="Class" />
      <Type Name="ParameterSet" Kind="Class" />
      <Type Name="PcaCatalog" Kind="Class" />
      <Type Name="PermutationFeatureImportanceExtensions" Kind="Class" />
      <Type Name="PoissonLoss" Kind="Class" />
      <Type Name="PoissonLossFactory" Kind="Class" />
      <Type Name="PredictionEngine`2" DisplayName="PredictionEngine&lt;TSrc,TDst&gt;" Kind="Class" />
      <Type Name="PredictionEngineBase`2" DisplayName="PredictionEngineBase&lt;TSrc,TDst&gt;" Kind="Class" />
      <Type Name="PredictionEngineExtensions" Kind="Class" />
      <Type Name="PredictionKind" Kind="Enumeration" />
      <Type Name="ProgressHeader" Kind="Class" />
      <Type Name="ProjectionCatalog" Kind="Class" />
      <Type Name="QuantileStatistics" Kind="Class" />
      <Type Name="RankerMetricsStatistics" Kind="Class" />
      <Type Name="RankingContext" Kind="Class" />
      <Type Name="RankingContext+RankingTrainers" Kind="Class" />
      <Type Name="RecommendationContext" Kind="Class" />
      <Type Name="RecommendationContext+RecommendationTrainers" Kind="Class" />
      <Type Name="RecommenderCatalog" Kind="Class" />
      <Type Name="RegressionContext" Kind="Class" />
      <Type Name="RegressionContext+RegressionTrainers" Kind="Class" />
      <Type Name="RegressionMetricsStatistics" Kind="Class" />
      <Type Name="RunMetric" Kind="Class" />
      <Type Name="RunResult" Kind="Class" />
      <Type Name="SignatureClassificationLoss" Kind="Delegate" />
      <Type Name="SignatureRegressionLoss" Kind="Delegate" />
      <Type Name="SignatureSuggestedSweepsParser" Kind="Delegate" />
      <Type Name="SignatureSweeper" Kind="Delegate" />
      <Type Name="SignatureSweepResultEvaluator" Kind="Delegate" />
      <Type Name="SimpleFileHandle" Kind="Class" />
      <Type Name="SmoothedHingeLoss" Kind="Class" />
      <Type Name="SmoothedHingeLoss+Arguments" Kind="Class" />
      <Type Name="SquaredLoss" Kind="Class" />
      <Type Name="SquaredLossFactory" Kind="Class" />
      <Type Name="StandardLearnersCatalog" Kind="Class" />
      <Type Name="TensorflowCatalog" Kind="Class" />
      <Type Name="TextCatalog" Kind="Class" />
      <Type Name="TextLoaderSaverCatalog" Kind="Class" />
      <Type Name="TrainContextBase" Kind="Class" />
      <Type Name="TrainContextBase+ContextInstantiatorBase" Kind="Class" />
      <Type Name="TrainerInfo" Kind="Class" />
      <Type Name="TransformExtensionsCatalog" Kind="Class" />
      <Type Name="TransformsCatalog" Kind="Class" />
      <Type Name="TransformsCatalog+CategoricalTransforms" Kind="Class" />
      <Type Name="TransformsCatalog+ConversionTransforms" Kind="Class" />
      <Type Name="TransformsCatalog+FeatureSelectionTransforms" Kind="Class" />
      <Type Name="TransformsCatalog+ProjectionTransforms" Kind="Class" />
      <Type Name="TransformsCatalog+SubCatalogBase" Kind="Class" />
      <Type Name="TransformsCatalog+TextTransforms" Kind="Class" />
      <Type Name="TreeExtensions" Kind="Class" />
      <Type Name="TweedieLoss" Kind="Class" />
      <Type Name="TweedieLoss+Arguments" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Calibrator">
      <Type Name="CalibratorEstimatorBase`2" DisplayName="CalibratorEstimatorBase&lt;TCalibratorTrainer,TICalibrator&gt;" Kind="Class" />
      <Type Name="CalibratorTransformer`1" DisplayName="CalibratorTransformer&lt;TICalibrator&gt;" Kind="Class" />
      <Type Name="FixedPlattCalibratorEstimator" Kind="Class" />
      <Type Name="ICalibrator" Kind="Interface" />
      <Type Name="NaiveCalibratorEstimator" Kind="Class" />
      <Type Name="NaiveCalibratorTransformer" Kind="Class" />
      <Type Name="PavCalibratorEstimator" Kind="Class" />
      <Type Name="PavCalibratorTransformer" Kind="Class" />
      <Type Name="PlattCalibratorEstimator" Kind="Class" />
      <Type Name="PlattCalibratorTransformer" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Core.Data">
      <Type Name="IDataReader`1" DisplayName="IDataReader&lt;TSource&gt;" Kind="Interface" />
      <Type Name="IDataReaderEstimator`2" DisplayName="IDataReaderEstimator&lt;TSource,TReader&gt;" Kind="Interface" />
      <Type Name="IEstimator`1" DisplayName="IEstimator&lt;TTransformer&gt;" Kind="Interface" />
      <Type Name="ITransformer" Kind="Interface" />
      <Type Name="SchemaShape" Kind="Class" />
      <Type Name="SchemaShape+Column" Kind="Structure" />
      <Type Name="SchemaShape+Column+VectorKind" Kind="Enumeration" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Core.Prediction">
    </Namespace>
    <Namespace Name="Microsoft.ML.Data">
      <Type Name="AnomalyDetectionEvaluator" Kind="Class" />
      <Type Name="AnomalyDetectionEvaluator+Aggregator" Kind="Class" />
      <Type Name="AnomalyDetectionEvaluator+Aggregator+CountersBase" Kind="Class" />
      <Type Name="AnomalyDetectionEvaluator+Aggregator+CountersBase+Info" Kind="Structure" />
      <Type Name="AnomalyDetectionEvaluator+Arguments" Kind="Class" />
      <Type Name="AnomalyDetectionEvaluator+OverallMetrics" Kind="Class" />
      <Type Name="AnomalyDetectionEvaluator+TopKResultsColumns" Kind="Class" />
      <Type Name="AnomalyDetectionMamlEvaluator" Kind="Class" />
      <Type Name="AnomalyDetectionMamlEvaluator+Arguments" Kind="Class" />
      <Type Name="AnomalyPredictionTransformer`1" DisplayName="AnomalyPredictionTransformer&lt;TModel&gt;" Kind="Class" />
      <Type Name="AppendRowsDataView" Kind="Class" />
      <Type Name="ApplyTransformUtils" Kind="Class" />
      <Type Name="ArrayDataViewBuilder" Kind="Class" />
      <Type Name="BinaryClassificationMetrics" Kind="Class" />
      <Type Name="BinaryClassifierEvaluator" Kind="Class" />
      <Type Name="BinaryClassifierEvaluator+Aggregator" Kind="Class" />
      <Type Name="BinaryClassifierEvaluator+Aggregator+Counters" Kind="Class" />
      <Type Name="BinaryClassifierEvaluator+Arguments" Kind="Class" />
      <Type Name="BinaryClassifierEvaluator+Metrics" Kind="Enumeration" />
      <Type Name="BinaryClassifierMamlEvaluator" Kind="Class" />
      <Type Name="BinaryClassifierMamlEvaluator+Arguments" Kind="Class" />
      <Type Name="BinaryClassifierSchema" Kind="Class" />
      <Type Name="BinaryClassifierScorer" Kind="Class" />
      <Type Name="BinaryClassifierScorer+Arguments" Kind="Class" />
      <Type Name="BinaryPerInstanceEvaluator" Kind="Class" />
      <Type Name="BinaryPredictionTransformer`1" DisplayName="BinaryPredictionTransformer&lt;TModel&gt;" Kind="Class" />
      <Type Name="BoolType" Kind="Class" />
      <Type Name="BufferBuilder`1" DisplayName="BufferBuilder&lt;T&gt;" Kind="Class" />
      <Type Name="CacheDataView" Kind="Class" />
      <Type Name="CalibratedBinaryClassificationMetrics" Kind="Class" />
      <Type Name="CatalogUtils" Kind="Class" />
      <Type Name="ChooseColumnsByIndexTransform" Kind="Class" />
      <Type Name="ChooseColumnsByIndexTransform+Arguments" Kind="Class" />
      <Type Name="ClusteringEvaluator" Kind="Class" />
      <Type Name="ClusteringEvaluator+Aggregator" Kind="Class" />
      <Type Name="ClusteringEvaluator+Aggregator+Counters" Kind="Class" />
      <Type Name="ClusteringEvaluator+Arguments" Kind="Class" />
      <Type Name="ClusteringMamlEvaluator" Kind="Class" />
      <Type Name="ClusteringMamlEvaluator+Arguments" Kind="Class" />
      <Type Name="ClusteringMetrics" Kind="Class" />
      <Type Name="ClusteringPerInstanceEvaluator" Kind="Class" />
      <Type Name="ClusteringPredictionTransformer`1" DisplayName="ClusteringPredictionTransformer&lt;TModel&gt;" Kind="Class" />
      <Type Name="ClusteringScorer" Kind="Class" />
      <Type Name="ClusteringScorer+Arguments" Kind="Class" />
      <Type Name="ColumnAttribute" Kind="Class" />
      <Type Name="ColumnBindings" Kind="Class" />
      <Type Name="ColumnConcatenatingTransformer" Kind="Class" />
      <Type Name="ColumnConcatenatingTransformer+Arguments" Kind="Class" />
      <Type Name="ColumnConcatenatingTransformer+Column" Kind="Class" />
      <Type Name="ColumnConcatenatingTransformer+ColumnInfo" Kind="Class" />
      <Type Name="ColumnConcatenatingTransformer+TaggedArguments" Kind="Class" />
      <Type Name="ColumnConcatenatingTransformer+TaggedColumn" Kind="Class" />
      <Type Name="ColumnCursorExtensions" Kind="Class" />
      <Type Name="ColumnNameAttribute" Kind="Class" />
      <Type Name="ColumnParsingUtils" Kind="Class" />
      <Type Name="ColumnType" Kind="Class" />
      <Type Name="Combiner`1" DisplayName="Combiner&lt;T&gt;" Kind="Class" />
      <Type Name="ComponentCreation" Kind="Class" />
      <Type Name="CompositeDataLoader" Kind="Class" />
      <Type Name="CompositeDataLoader+Arguments" Kind="Class" />
      <Type Name="CompositeDataReader" Kind="Class" />
      <Type Name="CompositeDataReader`2" DisplayName="CompositeDataReader&lt;TSource,TLastTransformer&gt;" Kind="Class" />
      <Type Name="CompositeReaderEstimator`2" DisplayName="CompositeReaderEstimator&lt;TSource,TLastTransformer&gt;" Kind="Class" />
      <Type Name="CompositeRowToRowMapper" Kind="Class" />
      <Type Name="CursorChannelAttribute" Kind="Class" />
      <Type Name="CursoringUtils" Kind="Class" />
      <Type Name="CursorState" Kind="Enumeration" />
      <Type Name="DataDebuggerPreview" Kind="Class" />
      <Type Name="DataDebuggerPreview+ColumnInfo" Kind="Class" />
      <Type Name="DataDebuggerPreview+RowInfo" Kind="Class" />
      <Type Name="DataKind" Kind="Enumeration" />
      <Type Name="DataSaverUtils" Kind="Class" />
      <Type Name="DataViewUtils" Kind="Class" />
      <Type Name="DateTimeOffsetType" Kind="Class" />
      <Type Name="DateTimeType" Kind="Class" />
      <Type Name="DefaultColumnNames" Kind="Class" />
      <Type Name="EmptyDataView" Kind="Class" />
      <Type Name="EstimatorChain`1" DisplayName="EstimatorChain&lt;TLastTransformer&gt;" Kind="Class" />
      <Type Name="Evaluate" Kind="Class" />
      <Type Name="EvaluatorBase`1" DisplayName="EvaluatorBase&lt;TAgg&gt;" Kind="Class" />
      <Type Name="EvaluatorBase`1+AggregatorBase" DisplayName="EvaluatorBase&lt;TAgg&gt;+AggregatorBase" Kind="Class" />
      <Type Name="EvaluatorBase`1+AggregatorDictionaryBase" DisplayName="EvaluatorBase&lt;TAgg&gt;+AggregatorDictionaryBase" Kind="Class" />
      <Type Name="FeatureContributionCalculatingEstimator" Kind="Class" />
      <Type Name="FeatureContributionCalculatingEstimator+Defaults" Kind="Class" />
      <Type Name="FeatureContributionCalculatingTransformer" Kind="Class" />
      <Type Name="FeatureContributionCalculatingTransformer+Arguments" Kind="Class" />
      <Type Name="FileHandleSource" Kind="Class" />
      <Type Name="FilterBase" Kind="Class" />
      <Type Name="FloatAdder" Kind="Class" />
      <Type Name="GenericScorer" Kind="Class" />
      <Type Name="GenericScorer+Arguments" Kind="Class" />
      <Type Name="ICursorable`1" DisplayName="ICursorable&lt;TRow&gt;" Kind="Interface" />
      <Type Name="IDataLoader" Kind="Interface" />
      <Type Name="IDataSaver" Kind="Interface" />
      <Type Name="IDataScorerTransform" Kind="Interface" />
      <Type Name="IDataTransform" Kind="Interface" />
      <Type Name="IDataView" Kind="Interface" />
      <Type Name="IManyToOneColumn" Kind="Interface" />
      <Type Name="IMultiStreamSource" Kind="Interface" />
      <Type Name="InPredicate`1" DisplayName="InPredicate&lt;T&gt;" Kind="Delegate" />
      <Type Name="IOneToOneColumn" Kind="Interface" />
      <Type Name="IPartitionedPathParser" Kind="Interface" />
      <Type Name="IPartitionedPathParserFactory" Kind="Interface" />
      <Type Name="IRowSeekable" Kind="Interface" />
      <Type Name="IRowToRowMapper" Kind="Interface" />
      <Type Name="ITransformTemplate" Kind="Interface" />
      <Type Name="KeyRange" Kind="Class" />
      <Type Name="KeyType" Kind="Class" />
      <Type Name="KeyTypeAttribute" Kind="Class" />
      <Type Name="LambdaFilter" Kind="Class" />
      <Type Name="LoadColumnAttribute" Kind="Class" />
      <Type Name="LoaderUtils" Kind="Class" />
      <Type Name="MamlEvaluatorBase" Kind="Class" />
      <Type Name="MamlEvaluatorBase+ArgumentsBase" Kind="Class" />
      <Type Name="ManyToOneColumn" Kind="Class" />
      <Type Name="ManyToOneColumn`1" DisplayName="ManyToOneColumn&lt;T&gt;" Kind="Class" />
      <Type Name="MetadataBuilder" Kind="Class" />
      <Type Name="MetadataDispatcher" Kind="Class" />
      <Type Name="MetadataDispatcher+Builder" Kind="Class" />
      <Type Name="MetadataDispatcherBase" Kind="Class" />
      <Type Name="MetadataDispatcherBase+ColInfo" Kind="Class" />
      <Type Name="MetadataDispatcherBase+GetterInfo" Kind="Class" />
      <Type Name="MetadataDispatcherBase+GetterInfo`1" DisplayName="MetadataDispatcherBase+GetterInfo&lt;TValue&gt;" Kind="Class" />
      <Type Name="MetadataDispatcherBase+GetterInfoDelegate`1" DisplayName="MetadataDispatcherBase+GetterInfoDelegate&lt;TValue&gt;" Kind="Class" />
      <Type Name="MetadataDispatcherBase+GetterInfoPrimitive`1" DisplayName="MetadataDispatcherBase+GetterInfoPrimitive&lt;TValue&gt;" Kind="Class" />
      <Type Name="MetadataInfo" Kind="Class" />
      <Type Name="MetadataInfo`1" DisplayName="MetadataInfo&lt;T&gt;" Kind="Class" />
      <Type Name="MetadataInfo`1+TElement" DisplayName="MetadataInfo&lt;T&gt;+TElement" Kind="Class" />
      <Type Name="MetadataUtils" Kind="Class" />
      <Type Name="MetadataUtils+Const" Kind="Class" />
      <Type Name="MetadataUtils+Const+ScoreColumnKind" Kind="Class" />
      <Type Name="MetadataUtils+Const+ScoreValueKind" Kind="Class" />
      <Type Name="MetadataUtils+Kinds" Kind="Class" />
      <Type Name="MetadataUtils+MetadataGetter`1" DisplayName="MetadataUtils+MetadataGetter&lt;TValue&gt;" Kind="Delegate" />
      <Type Name="MetricColumn" Kind="Class" />
      <Type Name="MetricColumn+Objective" Kind="Enumeration" />
      <Type Name="MetricKinds" Kind="Class" />
      <Type Name="MetricKinds+ColumnNames" Kind="Class" />
      <Type Name="MetricWriter" Kind="Class" />
      <Type Name="MultiClassClassifierEvaluator" Kind="Class" />
      <Type Name="MultiClassClassifierEvaluator+Aggregator" Kind="Class" />
      <Type Name="MultiClassClassifierEvaluator+Aggregator+Counters" Kind="Class" />
      <Type Name="MultiClassClassifierEvaluator+Arguments" Kind="Class" />
      <Type Name="MultiClassClassifierEvaluator+Metrics" Kind="Enumeration" />
      <Type Name="MultiClassClassifierMetrics" Kind="Class" />
      <Type Name="MultiClassClassifierScorer" Kind="Class" />
      <Type Name="MultiClassClassifierScorer+Arguments" Kind="Class" />
      <Type Name="MultiClassClassifierScorer+LabelNameBindableMapper" Kind="Class" />
      <Type Name="MultiClassMamlEvaluator" Kind="Class" />
      <Type Name="MultiClassMamlEvaluator+Arguments" Kind="Class" />
      <Type Name="MultiClassPerInstanceEvaluator" Kind="Class" />
      <Type Name="MulticlassPredictionTransformer`1" DisplayName="MulticlassPredictionTransformer&lt;TModel&gt;" Kind="Class" />
      <Type Name="MultiFileSource" Kind="Class" />
      <Type Name="MultiOutputRegressionEvaluator" Kind="Class" />
      <Type Name="MultiOutputRegressionEvaluator+Aggregator" Kind="Class" />
      <Type Name="MultiOutputRegressionEvaluator+Aggregator+Counters" Kind="Class" />
      <Type Name="MultiOutputRegressionEvaluator+Arguments" Kind="Class" />
      <Type Name="MultiOutputRegressionMamlEvaluator" Kind="Class" />
      <Type Name="MultiOutputRegressionMamlEvaluator+Arguments" Kind="Class" />
      <Type Name="MultiOutputRegressionPerInstanceEvaluator" Kind="Class" />
      <Type Name="NoColumnAttribute" Kind="Class" />
      <Type Name="NopTransform" Kind="Class" />
      <Type Name="NopTransform+NopInput" Kind="Class" />
      <Type Name="Normalize" Kind="Class" />
      <Type Name="NormalizeOption" Kind="Enumeration" />
      <Type Name="NumberType" Kind="Class" />
      <Type Name="OneToOneColumn" Kind="Class" />
      <Type Name="OneToOneColumn`1" DisplayName="OneToOneColumn&lt;T&gt;" Kind="Class" />
      <Type Name="OneToOneTransformBase" Kind="Class" />
      <Type Name="OneToOneTransformBase+ColInfo" Kind="Class" />
      <Type Name="OneToOneTransformerBase" Kind="Class" />
      <Type Name="OneToOneTransformerBase+OneToOneMapperBase" Kind="Class" />
      <Type Name="OpaqueDataView" Kind="Class" />
      <Type Name="ParquetPartitionedPathParser" Kind="Class" />
      <Type Name="ParquetPartitionedPathParserFactory" Kind="Class" />
      <Type Name="PartitionedFileLoader" Kind="Class" />
      <Type Name="PartitionedFileLoader+Arguments" Kind="Class" />
      <Type Name="PartitionedFileLoader+Column" Kind="Class" />
      <Type Name="PartitionedPathParser" Kind="Delegate" />
      <Type Name="PerGroupTransformBase`3" DisplayName="PerGroupTransformBase&lt;TLabel,TScore,TState&gt;" Kind="Class" />
      <Type Name="PerInstanceEvaluatorBase" Kind="Class" />
      <Type Name="PredictedLabelScorerBase" Kind="Class" />
      <Type Name="PredictedLabelScorerBase+ThresholdArgumentsBase" Kind="Class" />
      <Type Name="PredictionTransformerBase`2" DisplayName="PredictionTransformerBase&lt;TModel,TScorer&gt;" Kind="Class" />
      <Type Name="PrimitiveType" Kind="Class" />
      <Type Name="QuantileRegressionEvaluator" Kind="Class" />
      <Type Name="QuantileRegressionEvaluator+Aggregator" Kind="Class" />
      <Type Name="QuantileRegressionEvaluator+Arguments" Kind="Class" />
      <Type Name="QuantileRegressionMamlEvaluator" Kind="Class" />
      <Type Name="QuantileRegressionMamlEvaluator+Arguments" Kind="Class" />
      <Type Name="QuantileRegressionPerInstanceEvaluator" Kind="Class" />
      <Type Name="R4Adder" Kind="Class" />
      <Type Name="R8Adder" Kind="Class" />
      <Type Name="RankerEvaluator" Kind="Class" />
      <Type Name="RankerEvaluator+Aggregator" Kind="Class" />
      <Type Name="RankerEvaluator+Aggregator+Counters" Kind="Class" />
      <Type Name="RankerEvaluator+Arguments" Kind="Class" />
      <Type Name="RankerMamlEvaluator" Kind="Class" />
      <Type Name="RankerMamlEvaluator+Arguments" Kind="Class" />
      <Type Name="RankerMetrics" Kind="Class" />
      <Type Name="RankerPerInstanceTransform" Kind="Class" />
      <Type Name="RankingPredictionTransformer`1" DisplayName="RankingPredictionTransformer&lt;TModel&gt;" Kind="Class" />
      <Type Name="RegressionEvaluator" Kind="Class" />
      <Type Name="RegressionEvaluator+Aggregator" Kind="Class" />
      <Type Name="RegressionEvaluator+Arguments" Kind="Class" />
      <Type Name="RegressionEvaluator+Metrics" Kind="Enumeration" />
      <Type Name="RegressionEvaluatorBase`3" DisplayName="RegressionEvaluatorBase&lt;TAgg,TScore,TMetrics&gt;" Kind="Class" />
      <Type Name="RegressionEvaluatorBase`3+RegressionAggregatorBase" DisplayName="RegressionEvaluatorBase&lt;TAgg,TScore,TMetrics&gt;+RegressionAggregatorBase" Kind="Class" />
      <Type Name="RegressionEvaluatorBase`3+RegressionAggregatorBase+CountersBase" DisplayName="RegressionEvaluatorBase&lt;TAgg,TScore,TMetrics&gt;+RegressionAggregatorBase+CountersBase" Kind="Class" />
      <Type Name="RegressionLossEvaluatorBase`1" DisplayName="RegressionLossEvaluatorBase&lt;TAgg&gt;" Kind="Class" />
      <Type Name="RegressionLossEvaluatorBase`1+ArgumentsBase" DisplayName="RegressionLossEvaluatorBase&lt;TAgg&gt;+ArgumentsBase" Kind="Class" />
      <Type Name="RegressionMamlEvaluator" Kind="Class" />
      <Type Name="RegressionMamlEvaluator+Arguments" Kind="Class" />
      <Type Name="RegressionMetrics" Kind="Class" />
      <Type Name="RegressionPerInstanceEvaluator" Kind="Class" />
      <Type Name="RegressionPredictionTransformer`1" DisplayName="RegressionPredictionTransformer&lt;TModel&gt;" Kind="Class" />
      <Type Name="Row" Kind="Class" />
      <Type Name="RowCursor" Kind="Class" />
      <Type Name="RowCursor`1" DisplayName="RowCursor&lt;TRow&gt;" Kind="Class" />
      <Type Name="RowCursorUtils" Kind="Class" />
      <Type Name="RowId" Kind="Structure" />
      <Type Name="RowSeeker" Kind="Class" />
      <Type Name="RowToRowEvaluatorBase`1" DisplayName="RowToRowEvaluatorBase&lt;TAgg&gt;" Kind="Class" />
      <Type Name="RowToRowMapperTransform" Kind="Class" />
      <Type Name="RowToRowMapperTransformBase" Kind="Class" />
      <Type Name="RowToRowScorerBase" Kind="Class" />
      <Type Name="RowToRowTransformBase" Kind="Class" />
      <Type Name="RowToRowTransformerBase" Kind="Class" />
      <Type Name="RowToRowTransformerBase+MapperBase" Kind="Class" />
      <Type Name="Schema" Kind="Class" />
      <Type Name="Schema+Column" Kind="Structure" />
      <Type Name="Schema+DetachedColumn" Kind="Structure" />
      <Type Name="Schema+Metadata" Kind="Class" />
      <Type Name="SchemaBuilder" Kind="Class" />
      <Type Name="SchemaDefinition" Kind="Class" />
      <Type Name="SchemaDefinition+Column" Kind="Class" />
      <Type Name="SchemaDefinition+Direction" Kind="Enumeration" />
      <Type Name="ScoreMapperSchema" Kind="Class" />
      <Type Name="ScoreMapperSchemaBase" Kind="Class" />
      <Type Name="ScorerArgumentsBase" Kind="Class" />
      <Type Name="SequencePredictorSchema" Kind="Class" />
      <Type Name="SignatureBindableMapper" Kind="Delegate" />
      <Type Name="SignatureDataLoader" Kind="Delegate" />
      <Type Name="SignatureDataSaver" Kind="Delegate" />
      <Type Name="SignatureDataTransform" Kind="Delegate" />
      <Type Name="SignatureLoadColumnFunction" Kind="Delegate" />
      <Type Name="SignatureLoadDataLoader" Kind="Delegate" />
      <Type Name="SignatureLoadDataTransform" Kind="Delegate" />
      <Type Name="SignatureLoadRowMapper" Kind="Delegate" />
      <Type Name="SimplePartitionedPathParser" Kind="Class" />
      <Type Name="SimplePartitionedPathParser+Arguments" Kind="Class" />
      <Type Name="SimpleSchemaBase" Kind="Class" />
      <Type Name="SimpleSchemaUtils" Kind="Class" />
      <Type Name="SingleFeaturePredictionTransformerBase`2" DisplayName="SingleFeaturePredictionTransformerBase&lt;TModel,TScorer&gt;" Kind="Class" />
      <Type Name="SlotCursor" Kind="Class" />
      <Type Name="SourceNameColumnBase" Kind="Class" />
      <Type Name="StructuredType" Kind="Class" />
      <Type Name="TextCombiner" Kind="Class" />
      <Type Name="TextLoader" Kind="Class" />
      <Type Name="TextLoader+Arguments" Kind="Class" />
      <Type Name="TextLoader+ArgumentsCore" Kind="Class" />
      <Type Name="TextLoader+Column" Kind="Class" />
      <Type Name="TextLoader+Range" Kind="Class" />
      <Type Name="TextModelHelper" Kind="Class" />
      <Type Name="TextType" Kind="Class" />
      <Type Name="TimeSpanType" Kind="Class" />
      <Type Name="TrainedWrapperEstimatorBase" Kind="Class" />
      <Type Name="TransformBase" Kind="Class" />
      <Type Name="TransformerChain" Kind="Class" />
      <Type Name="TransformerChain`1" DisplayName="TransformerChain&lt;TLastTransformer&gt;" Kind="Class" />
      <Type Name="TransformerScope" Kind="Enumeration" />
      <Type Name="TransformWrapper" Kind="Class" />
      <Type Name="TreeEnsembleFeaturizerBindableMapper" Kind="Class" />
      <Type Name="TreeEnsembleFeaturizerBindableMapper+Arguments" Kind="Class" />
      <Type Name="TreeEnsembleFeaturizerBindableMapper+OutputColumnNames" Kind="Class" />
      <Type Name="TrivialEstimator`1" DisplayName="TrivialEstimator&lt;TTransformer&gt;" Kind="Class" />
      <Type Name="TrivialReaderEstimator`2" DisplayName="TrivialReaderEstimator&lt;TSource,TReader&gt;" Kind="Class" />
      <Type Name="TrivialWrapperEstimator" Kind="Class" />
      <Type Name="TypeParsingUtils" Kind="Class" />
      <Type Name="U4Adder" Kind="Class" />
      <Type Name="ValueGetter`1" DisplayName="ValueGetter&lt;TValue&gt;" Kind="Delegate" />
      <Type Name="VBuffer`1" DisplayName="VBuffer&lt;T&gt;" Kind="Structure" />
      <Type Name="VBufferEditor" Kind="Class" />
      <Type Name="VBufferEditor`1" DisplayName="VBufferEditor&lt;T&gt;" Kind="Structure" />
      <Type Name="VectorType" Kind="Class" />
      <Type Name="VectorTypeAttribute" Kind="Class" />
      <Type Name="ZipDataView" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Data.Commands">
    </Namespace>
    <Namespace Name="Microsoft.ML.Data.IO">
      <Type Name="BinaryLoader" Kind="Class" />
      <Type Name="BinaryLoader+Arguments" Kind="Class" />
      <Type Name="BinarySaver" Kind="Class" />
      <Type Name="BinarySaver+Arguments" Kind="Class" />
      <Type Name="Compression" Kind="Class" />
      <Type Name="Compression+NoneImpl" Kind="Class" />
      <Type Name="Compression+ZlibImpl" Kind="Class" />
      <Type Name="Compression+ZlibImpl+ArgumentsBase" Kind="Class" />
      <Type Name="Compression+ZlibImpl+DeflateArguments" Kind="Class" />
      <Type Name="Compression+ZlibImpl+ZlibArguments" Kind="Class" />
      <Type Name="CompressionCodecExtension" Kind="Class" />
      <Type Name="CompressionKind" Kind="Enumeration" />
      <Type Name="Header" Kind="Structure" />
      <Type Name="TextSaver" Kind="Class" />
      <Type Name="TextSaver+Arguments" Kind="Class" />
      <Type Name="TransposeLoader" Kind="Class" />
      <Type Name="TransposeLoader+Arguments" Kind="Class" />
      <Type Name="TransposeLoader+Header" Kind="Structure" />
      <Type Name="TransposeSaver" Kind="Class" />
      <Type Name="TransposeSaver+Arguments" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Data.IO.Zlib">
      <Type Name="Constants" Kind="Class" />
      <Type Name="Constants+Flush" Kind="Enumeration" />
      <Type Name="Constants+Level" Kind="Enumeration" />
      <Type Name="Constants+RetCode" Kind="Enumeration" />
      <Type Name="Constants+Strategy" Kind="Enumeration" />
      <Type Name="Constants+Type" Kind="Enumeration" />
      <Type Name="ZDeflateStream" Kind="Class" />
      <Type Name="ZInflateStream" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Ensemble">
      <Type Name="EnsembleDistributionModelParameters" Kind="Class" />
      <Type Name="EnsembleModelParameters" Kind="Class" />
      <Type Name="EnsembleModelParametersBase`2" DisplayName="EnsembleModelParametersBase&lt;TPredictor,TOutput&gt;" Kind="Class" />
      <Type Name="EnsembleMultiClassModelParameters" Kind="Class" />
      <Type Name="FeatureSubsetModel`1" DisplayName="FeatureSubsetModel&lt;TPredictor&gt;" Kind="Class" />
      <Type Name="IModelCombiner" Kind="Interface" />
      <Type Name="SchemaBindablePipelineEnsembleBase" Kind="Class" />
      <Type Name="SignatureModelCombiner" Kind="Delegate" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Ensemble.EntryPoints">
      <Type Name="AllFeatureSelectorFactory" Kind="Class" />
      <Type Name="AllSelectorFactory" Kind="Class" />
      <Type Name="AllSelectorMultiClassFactory" Kind="Class" />
      <Type Name="AverageFactory" Kind="Class" />
      <Type Name="DisagreementDiversityFactory" Kind="Class" />
      <Type Name="MedianFactory" Kind="Class" />
      <Type Name="MultiDisagreementDiversityFactory" Kind="Class" />
      <Type Name="MultiVotingFactory" Kind="Class" />
      <Type Name="PipelineEnsemble" Kind="Class" />
      <Type Name="PipelineEnsemble+SummaryOutput" Kind="Class" />
      <Type Name="RegressionDisagreementDiversityFactory" Kind="Class" />
      <Type Name="VotingFactory" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Ensemble.OutputCombiners">
      <Type Name="Average" Kind="Class" />
      <Type Name="BaseAverager" Kind="Class" />
      <Type Name="BaseMultiAverager" Kind="Class" />
      <Type Name="BaseMultiCombiner" Kind="Class" />
      <Type Name="BaseMultiCombiner+ArgumentsBase" Kind="Class" />
      <Type Name="Combiner`1" DisplayName="Combiner&lt;TOutput&gt;" Kind="Delegate" />
      <Type Name="IBinaryOutputCombiner" Kind="Interface" />
      <Type Name="IMultiClassOutputCombiner" Kind="Interface" />
      <Type Name="IOutputCombiner" Kind="Interface" />
      <Type Name="IOutputCombiner`1" DisplayName="IOutputCombiner&lt;TOutput&gt;" Kind="Interface" />
      <Type Name="IRegressionOutputCombiner" Kind="Interface" />
      <Type Name="ISupportBinaryOutputCombinerFactory" Kind="Interface" />
      <Type Name="ISupportMulticlassOutputCombinerFactory" Kind="Interface" />
      <Type Name="ISupportRegressionOutputCombinerFactory" Kind="Interface" />
      <Type Name="IWeightedAverager" Kind="Interface" />
      <Type Name="Median" Kind="Class" />
      <Type Name="MultiAverage" Kind="Class" />
      <Type Name="MultiAverage+Arguments" Kind="Class" />
      <Type Name="MultiMedian" Kind="Class" />
      <Type Name="MultiMedian+Arguments" Kind="Class" />
      <Type Name="MultiVoting" Kind="Class" />
      <Type Name="MultiWeightageKind" Kind="Enumeration" />
      <Type Name="MultiWeightedAverage" Kind="Class" />
      <Type Name="MultiWeightedAverage+Arguments" Kind="Class" />
      <Type Name="SignatureCombiner" Kind="Delegate" />
      <Type Name="Voting" Kind="Class" />
      <Type Name="WeightageKind" Kind="Enumeration" />
      <Type Name="WeightedAverage" Kind="Class" />
      <Type Name="WeightedAverage+Arguments" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Ensemble.Selector">
      <Type Name="IBinaryDiversityMeasure" Kind="Interface" />
      <Type Name="IDiversityMeasure`1" DisplayName="IDiversityMeasure&lt;TOutput&gt;" Kind="Interface" />
      <Type Name="IMulticlassDiversityMeasure" Kind="Interface" />
      <Type Name="IRegressionDiversityMeasure" Kind="Interface" />
      <Type Name="ISupportBinaryDiversityMeasureFactory" Kind="Interface" />
      <Type Name="ISupportMulticlassDiversityMeasureFactory" Kind="Interface" />
      <Type Name="ISupportRegressionDiversityMeasureFactory" Kind="Interface" />
      <Type Name="SignatureEnsembleDataSelector" Kind="Delegate" />
      <Type Name="SignatureEnsembleDiversityMeasure" Kind="Delegate" />
      <Type Name="SignatureEnsembleFeatureSelector" Kind="Delegate" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Ensemble.Selector.DiversityMeasure">
      <Type Name="BaseDisagreementDiversityMeasure`1" DisplayName="BaseDisagreementDiversityMeasure&lt;TOutput&gt;" Kind="Class" />
      <Type Name="DisagreementDiversityMeasure" Kind="Class" />
      <Type Name="ModelDiversityMetric`1" DisplayName="ModelDiversityMetric&lt;TOutput&gt;" Kind="Class" />
      <Type Name="MultiDisagreementDiversityMeasure" Kind="Class" />
      <Type Name="RegressionDisagreementDiversityMeasure" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.EntryPoints">
      <Type Name="ArrayIndexParameterBinding" Kind="Class" />
      <Type Name="ArrayIndexVariableBinding" Kind="Class" />
      <Type Name="ArrayVar`1" DisplayName="ArrayVar&lt;T&gt;" Kind="Class" />
      <Type Name="Cache" Kind="Class" />
      <Type Name="Cache+CacheInput" Kind="Class" />
      <Type Name="Cache+CacheOutput" Kind="Class" />
      <Type Name="Cache+CachingType" Kind="Enumeration" />
      <Type Name="CachingOptions" Kind="Enumeration" />
      <Type Name="CommonInputs" Kind="Class" />
      <Type Name="CommonInputs+ICalibratorInput" Kind="Interface" />
      <Type Name="CommonInputs+IEvaluatorInput" Kind="Interface" />
      <Type Name="CommonInputs+IFeaturizerInput" Kind="Interface" />
      <Type Name="CommonInputs+ITrainerInput" Kind="Interface" />
      <Type Name="CommonInputs+ITrainerInputWithGroupId" Kind="Interface" />
      <Type Name="CommonInputs+ITrainerInputWithLabel" Kind="Interface" />
      <Type Name="CommonInputs+ITrainerInputWithWeight" Kind="Interface" />
      <Type Name="CommonInputs+ITransformInput" Kind="Interface" />
      <Type Name="CommonInputs+IUnsupervisedTrainerWithWeight" Kind="Interface" />
      <Type Name="CommonOutputs" Kind="Class" />
      <Type Name="CommonOutputs+AnomalyDetectionOutput" Kind="Class" />
      <Type Name="CommonOutputs+BinaryClassificationOutput" Kind="Class" />
      <Type Name="CommonOutputs+CalibratorOutput" Kind="Class" />
      <Type Name="CommonOutputs+ClassificationEvaluateOutput" Kind="Class" />
      <Type Name="CommonOutputs+ClusteringOutput" Kind="Class" />
      <Type Name="CommonOutputs+CommonEvaluateOutput" Kind="Class" />
      <Type Name="CommonOutputs+EvaluateOutputBase" Kind="Class" />
      <Type Name="CommonOutputs+IAnomalyDetectionOutput" Kind="Interface" />
      <Type Name="CommonOutputs+IBinaryClassificationOutput" Kind="Interface" />
      <Type Name="CommonOutputs+ICalibratorOutput" Kind="Interface" />
      <Type Name="CommonOutputs+IClassificationEvaluatorOutput" Kind="Interface" />
      <Type Name="CommonOutputs+IClusteringOutput" Kind="Interface" />
      <Type Name="CommonOutputs+IEvaluatorOutput" Kind="Interface" />
      <Type Name="CommonOutputs+IMulticlassClassificationOutput" Kind="Interface" />
      <Type Name="CommonOutputs+IMultiRegressionOutput" Kind="Interface" />
      <Type Name="CommonOutputs+IRankingOutput" Kind="Interface" />
      <Type Name="CommonOutputs+IRegressionOutput" Kind="Interface" />
      <Type Name="CommonOutputs+ISequencePredictionOutput" Kind="Interface" />
      <Type Name="CommonOutputs+ITrainerOutput" Kind="Interface" />
      <Type Name="CommonOutputs+ITransformOutput" Kind="Interface" />
      <Type Name="CommonOutputs+MacroOutput" Kind="Class" />
      <Type Name="CommonOutputs+MacroOutput`1" DisplayName="CommonOutputs+MacroOutput&lt;TOut&gt;" Kind="Class" />
      <Type Name="CommonOutputs+MulticlassClassificationOutput" Kind="Class" />
      <Type Name="CommonOutputs+MultiRegressionOutput" Kind="Class" />
      <Type Name="CommonOutputs+RankingOutput" Kind="Class" />
      <Type Name="CommonOutputs+RegressionOutput" Kind="Class" />
      <Type Name="CommonOutputs+SequencePredictionOutput" Kind="Class" />
      <Type Name="CommonOutputs+SummaryOutput" Kind="Class" />
      <Type Name="CommonOutputs+TrainerOutput" Kind="Class" />
      <Type Name="CommonOutputs+TransformOutput" Kind="Class" />
      <Type Name="DictionaryKeyParameterBinding" Kind="Class" />
      <Type Name="DictionaryKeyVariableBinding" Kind="Class" />
      <Type Name="DictionaryVar`1" DisplayName="DictionaryVar&lt;T&gt;" Kind="Class" />
      <Type Name="EnsembleCreator" Kind="Class" />
      <Type Name="EnsembleCreator+ClassifierCombiner" Kind="Enumeration" />
      <Type Name="EnsembleCreator+ClassifierInput" Kind="Class" />
      <Type Name="EnsembleCreator+InputBase" Kind="Class" />
      <Type Name="EnsembleCreator+PipelineAnomalyInput" Kind="Class" />
      <Type Name="EnsembleCreator+PipelineClassifierInput" Kind="Class" />
      <Type Name="EnsembleCreator+PipelineInputBase" Kind="Class" />
      <Type Name="EnsembleCreator+PipelineRegressionInput" Kind="Class" />
      <Type Name="EnsembleCreator+RegressionInput" Kind="Class" />
      <Type Name="EnsembleCreator+ScoreCombiner" Kind="Enumeration" />
      <Type Name="EntryPointGraph" Kind="Class" />
      <Type Name="EntryPointNode" Kind="Class" />
      <Type Name="EntryPointVariable" Kind="Class" />
      <Type Name="EvaluateInputBase" Kind="Class" />
      <Type Name="LearnerInputBase" Kind="Class" />
      <Type Name="LearnerInputBaseWithGroupId" Kind="Class" />
      <Type Name="LearnerInputBaseWithLabel" Kind="Class" />
      <Type Name="LearnerInputBaseWithWeight" Kind="Class" />
      <Type Name="Optional" Kind="Class" />
      <Type Name="Optional`1" DisplayName="Optional&lt;T&gt;" Kind="Class" />
      <Type Name="ParameterBinding" Kind="Class" />
      <Type Name="PredictorModel" Kind="Class" />
      <Type Name="RunContext" Kind="Class" />
      <Type Name="SchemaManipulation" Kind="Class" />
      <Type Name="ScoreModel" Kind="Class" />
      <Type Name="ScoreModel+Input" Kind="Class" />
      <Type Name="ScoreModel+InputTransformScorer" Kind="Class" />
      <Type Name="ScoreModel+ModelInput" Kind="Class" />
      <Type Name="ScoreModel+ModelOutput" Kind="Class" />
      <Type Name="ScoreModel+Output" Kind="Class" />
      <Type Name="ScoreModel+RenameBinaryPredictionScoreColumnsInput" Kind="Class" />
      <Type Name="ScoreModel+ScoreColumnSelectorInput" Kind="Class" />
      <Type Name="SelectRows" Kind="Class" />
      <Type Name="SimpleParameterBinding" Kind="Class" />
      <Type Name="SimpleVariableBinding" Kind="Class" />
      <Type Name="SummarizePredictor" Kind="Class" />
      <Type Name="SummarizePredictor+Input" Kind="Class" />
      <Type Name="SummarizePredictor+InputBase" Kind="Class" />
      <Type Name="TransformInputBase" Kind="Class" />
      <Type Name="TransformModel" Kind="Class" />
      <Type Name="UnsupervisedLearnerInputBaseWithWeight" Kind="Class" />
      <Type Name="Var`1" DisplayName="Var&lt;T&gt;" Kind="Class" />
      <Type Name="VariableBinding" Kind="Class" />
      <Type Name="VarSerializer" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.EntryPoints.JsonUtils">
      <Type Name="FieldNames" Kind="Class" />
      <Type Name="FieldNames+Deprecated" Kind="Class" />
      <Type Name="FieldNames+PipelineSweeperSupportedMetrics" Kind="Class" />
      <Type Name="FieldNames+Range" Kind="Class" />
      <Type Name="FieldNames+SweepableDiscreteParam" Kind="Class" />
      <Type Name="FieldNames+SweepableFloatParam" Kind="Class" />
      <Type Name="FieldNames+SweepableLongParam" Kind="Class" />
      <Type Name="InputBuilder" Kind="Class" />
      <Type Name="OutputHelper" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.FactorizationMachine">
      <Type Name="FieldAwareFactorizationMachineModelParameters" Kind="Class" />
      <Type Name="FieldAwareFactorizationMachinePredictionTransformer" Kind="Class" />
      <Type Name="FieldAwareFactorizationMachineTrainer" Kind="Class" />
      <Type Name="FieldAwareFactorizationMachineTrainer+Arguments" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.ImageAnalytics">
      <Type Name="ImageGrayscaleTransform" Kind="Class" />
      <Type Name="ImageGrayscaleTransform+Arguments" Kind="Class" />
      <Type Name="ImageGrayscaleTransform+Column" Kind="Class" />
      <Type Name="ImageGrayscalingEstimator" Kind="Class" />
      <Type Name="ImageLoaderTransform" Kind="Class" />
      <Type Name="ImageLoaderTransform+Arguments" Kind="Class" />
      <Type Name="ImageLoaderTransform+Column" Kind="Class" />
      <Type Name="ImageLoadingEstimator" Kind="Class" />
      <Type Name="ImagePixelExtractingEstimator" Kind="Class" />
      <Type Name="ImagePixelExtractorTransform" Kind="Class" />
      <Type Name="ImagePixelExtractorTransform+Arguments" Kind="Class" />
      <Type Name="ImagePixelExtractorTransform+ColorBits" Kind="Enumeration" />
      <Type Name="ImagePixelExtractorTransform+Column" Kind="Class" />
      <Type Name="ImagePixelExtractorTransform+ColumnInfo" Kind="Class" />
      <Type Name="ImageResizerTransform" Kind="Class" />
      <Type Name="ImageResizerTransform+Anchor" Kind="Enumeration" />
      <Type Name="ImageResizerTransform+Arguments" Kind="Class" />
      <Type Name="ImageResizerTransform+Column" Kind="Class" />
      <Type Name="ImageResizerTransform+ColumnInfo" Kind="Class" />
      <Type Name="ImageResizerTransform+ResizingKind" Kind="Enumeration" />
      <Type Name="ImageResizingEstimator" Kind="Class" />
      <Type Name="ImageType" Kind="Class" />
      <Type Name="VectorToImageTransform" Kind="Class" />
      <Type Name="VectorToImageTransform+Arguments" Kind="Class" />
      <Type Name="VectorToImageTransform+Column" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.ImageAnalytics.EntryPoints">
      <Type Name="ImageAnalytics" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Internal.Calibration">
      <Type Name="CalibratedPredictorBase" Kind="Class" />
      <Type Name="CalibrationDataStore" Kind="Class" />
      <Type Name="CalibrationDataStore+DataItem" Kind="Structure" />
      <Type Name="CalibratorTrainerBase" Kind="Class" />
      <Type Name="FixedPlattCalibratorTrainer" Kind="Class" />
      <Type Name="FixedPlattCalibratorTrainer+Arguments" Kind="Class" />
      <Type Name="ICalibratorTrainer" Kind="Interface" />
      <Type Name="ICalibratorTrainerFactory" Kind="Interface" />
      <Type Name="NaiveCalibrator" Kind="Class" />
      <Type Name="NaiveCalibratorTrainer" Kind="Class" />
      <Type Name="ParameterMixingCalibratedPredictor" Kind="Class" />
      <Type Name="PavCalibrator" Kind="Class" />
      <Type Name="PavCalibratorTrainer" Kind="Class" />
      <Type Name="PlattCalibrator" Kind="Class" />
      <Type Name="PlattCalibratorTrainer" Kind="Class" />
      <Type Name="SignatureCalibrator" Kind="Delegate" />
      <Type Name="ValueMapperCalibratedPredictorBase" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Internal.CpuMath">
      <Type Name="GeneralUtils" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Internal.Internallearn">
      <Type Name="EarlyStoppingCriterion`1" DisplayName="EarlyStoppingCriterion&lt;TArguments&gt;" Kind="Class" />
      <Type Name="EarlyStoppingCriterion`1+ArgumentsBase" DisplayName="EarlyStoppingCriterion&lt;TArguments&gt;+ArgumentsBase" Kind="Class" />
      <Type Name="FeatureContributionCalculator" Kind="Class" />
      <Type Name="GLEarlyStoppingCriterion" Kind="Class" />
      <Type Name="GLEarlyStoppingCriterion+Arguments" Kind="Class" />
      <Type Name="ICalculateFeatureContribution" Kind="Interface" />
      <Type Name="ICanGetTrainingLabelNames" Kind="Interface" />
      <Type Name="IEarlyStoppingCriterion" Kind="Interface" />
      <Type Name="IEarlyStoppingCriterionFactory" Kind="Interface" />
      <Type Name="IHaveFeatureWeights" Kind="Interface" />
      <Type Name="IPredictorWithFeatureWeights`1" DisplayName="IPredictorWithFeatureWeights&lt;TResult&gt;" Kind="Interface" />
      <Type Name="LPEarlyStoppingCriterion" Kind="Class" />
      <Type Name="LPEarlyStoppingCriterion+Arguments" Kind="Class" />
      <Type Name="ModelParametersBase`1" DisplayName="ModelParametersBase&lt;TOutput&gt;" Kind="Class" />
      <Type Name="MovingWindowEarlyStoppingCriterion" Kind="Class" />
      <Type Name="MovingWindowEarlyStoppingCriterion+Arguments" Kind="Class" />
      <Type Name="PQEarlyStoppingCriterion" Kind="Class" />
      <Type Name="PQEarlyStoppingCriterion+Arguments" Kind="Class" />
      <Type Name="PredictionUtil" Kind="Class" />
      <Type Name="ReverseComparer`1" DisplayName="ReverseComparer&lt;T&gt;" Kind="Class" />
      <Type Name="SignatureEarlyStoppingCriterion" Kind="Delegate" />
      <Type Name="SignatureFeatureScorerTrainer" Kind="Delegate" />
      <Type Name="SignaturePredictorFromFile" Kind="Delegate" />
      <Type Name="SlotDropper" Kind="Class" />
      <Type Name="TGUIAttribute" Kind="Class" />
      <Type Name="TolerantEarlyStoppingCriterion" Kind="Class" />
      <Type Name="TolerantEarlyStoppingCriterion+Arguments" Kind="Class" />
      <Type Name="TypeUtils" Kind="Class" />
      <Type Name="UPEarlyStoppingCriterion" Kind="Class" />
      <Type Name="UPEarlyStoppingCriterion+Arguments" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Internal.Internallearn.ResultProcessor">
      <Type Name="ExperimentItemResult" Kind="Structure" />
      <Type Name="PredictorResult" Kind="Class" />
      <Type Name="ResultMetric" Kind="Class" />
      <Type Name="ResultProcessor" Kind="Class" />
      <Type Name="ResultProcessorArguments" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Learners">
      <Type Name="CoefficientStatistics" Kind="Structure" />
      <Type Name="ComputeLRTrainingStd" Kind="Class" />
      <Type Name="ComputeLRTrainingStdThroughHal" Kind="Class" />
      <Type Name="LbfgsTrainerBase`3" DisplayName="LbfgsTrainerBase&lt;TArgs,TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="LbfgsTrainerBase`3+ArgumentsBase" DisplayName="LbfgsTrainerBase&lt;TArgs,TTransformer,TModel&gt;+ArgumentsBase" Kind="Class" />
      <Type Name="LinearBinaryModelParameters" Kind="Class" />
      <Type Name="LinearModelParameters" Kind="Class" />
      <Type Name="LinearModelStatistics" Kind="Class" />
      <Type Name="LinearRegressionModelParameters" Kind="Class" />
      <Type Name="LogisticRegression" Kind="Class" />
      <Type Name="LogisticRegression+Arguments" Kind="Class" />
      <Type Name="MetaMulticlassTrainer`2" DisplayName="MetaMulticlassTrainer&lt;TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="MetaMulticlassTrainer`2+ArgumentsBase" DisplayName="MetaMulticlassTrainer&lt;TTransformer,TModel&gt;+ArgumentsBase" Kind="Class" />
      <Type Name="MulticlassLogisticRegression" Kind="Class" />
      <Type Name="MulticlassLogisticRegression+Arguments" Kind="Class" />
      <Type Name="MulticlassLogisticRegressionModelParameters" Kind="Class" />
      <Type Name="PoissonRegressionModelParameters" Kind="Class" />
      <Type Name="RegressionModelParameters" Kind="Class" />
      <Type Name="StochasticTrainerBase`2" DisplayName="StochasticTrainerBase&lt;TTransformer,TModel&gt;" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Legacy">
    </Namespace>
    <Namespace Name="Microsoft.ML.Legacy.Data">
    </Namespace>
    <Namespace Name="Microsoft.ML.Legacy.Models">
    </Namespace>
    <Namespace Name="Microsoft.ML.Legacy.TimeSeriesProcessing">
    </Namespace>
    <Namespace Name="Microsoft.ML.Legacy.Trainers">
    </Namespace>
    <Namespace Name="Microsoft.ML.Legacy.Transforms">
    </Namespace>
    <Namespace Name="Microsoft.ML.LightGBM">
      <Type Name="AllgatherFunction" Kind="Delegate" />
      <Type Name="IBoosterParameter" Kind="Interface" />
      <Type Name="IParallel" Kind="Interface" />
      <Type Name="ISupportBoosterParameterFactory" Kind="Interface" />
      <Type Name="ISupportParallel" Kind="Interface" />
      <Type Name="LightGbm" Kind="Class" />
      <Type Name="LightGbmArguments" Kind="Class" />
      <Type Name="LightGbmArguments+BoosterParameter`1" DisplayName="LightGbmArguments+BoosterParameter&lt;TArgs&gt;" Kind="Class" />
      <Type Name="LightGbmArguments+DartBooster" Kind="Class" />
      <Type Name="LightGbmArguments+DartBooster+Arguments" Kind="Class" />
      <Type Name="LightGbmArguments+EvalMetricType" Kind="Enumeration" />
      <Type Name="LightGbmArguments+GossBooster" Kind="Class" />
      <Type Name="LightGbmArguments+GossBooster+Arguments" Kind="Class" />
      <Type Name="LightGbmArguments+TreeBooster" Kind="Class" />
      <Type Name="LightGbmArguments+TreeBooster+Arguments" Kind="Class" />
      <Type Name="LightGbmBinaryModelParameters" Kind="Class" />
      <Type Name="LightGbmBinaryTrainer" Kind="Class" />
      <Type Name="LightGbmMulticlassTrainer" Kind="Class" />
      <Type Name="LightGbmRankingModelParameters" Kind="Class" />
      <Type Name="LightGbmRankingTrainer" Kind="Class" />
      <Type Name="LightGbmRegressionModelParameters" Kind="Class" />
      <Type Name="LightGbmRegressorTrainer" Kind="Class" />
      <Type Name="LightGbmTrainerBase`3" DisplayName="LightGbmTrainerBase&lt;TOutput,TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="ReduceFunction" Kind="Delegate" />
      <Type Name="ReduceScatterFunction" Kind="Delegate" />
      <Type Name="SignatureLightGBMBooster" Kind="Delegate" />
      <Type Name="SignatureParallelTrainer" Kind="Delegate" />
      <Type Name="SingleTrainer" Kind="Class" />
      <Type Name="SingleTrainerFactory" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Model">
      <Type Name="ICanSaveInBinaryFormat" Kind="Interface" />
      <Type Name="ICanSaveModel" Kind="Interface" />
      <Type Name="ModelLoadContext" Kind="Class" />
      <Type Name="ModelSaveContext" Kind="Class" />
      <Type Name="Repository" Kind="Class" />
      <Type Name="Repository+Entry" Kind="Class" />
      <Type Name="RepositoryReader" Kind="Class" />
      <Type Name="RepositoryWriter" Kind="Class" />
      <Type Name="SignatureLoadModel" Kind="Delegate" />
      <Type Name="VersionInfo" Kind="Structure" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Model.Onnx">
      <Type Name="OnnxNode" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Models">
    </Namespace>
    <Namespace Name="Microsoft.ML.Numeric">
      <Type Name="BacktrackingLineSearch" Kind="Class" />
      <Type Name="CubicInterpLineSearch" Kind="Class" />
      <Type Name="DifferentiableFunction" Kind="Delegate" />
      <Type Name="DifferentiableFunctionAggregator" Kind="Class" />
      <Type Name="DiffFunc1D" Kind="Delegate" />
      <Type Name="DTerminate" Kind="Delegate" />
      <Type Name="GDOptimizer" Kind="Class" />
      <Type Name="GoldenSectionSearch" Kind="Class" />
      <Type Name="GradientCheckingMonitor" Kind="Class" />
      <Type Name="GradientTester" Kind="Class" />
      <Type Name="IDiffLineSearch" Kind="Interface" />
      <Type Name="ILineSearch" Kind="Interface" />
      <Type Name="IndexedDifferentiableFunction" Kind="Delegate" />
      <Type Name="ITerminationCriterion" Kind="Interface" />
      <Type Name="L1Optimizer" Kind="Class" />
      <Type Name="L1Optimizer+L1OptimizerState" Kind="Class" />
      <Type Name="MeanImprovementCriterion" Kind="Class" />
      <Type Name="MeanRelativeImprovementCriterion" Kind="Class" />
      <Type Name="Optimizer" Kind="Class" />
      <Type Name="Optimizer+OptimizerException" Kind="Class" />
      <Type Name="Optimizer+OptimizerState" Kind="Class" />
      <Type Name="Optimizer+PrematureConvergenceException" Kind="Class" />
      <Type Name="RelativeNormGradient" Kind="Class" />
      <Type Name="SgdOptimizer" Kind="Class" />
      <Type Name="SgdOptimizer+DStochasticGradient" Kind="Delegate" />
      <Type Name="SgdOptimizer+RateScheduleType" Kind="Enumeration" />
      <Type Name="StaticTerminationCriterion" Kind="Class" />
      <Type Name="UpperBoundOnDistanceWithL2" Kind="Class" />
      <Type Name="VectorUtils" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Api">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Command">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.CommandLine">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Data">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Data.Conversion">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Data.IO">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Data.IO.Zlib">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.DataPipe">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Ensemble">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Ensemble.EntryPoints">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Ensemble.OutputCombiners">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Ensemble.Selector">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Ensemble.Selector.DiversityMeasure">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Ensemble.Selector.FeatureSelector">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Ensemble.Selector.SubModelSelector">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Ensemble.Selector.SubsetSelector">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.EntryPoints">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.EntryPoints.CodeGen">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.EntryPoints.JsonUtils">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.FactorizationMachine">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.FastTree">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.FastTree.Internal">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.ImageAnalytics">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.ImageAnalytics.EntryPoints">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Internal.Calibration">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Internal.CpuMath">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Internal.Internallearn">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Internal.Internallearn.ResultProcessor">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Internal.IO">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Internal.Tools">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Internal.Utilities">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.KMeans">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Learners">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.LightGBM">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Model">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Model.Onnx">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Model.Pfa">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Numeric">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.PCA">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.PipelineInference">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Sweeper">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Sweeper.Algorithms">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.TextAnalytics">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.TimeSeriesProcessing">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Tools">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Training">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Transforms">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.TreePredictor">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.UniversalModelFormat.Onnx">
    </Namespace>
    <Namespace Name="Microsoft.ML.SamplesUtils">
      <Type Name="DatasetUtils" Kind="Class" />
      <Type Name="DatasetUtils+SampleInfertData" Kind="Class" />
      <Type Name="DatasetUtils+SampleInput" Kind="Class" />
      <Type Name="DatasetUtils+SampleSentimentData" Kind="Class" />
      <Type Name="DatasetUtils+SampleTopicsData" Kind="Class" />
      <Type Name="DatasetUtils+SampleVectorOfNumbersData" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.StaticPipe">
      <Type Name="AveragedPerceptronStaticExtensions" Kind="Class" />
      <Type Name="CategoricalHashStaticExtensions" Kind="Class" />
      <Type Name="CategoricalHashStaticExtensions+OneHotHashScalarOutputKind" Kind="Enumeration" />
      <Type Name="CategoricalHashStaticExtensions+OneHotHashVectorOutputKind" Kind="Enumeration" />
      <Type Name="CategoricalStaticExtensions" Kind="Class" />
      <Type Name="CategoricalStaticExtensions+OneHotScalarOutputKind" Kind="Enumeration" />
      <Type Name="CategoricalStaticExtensions+OneHotVectorOutputKind" Kind="Enumeration" />
      <Type Name="CharacterTokenizerStaticExtensions" Kind="Class" />
      <Type Name="ConcatStaticExtensions" Kind="Class" />
      <Type Name="ConcatStaticExtensions+ScalarOrVector`1" DisplayName="ConcatStaticExtensions+ScalarOrVector&lt;T&gt;" Kind="Class" />
      <Type Name="ConcatStaticExtensions+ScalarOrVectorOrVarVector`1" DisplayName="ConcatStaticExtensions+ScalarOrVectorOrVarVector&lt;T&gt;" Kind="Class" />
      <Type Name="ConvertStaticExtensions" Kind="Class" />
      <Type Name="CountFeatureSelectorStaticExtensions" Kind="Class" />
      <Type Name="Custom`1" DisplayName="Custom&lt;T&gt;" Kind="Class" />
      <Type Name="DataLoadSaveOperationsExtensions" Kind="Class" />
      <Type Name="DataReader`2" DisplayName="DataReader&lt;TIn,TShape&gt;" Kind="Class" />
      <Type Name="DataReaderEstimator`3" DisplayName="DataReaderEstimator&lt;TIn,TShape,TDataReader&gt;" Kind="Class" />
      <Type Name="DataView`1" DisplayName="DataView&lt;TShape&gt;" Kind="Class" />
      <Type Name="DataViewExtensions" Kind="Class" />
      <Type Name="Estimator`3" DisplayName="Estimator&lt;TInShape,TOutShape,TTransformer&gt;" Kind="Class" />
      <Type Name="EvaluatorStaticExtensions" Kind="Class" />
      <Type Name="FactorizationMachineExtensions" Kind="Class" />
      <Type Name="GlobalContrastNormalizerStaticExtensions" Kind="Class" />
      <Type Name="ImageGreyScalingStaticExtensions" Kind="Class" />
      <Type Name="ImageLoadingStaticExtensions" Kind="Class" />
      <Type Name="ImagePixelExtractingStaticExtensions" Kind="Class" />
      <Type Name="ImageResizingStaticExtensions" Kind="Class" />
      <Type Name="ImageStaticPipe" Kind="Class" />
      <Type Name="IsShapeAttribute" Kind="Class" />
      <Type Name="Key`1" DisplayName="Key&lt;T&gt;" Kind="Class" />
      <Type Name="Key`2" DisplayName="Key&lt;T,TVal&gt;" Kind="Class" />
      <Type Name="KeyToBinaryVectorStaticExtensions" Kind="Class" />
      <Type Name="KeyToValueStaticExtensions" Kind="Class" />
      <Type Name="KeyToVectorStaticExtensions" Kind="Class" />
      <Type Name="KMeansClusteringExtensions" Kind="Class" />
      <Type Name="LbfgsBinaryClassificationStaticExtensions" Kind="Class" />
      <Type Name="LbfgsMulticlassExtensions" Kind="Class" />
      <Type Name="LbfgsRegressionExtensions" Kind="Class" />
      <Type Name="LdaFitResult" Kind="Class" />
      <Type Name="LdaFitResult+OnFit" Kind="Delegate" />
      <Type Name="LdaStaticExtensions" Kind="Class" />
      <Type Name="LocalPathReader" Kind="Class" />
      <Type Name="LpNormalizerStaticExtensions" Kind="Class" />
      <Type Name="MatrixFactorizationExtensions" Kind="Class" />
      <Type Name="MultiClassClassificationStaticExtensions" Kind="Class" />
      <Type Name="MutualInformationFeatureSelectorStaticExtensions" Kind="Class" />
      <Type Name="NAIndicatorStaticExtensions" Kind="Class" />
      <Type Name="NAReplacerStaticExtensions" Kind="Class" />
      <Type Name="NgramEstimatorStaticExtensions" Kind="Class" />
      <Type Name="NgramHashEstimatorStaticExtensions" Kind="Class" />
      <Type Name="NormalizerStaticExtensions" Kind="Class" />
      <Type Name="NormalizerStaticExtensions+OnFitAffine`1" DisplayName="NormalizerStaticExtensions+OnFitAffine&lt;TData&gt;" Kind="Delegate" />
      <Type Name="NormalizerStaticExtensions+OnFitBinned`1" DisplayName="NormalizerStaticExtensions+OnFitBinned&lt;TData&gt;" Kind="Delegate" />
      <Type Name="NormalizerStaticExtensions+OnFitCumulativeDistribution`1" DisplayName="NormalizerStaticExtensions+OnFitCumulativeDistribution&lt;TData&gt;" Kind="Delegate" />
      <Type Name="NormVector`1" DisplayName="NormVector&lt;T&gt;" Kind="Class" />
      <Type Name="OnlineGradientDescentExtensions" Kind="Class" />
      <Type Name="PcaEstimatorExtensions" Kind="Class" />
      <Type Name="PipelineColumn" Kind="Class" />
      <Type Name="RffStaticExtenensions" Kind="Class" />
      <Type Name="Scalar`1" DisplayName="Scalar&lt;T&gt;" Kind="Class" />
      <Type Name="SchemaBearing`1" DisplayName="SchemaBearing&lt;TShape&gt;" Kind="Class" />
      <Type Name="SdcaStaticExtensions" Kind="Class" />
      <Type Name="SgdStaticExtensions" Kind="Class" />
      <Type Name="StaticPipeExtensions" Kind="Class" />
      <Type Name="StopwordRemoverStaticExtensions" Kind="Class" />
      <Type Name="TermStaticExtensions" Kind="Class" />
      <Type Name="TextFeaturizerStaticExtensions" Kind="Class" />
      <Type Name="TextLoaderStatic" Kind="Class" />
      <Type Name="TextLoaderStatic+Context" Kind="Class" />
      <Type Name="TextNormalizerStaticExtensions" Kind="Class" />
      <Type Name="TrainingStaticExtensions" Kind="Class" />
      <Type Name="Transformer`3" DisplayName="Transformer&lt;TInShape,TOutShape,TTransformer&gt;" Kind="Class" />
      <Type Name="TreeRegressionExtensions" Kind="Class" />
      <Type Name="UnknownSizeBitmap" Kind="Class" />
      <Type Name="VarKey`1" DisplayName="VarKey&lt;T&gt;" Kind="Class" />
      <Type Name="VarVector`1" DisplayName="VarVector&lt;T&gt;" Kind="Class" />
      <Type Name="Vector`1" DisplayName="Vector&lt;T&gt;" Kind="Class" />
      <Type Name="WordBagEstimatorStaticExtensions" Kind="Class" />
      <Type Name="WordEmbeddingsStaticExtensions" Kind="Class" />
      <Type Name="WordHashBagEstimatorStaticExtensions" Kind="Class" />
      <Type Name="WordTokenizerStaticExtensions" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.StaticPipe.Runtime">
      <Type Name="EstimatorReconciler" Kind="Class" />
      <Type Name="ReaderReconciler`1" DisplayName="ReaderReconciler&lt;TIn&gt;" Kind="Class" />
      <Type Name="Reconciler" Kind="Class" />
      <Type Name="SchemaAssertionContext" Kind="Class" />
      <Type Name="SchemaAssertionContext+KeyTypeSelectorAssertions`1" DisplayName="SchemaAssertionContext+KeyTypeSelectorAssertions&lt;T&gt;" Kind="Structure" />
      <Type Name="SchemaAssertionContext+KeyTypeVectorAssertions`1" DisplayName="SchemaAssertionContext+KeyTypeVectorAssertions&lt;T&gt;" Kind="Structure" />
      <Type Name="SchemaAssertionContext+NormalizableTypeAssertions`1" DisplayName="SchemaAssertionContext+NormalizableTypeAssertions&lt;T&gt;" Kind="Structure" />
      <Type Name="SchemaAssertionContext+PrimitiveTypeAssertions`1" DisplayName="SchemaAssertionContext+PrimitiveTypeAssertions&lt;T&gt;" Kind="Structure" />
      <Type Name="StaticPipeUtils" Kind="Class" />
      <Type Name="StaticPipeUtils+IndexHelper`1" DisplayName="StaticPipeUtils+IndexHelper&lt;T&gt;" Kind="Class" />
      <Type Name="TrainerEstimatorReconciler" Kind="Class" />
      <Type Name="TrainerEstimatorReconciler+BinaryClassifier" Kind="Class" />
      <Type Name="TrainerEstimatorReconciler+BinaryClassifier+EstimatorFactory" Kind="Delegate" />
      <Type Name="TrainerEstimatorReconciler+BinaryClassifierNoCalibration" Kind="Class" />
      <Type Name="TrainerEstimatorReconciler+BinaryClassifierNoCalibration+EstimatorFactory" Kind="Delegate" />
      <Type Name="TrainerEstimatorReconciler+Clustering" Kind="Class" />
      <Type Name="TrainerEstimatorReconciler+Clustering+EstimatorFactory" Kind="Delegate" />
      <Type Name="TrainerEstimatorReconciler+MulticlassClassifier`1" DisplayName="TrainerEstimatorReconciler+MulticlassClassifier&lt;TVal&gt;" Kind="Class" />
      <Type Name="TrainerEstimatorReconciler+MulticlassClassifier`1+EstimatorFactory" DisplayName="TrainerEstimatorReconciler+MulticlassClassifier&lt;TVal&gt;+EstimatorFactory" Kind="Delegate" />
      <Type Name="TrainerEstimatorReconciler+Ranker`1" DisplayName="TrainerEstimatorReconciler+Ranker&lt;TVal&gt;" Kind="Class" />
      <Type Name="TrainerEstimatorReconciler+Ranker`1+EstimatorFactory" DisplayName="TrainerEstimatorReconciler+Ranker&lt;TVal&gt;+EstimatorFactory" Kind="Delegate" />
      <Type Name="TrainerEstimatorReconciler+Regression" Kind="Class" />
      <Type Name="TrainerEstimatorReconciler+Regression+EstimatorFactory" Kind="Delegate" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Sweeper">
      <Type Name="BaseParamArguments" Kind="Class" />
      <Type Name="DeterministicSweeperAsync" Kind="Class" />
      <Type Name="DeterministicSweeperAsync+Arguments" Kind="Class" />
      <Type Name="DiscreteParamArguments" Kind="Class" />
      <Type Name="DiscreteValueGenerator" Kind="Class" />
      <Type Name="ExeConfigRunnerBase" Kind="Class" />
      <Type Name="ExeConfigRunnerBase+ArgumentsBase" Kind="Class" />
      <Type Name="FloatParamArguments" Kind="Class" />
      <Type Name="FloatParameterValue" Kind="Class" />
      <Type Name="FloatValueGenerator" Kind="Class" />
      <Type Name="IAsyncSweeper" Kind="Interface" />
      <Type Name="IConfigRunner" Kind="Interface" />
      <Type Name="InternalSweepResultEvaluator" Kind="Class" />
      <Type Name="InternalSweepResultEvaluator+Arguments" Kind="Class" />
      <Type Name="INumericValueGenerator" Kind="Interface" />
      <Type Name="LocalExeConfigRunner" Kind="Class" />
      <Type Name="LocalExeConfigRunner+Arguments" Kind="Class" />
      <Type Name="LongParamArguments" Kind="Class" />
      <Type Name="LongParameterValue" Kind="Class" />
      <Type Name="LongValueGenerator" Kind="Class" />
      <Type Name="NelderMeadSweeper" Kind="Class" />
      <Type Name="NelderMeadSweeper+Arguments" Kind="Class" />
      <Type Name="NumericParamArguments" Kind="Class" />
      <Type Name="ParameterSetWithId" Kind="Class" />
      <Type Name="RandomGridSweeper" Kind="Class" />
      <Type Name="RandomGridSweeper+Arguments" Kind="Class" />
      <Type Name="SignatureAsyncSweeper" Kind="Delegate" />
      <Type Name="SignatureConfigRunner" Kind="Delegate" />
      <Type Name="SignatureSweeperFromParameterList" Kind="Delegate" />
      <Type Name="SignatureSweeperParameter" Kind="Delegate" />
      <Type Name="SimpleAsyncSweeper" Kind="Class" />
      <Type Name="SmacSweeper" Kind="Class" />
      <Type Name="SmacSweeper+Arguments" Kind="Class" />
      <Type Name="StringParameterValue" Kind="Class" />
      <Type Name="SuggestedSweepsParser" Kind="Class" />
      <Type Name="SweeperBase" Kind="Class" />
      <Type Name="SweeperBase+ArgumentsBase" Kind="Class" />
      <Type Name="SynthConfigRunner" Kind="Class" />
      <Type Name="SynthConfigRunner+Arguments" Kind="Class" />
      <Type Name="UniformRandomSweeper" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Sweeper.Algorithms">
      <Type Name="KdoSweeper" Kind="Class" />
      <Type Name="KdoSweeper+Arguments" Kind="Class" />
      <Type Name="SweeperProbabilityUtils" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.TimeSeries">
      <Type Name="PredictionFunctionExtensions" Kind="Class" />
      <Type Name="TimeSeriesPredictionFunction`2" DisplayName="TimeSeriesPredictionFunction&lt;TSrc,TDst&gt;" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.TimeSeriesProcessing">
      <Type Name="AdaptiveSingularSpectrumSequenceModeler" Kind="Class" />
      <Type Name="AdaptiveSingularSpectrumSequenceModeler+GrowthRatio" Kind="Structure" />
      <Type Name="AdaptiveSingularSpectrumSequenceModeler+ModelInfo" Kind="Class" />
      <Type Name="AdaptiveSingularSpectrumSequenceModeler+RankSelectionMethod" Kind="Enumeration" />
      <Type Name="AdaptiveSingularSpectrumSequenceModeler+SsaForecastResult" Kind="Class" />
      <Type Name="EigenUtils" Kind="Class" />
      <Type Name="EigenUtils+Compz" Kind="Enumeration" />
      <Type Name="EigenUtils+Job" Kind="Enumeration" />
      <Type Name="EigenUtils+Layout" Kind="Enumeration" />
      <Type Name="EigenUtils+Uplo" Kind="Enumeration" />
      <Type Name="ErrorFunctionUtils" Kind="Class" />
      <Type Name="ErrorFunctionUtils+ErrorFunction" Kind="Enumeration" />
      <Type Name="ExponentialAverageTransform" Kind="Class" />
      <Type Name="ExponentialAverageTransform+Arguments" Kind="Class" />
      <Type Name="ExponentialAverageTransform+State" Kind="Class" />
      <Type Name="ForecastResultBase`1" DisplayName="ForecastResultBase&lt;T&gt;" Kind="Class" />
      <Type Name="IidAnomalyDetectionBase" Kind="Class" />
      <Type Name="IidAnomalyDetectionBase+State" Kind="Class" />
      <Type Name="IidChangePointDetector" Kind="Class" />
      <Type Name="IidChangePointDetector+Arguments" Kind="Class" />
      <Type Name="IidChangePointEstimator" Kind="Class" />
      <Type Name="IidSpikeDetector" Kind="Class" />
      <Type Name="IidSpikeDetector+Arguments" Kind="Class" />
      <Type Name="IidSpikeEstimator" Kind="Class" />
      <Type Name="MovingAverageTransform" Kind="Class" />
      <Type Name="MovingAverageTransform+Arguments" Kind="Class" />
      <Type Name="MovingAverageTransform+State" Kind="Class" />
      <Type Name="PercentileThresholdTransform" Kind="Class" />
      <Type Name="PercentileThresholdTransform+Arguments" Kind="Class" />
      <Type Name="PercentileThresholdTransform+State" Kind="Class" />
      <Type Name="PolynomialUtils" Kind="Class" />
      <Type Name="PValueTransform" Kind="Class" />
      <Type Name="PValueTransform+Arguments" Kind="Class" />
      <Type Name="PValueTransform+State" Kind="Class" />
      <Type Name="SequenceModelerBase`2" DisplayName="SequenceModelerBase&lt;TInput,TOutput&gt;" Kind="Class" />
      <Type Name="SequentialAnomalyDetectionTransformBase`2" DisplayName="SequentialAnomalyDetectionTransformBase&lt;TInput,TState&gt;" Kind="Class" />
      <Type Name="SequentialAnomalyDetectionTransformBase`2+AlertingScore" DisplayName="SequentialAnomalyDetectionTransformBase&lt;TInput,TState&gt;+AlertingScore" Kind="Enumeration" />
      <Type Name="SequentialAnomalyDetectionTransformBase`2+AnomalyDetectionStateBase" DisplayName="SequentialAnomalyDetectionTransformBase&lt;TInput,TState&gt;+AnomalyDetectionStateBase" Kind="Class" />
      <Type Name="SequentialAnomalyDetectionTransformBase`2+AnomalySide" DisplayName="SequentialAnomalyDetectionTransformBase&lt;TInput,TState&gt;+AnomalySide" Kind="Enumeration" />
      <Type Name="SequentialAnomalyDetectionTransformBase`2+ArgumentsBase" DisplayName="SequentialAnomalyDetectionTransformBase&lt;TInput,TState&gt;+ArgumentsBase" Kind="Class" />
      <Type Name="SequentialAnomalyDetectionTransformBase`2+MartingaleType" DisplayName="SequentialAnomalyDetectionTransformBase&lt;TInput,TState&gt;+MartingaleType" Kind="Enumeration" />
      <Type Name="SequentialTransformBase`3" DisplayName="SequentialTransformBase&lt;TInput,TOutput,TState&gt;" Kind="Class" />
      <Type Name="SequentialTransformBase`3+StateBase" DisplayName="SequentialTransformBase&lt;TInput,TOutput,TState&gt;+StateBase" Kind="Class" />
      <Type Name="SequentialTransformerBase`3" DisplayName="SequentialTransformerBase&lt;TInput,TOutput,TState&gt;" Kind="Class" />
      <Type Name="SequentialTransformerBase`3+StateBase" DisplayName="SequentialTransformerBase&lt;TInput,TOutput,TState&gt;+StateBase" Kind="Class" />
      <Type Name="SlidingWindowTransform" Kind="Class" />
      <Type Name="SlidingWindowTransformBase`1" DisplayName="SlidingWindowTransformBase&lt;TInput&gt;" Kind="Class" />
      <Type Name="SlidingWindowTransformBase`1+Arguments" DisplayName="SlidingWindowTransformBase&lt;TInput&gt;+Arguments" Kind="Class" />
      <Type Name="SlidingWindowTransformBase`1+BeginOptions" DisplayName="SlidingWindowTransformBase&lt;TInput&gt;+BeginOptions" Kind="Enumeration" />
      <Type Name="SlidingWindowTransformBase`1+StateSlide" DisplayName="SlidingWindowTransformBase&lt;TInput&gt;+StateSlide" Kind="Class" />
      <Type Name="SsaAnomalyDetectionBase" Kind="Class" />
      <Type Name="SsaAnomalyDetectionBase+SsaArguments" Kind="Class" />
      <Type Name="SsaAnomalyDetectionBase+State" Kind="Class" />
      <Type Name="SsaChangePointDetector" Kind="Class" />
      <Type Name="SsaChangePointDetector+Arguments" Kind="Class" />
      <Type Name="SsaChangePointEstimator" Kind="Class" />
      <Type Name="SsaSpikeDetector" Kind="Class" />
      <Type Name="SsaSpikeDetector+Arguments" Kind="Class" />
      <Type Name="SsaSpikeEstimator" Kind="Class" />
      <Type Name="TimeSeriesProcessingEntryPoints" Kind="Class" />
      <Type Name="TrajectoryMatrix" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Tools">
      <Type Name="Maml" Kind="Class" />
      <Type Name="SignatureModuleGenerator" Kind="Delegate" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Trainers">
      <Type Name="LinearTrainerBase`2" DisplayName="LinearTrainerBase&lt;TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="MatrixFactorizationTrainer" Kind="Class" />
      <Type Name="MatrixFactorizationTrainer+Arguments" Kind="Class" />
      <Type Name="MatrixFactorizationTrainer+LossFunctionType" Kind="Enumeration" />
      <Type Name="MultiClassNaiveBayesModelParameters" Kind="Class" />
      <Type Name="MultiClassNaiveBayesTrainer" Kind="Class" />
      <Type Name="MultiClassNaiveBayesTrainer+Arguments" Kind="Class" />
      <Type Name="Ova" Kind="Class" />
      <Type Name="Ova+Arguments" Kind="Class" />
      <Type Name="OvaModelParameters" Kind="Class" />
      <Type Name="OvaModelParameters+OutputFormula" Kind="Enumeration" />
      <Type Name="Pkpd" Kind="Class" />
      <Type Name="Pkpd+Arguments" Kind="Class" />
      <Type Name="PkpdModelParameters" Kind="Class" />
      <Type Name="PoissonRegression" Kind="Class" />
      <Type Name="PoissonRegression+Arguments" Kind="Class" />
      <Type Name="PriorModelParameters" Kind="Class" />
      <Type Name="PriorTrainer" Kind="Class" />
      <Type Name="PriorTrainer+Arguments" Kind="Class" />
      <Type Name="RandomModelParameters" Kind="Class" />
      <Type Name="RandomTrainer" Kind="Class" />
      <Type Name="RandomTrainer+Arguments" Kind="Class" />
      <Type Name="Sdca" Kind="Class" />
      <Type Name="SdcaBinaryTrainer" Kind="Class" />
      <Type Name="SdcaBinaryTrainer+Arguments" Kind="Class" />
      <Type Name="SdcaMultiClassTrainer" Kind="Class" />
      <Type Name="SdcaMultiClassTrainer+Arguments" Kind="Class" />
      <Type Name="SdcaRegressionTrainer" Kind="Class" />
      <Type Name="SdcaRegressionTrainer+Arguments" Kind="Class" />
      <Type Name="SdcaTrainerBase`3" DisplayName="SdcaTrainerBase&lt;TArgs,TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="SdcaTrainerBase`3+ArgumentsBase" DisplayName="SdcaTrainerBase&lt;TArgs,TTransformer,TModel&gt;+ArgumentsBase" Kind="Class" />
      <Type Name="SdcaTrainerBase`3+IdToIdxLookup" DisplayName="SdcaTrainerBase&lt;TArgs,TTransformer,TModel&gt;+IdToIdxLookup" Kind="Class" />
      <Type Name="SdcaTrainerBase`3+MetricKind" DisplayName="SdcaTrainerBase&lt;TArgs,TTransformer,TModel&gt;+MetricKind" Kind="Enumeration" />
      <Type Name="StochasticGradientDescentClassificationTrainer" Kind="Class" />
      <Type Name="StochasticGradientDescentClassificationTrainer+Arguments" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Trainers.FastTree">
      <Type Name="BinaryClassificationGamModelParameters" Kind="Class" />
      <Type Name="BinaryClassificationGamTrainer" Kind="Class" />
      <Type Name="BinaryClassificationGamTrainer+Arguments" Kind="Class" />
      <Type Name="BoostedTreeArgs" Kind="Class" />
      <Type Name="BoostedTreeArgs+OptimizationAlgorithmType" Kind="Enumeration" />
      <Type Name="BoostingFastTreeTrainerBase`3" DisplayName="BoostingFastTreeTrainerBase&lt;TArgs,TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="Bundle" Kind="Enumeration" />
      <Type Name="FastForest" Kind="Class" />
      <Type Name="FastForestArgumentsBase" Kind="Class" />
      <Type Name="FastForestClassification" Kind="Class" />
      <Type Name="FastForestClassification+Arguments" Kind="Class" />
      <Type Name="FastForestClassificationModelParameters" Kind="Class" />
      <Type Name="FastForestRegression" Kind="Class" />
      <Type Name="FastForestRegression+Arguments" Kind="Class" />
      <Type Name="FastForestRegressionModelParameters" Kind="Class" />
      <Type Name="FastTree" Kind="Class" />
      <Type Name="FastTreeBinaryClassificationTrainer" Kind="Class" />
      <Type Name="FastTreeBinaryClassificationTrainer+Arguments" Kind="Class" />
      <Type Name="FastTreeBinaryModelParameters" Kind="Class" />
      <Type Name="FastTreeRankingModelParameters" Kind="Class" />
      <Type Name="FastTreeRankingTrainer" Kind="Class" />
      <Type Name="FastTreeRankingTrainer+Arguments" Kind="Class" />
      <Type Name="FastTreeRankingTrainer+LambdaRankObjectiveFunction" Kind="Class" />
      <Type Name="FastTreeRegressionModelParameters" Kind="Class" />
      <Type Name="FastTreeRegressionTrainer" Kind="Class" />
      <Type Name="FastTreeRegressionTrainer+Arguments" Kind="Class" />
      <Type Name="FastTreeTrainerBase`3" DisplayName="FastTreeTrainerBase&lt;TArgs,TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="FastTreeTweedieModelParameters" Kind="Class" />
      <Type Name="FastTreeTweedieTrainer" Kind="Class" />
      <Type Name="FastTreeTweedieTrainer+Arguments" Kind="Class" />
      <Type Name="FindBestThresholdFromRawArrayFun" Kind="Delegate" />
      <Type Name="Gam" Kind="Class" />
      <Type Name="GamModelParametersBase" Kind="Class" />
      <Type Name="GamTrainerBase`3" DisplayName="GamTrainerBase&lt;TArgs,TTransformer,TPredictor&gt;" Kind="Class" />
      <Type Name="GamTrainerBase`3+ArgumentsBase" DisplayName="GamTrainerBase&lt;TArgs,TTransformer,TPredictor&gt;+ArgumentsBase" Kind="Class" />
      <Type Name="IParallelTraining" Kind="Interface" />
      <Type Name="ISupportParallelTraining" Kind="Interface" />
      <Type Name="RandomForestTrainerBase`3" DisplayName="RandomForestTrainerBase&lt;TArgs,TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="RandomForestTrainerBase`3+RandomForestObjectiveFunction" DisplayName="RandomForestTrainerBase&lt;TArgs,TTransformer,TModel&gt;+RandomForestObjectiveFunction" Kind="Class" />
      <Type Name="RegressionGamModelParameters" Kind="Class" />
      <Type Name="RegressionGamTrainer" Kind="Class" />
      <Type Name="RegressionGamTrainer+Arguments" Kind="Class" />
      <Type Name="SignatureParallelTrainer" Kind="Delegate" />
      <Type Name="SignatureTreeEnsembleTrainer" Kind="Delegate" />
      <Type Name="SingleTrainer" Kind="Class" />
      <Type Name="SingleTrainerFactory" Kind="Class" />
      <Type Name="TreeArgs" Kind="Class" />
      <Type Name="TreeEnsembleModelParameters" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Trainers.FastTree.Internal">
      <Type Name="AcceleratedGradientDescent" Kind="Class" />
      <Type Name="AgdScoreTracker" Kind="Class" />
      <Type Name="Algorithms" Kind="Class" />
      <Type Name="BaggingProvider" Kind="Class" />
      <Type Name="BestStepRegressionGradientWrapper" Kind="Class" />
      <Type Name="BinaryClassificationTest" Kind="Class" />
      <Type Name="BlockingThreadPool" Kind="Class" />
      <Type Name="BufferPoolManager" Kind="Class" />
      <Type Name="ConjugateGradientDescent" Kind="Class" />
      <Type Name="CountEvent" Kind="Enumeration" />
      <Type Name="Dataset" Kind="Class" />
      <Type Name="Dataset+DatasetSkeleton" Kind="Class" />
      <Type Name="Dataset+DatasetSkeletonQueryDocData" Kind="Structure" />
      <Type Name="Dataset+DupeIdInfo" Kind="Enumeration" />
      <Type Name="Dataset+RowForwardIndexer" Kind="Class" />
      <Type Name="Dataset+RowForwardIndexer+Row" Kind="Structure" />
      <Type Name="DatasetUtils" Kind="Class" />
      <Type Name="DcgCalculator" Kind="Class" />
      <Type Name="DcgPermutationComparer" Kind="Class" />
      <Type Name="DcgPermutationComparerFactory" Kind="Class" />
      <Type Name="DescendingDotNetPermutationComparer" Kind="Class" />
      <Type Name="DescendingReversePermutationComparer" Kind="Class" />
      <Type Name="DescendingStableIdealComparer" Kind="Class" />
      <Type Name="DescendingStablePermutationComparer" Kind="Class" />
      <Type Name="DescendingStablePessimisticPermutationComparer" Kind="Class" />
      <Type Name="DocumentPartitioning" Kind="Class" />
      <Type Name="FastNdcgTest" Kind="Class" />
      <Type Name="FastNdcgTestForTrainSet" Kind="Class" />
      <Type Name="Feature" Kind="Class" />
      <Type Name="Feature+FeatureType" Kind="Enumeration" />
      <Type Name="FeatureFlockBase" Kind="Class" />
      <Type Name="FeatureFlockBase+FlockForwardIndexerBase" Kind="Class" />
      <Type Name="FeatureHistogram" Kind="Class" />
      <Type Name="FeatureToGainMap" Kind="Class" />
      <Type Name="GradientDescent" Kind="Class" />
      <Type Name="IEnsembleCompressor`1" DisplayName="IEnsembleCompressor&lt;TLabel&gt;" Kind="Interface" />
      <Type Name="IFastTrainingScoresUpdate" Kind="Interface" />
      <Type Name="IGradientAdjuster" Kind="Interface" />
      <Type Name="IIntArrayForwardIndexer" Kind="Interface" />
      <Type Name="IntArray" Kind="Class" />
      <Type Name="IntArrayBits" Kind="Enumeration" />
      <Type Name="IntArrayType" Kind="Enumeration" />
      <Type Name="IStepSearch" Kind="Interface" />
      <Type Name="IThreadTask" Kind="Interface" />
      <Type Name="LassoBasedEnsembleCompressor" Kind="Class" />
      <Type Name="LassoFit" Kind="Class" />
      <Type Name="LeastSquaresRegressionTreeLearner" Kind="Class" />
      <Type Name="LeastSquaresRegressionTreeLearner+LeafSplitCandidates" Kind="Class" />
      <Type Name="LeastSquaresRegressionTreeLearner+SplitInfo" Kind="Structure" />
      <Type Name="LineSearch" Kind="Class" />
      <Type Name="LinqExtensions" Kind="Class" />
      <Type Name="MappedObjectPool`1" DisplayName="MappedObjectPool&lt;T&gt;" Kind="Class" />
      <Type Name="MD5Hash" Kind="Structure" />
      <Type Name="MD5Hasher" Kind="Class" />
      <Type Name="NdcgTest" Kind="Class" />
      <Type Name="ObjectiveFunctionBase" Kind="Class" />
      <Type Name="OptimizationAlgorithm" Kind="Class" />
      <Type Name="OptimizationAlgorithm+PreScoreUpdateHandler" Kind="Delegate" />
      <Type Name="PerBinStats" Kind="Structure" />
      <Type Name="PseudorandomFunction" Kind="Class" />
      <Type Name="QuantileRegressionTree" Kind="Class" />
      <Type Name="QueryWeightsBestResressionStepGradientWrapper" Kind="Class" />
      <Type Name="QueryWeightsGradientWrapper" Kind="Class" />
      <Type Name="RandomForestLeastSquaresTreeLearner" Kind="Class" />
      <Type Name="RandomForestOptimizer" Kind="Class" />
      <Type Name="RankingBaggingProvider" Kind="Class" />
      <Type Name="RecursiveRegressionTree" Kind="Class" />
      <Type Name="RegressionTest" Kind="Class" />
      <Type Name="RegressionTree" Kind="Class" />
      <Type Name="RegressionTree+TreeType" Kind="Enumeration" />
      <Type Name="RegressionTreeNodeDocuments" Kind="Class" />
      <Type Name="ScoreTracker" Kind="Class" />
      <Type Name="ScoreTracker+ScoresUpdatedDelegate" Kind="Delegate" />
      <Type Name="StreamExtensions" Kind="Class" />
      <Type Name="SufficientStatsBase" Kind="Class" />
      <Type Name="SufficientStatsBase`1" DisplayName="SufficientStatsBase&lt;TSuffStats&gt;" Kind="Class" />
      <Type Name="SumupInputData" Kind="Class" />
      <Type Name="Test" Kind="Class" />
      <Type Name="TestHistory" Kind="Class" />
      <Type Name="TestResult" Kind="Class" />
      <Type Name="TestResult+ValueOperator" Kind="Enumeration" />
      <Type Name="TestWindowWithTolerance" Kind="Class" />
      <Type Name="Timer" Kind="Class" />
      <Type Name="Timer+TimedEvent" Kind="Class" />
      <Type Name="TimerEvent" Kind="Enumeration" />
      <Type Name="ToByteArrayExtensions" Kind="Class" />
      <Type Name="TreeEnsemble" Kind="Class" />
      <Type Name="TreeEnsembleCombiner" Kind="Class" />
      <Type Name="TreeLearner" Kind="Class" />
      <Type Name="TreeLearnerException" Kind="Class" />
      <Type Name="TrivialGradientWrapper" Kind="Class" />
      <Type Name="TsvFeature" Kind="Class" />
      <Type Name="VectorUtils" Kind="Class" />
      <Type Name="WinLossCalculator" Kind="Class" />
      <Type Name="WinLossSurplusTest" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Trainers.HalLearners">
      <Type Name="OlsLinearRegressionModelParameters" Kind="Class" />
      <Type Name="OlsLinearRegressionTrainer" Kind="Class" />
      <Type Name="OlsLinearRegressionTrainer+Arguments" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Trainers.KMeans">
      <Type Name="KMeansModelParameters" Kind="Class" />
      <Type Name="KMeansPlusPlusTrainer" Kind="Class" />
      <Type Name="KMeansPlusPlusTrainer+Arguments" Kind="Class" />
      <Type Name="KMeansPlusPlusTrainer+InitAlgorithm" Kind="Enumeration" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Trainers.Online">
      <Type Name="AveragedLinearArguments" Kind="Class" />
      <Type Name="AveragedLinearTrainer`2" DisplayName="AveragedLinearTrainer&lt;TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="AveragedPerceptronTrainer" Kind="Class" />
      <Type Name="AveragedPerceptronTrainer+Arguments" Kind="Class" />
      <Type Name="LinearSvmTrainer" Kind="Class" />
      <Type Name="LinearSvmTrainer+Arguments" Kind="Class" />
      <Type Name="OnlineGradientDescentTrainer" Kind="Class" />
      <Type Name="OnlineGradientDescentTrainer+Arguments" Kind="Class" />
      <Type Name="OnlineLinearArguments" Kind="Class" />
      <Type Name="OnlineLinearTrainer`2" DisplayName="OnlineLinearTrainer&lt;TTransformer,TModel&gt;" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Trainers.PCA">
      <Type Name="PcaModelParameters" Kind="Class" />
      <Type Name="RandomizedPcaTrainer" Kind="Class" />
      <Type Name="RandomizedPcaTrainer+Arguments" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Trainers.Recommender">
      <Type Name="MatrixFactorizationPredictionTransformer" Kind="Class" />
      <Type Name="MatrixFactorizationPredictor" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Trainers.SymSgd">
      <Type Name="SymSgdClassificationTrainer" Kind="Class" />
      <Type Name="SymSgdClassificationTrainer+Arguments" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Training">
      <Type Name="CursOpt" Kind="Enumeration" />
      <Type Name="ITrainerEstimator`2" DisplayName="ITrainerEstimator&lt;TTransformer,TPredictor&gt;" Kind="Interface" />
      <Type Name="TrainerBase`1" DisplayName="TrainerBase&lt;TPredictor&gt;" Kind="Class" />
      <Type Name="TrainerEstimatorBase`2" DisplayName="TrainerEstimatorBase&lt;TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="TrainerEstimatorBaseWithGroupId`2" DisplayName="TrainerEstimatorBaseWithGroupId&lt;TTransformer,TModel&gt;" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Transforms">
      <Type Name="AlexNetExtension" Kind="Class" />
      <Type Name="BootstrapSample" Kind="Class" />
      <Type Name="BootstrapSamplingTransformer" Kind="Class" />
      <Type Name="BootstrapSamplingTransformer+Arguments" Kind="Class" />
      <Type Name="ColumnConcatenatingEstimator" Kind="Class" />
      <Type Name="ColumnCopyingEstimator" Kind="Class" />
      <Type Name="ColumnCopyingTransformer" Kind="Class" />
      <Type Name="ColumnCopyingTransformer+Arguments" Kind="Class" />
      <Type Name="ColumnCopyingTransformer+Column" Kind="Class" />
      <Type Name="ColumnSelectingEstimator" Kind="Class" />
      <Type Name="ColumnSelectingTransformer" Kind="Class" />
      <Type Name="ColumnSelectingTransformer+Arguments" Kind="Class" />
      <Type Name="CompositeTransformer" Kind="Class" />
      <Type Name="CustomMappingEstimator`2" DisplayName="CustomMappingEstimator&lt;TSrc,TDst&gt;" Kind="Class" />
      <Type Name="CustomMappingTransformer`2" DisplayName="CustomMappingTransformer&lt;TSrc,TDst&gt;" Kind="Class" />
      <Type Name="DnnImageFeaturizerEstimator" Kind="Class" />
      <Type Name="DnnImageFeaturizerInput" Kind="Class" />
      <Type Name="DnnImageModelSelector" Kind="Class" />
      <Type Name="GaussianFourierSampler" Kind="Class" />
      <Type Name="GaussianFourierSampler+Arguments" Kind="Class" />
      <Type Name="GenerateNumberTransform" Kind="Class" />
      <Type Name="GenerateNumberTransform+Arguments" Kind="Class" />
      <Type Name="GenerateNumberTransform+Column" Kind="Class" />
      <Type Name="GroupingOperations" Kind="Class" />
      <Type Name="GroupTransform" Kind="Class" />
      <Type Name="GroupTransform+Arguments" Kind="Class" />
      <Type Name="IFourierDistributionSampler" Kind="Interface" />
      <Type Name="IFourierDistributionSamplerFactory" Kind="Interface" />
      <Type Name="LabelConvertTransform" Kind="Class" />
      <Type Name="LabelConvertTransform+Arguments" Kind="Class" />
      <Type Name="LabelConvertTransform+Column" Kind="Class" />
      <Type Name="LabelIndicatorTransform" Kind="Class" />
      <Type Name="LabelIndicatorTransform+Arguments" Kind="Class" />
      <Type Name="LabelIndicatorTransform+Column" Kind="Class" />
      <Type Name="LambdaTransform" Kind="Class" />
      <Type Name="LambdaTransform+LoadDelegate" Kind="Delegate" />
      <Type Name="LaplacianFourierSampler" Kind="Class" />
      <Type Name="LaplacianFourierSampler+Arguments" Kind="Class" />
      <Type Name="LoadTransform" Kind="Class" />
      <Type Name="LoadTransform+Arguments" Kind="Class" />
      <Type Name="MissingValueDroppingEstimator" Kind="Class" />
      <Type Name="MissingValueDroppingTransformer" Kind="Class" />
      <Type Name="MissingValueDroppingTransformer+Arguments" Kind="Class" />
      <Type Name="MissingValueDroppingTransformer+Column" Kind="Class" />
      <Type Name="MissingValueHandlingTransformer" Kind="Class" />
      <Type Name="MissingValueHandlingTransformer+Arguments" Kind="Class" />
      <Type Name="MissingValueHandlingTransformer+Column" Kind="Class" />
      <Type Name="MissingValueHandlingTransformer+ReplacementKind" Kind="Enumeration" />
      <Type Name="MissingValueIndicatorEstimator" Kind="Class" />
      <Type Name="MissingValueIndicatorTransform" Kind="Class" />
      <Type Name="MissingValueIndicatorTransform+Arguments" Kind="Class" />
      <Type Name="MissingValueIndicatorTransform+Column" Kind="Class" />
      <Type Name="MissingValueIndicatorTransformer" Kind="Class" />
      <Type Name="MissingValueIndicatorTransformer+Arguments" Kind="Class" />
      <Type Name="MissingValueIndicatorTransformer+Column" Kind="Class" />
      <Type Name="MissingValueReplacingEstimator" Kind="Class" />
      <Type Name="MissingValueReplacingEstimator+Defaults" Kind="Class" />
      <Type Name="MissingValueReplacingTransformer" Kind="Class" />
      <Type Name="MissingValueReplacingTransformer+Arguments" Kind="Class" />
      <Type Name="MissingValueReplacingTransformer+Column" Kind="Class" />
      <Type Name="MissingValueReplacingTransformer+ColumnInfo" Kind="Class" />
      <Type Name="MissingValueReplacingTransformer+ColumnInfo+ReplacementMode" Kind="Enumeration" />
      <Type Name="MissingValueReplacingTransformer+ReplacementKind" Kind="Enumeration" />
      <Type Name="NAFilter" Kind="Class" />
      <Type Name="NAFilter+Arguments" Kind="Class" />
      <Type Name="NAHandling" Kind="Class" />
      <Type Name="OnnxScoringEstimator" Kind="Class" />
      <Type Name="OnnxTransform" Kind="Class" />
      <Type Name="OnnxTransform+Arguments" Kind="Class" />
      <Type Name="OptionalColumnTransform" Kind="Class" />
      <Type Name="OptionalColumnTransform+Arguments" Kind="Class" />
      <Type Name="ProduceIdTransform" Kind="Class" />
      <Type Name="ProduceIdTransform+Arguments" Kind="Class" />
      <Type Name="RandomNumberGenerator" Kind="Class" />
      <Type Name="RangeFilter" Kind="Class" />
      <Type Name="RangeFilter+Arguments" Kind="Class" />
      <Type Name="ResNet101Extension" Kind="Class" />
      <Type Name="ResNet18Extension" Kind="Class" />
      <Type Name="ResNet50Extension" Kind="Class" />
      <Type Name="RowShufflingTransformer" Kind="Class" />
      <Type Name="RowShufflingTransformer+Arguments" Kind="Class" />
      <Type Name="SelectFeatures" Kind="Class" />
      <Type Name="SignatureFourierDistributionSampler" Kind="Delegate" />
      <Type Name="SkipFilter" Kind="Class" />
      <Type Name="SkipTakeFilter" Kind="Class" />
      <Type Name="SkipTakeFilter+Arguments" Kind="Class" />
      <Type Name="SkipTakeFilter+SkipArguments" Kind="Class" />
      <Type Name="SkipTakeFilter+TakeArguments" Kind="Class" />
      <Type Name="TakeFilter" Kind="Class" />
      <Type Name="TensorFlowEstimator" Kind="Class" />
      <Type Name="TensorFlowModelInfo" Kind="Class" />
      <Type Name="TensorFlowTransform" Kind="Class" />
      <Type Name="TensorFlowTransform+Arguments" Kind="Class" />
      <Type Name="UngroupTransform" Kind="Class" />
      <Type Name="UngroupTransform+Arguments" Kind="Class" />
      <Type Name="UngroupTransform+UngroupMode" Kind="Enumeration" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Transforms.Categorical">
      <Type Name="Categorical" Kind="Class" />
      <Type Name="OneHotEncodingEstimator" Kind="Class" />
      <Type Name="OneHotEncodingEstimator+ColumnInfo" Kind="Class" />
      <Type Name="OneHotEncodingTransformer" Kind="Class" />
      <Type Name="OneHotEncodingTransformer+Arguments" Kind="Class" />
      <Type Name="OneHotEncodingTransformer+Column" Kind="Class" />
      <Type Name="OneHotEncodingTransformer+OutputKind" Kind="Enumeration" />
      <Type Name="OneHotHashEncoding" Kind="Class" />
      <Type Name="OneHotHashEncoding+Arguments" Kind="Class" />
      <Type Name="OneHotHashEncoding+Column" Kind="Class" />
      <Type Name="OneHotHashEncodingEstimator" Kind="Class" />
      <Type Name="OneHotHashEncodingEstimator+ColumnInfo" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Transforms.Conversions">
      <Type Name="HashingEstimator" Kind="Class" />
      <Type Name="HashingTransformer" Kind="Class" />
      <Type Name="HashingTransformer+Arguments" Kind="Class" />
      <Type Name="HashingTransformer+Column" Kind="Class" />
      <Type Name="HashingTransformer+ColumnInfo" Kind="Class" />
      <Type Name="HashJoin" Kind="Class" />
      <Type Name="HashJoiningTransform" Kind="Class" />
      <Type Name="HashJoiningTransform+Arguments" Kind="Class" />
      <Type Name="HashJoiningTransform+Column" Kind="Class" />
      <Type Name="HashJoiningTransform+ColumnInfoEx" Kind="Class" />
      <Type Name="KeyToBinaryVectorMappingEstimator" Kind="Class" />
      <Type Name="KeyToBinaryVectorMappingTransformer" Kind="Class" />
      <Type Name="KeyToBinaryVectorMappingTransformer+Arguments" Kind="Class" />
      <Type Name="KeyToBinaryVectorMappingTransformer+ColumnInfo" Kind="Class" />
      <Type Name="KeyToValueMappingEstimator" Kind="Class" />
      <Type Name="KeyToValueMappingTransformer" Kind="Class" />
      <Type Name="KeyToValueMappingTransformer+Arguments" Kind="Class" />
      <Type Name="KeyToValueMappingTransformer+Column" Kind="Class" />
      <Type Name="KeyToVectorMappingEstimator" Kind="Class" />
      <Type Name="KeyToVectorMappingTransformer" Kind="Class" />
      <Type Name="KeyToVectorMappingTransformer+Arguments" Kind="Class" />
      <Type Name="KeyToVectorMappingTransformer+Column" Kind="Class" />
      <Type Name="KeyToVectorMappingTransformer+ColumnBase" Kind="Class" />
      <Type Name="KeyToVectorMappingTransformer+ColumnInfo" Kind="Class" />
      <Type Name="KeyValueOrder" Kind="Enumeration" />
      <Type Name="ToKeyFitResult`1" DisplayName="ToKeyFitResult&lt;T&gt;" Kind="Class" />
      <Type Name="ToKeyFitResult`1+OnFit" DisplayName="ToKeyFitResult&lt;T&gt;+OnFit" Kind="Delegate" />
      <Type Name="TypeConversion" Kind="Class" />
      <Type Name="TypeConvertingEstimator" Kind="Class" />
      <Type Name="TypeConvertingTransformer" Kind="Class" />
      <Type Name="TypeConvertingTransformer+Arguments" Kind="Class" />
      <Type Name="TypeConvertingTransformer+Column" Kind="Class" />
      <Type Name="TypeConvertingTransformer+ColumnInfo" Kind="Class" />
      <Type Name="ValueMappingEstimator`2" DisplayName="ValueMappingEstimator&lt;TKey,TValue&gt;" Kind="Class" />
      <Type Name="ValueMappingTransformer" Kind="Class" />
      <Type Name="ValueMappingTransformer`2" DisplayName="ValueMappingTransformer&lt;TKey,TValue&gt;" Kind="Class" />
      <Type Name="ValueMappingTransformer+Arguments" Kind="Class" />
      <Type Name="ValueMappingTransformer+Column" Kind="Class" />
      <Type Name="ValueToKeyMappingEstimator" Kind="Class" />
      <Type Name="ValueToKeyMappingEstimator+Defaults" Kind="Class" />
      <Type Name="ValueToKeyMappingTransformer" Kind="Class" />
      <Type Name="ValueToKeyMappingTransformer+Arguments" Kind="Class" />
      <Type Name="ValueToKeyMappingTransformer+ArgumentsBase" Kind="Class" />
      <Type Name="ValueToKeyMappingTransformer+Column" Kind="Class" />
      <Type Name="ValueToKeyMappingTransformer+ColumnBase" Kind="Class" />
      <Type Name="ValueToKeyMappingTransformer+ColumnInfo" Kind="Class" />
      <Type Name="ValueToKeyMappingTransformer+SortOrder" Kind="Enumeration" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Transforms.FeatureSelection">
      <Type Name="CountFeatureSelectingEstimator" Kind="Class" />
      <Type Name="CountFeatureSelectingEstimator+Arguments" Kind="Class" />
      <Type Name="CountFeatureSelectingEstimator+ColumnInfo" Kind="Class" />
      <Type Name="MutualInformationFeatureSelectingEstimator" Kind="Class" />
      <Type Name="MutualInformationFeatureSelectingEstimator+Arguments" Kind="Class" />
      <Type Name="MutualInformationFeatureSelectingEstimator+Defaults" Kind="Class" />
      <Type Name="SlotsDroppingTransformer" Kind="Class" />
      <Type Name="SlotsDroppingTransformer+Arguments" Kind="Class" />
      <Type Name="SlotsDroppingTransformer+Column" Kind="Class" />
      <Type Name="SlotsDroppingTransformer+ColumnInfo" Kind="Class" />
      <Type Name="SlotsDroppingTransformer+Range" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Transforms.Normalizers">
      <Type Name="AffineNormSerializationUtils" Kind="Class" />
      <Type Name="BinNormSerializationUtils" Kind="Class" />
      <Type Name="CdfNormSerializationUtils" Kind="Class" />
      <Type Name="MeanVarDblAggregator" Kind="Class" />
      <Type Name="MeanVarSngAggregator" Kind="Class" />
      <Type Name="MinMaxDblAggregator" Kind="Class" />
      <Type Name="NormalizeTransform" Kind="Class" />
      <Type Name="NormalizeTransform+AffineArgumentsBase" Kind="Class" />
      <Type Name="NormalizeTransform+AffineColumn" Kind="Class" />
      <Type Name="NormalizeTransform+ArgumentsBase" Kind="Class" />
      <Type Name="NormalizeTransform+BinArguments" Kind="Class" />
      <Type Name="NormalizeTransform+BinArgumentsBase" Kind="Class" />
      <Type Name="NormalizeTransform+BinColumn" Kind="Class" />
      <Type Name="NormalizeTransform+ColumnBase" Kind="Class" />
      <Type Name="NormalizeTransform+FixZeroArgumentsBase" Kind="Class" />
      <Type Name="NormalizeTransform+FixZeroColumnBase" Kind="Class" />
      <Type Name="NormalizeTransform+LogMeanVarArguments" Kind="Class" />
      <Type Name="NormalizeTransform+LogNormalColumn" Kind="Class" />
      <Type Name="NormalizeTransform+MeanVarArguments" Kind="Class" />
      <Type Name="NormalizeTransform+MinMaxArguments" Kind="Class" />
      <Type Name="NormalizeTransform+SupervisedBinArguments" Kind="Class" />
      <Type Name="NormalizingEstimator" Kind="Class" />
      <Type Name="NormalizingEstimator+BinningColumn" Kind="Class" />
      <Type Name="NormalizingEstimator+ColumnBase" Kind="Class" />
      <Type Name="NormalizingEstimator+FixZeroColumnBase" Kind="Class" />
      <Type Name="NormalizingEstimator+LogMeanVarColumn" Kind="Class" />
      <Type Name="NormalizingEstimator+MeanVarColumn" Kind="Class" />
      <Type Name="NormalizingEstimator+MinMaxColumn" Kind="Class" />
      <Type Name="NormalizingEstimator+NormalizerMode" Kind="Enumeration" />
      <Type Name="NormalizingEstimator+SupervisedBinningColumn" Kind="Class" />
      <Type Name="NormalizingTransformer" Kind="Class" />
      <Type Name="NormalizingTransformer+AffineNormalizerModelParameters`1" DisplayName="NormalizingTransformer+AffineNormalizerModelParameters&lt;TData&gt;" Kind="Class" />
      <Type Name="NormalizingTransformer+BinNormalizerModelParameters`1" DisplayName="NormalizingTransformer+BinNormalizerModelParameters&lt;TData&gt;" Kind="Class" />
      <Type Name="NormalizingTransformer+CdfNormalizerModelParameters`1" DisplayName="NormalizingTransformer+CdfNormalizerModelParameters&lt;TData&gt;" Kind="Class" />
      <Type Name="NormalizingTransformer+ColumnInfo" Kind="Class" />
      <Type Name="NormalizingTransformer+NormalizerModelParametersBase" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Transforms.Projections">
      <Type Name="GlobalContrastNormalizingEstimator" Kind="Class" />
      <Type Name="LpNormalization" Kind="Class" />
      <Type Name="LpNormalizingEstimator" Kind="Class" />
      <Type Name="LpNormalizingEstimatorBase" Kind="Class" />
      <Type Name="LpNormalizingEstimatorBase+NormalizerKind" Kind="Enumeration" />
      <Type Name="LpNormalizingTransformer" Kind="Class" />
      <Type Name="LpNormalizingTransformer+Arguments" Kind="Class" />
      <Type Name="LpNormalizingTransformer+Column" Kind="Class" />
      <Type Name="LpNormalizingTransformer+ColumnBase" Kind="Class" />
      <Type Name="LpNormalizingTransformer+ColumnInfoBase" Kind="Class" />
      <Type Name="LpNormalizingTransformer+GcnArguments" Kind="Class" />
      <Type Name="LpNormalizingTransformer+GcnColumn" Kind="Class" />
      <Type Name="LpNormalizingTransformer+GcnColumnInfo" Kind="Class" />
      <Type Name="LpNormalizingTransformer+LpNormColumnInfo" Kind="Class" />
      <Type Name="PcaTransform" Kind="Class" />
      <Type Name="PcaTransform+Arguments" Kind="Class" />
      <Type Name="PcaTransform+Column" Kind="Class" />
      <Type Name="PcaTransform+ColumnInfo" Kind="Class" />
      <Type Name="PrincipalComponentAnalysisEstimator" Kind="Class" />
      <Type Name="RandomFourierFeaturizingEstimator" Kind="Class" />
      <Type Name="RandomFourierFeaturizingTransformer" Kind="Class" />
      <Type Name="RandomFourierFeaturizingTransformer+Arguments" Kind="Class" />
      <Type Name="RandomFourierFeaturizingTransformer+Column" Kind="Class" />
      <Type Name="RandomFourierFeaturizingTransformer+ColumnInfo" Kind="Class" />
      <Type Name="VectorWhiteningEstimator" Kind="Class" />
      <Type Name="VectorWhiteningTransformer" Kind="Class" />
      <Type Name="VectorWhiteningTransformer+Arguments" Kind="Class" />
      <Type Name="VectorWhiteningTransformer+Column" Kind="Class" />
      <Type Name="VectorWhiteningTransformer+ColumnInfo" Kind="Class" />
      <Type Name="WhiteningKind" Kind="Enumeration" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Transforms.TensorFlow">
      <Type Name="TensorFlowUtils" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Transforms.Text">
      <Type Name="CustomStopWordsRemovingEstimator" Kind="Class" />
      <Type Name="CustomStopWordsRemovingTransform" Kind="Class" />
      <Type Name="CustomStopWordsRemovingTransform+Arguments" Kind="Class" />
      <Type Name="CustomStopWordsRemovingTransform+ArgumentsBase" Kind="Class" />
      <Type Name="CustomStopWordsRemovingTransform+Column" Kind="Class" />
      <Type Name="CustomStopWordsRemovingTransform+LoaderArguments" Kind="Class" />
      <Type Name="ExtractorColumn" Kind="Class" />
      <Type Name="INgramExtractorFactory" Kind="Interface" />
      <Type Name="INgramExtractorFactoryFactory" Kind="Interface" />
      <Type Name="IStopWordsRemoverFactory" Kind="Interface" />
      <Type Name="LatentDirichletAllocationEstimator" Kind="Class" />
      <Type Name="LatentDirichletAllocationTransformer" Kind="Class" />
      <Type Name="LatentDirichletAllocationTransformer+Arguments" Kind="Class" />
      <Type Name="LatentDirichletAllocationTransformer+Column" Kind="Class" />
      <Type Name="LatentDirichletAllocationTransformer+ColumnInfo" Kind="Class" />
      <Type Name="LatentDirichletAllocationTransformer+LdaSummary" Kind="Class" />
      <Type Name="NgramExtractingEstimator" Kind="Class" />
      <Type Name="NgramExtractingEstimator+WeightingCriteria" Kind="Enumeration" />
      <Type Name="NgramExtractingTransformer" Kind="Class" />
      <Type Name="NgramExtractingTransformer+Arguments" Kind="Class" />
      <Type Name="NgramExtractingTransformer+Column" Kind="Class" />
      <Type Name="NgramExtractingTransformer+ColumnInfo" Kind="Class" />
      <Type Name="NgramExtractionUtils" Kind="Class" />
      <Type Name="NgramExtractorTransform" Kind="Class" />
      <Type Name="NgramExtractorTransform+Arguments" Kind="Class" />
      <Type Name="NgramExtractorTransform+ArgumentsBase" Kind="Class" />
      <Type Name="NgramExtractorTransform+Column" Kind="Class" />
      <Type Name="NgramExtractorTransform+NgramExtractorArguments" Kind="Class" />
      <Type Name="NgramHashExtractingTransformer" Kind="Class" />
      <Type Name="NgramHashExtractingTransformer+Arguments" Kind="Class" />
      <Type Name="NgramHashExtractingTransformer+ArgumentsBase" Kind="Class" />
      <Type Name="NgramHashExtractingTransformer+Column" Kind="Class" />
      <Type Name="NgramHashExtractingTransformer+ColumnBase" Kind="Class" />
      <Type Name="NgramHashExtractingTransformer+NgramHashExtractorArguments" Kind="Class" />
      <Type Name="NgramHashingEstimator" Kind="Class" />
      <Type Name="NgramHashingTransformer" Kind="Class" />
      <Type Name="NgramHashingTransformer+Arguments" Kind="Class" />
      <Type Name="NgramHashingTransformer+Column" Kind="Class" />
      <Type Name="NgramHashingTransformer+ColumnInfo" Kind="Class" />
      <Type Name="PredefinedStopWordsRemoverFactory" Kind="Class" />
      <Type Name="SentimentAnalyzingTransformer" Kind="Class" />
      <Type Name="SentimentAnalyzingTransformer+Arguments" Kind="Class" />
      <Type Name="SignatureNgramExtractorFactory" Kind="Delegate" />
      <Type Name="StopWordsRemovingEstimator" Kind="Class" />
      <Type Name="StopWordsRemovingEstimator+Language" Kind="Enumeration" />
      <Type Name="StopWordsRemovingTransformer" Kind="Class" />
      <Type Name="StopWordsRemovingTransformer+Arguments" Kind="Class" />
      <Type Name="StopWordsRemovingTransformer+Column" Kind="Class" />
      <Type Name="StopWordsRemovingTransformer+ColumnInfo" Kind="Class" />
      <Type Name="TermLoaderArguments" Kind="Class" />
      <Type Name="TextAnalytics" Kind="Class" />
      <Type Name="TextFeaturizingEstimator" Kind="Class" />
      <Type Name="TextFeaturizingEstimator+Arguments" Kind="Class" />
      <Type Name="TextFeaturizingEstimator+Column" Kind="Class" />
      <Type Name="TextFeaturizingEstimator+Language" Kind="Enumeration" />
      <Type Name="TextFeaturizingEstimator+Settings" Kind="Class" />
      <Type Name="TextFeaturizingEstimator+TextNormKind" Kind="Enumeration" />
      <Type Name="TextNormalizingEstimator" Kind="Class" />
      <Type Name="TextNormalizingEstimator+CaseNormalizationMode" Kind="Enumeration" />
      <Type Name="TextNormalizingTransformer" Kind="Class" />
      <Type Name="TextNormalizingTransformer+Arguments" Kind="Class" />
      <Type Name="TextNormalizingTransformer+Column" Kind="Class" />
      <Type Name="TokenizingByCharactersEstimator" Kind="Class" />
      <Type Name="TokenizingByCharactersTransformer" Kind="Class" />
      <Type Name="TokenizingByCharactersTransformer+Arguments" Kind="Class" />
      <Type Name="TokenizingByCharactersTransformer+Column" Kind="Class" />
      <Type Name="WordBagBuildingTransformer" Kind="Class" />
      <Type Name="WordBagBuildingTransformer+Arguments" Kind="Class" />
      <Type Name="WordBagBuildingTransformer+Column" Kind="Class" />
      <Type Name="WordBagBuildingTransformer+TokenizeColumn" Kind="Class" />
      <Type Name="WordBagEstimator" Kind="Class" />
      <Type Name="WordEmbeddingsExtractingEstimator" Kind="Class" />
      <Type Name="WordEmbeddingsExtractingTransformer" Kind="Class" />
      <Type Name="WordEmbeddingsExtractingTransformer+Arguments" Kind="Class" />
      <Type Name="WordEmbeddingsExtractingTransformer+Column" Kind="Class" />
      <Type Name="WordEmbeddingsExtractingTransformer+ColumnInfo" Kind="Class" />
      <Type Name="WordEmbeddingsExtractingTransformer+PretrainedModelKind" Kind="Enumeration" />
      <Type Name="WordHashBagEstimator" Kind="Class" />
      <Type Name="WordHashBagProducingTransformer" Kind="Class" />
      <Type Name="WordHashBagProducingTransformer+Arguments" Kind="Class" />
      <Type Name="WordHashBagProducingTransformer+Column" Kind="Class" />
      <Type Name="WordTokenizingEstimator" Kind="Class" />
      <Type Name="WordTokenizingTransformer" Kind="Class" />
      <Type Name="WordTokenizingTransformer+Arguments" Kind="Class" />
      <Type Name="WordTokenizingTransformer+ArgumentsBase" Kind="Class" />
      <Type Name="WordTokenizingTransformer+Column" Kind="Class" />
      <Type Name="WordTokenizingTransformer+ColumnInfo" Kind="Class" />
      <Type Name="WordTokenizingTransformer+TokenizeArguments" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.UniversalModelFormat.Onnx">
      <Type Name="AttributeProto" Kind="Class" />
      <Type Name="AttributeProto+Types" Kind="Class" />
      <Type Name="AttributeProto+Types+AttributeType" Kind="Enumeration" />
      <Type Name="GraphProto" Kind="Class" />
      <Type Name="ModelProto" Kind="Class" />
      <Type Name="NodeProto" Kind="Class" />
      <Type Name="OnnxMlReflection" Kind="Class" />
      <Type Name="OperatorSetIdProto" Kind="Class" />
      <Type Name="StringStringEntryProto" Kind="Class" />
      <Type Name="TensorProto" Kind="Class" />
      <Type Name="TensorProto+Types" Kind="Class" />
      <Type Name="TensorProto+Types+DataType" Kind="Enumeration" />
      <Type Name="TensorProto+Types+Segment" Kind="Class" />
      <Type Name="TensorShapeProto" Kind="Class" />
      <Type Name="TensorShapeProto+Types" Kind="Class" />
      <Type Name="TensorShapeProto+Types+Dimension" Kind="Class" />
      <Type Name="TensorShapeProto+Types+Dimension+ValueOneofCase" Kind="Enumeration" />
      <Type Name="TypeProto" Kind="Class" />
      <Type Name="TypeProto+Types" Kind="Class" />
      <Type Name="TypeProto+Types+Map" Kind="Class" />
      <Type Name="TypeProto+Types+Sequence" Kind="Class" />
      <Type Name="TypeProto+Types+Tensor" Kind="Class" />
      <Type Name="TypeProto+ValueOneofCase" Kind="Enumeration" />
      <Type Name="ValueInfoProto" Kind="Class" />
      <Type Name="Version" Kind="Enumeration" />
    </Namespace>
  </Types>
  <Title>Untitled</Title>
  <ExtensionMethods>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataOperations" />
      </Targets>
      <Member MemberName="ReadFromBinary">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.IDataView ReadFromBinary (this Microsoft.ML.DataOperations catalog, System.IO.Stream stream);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.IDataView ReadFromBinary(class Microsoft.ML.DataOperations catalog, class System.IO.Stream stream) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.BinaryLoaderSaverCatalog.ReadFromBinary(Microsoft.ML.DataOperations,System.IO.Stream)" />
        <MemberSignature Language="F#" Value="static member ReadFromBinary : Microsoft.ML.DataOperations * System.IO.Stream -&gt; Microsoft.ML.Data.IDataView" Usage="Microsoft.ML.BinaryLoaderSaverCatalog.ReadFromBinary (catalog, stream)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.IDataView</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.DataOperations" RefType="this" />
          <Parameter Name="stream" Type="System.IO.Stream" />
        </Parameters>
        <Docs>
          <param name="catalog">The catalog.</param>
          <param name="stream">The stream to read from.</param>
          <summary>
            Read a data view from a Stream on a binary file using <see cref="T:Microsoft.ML.Data.IO.BinaryLoader" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.BinaryLoaderSaverCatalog" Member="M:Microsoft.ML.BinaryLoaderSaverCatalog.ReadFromBinary(Microsoft.ML.DataOperations,System.IO.Stream)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataOperations" />
      </Targets>
      <Member MemberName="ReadFromBinary">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.IDataView ReadFromBinary (this Microsoft.ML.DataOperations catalog, string path);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.IDataView ReadFromBinary(class Microsoft.ML.DataOperations catalog, string path) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.BinaryLoaderSaverCatalog.ReadFromBinary(Microsoft.ML.DataOperations,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadFromBinary (catalog As DataOperations, path As String) As IDataView" />
        <MemberSignature Language="F#" Value="static member ReadFromBinary : Microsoft.ML.DataOperations * string -&gt; Microsoft.ML.Data.IDataView" Usage="Microsoft.ML.BinaryLoaderSaverCatalog.ReadFromBinary (catalog, path)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.IDataView</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.DataOperations" RefType="this" />
          <Parameter Name="path" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="catalog">The catalog.</param>
          <param name="path">The path to the file to read from.</param>
          <summary>
            Read a data view from a binary file using <see cref="T:Microsoft.ML.Data.IO.BinaryLoader" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.BinaryLoaderSaverCatalog" Member="M:Microsoft.ML.BinaryLoaderSaverCatalog.ReadFromBinary(Microsoft.ML.DataOperations,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataOperations" />
      </Targets>
      <Member MemberName="SaveAsBinary">
        <MemberSignature Language="C#" Value="public static void SaveAsBinary (this Microsoft.ML.DataOperations catalog, Microsoft.ML.Data.IDataView data, System.IO.Stream stream, bool keepHidden = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SaveAsBinary(class Microsoft.ML.DataOperations catalog, class Microsoft.ML.Data.IDataView data, class System.IO.Stream stream, bool keepHidden) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.BinaryLoaderSaverCatalog.SaveAsBinary(Microsoft.ML.DataOperations,Microsoft.ML.Data.IDataView,System.IO.Stream,System.Boolean)" />
        <MemberSignature Language="F#" Value="static member SaveAsBinary : Microsoft.ML.DataOperations * Microsoft.ML.Data.IDataView * System.IO.Stream * bool -&gt; unit" Usage="Microsoft.ML.BinaryLoaderSaverCatalog.SaveAsBinary (catalog, data, stream, keepHidden)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.DataOperations" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.Data.IDataView" />
          <Parameter Name="stream" Type="System.IO.Stream" />
          <Parameter Name="keepHidden" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The catalog.</param>
          <param name="data">The data view to save.</param>
          <param name="stream">The stream to write to.</param>
          <param name="keepHidden">Whether to keep hidden columns in the dataset.</param>
          <summary>
            Save the data view into a binary stream.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.BinaryLoaderSaverCatalog" Member="M:Microsoft.ML.BinaryLoaderSaverCatalog.SaveAsBinary(Microsoft.ML.DataOperations,Microsoft.ML.Data.IDataView,System.IO.Stream,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.CategoricalTransforms" />
      </Targets>
      <Member MemberName="OneHotEncoding">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Categorical.OneHotEncodingEstimator OneHotEncoding (this Microsoft.ML.TransformsCatalog.CategoricalTransforms catalog, params Microsoft.ML.Transforms.Categorical.OneHotEncodingEstimator.ColumnInfo[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Categorical.OneHotEncodingEstimator OneHotEncoding(class Microsoft.ML.TransformsCatalog/CategoricalTransforms catalog, class Microsoft.ML.Transforms.Categorical.OneHotEncodingEstimator/ColumnInfo[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.CategoricalCatalog.OneHotEncoding(Microsoft.ML.TransformsCatalog.CategoricalTransforms,Microsoft.ML.Transforms.Categorical.OneHotEncodingEstimator.ColumnInfo[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OneHotEncoding (catalog As TransformsCatalog.CategoricalTransforms, ParamArray columns As OneHotEncodingEstimator.ColumnInfo()) As OneHotEncodingEstimator" />
        <MemberSignature Language="F#" Value="static member OneHotEncoding : Microsoft.ML.TransformsCatalog.CategoricalTransforms * Microsoft.ML.Transforms.Categorical.OneHotEncodingEstimator.ColumnInfo[] -&gt; Microsoft.ML.Transforms.Categorical.OneHotEncodingEstimator" Usage="Microsoft.ML.CategoricalCatalog.OneHotEncoding (catalog, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Categorical.OneHotEncodingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+CategoricalTransforms" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.Transforms.Categorical.OneHotEncodingEstimator+ColumnInfo[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform catalog</param>
          <param name="columns">The column settings.</param>
          <summary>
            Convert several text column into one-hot encoded vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.CategoricalCatalog" Member="M:Microsoft.ML.CategoricalCatalog.OneHotEncoding(Microsoft.ML.TransformsCatalog.CategoricalTransforms,Microsoft.ML.Transforms.Categorical.OneHotEncodingEstimator.ColumnInfo[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.CategoricalTransforms" />
      </Targets>
      <Member MemberName="OneHotEncoding">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Categorical.OneHotEncodingEstimator OneHotEncoding (this Microsoft.ML.TransformsCatalog.CategoricalTransforms catalog, string inputColumn, string outputColumn = null, Microsoft.ML.Transforms.Categorical.OneHotEncodingTransformer.OutputKind outputKind = Microsoft.ML.Transforms.Categorical.OneHotEncodingTransformer+OutputKind.Ind);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Categorical.OneHotEncodingEstimator OneHotEncoding(class Microsoft.ML.TransformsCatalog/CategoricalTransforms catalog, string inputColumn, string outputColumn, valuetype Microsoft.ML.Transforms.Categorical.OneHotEncodingTransformer/OutputKind outputKind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.CategoricalCatalog.OneHotEncoding(Microsoft.ML.TransformsCatalog.CategoricalTransforms,System.String,System.String,Microsoft.ML.Transforms.Categorical.OneHotEncodingTransformer.OutputKind)" />
        <MemberSignature Language="F#" Value="static member OneHotEncoding : Microsoft.ML.TransformsCatalog.CategoricalTransforms * string * string * Microsoft.ML.Transforms.Categorical.OneHotEncodingTransformer.OutputKind -&gt; Microsoft.ML.Transforms.Categorical.OneHotEncodingEstimator" Usage="Microsoft.ML.CategoricalCatalog.OneHotEncoding (catalog, inputColumn, outputColumn, outputKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Categorical.OneHotEncodingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+CategoricalTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="outputKind" Type="Microsoft.ML.Transforms.Categorical.OneHotEncodingTransformer+OutputKind" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform catalog</param>
          <param name="inputColumn">The input column</param>
          <param name="outputColumn">The output column. If <c>null</c>, <paramref name="inputColumn" /> is used.</param>
          <param name="outputKind">The conversion mode.</param>
          <summary>
            Convert a text column into one-hot encoded vector.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.CategoricalCatalog" Member="M:Microsoft.ML.CategoricalCatalog.OneHotEncoding(Microsoft.ML.TransformsCatalog.CategoricalTransforms,System.String,System.String,Microsoft.ML.Transforms.Categorical.OneHotEncodingTransformer.OutputKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.CategoricalTransforms" />
      </Targets>
      <Member MemberName="OneHotHashEncoding">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Categorical.OneHotHashEncodingEstimator OneHotHashEncoding (this Microsoft.ML.TransformsCatalog.CategoricalTransforms catalog, params Microsoft.ML.Transforms.Categorical.OneHotHashEncodingEstimator.ColumnInfo[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Categorical.OneHotHashEncodingEstimator OneHotHashEncoding(class Microsoft.ML.TransformsCatalog/CategoricalTransforms catalog, class Microsoft.ML.Transforms.Categorical.OneHotHashEncodingEstimator/ColumnInfo[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.CategoricalCatalog.OneHotHashEncoding(Microsoft.ML.TransformsCatalog.CategoricalTransforms,Microsoft.ML.Transforms.Categorical.OneHotHashEncodingEstimator.ColumnInfo[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OneHotHashEncoding (catalog As TransformsCatalog.CategoricalTransforms, ParamArray columns As OneHotHashEncodingEstimator.ColumnInfo()) As OneHotHashEncodingEstimator" />
        <MemberSignature Language="F#" Value="static member OneHotHashEncoding : Microsoft.ML.TransformsCatalog.CategoricalTransforms * Microsoft.ML.Transforms.Categorical.OneHotHashEncodingEstimator.ColumnInfo[] -&gt; Microsoft.ML.Transforms.Categorical.OneHotHashEncodingEstimator" Usage="Microsoft.ML.CategoricalCatalog.OneHotHashEncoding (catalog, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Categorical.OneHotHashEncodingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+CategoricalTransforms" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.Transforms.Categorical.OneHotHashEncodingEstimator+ColumnInfo[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform catalog</param>
          <param name="columns">The column settings.</param>
          <summary>
            Convert several text column into hash-based one-hot encoded vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.CategoricalCatalog" Member="M:Microsoft.ML.CategoricalCatalog.OneHotHashEncoding(Microsoft.ML.TransformsCatalog.CategoricalTransforms,Microsoft.ML.Transforms.Categorical.OneHotHashEncodingEstimator.ColumnInfo[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.CategoricalTransforms" />
      </Targets>
      <Member MemberName="OneHotHashEncoding">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Categorical.OneHotHashEncodingEstimator OneHotHashEncoding (this Microsoft.ML.TransformsCatalog.CategoricalTransforms catalog, string inputColumn, string outputColumn = null, int hashBits = 16, int invertHash = 0, Microsoft.ML.Transforms.Categorical.OneHotEncodingTransformer.OutputKind outputKind = Microsoft.ML.Transforms.Categorical.OneHotEncodingTransformer+OutputKind.Ind);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Categorical.OneHotHashEncodingEstimator OneHotHashEncoding(class Microsoft.ML.TransformsCatalog/CategoricalTransforms catalog, string inputColumn, string outputColumn, int32 hashBits, int32 invertHash, valuetype Microsoft.ML.Transforms.Categorical.OneHotEncodingTransformer/OutputKind outputKind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.CategoricalCatalog.OneHotHashEncoding(Microsoft.ML.TransformsCatalog.CategoricalTransforms,System.String,System.String,System.Int32,System.Int32,Microsoft.ML.Transforms.Categorical.OneHotEncodingTransformer.OutputKind)" />
        <MemberSignature Language="F#" Value="static member OneHotHashEncoding : Microsoft.ML.TransformsCatalog.CategoricalTransforms * string * string * int * int * Microsoft.ML.Transforms.Categorical.OneHotEncodingTransformer.OutputKind -&gt; Microsoft.ML.Transforms.Categorical.OneHotHashEncodingEstimator" Usage="Microsoft.ML.CategoricalCatalog.OneHotHashEncoding (catalog, inputColumn, outputColumn, hashBits, invertHash, outputKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Categorical.OneHotHashEncodingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+CategoricalTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="hashBits" Type="System.Int32" />
          <Parameter Name="invertHash" Type="System.Int32" />
          <Parameter Name="outputKind" Type="Microsoft.ML.Transforms.Categorical.OneHotEncodingTransformer+OutputKind" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform catalog</param>
          <param name="inputColumn">The input column</param>
          <param name="outputColumn">The output column. If <c>null</c>, <paramref name="inputColumn" /> is used.</param>
          <param name="hashBits">Number of bits to hash into. Must be between 1 and 30, inclusive.</param>
          <param name="invertHash">During hashing we constuct mappings between original values and the produced hash values.
            Text representation of original values are stored in the slot names of the  metadata for the new column.Hashing, as such, can map many initial values to one.
            <paramref name="invertHash" /> specifies the upper bound of the number of distinct input values mapping to a hash that should be retained.
            <value>0</value> does not retain any input values. <value>-1</value> retains all input values mapping to each hash.</param>
          <param name="outputKind">The conversion mode.</param>
          <summary>
            Convert a text column into hash-based one-hot encoded vector.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.CategoricalCatalog" Member="M:Microsoft.ML.CategoricalCatalog.OneHotHashEncoding(Microsoft.ML.TransformsCatalog.CategoricalTransforms,System.String,System.String,System.Int32,System.Int32,Microsoft.ML.Transforms.Categorical.OneHotEncodingTransformer.OutputKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="MapKeyToBinaryVector">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Conversions.KeyToBinaryVectorMappingEstimator MapKeyToBinaryVector (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, params Microsoft.ML.Transforms.Conversions.KeyToBinaryVectorMappingTransformer.ColumnInfo[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Conversions.KeyToBinaryVectorMappingEstimator MapKeyToBinaryVector(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, class Microsoft.ML.Transforms.Conversions.KeyToBinaryVectorMappingTransformer/ColumnInfo[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsCatalog.MapKeyToBinaryVector(Microsoft.ML.TransformsCatalog.ConversionTransforms,Microsoft.ML.Transforms.Conversions.KeyToBinaryVectorMappingTransformer.ColumnInfo[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function MapKeyToBinaryVector (catalog As TransformsCatalog.ConversionTransforms, ParamArray columns As KeyToBinaryVectorMappingTransformer.ColumnInfo()) As KeyToBinaryVectorMappingEstimator" />
        <MemberSignature Language="F#" Value="static member MapKeyToBinaryVector : Microsoft.ML.TransformsCatalog.ConversionTransforms * Microsoft.ML.Transforms.Conversions.KeyToBinaryVectorMappingTransformer.ColumnInfo[] -&gt; Microsoft.ML.Transforms.Conversions.KeyToBinaryVectorMappingEstimator" Usage="Microsoft.ML.ConversionsCatalog.MapKeyToBinaryVector (catalog, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Conversions.KeyToBinaryVectorMappingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.Transforms.Conversions.KeyToBinaryVectorMappingTransformer+ColumnInfo[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The categorical transform's catalog.</param>
          <param name="columns">The input column.</param>
          <summary>
             Convert the key types back to binary verctor.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsCatalog" Member="M:Microsoft.ML.ConversionsCatalog.MapKeyToBinaryVector(Microsoft.ML.TransformsCatalog.ConversionTransforms,Microsoft.ML.Transforms.Conversions.KeyToBinaryVectorMappingTransformer.ColumnInfo[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="MapKeyToBinaryVector">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Conversions.KeyToBinaryVectorMappingEstimator MapKeyToBinaryVector (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, string inputColumn, string outputColumn = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Conversions.KeyToBinaryVectorMappingEstimator MapKeyToBinaryVector(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, string inputColumn, string outputColumn) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsCatalog.MapKeyToBinaryVector(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function MapKeyToBinaryVector (catalog As TransformsCatalog.ConversionTransforms, inputColumn As String, Optional outputColumn As String = null) As KeyToBinaryVectorMappingEstimator" />
        <MemberSignature Language="F#" Value="static member MapKeyToBinaryVector : Microsoft.ML.TransformsCatalog.ConversionTransforms * string * string -&gt; Microsoft.ML.Transforms.Conversions.KeyToBinaryVectorMappingEstimator" Usage="Microsoft.ML.ConversionsCatalog.MapKeyToBinaryVector (catalog, inputColumn, outputColumn)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Conversions.KeyToBinaryVectorMappingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="catalog">The categorical transform's catalog.</param>
          <param name="inputColumn">The name of the input column of the transformation.</param>
          <param name="outputColumn">The name of the column produced by the transformation.</param>
          <summary>
             Convert the key types back to binary verctor.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsCatalog" Member="M:Microsoft.ML.ConversionsCatalog.MapKeyToBinaryVector(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="ConvertType">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Conversions.TypeConvertingEstimator ConvertType (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, params Microsoft.ML.Transforms.Conversions.TypeConvertingTransformer.ColumnInfo[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Conversions.TypeConvertingEstimator ConvertType(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, class Microsoft.ML.Transforms.Conversions.TypeConvertingTransformer/ColumnInfo[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsExtensionsCatalog.ConvertType(Microsoft.ML.TransformsCatalog.ConversionTransforms,Microsoft.ML.Transforms.Conversions.TypeConvertingTransformer.ColumnInfo[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConvertType (catalog As TransformsCatalog.ConversionTransforms, ParamArray columns As TypeConvertingTransformer.ColumnInfo()) As TypeConvertingEstimator" />
        <MemberSignature Language="F#" Value="static member ConvertType : Microsoft.ML.TransformsCatalog.ConversionTransforms * Microsoft.ML.Transforms.Conversions.TypeConvertingTransformer.ColumnInfo[] -&gt; Microsoft.ML.Transforms.Conversions.TypeConvertingEstimator" Usage="Microsoft.ML.ConversionsExtensionsCatalog.ConvertType (catalog, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Conversions.TypeConvertingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.Transforms.Conversions.TypeConvertingTransformer+ColumnInfo[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="columns">Description of dataset columns and how to process them.</param>
          <summary>
            Changes column type of the input column.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsExtensionsCatalog" Member="M:Microsoft.ML.ConversionsExtensionsCatalog.ConvertType(Microsoft.ML.TransformsCatalog.ConversionTransforms,Microsoft.ML.Transforms.Conversions.TypeConvertingTransformer.ColumnInfo[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="ConvertType">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Conversions.TypeConvertingEstimator ConvertType (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, string inputColumn, string outputColumn = null, Microsoft.ML.Data.DataKind outputKind = Microsoft.ML.Data.DataKind.Num);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Conversions.TypeConvertingEstimator ConvertType(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, string inputColumn, string outputColumn, valuetype Microsoft.ML.Data.DataKind outputKind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsExtensionsCatalog.ConvertType(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.String,Microsoft.ML.Data.DataKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConvertType (catalog As TransformsCatalog.ConversionTransforms, inputColumn As String, Optional outputColumn As String = null, Optional outputKind As DataKind = Microsoft.ML.Data.DataKind.Num) As TypeConvertingEstimator" />
        <MemberSignature Language="F#" Value="static member ConvertType : Microsoft.ML.TransformsCatalog.ConversionTransforms * string * string * Microsoft.ML.Data.DataKind -&gt; Microsoft.ML.Transforms.Conversions.TypeConvertingEstimator" Usage="Microsoft.ML.ConversionsExtensionsCatalog.ConvertType (catalog, inputColumn, outputColumn, outputKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Conversions.TypeConvertingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="outputKind" Type="Microsoft.ML.Data.DataKind" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="inputColumn">Name of the input column.</param>
          <param name="outputColumn">Name of the column to be transformed. If this is null '<paramref name="inputColumn" />' will be used.</param>
          <param name="outputKind">Number of bits to hash into. Must be between 1 and 31, inclusive.</param>
          <summary>
            Changes column type of the input column.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsExtensionsCatalog" Member="M:Microsoft.ML.ConversionsExtensionsCatalog.ConvertType(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.String,Microsoft.ML.Data.DataKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="Hash">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Conversions.HashingEstimator Hash (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, params Microsoft.ML.Transforms.Conversions.HashingTransformer.ColumnInfo[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Conversions.HashingEstimator Hash(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, class Microsoft.ML.Transforms.Conversions.HashingTransformer/ColumnInfo[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsExtensionsCatalog.Hash(Microsoft.ML.TransformsCatalog.ConversionTransforms,Microsoft.ML.Transforms.Conversions.HashingTransformer.ColumnInfo[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Hash (catalog As TransformsCatalog.ConversionTransforms, ParamArray columns As HashingTransformer.ColumnInfo()) As HashingEstimator" />
        <MemberSignature Language="F#" Value="static member Hash : Microsoft.ML.TransformsCatalog.ConversionTransforms * Microsoft.ML.Transforms.Conversions.HashingTransformer.ColumnInfo[] -&gt; Microsoft.ML.Transforms.Conversions.HashingEstimator" Usage="Microsoft.ML.ConversionsExtensionsCatalog.Hash (catalog, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Conversions.HashingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.Transforms.Conversions.HashingTransformer+ColumnInfo[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="columns">Description of dataset columns and how to process them.</param>
          <summary>
            Hashes the values in the input column.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsExtensionsCatalog" Member="M:Microsoft.ML.ConversionsExtensionsCatalog.Hash(Microsoft.ML.TransformsCatalog.ConversionTransforms,Microsoft.ML.Transforms.Conversions.HashingTransformer.ColumnInfo[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="Hash">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Conversions.HashingEstimator Hash (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, string inputColumn, string outputColumn = null, int hashBits = 31, int invertHash = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Conversions.HashingEstimator Hash(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, string inputColumn, string outputColumn, int32 hashBits, int32 invertHash) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsExtensionsCatalog.Hash(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.String,System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Hash (catalog As TransformsCatalog.ConversionTransforms, inputColumn As String, Optional outputColumn As String = null, Optional hashBits As Integer = 31, Optional invertHash As Integer = 0) As HashingEstimator" />
        <MemberSignature Language="F#" Value="static member Hash : Microsoft.ML.TransformsCatalog.ConversionTransforms * string * string * int * int -&gt; Microsoft.ML.Transforms.Conversions.HashingEstimator" Usage="Microsoft.ML.ConversionsExtensionsCatalog.Hash (catalog, inputColumn, outputColumn, hashBits, invertHash)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Conversions.HashingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="hashBits" Type="System.Int32" />
          <Parameter Name="invertHash" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="inputColumn">Name of the input column.</param>
          <param name="outputColumn">Name of the column to be transformed. If this is null '<paramref name="inputColumn" />' will be used.</param>
          <param name="hashBits">Number of bits to hash into. Must be between 1 and 31, inclusive.</param>
          <param name="invertHash">During hashing we constuct mappings between original values and the produced hash values.
            Text representation of original values are stored in the slot names of the  metadata for the new column.Hashing, as such, can map many initial values to one.
            <paramref name="invertHash" /> specifies the upper bound of the number of distinct input values mapping to a hash that should be retained.
            <value>0</value> does not retain any input values. <value>-1</value> retains all input values mapping to each hash.</param>
          <summary>
            Hashes the values in the input column.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsExtensionsCatalog" Member="M:Microsoft.ML.ConversionsExtensionsCatalog.Hash(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.String,System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="MapKeyToValue">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Conversions.KeyToValueMappingEstimator MapKeyToValue (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, string inputColumn);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Conversions.KeyToValueMappingEstimator MapKeyToValue(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, string inputColumn) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsExtensionsCatalog.MapKeyToValue(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function MapKeyToValue (catalog As TransformsCatalog.ConversionTransforms, inputColumn As String) As KeyToValueMappingEstimator" />
        <MemberSignature Language="F#" Value="static member MapKeyToValue : Microsoft.ML.TransformsCatalog.ConversionTransforms * string -&gt; Microsoft.ML.Transforms.Conversions.KeyToValueMappingEstimator" Usage="Microsoft.ML.ConversionsExtensionsCatalog.MapKeyToValue (catalog, inputColumn)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Conversions.KeyToValueMappingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="catalog">The categorical transform's catalog.</param>
          <param name="inputColumn">Name of the input column.</param>
          <summary>
            Convert the key types back to their original values.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsExtensionsCatalog" Member="M:Microsoft.ML.ConversionsExtensionsCatalog.MapKeyToValue(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="MapKeyToValue">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Conversions.KeyToValueMappingEstimator MapKeyToValue (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, params ValueTuple&lt;string,string&gt;[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Conversions.KeyToValueMappingEstimator MapKeyToValue(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, valuetype System.ValueTuple`2&lt;string, string&gt;[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsExtensionsCatalog.MapKeyToValue(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.ValueTuple{System.String,System.String}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function MapKeyToValue (catalog As TransformsCatalog.ConversionTransforms, ParamArray columns As ValueTuple(Of String, String)()) As KeyToValueMappingEstimator" />
        <MemberSignature Language="F#" Value="static member MapKeyToValue : Microsoft.ML.TransformsCatalog.ConversionTransforms * ValueTuple&lt;string, string&gt;[] -&gt; Microsoft.ML.Transforms.Conversions.KeyToValueMappingEstimator" Usage="Microsoft.ML.ConversionsExtensionsCatalog.MapKeyToValue (catalog, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Conversions.KeyToValueMappingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="columns" Type="System.ValueTuple&lt;System.String,System.String&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
              <Attribute>
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "input", "output" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The categorical transform's catalog</param>
          <param name="columns">The pairs of input and output columns.</param>
          <summary>
             Convert the key types (name of the column specified in the first item of the tuple) back to their original values
             (named as specified in the second item of the tuple).
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsExtensionsCatalog" Member="M:Microsoft.ML.ConversionsExtensionsCatalog.MapKeyToValue(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.ValueTuple{System.String,System.String}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="MapKeyToVector">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Conversions.KeyToVectorMappingEstimator MapKeyToVector (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, params Microsoft.ML.Transforms.Conversions.KeyToVectorMappingTransformer.ColumnInfo[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Conversions.KeyToVectorMappingEstimator MapKeyToVector(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, class Microsoft.ML.Transforms.Conversions.KeyToVectorMappingTransformer/ColumnInfo[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsExtensionsCatalog.MapKeyToVector(Microsoft.ML.TransformsCatalog.ConversionTransforms,Microsoft.ML.Transforms.Conversions.KeyToVectorMappingTransformer.ColumnInfo[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function MapKeyToVector (catalog As TransformsCatalog.ConversionTransforms, ParamArray columns As KeyToVectorMappingTransformer.ColumnInfo()) As KeyToVectorMappingEstimator" />
        <MemberSignature Language="F#" Value="static member MapKeyToVector : Microsoft.ML.TransformsCatalog.ConversionTransforms * Microsoft.ML.Transforms.Conversions.KeyToVectorMappingTransformer.ColumnInfo[] -&gt; Microsoft.ML.Transforms.Conversions.KeyToVectorMappingEstimator" Usage="Microsoft.ML.ConversionsExtensionsCatalog.MapKeyToVector (catalog, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Conversions.KeyToVectorMappingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.Transforms.Conversions.KeyToVectorMappingTransformer+ColumnInfo[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The categorical transform's catalog.</param>
          <param name="columns">The input column to map back to vectors.</param>
          <summary>
            Convert the key types back to their original vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsExtensionsCatalog" Member="M:Microsoft.ML.ConversionsExtensionsCatalog.MapKeyToVector(Microsoft.ML.TransformsCatalog.ConversionTransforms,Microsoft.ML.Transforms.Conversions.KeyToVectorMappingTransformer.ColumnInfo[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="MapKeyToVector">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Conversions.KeyToVectorMappingEstimator MapKeyToVector (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, string inputColumn, string outputColumn = null, bool bag = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Conversions.KeyToVectorMappingEstimator MapKeyToVector(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, string inputColumn, string outputColumn, bool bag) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsExtensionsCatalog.MapKeyToVector(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.String,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function MapKeyToVector (catalog As TransformsCatalog.ConversionTransforms, inputColumn As String, Optional outputColumn As String = null, Optional bag As Boolean = false) As KeyToVectorMappingEstimator" />
        <MemberSignature Language="F#" Value="static member MapKeyToVector : Microsoft.ML.TransformsCatalog.ConversionTransforms * string * string * bool -&gt; Microsoft.ML.Transforms.Conversions.KeyToVectorMappingEstimator" Usage="Microsoft.ML.ConversionsExtensionsCatalog.MapKeyToVector (catalog, inputColumn, outputColumn, bag)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Conversions.KeyToVectorMappingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="bag" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The categorical transform's catalog.</param>
          <param name="inputColumn">The name of the input column.</param>
          <param name="outputColumn">The name of the output column.</param>
          <param name="bag">Whether bagging is used for the conversion. </param>
          <summary>
            Convert the key types back to their original vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsExtensionsCatalog" Member="M:Microsoft.ML.ConversionsExtensionsCatalog.MapKeyToVector(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.String,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="MapValueToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Conversions.ValueToKeyMappingEstimator MapValueToKey (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, Microsoft.ML.Transforms.Conversions.ValueToKeyMappingTransformer.ColumnInfo[] columns, string file = null, string termsColumn = null, Microsoft.ML.IComponentFactory&lt;Microsoft.ML.Data.IMultiStreamSource,Microsoft.ML.Data.IDataLoader&gt; loaderFactory = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Conversions.ValueToKeyMappingEstimator MapValueToKey(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, class Microsoft.ML.Transforms.Conversions.ValueToKeyMappingTransformer/ColumnInfo[] columns, string file, string termsColumn, class Microsoft.ML.IComponentFactory`2&lt;class Microsoft.ML.Data.IMultiStreamSource, class Microsoft.ML.Data.IDataLoader&gt; loaderFactory) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsExtensionsCatalog.MapValueToKey(Microsoft.ML.TransformsCatalog.ConversionTransforms,Microsoft.ML.Transforms.Conversions.ValueToKeyMappingTransformer.ColumnInfo[],System.String,System.String,Microsoft.ML.IComponentFactory{Microsoft.ML.Data.IMultiStreamSource,Microsoft.ML.Data.IDataLoader})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function MapValueToKey (catalog As TransformsCatalog.ConversionTransforms, columns As ValueToKeyMappingTransformer.ColumnInfo(), Optional file As String = null, Optional termsColumn As String = null, Optional loaderFactory As IComponentFactory(Of IMultiStreamSource, IDataLoader) = null) As ValueToKeyMappingEstimator" />
        <MemberSignature Language="F#" Value="static member MapValueToKey : Microsoft.ML.TransformsCatalog.ConversionTransforms * Microsoft.ML.Transforms.Conversions.ValueToKeyMappingTransformer.ColumnInfo[] * string * string * Microsoft.ML.IComponentFactory&lt;Microsoft.ML.Data.IMultiStreamSource, Microsoft.ML.Data.IDataLoader&gt; -&gt; Microsoft.ML.Transforms.Conversions.ValueToKeyMappingEstimator" Usage="Microsoft.ML.ConversionsExtensionsCatalog.MapValueToKey (catalog, columns, file, termsColumn, loaderFactory)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Conversions.ValueToKeyMappingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.Transforms.Conversions.ValueToKeyMappingTransformer+ColumnInfo[]" />
          <Parameter Name="file" Type="System.String" />
          <Parameter Name="termsColumn" Type="System.String" />
          <Parameter Name="loaderFactory" Type="Microsoft.ML.IComponentFactory&lt;Microsoft.ML.Data.IMultiStreamSource,Microsoft.ML.Data.IDataLoader&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The categorical transform's catalog.</param>
          <param name="columns">The data columns to map to keys.</param>
          <param name="file">The path of the file containing the terms.</param>
          <param name="termsColumn" />
          <param name="loaderFactory" />
          <summary>
            Converts value types into <see cref="T:Microsoft.ML.Data.KeyType" /> loading the keys to use from <paramref name="file" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsExtensionsCatalog" Member="M:Microsoft.ML.ConversionsExtensionsCatalog.MapValueToKey(Microsoft.ML.TransformsCatalog.ConversionTransforms,Microsoft.ML.Transforms.Conversions.ValueToKeyMappingTransformer.ColumnInfo[],System.String,System.String,Microsoft.ML.IComponentFactory{Microsoft.ML.Data.IMultiStreamSource,Microsoft.ML.Data.IDataLoader})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="MapValueToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Conversions.ValueToKeyMappingEstimator MapValueToKey (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, string inputColumn, string outputColumn = null, int maxNumTerms = 1000000, Microsoft.ML.Transforms.Conversions.ValueToKeyMappingTransformer.SortOrder sort = Microsoft.ML.Transforms.Conversions.ValueToKeyMappingTransformer+SortOrder.Occurrence);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Conversions.ValueToKeyMappingEstimator MapValueToKey(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, string inputColumn, string outputColumn, int32 maxNumTerms, valuetype Microsoft.ML.Transforms.Conversions.ValueToKeyMappingTransformer/SortOrder sort) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsExtensionsCatalog.MapValueToKey(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.String,System.Int32,Microsoft.ML.Transforms.Conversions.ValueToKeyMappingTransformer.SortOrder)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function MapValueToKey (catalog As TransformsCatalog.ConversionTransforms, inputColumn As String, Optional outputColumn As String = null, Optional maxNumTerms As Integer = 1000000, Optional sort As ValueToKeyMappingTransformer.SortOrder = Microsoft.ML.Transforms.Conversions.ValueToKeyMappingTransformer+SortOrder.Occurrence) As ValueToKeyMappingEstimator" />
        <MemberSignature Language="F#" Value="static member MapValueToKey : Microsoft.ML.TransformsCatalog.ConversionTransforms * string * string * int * Microsoft.ML.Transforms.Conversions.ValueToKeyMappingTransformer.SortOrder -&gt; Microsoft.ML.Transforms.Conversions.ValueToKeyMappingEstimator" Usage="Microsoft.ML.ConversionsExtensionsCatalog.MapValueToKey (catalog, inputColumn, outputColumn, maxNumTerms, sort)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Conversions.ValueToKeyMappingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="maxNumTerms" Type="System.Int32" />
          <Parameter Name="sort" Type="Microsoft.ML.Transforms.Conversions.ValueToKeyMappingTransformer+SortOrder" />
        </Parameters>
        <Docs>
          <param name="catalog">The categorical transform's catalog.</param>
          <param name="inputColumn">Name of the column to be transformed.</param>
          <param name="outputColumn">Name of the output column. If this is null '<paramref name="inputColumn" />' will be used.</param>
          <param name="maxNumTerms">Maximum number of keys to keep per column when auto-training.</param>
          <param name="sort">How items should be ordered when vectorized. If <see cref="F:Microsoft.ML.Transforms.Conversions.ValueToKeyMappingTransformer.SortOrder.Occurrence" /> choosen they will be in the order encountered.
            If <see cref="F:Microsoft.ML.Transforms.Conversions.ValueToKeyMappingTransformer.SortOrder.Value" />, items are sorted according to their default comparison, for example, text sorting will be case sensitive (for example, 'A' then 'Z' then 'a').</param>
          <summary>
            Converts value types into <see cref="T:Microsoft.ML.Data.KeyType" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsExtensionsCatalog" Member="M:Microsoft.ML.ConversionsExtensionsCatalog.MapValueToKey(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.String,System.String,System.Int32,Microsoft.ML.Transforms.Conversions.ValueToKeyMappingTransformer.SortOrder)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ConversionTransforms" />
      </Targets>
      <Member MemberName="ValueMap&lt;TInputType,TOutputType&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Conversions.ValueMappingEstimator&lt;TInputType,TOutputType&gt; ValueMap&lt;TInputType,TOutputType&gt; (this Microsoft.ML.TransformsCatalog.ConversionTransforms catalog, System.Collections.Generic.IEnumerable&lt;TInputType&gt; keys, System.Collections.Generic.IEnumerable&lt;TOutputType&gt; values, params ValueTuple&lt;string,string&gt;[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Conversions.ValueMappingEstimator`2&lt;!!TInputType, !!TOutputType&gt; ValueMap&lt;TInputType, TOutputType&gt;(class Microsoft.ML.TransformsCatalog/ConversionTransforms catalog, class System.Collections.Generic.IEnumerable`1&lt;!!TInputType&gt; keys, class System.Collections.Generic.IEnumerable`1&lt;!!TOutputType&gt; values, valuetype System.ValueTuple`2&lt;string, string&gt;[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ConversionsExtensionsCatalog.ValueMap``2(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.ValueTuple{System.String,System.String}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ValueMap(Of TInputType, TOutputType) (catalog As TransformsCatalog.ConversionTransforms, keys As IEnumerable(Of TInputType), values As IEnumerable(Of TOutputType), ParamArray columns As ValueTuple(Of String, String)()) As ValueMappingEstimator(Of TInputType, TOutputType)" />
        <MemberSignature Language="F#" Value="static member ValueMap : Microsoft.ML.TransformsCatalog.ConversionTransforms * seq&lt;'InputType&gt; * seq&lt;'OutputType&gt; * ValueTuple&lt;string, string&gt;[] -&gt; Microsoft.ML.Transforms.Conversions.ValueMappingEstimator&lt;'InputType, 'OutputType&gt;" Usage="Microsoft.ML.ConversionsExtensionsCatalog.ValueMap (catalog, keys, values, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Conversions.ValueMappingEstimator&lt;TInputType,TOutputType&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TInputType" />
          <TypeParameter Name="TOutputType" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ConversionTransforms" RefType="this" />
          <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;TInputType&gt;" />
          <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;TOutputType&gt;" />
          <Parameter Name="columns" Type="System.ValueTuple&lt;System.String,System.String&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
              <Attribute>
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "source", "name" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="TInputType">The key type.</typeparam>
          <typeparam name="TOutputType">The value type.</typeparam>
          <param name="catalog">The categorical transform's catalog</param>
          <param name="keys">The list of keys to use for the mapping. The mapping is 1-1 with values. This list must be the same length as values and
            cannot contain duplicate keys.</param>
          <param name="values">The list of values to pair with the keys for the mapping. This list must be equal to the same length as keys.</param>
          <param name="columns">The columns to apply this transform on.</param>
          <summary>
            Maps specified keys to specified values
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ConversionsExtensionsCatalog" Member="M:Microsoft.ML.ConversionsExtensionsCatalog.ValueMap``2(Microsoft.ML.TransformsCatalog.ConversionTransforms,System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.ValueTuple{System.String,System.String}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="CustomMapping&lt;TSrc,TDst&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.CustomMappingEstimator&lt;TSrc,TDst&gt; CustomMapping&lt;TSrc,TDst&gt; (this Microsoft.ML.TransformsCatalog catalog, Action&lt;TSrc,TDst&gt; mapAction, string contractName, Microsoft.ML.Data.SchemaDefinition inputSchemaDefinition = null, Microsoft.ML.Data.SchemaDefinition outputSchemaDefinition = null) where TSrc : class, new() where TDst : class, new();" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.CustomMappingEstimator`2&lt;!!TSrc, !!TDst&gt; CustomMapping&lt;class .ctor TSrc, class .ctor TDst&gt;(class Microsoft.ML.TransformsCatalog catalog, class System.Action`2&lt;!!TSrc, !!TDst&gt; mapAction, string contractName, class Microsoft.ML.Data.SchemaDefinition inputSchemaDefinition, class Microsoft.ML.Data.SchemaDefinition outputSchemaDefinition) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.CustomMappingCatalog.CustomMapping``2(Microsoft.ML.TransformsCatalog,System.Action{``0,``1},System.String,Microsoft.ML.Data.SchemaDefinition,Microsoft.ML.Data.SchemaDefinition)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CustomMapping(Of TSrc As {Class, New}, TDst As {Class, New}) (catalog As TransformsCatalog, mapAction As Action(Of TSrc, TDst), contractName As String, Optional inputSchemaDefinition As SchemaDefinition = null, Optional outputSchemaDefinition As SchemaDefinition = null) As CustomMappingEstimator(Of TSrc, TDst)" />
        <MemberSignature Language="F#" Value="static member CustomMapping : Microsoft.ML.TransformsCatalog * Action&lt;'Src, 'Dst (requires 'Src : null and 'Src : (new : unit -&gt; 'Src) and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))&gt; * string * Microsoft.ML.Data.SchemaDefinition * Microsoft.ML.Data.SchemaDefinition -&gt; Microsoft.ML.Transforms.CustomMappingEstimator&lt;'Src, 'Dst (requires 'Src : null and 'Src : (new : unit -&gt; 'Src) and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))&gt; (requires 'Src : null and 'Src : (new : unit -&gt; 'Src) and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))" Usage="Microsoft.ML.CustomMappingCatalog.CustomMapping (catalog, mapAction, contractName, inputSchemaDefinition, outputSchemaDefinition)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.CustomMappingEstimator&lt;TSrc,TDst&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSrc">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
          <TypeParameter Name="TDst">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="mapAction" Type="System.Action&lt;TSrc,TDst&gt;" />
          <Parameter Name="contractName" Type="System.String" />
          <Parameter Name="inputSchemaDefinition" Type="Microsoft.ML.Data.SchemaDefinition" />
          <Parameter Name="outputSchemaDefinition" Type="Microsoft.ML.Data.SchemaDefinition" />
        </Parameters>
        <Docs>
          <typeparam name="TSrc">The class defining which columns to take from the incoming data.</typeparam>
          <typeparam name="TDst">The class defining which new columns are added to the data.</typeparam>
          <param name="catalog">The transform catalog</param>
          <param name="mapAction">The mapping action. This must be thread-safe and free from side effects.</param>
          <param name="contractName">The contract name, used by ML.NET for loading the model. If <c>null</c> is specified, such a trained model would not be save-able.</param>
          <param name="inputSchemaDefinition">Additional parameters for schema mapping between <typeparamref name="TSrc" /> and input data.</param>
          <param name="outputSchemaDefinition">Additional parameters for schema mapping between <typeparamref name="TDst" /> and output data.</param>
          <summary>
            Create a custom mapping of input columns to output columns.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.CustomMappingCatalog" Member="M:Microsoft.ML.CustomMappingCatalog.CustomMapping``2(Microsoft.ML.TransformsCatalog,System.Action{``0,``1},System.String,Microsoft.ML.Data.SchemaDefinition,Microsoft.ML.Data.SchemaDefinition)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="CustomMappingTransformer&lt;TSrc,TDst&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.CustomMappingTransformer&lt;TSrc,TDst&gt; CustomMappingTransformer&lt;TSrc,TDst&gt; (this Microsoft.ML.TransformsCatalog catalog, Action&lt;TSrc,TDst&gt; mapAction, string contractName, Microsoft.ML.Data.SchemaDefinition inputSchemaDefinition = null, Microsoft.ML.Data.SchemaDefinition outputSchemaDefinition = null) where TSrc : class, new() where TDst : class, new();" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.CustomMappingTransformer`2&lt;!!TSrc, !!TDst&gt; CustomMappingTransformer&lt;class .ctor TSrc, class .ctor TDst&gt;(class Microsoft.ML.TransformsCatalog catalog, class System.Action`2&lt;!!TSrc, !!TDst&gt; mapAction, string contractName, class Microsoft.ML.Data.SchemaDefinition inputSchemaDefinition, class Microsoft.ML.Data.SchemaDefinition outputSchemaDefinition) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.CustomMappingCatalog.CustomMappingTransformer``2(Microsoft.ML.TransformsCatalog,System.Action{``0,``1},System.String,Microsoft.ML.Data.SchemaDefinition,Microsoft.ML.Data.SchemaDefinition)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CustomMappingTransformer(Of TSrc As {Class, New}, TDst As {Class, New}) (catalog As TransformsCatalog, mapAction As Action(Of TSrc, TDst), contractName As String, Optional inputSchemaDefinition As SchemaDefinition = null, Optional outputSchemaDefinition As SchemaDefinition = null) As CustomMappingTransformer(Of TSrc, TDst)" />
        <MemberSignature Language="F#" Value="static member CustomMappingTransformer : Microsoft.ML.TransformsCatalog * Action&lt;'Src, 'Dst (requires 'Src : null and 'Src : (new : unit -&gt; 'Src) and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))&gt; * string * Microsoft.ML.Data.SchemaDefinition * Microsoft.ML.Data.SchemaDefinition -&gt; Microsoft.ML.Transforms.CustomMappingTransformer&lt;'Src, 'Dst (requires 'Src : null and 'Src : (new : unit -&gt; 'Src) and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))&gt; (requires 'Src : null and 'Src : (new : unit -&gt; 'Src) and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))" Usage="Microsoft.ML.CustomMappingCatalog.CustomMappingTransformer (catalog, mapAction, contractName, inputSchemaDefinition, outputSchemaDefinition)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.CustomMappingTransformer&lt;TSrc,TDst&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSrc">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
          <TypeParameter Name="TDst">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="mapAction" Type="System.Action&lt;TSrc,TDst&gt;" />
          <Parameter Name="contractName" Type="System.String" />
          <Parameter Name="inputSchemaDefinition" Type="Microsoft.ML.Data.SchemaDefinition" />
          <Parameter Name="outputSchemaDefinition" Type="Microsoft.ML.Data.SchemaDefinition" />
        </Parameters>
        <Docs>
          <typeparam name="TSrc">The class defining which columns to take from the incoming data.</typeparam>
          <typeparam name="TDst">The class defining which new columns are added to the data.</typeparam>
          <param name="catalog">The transform catalog</param>
          <param name="mapAction">The mapping action. This must be thread-safe and free from side effects.</param>
          <param name="contractName">The contract name, used by ML.NET for loading the model. If <c>null</c> is specified, such a trained model would not be save-able.</param>
          <param name="inputSchemaDefinition">Additional parameters for schema mapping between <typeparamref name="TSrc" /> and input data.</param>
          <param name="outputSchemaDefinition">Additional parameters for schema mapping between <typeparamref name="TDst" /> and output data.</param>
          <summary>
            Create a custom mapping of input columns to output columns. Most likely, you should call this method when you are loading the model:
            use <see cref="M:Microsoft.ML.CustomMappingCatalog.CustomMapping``2(Microsoft.ML.TransformsCatalog,System.Action{``0,``1},System.String,Microsoft.ML.Data.SchemaDefinition,Microsoft.ML.Data.SchemaDefinition)" /> when you are
            training the model.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.CustomMappingCatalog" Member="M:Microsoft.ML.CustomMappingCatalog.CustomMappingTransformer``2(Microsoft.ML.TransformsCatalog,System.Action{``0,``1},System.String,Microsoft.ML.Data.SchemaDefinition,Microsoft.ML.Data.SchemaDefinition)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataOperations" />
      </Targets>
      <Member MemberName="GetEnvironment">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.IHostEnvironment GetEnvironment (this Microsoft.ML.DataOperations catalog);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.IHostEnvironment GetEnvironment(class Microsoft.ML.DataOperations catalog) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.CatalogUtils.GetEnvironment(Microsoft.ML.DataOperations)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetEnvironment (catalog As DataOperations) As IHostEnvironment" />
        <MemberSignature Language="F#" Value="static member GetEnvironment : Microsoft.ML.DataOperations -&gt; Microsoft.ML.IHostEnvironment" Usage="Microsoft.ML.Data.CatalogUtils.GetEnvironment catalog" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.IHostEnvironment</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.DataOperations" RefType="this" />
        </Parameters>
        <Docs>
          <param name="catalog">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.CatalogUtils" Member="M:Microsoft.ML.Data.CatalogUtils.GetEnvironment(Microsoft.ML.DataOperations)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.ModelOperationsCatalog" />
      </Targets>
      <Member MemberName="GetEnvironment">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.IHostEnvironment GetEnvironment (this Microsoft.ML.ModelOperationsCatalog catalog);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.IHostEnvironment GetEnvironment(class Microsoft.ML.ModelOperationsCatalog catalog) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.CatalogUtils.GetEnvironment(Microsoft.ML.ModelOperationsCatalog)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetEnvironment (catalog As ModelOperationsCatalog) As IHostEnvironment" />
        <MemberSignature Language="F#" Value="static member GetEnvironment : Microsoft.ML.ModelOperationsCatalog -&gt; Microsoft.ML.IHostEnvironment" Usage="Microsoft.ML.Data.CatalogUtils.GetEnvironment catalog" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.IHostEnvironment</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.ModelOperationsCatalog" RefType="this" />
        </Parameters>
        <Docs>
          <param name="catalog">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.CatalogUtils" Member="M:Microsoft.ML.Data.CatalogUtils.GetEnvironment(Microsoft.ML.ModelOperationsCatalog)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.ModelOperationsCatalog.SubCatalogBase" />
      </Targets>
      <Member MemberName="GetEnvironment">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.IHostEnvironment GetEnvironment (this Microsoft.ML.ModelOperationsCatalog.SubCatalogBase subCatalog);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.IHostEnvironment GetEnvironment(class Microsoft.ML.ModelOperationsCatalog/SubCatalogBase subCatalog) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.CatalogUtils.GetEnvironment(Microsoft.ML.ModelOperationsCatalog.SubCatalogBase)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetEnvironment (subCatalog As ModelOperationsCatalog.SubCatalogBase) As IHostEnvironment" />
        <MemberSignature Language="F#" Value="static member GetEnvironment : Microsoft.ML.ModelOperationsCatalog.SubCatalogBase -&gt; Microsoft.ML.IHostEnvironment" Usage="Microsoft.ML.Data.CatalogUtils.GetEnvironment subCatalog" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.IHostEnvironment</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="subCatalog" Type="Microsoft.ML.ModelOperationsCatalog+SubCatalogBase" RefType="this" />
        </Parameters>
        <Docs>
          <param name="subCatalog">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.CatalogUtils" Member="M:Microsoft.ML.Data.CatalogUtils.GetEnvironment(Microsoft.ML.ModelOperationsCatalog.SubCatalogBase)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="GetEnvironment">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.IHostEnvironment GetEnvironment (this Microsoft.ML.TransformsCatalog catalog);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.IHostEnvironment GetEnvironment(class Microsoft.ML.TransformsCatalog catalog) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.CatalogUtils.GetEnvironment(Microsoft.ML.TransformsCatalog)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetEnvironment (catalog As TransformsCatalog) As IHostEnvironment" />
        <MemberSignature Language="F#" Value="static member GetEnvironment : Microsoft.ML.TransformsCatalog -&gt; Microsoft.ML.IHostEnvironment" Usage="Microsoft.ML.Data.CatalogUtils.GetEnvironment catalog" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.IHostEnvironment</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
        </Parameters>
        <Docs>
          <param name="catalog">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.CatalogUtils" Member="M:Microsoft.ML.Data.CatalogUtils.GetEnvironment(Microsoft.ML.TransformsCatalog)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.SubCatalogBase" />
      </Targets>
      <Member MemberName="GetEnvironment">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.IHostEnvironment GetEnvironment (this Microsoft.ML.TransformsCatalog.SubCatalogBase subCatalog);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.IHostEnvironment GetEnvironment(class Microsoft.ML.TransformsCatalog/SubCatalogBase subCatalog) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.CatalogUtils.GetEnvironment(Microsoft.ML.TransformsCatalog.SubCatalogBase)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetEnvironment (subCatalog As TransformsCatalog.SubCatalogBase) As IHostEnvironment" />
        <MemberSignature Language="F#" Value="static member GetEnvironment : Microsoft.ML.TransformsCatalog.SubCatalogBase -&gt; Microsoft.ML.IHostEnvironment" Usage="Microsoft.ML.Data.CatalogUtils.GetEnvironment subCatalog" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.IHostEnvironment</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="subCatalog" Type="Microsoft.ML.TransformsCatalog+SubCatalogBase" RefType="this" />
        </Parameters>
        <Docs>
          <param name="subCatalog">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.CatalogUtils" Member="M:Microsoft.ML.Data.CatalogUtils.GetEnvironment(Microsoft.ML.TransformsCatalog.SubCatalogBase)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Data.IDataView" />
      </Targets>
      <Member MemberName="GetColumn&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; GetColumn&lt;T&gt; (this Microsoft.ML.Data.IDataView data, Microsoft.ML.IHostEnvironment env, string columnName);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; GetColumn&lt;T&gt;(class Microsoft.ML.Data.IDataView data, class Microsoft.ML.IHostEnvironment env, string columnName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.ColumnCursorExtensions.GetColumn``1(Microsoft.ML.Data.IDataView,Microsoft.ML.IHostEnvironment,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetColumn(Of T) (data As IDataView, env As IHostEnvironment, columnName As String) As IEnumerable(Of T)" />
        <MemberSignature Language="F#" Value="static member GetColumn : Microsoft.ML.Data.IDataView * Microsoft.ML.IHostEnvironment * string -&gt; seq&lt;'T&gt;" Usage="Microsoft.ML.Data.ColumnCursorExtensions.GetColumn (data, env, columnName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.Data.IDataView" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" />
          <Parameter Name="columnName" Type="System.String" />
        </Parameters>
        <Docs>
          <typeparam name="T">The type of the values. This must match the actual column type.</typeparam>
          <param name="data">The data view to get the column from.</param>
          <param name="env">The current host environment.</param>
          <param name="columnName">The name of the column to extract.</param>
          <summary>
            Extract all values of one column of the data view in a form of an <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.ColumnCursorExtensions" Member="M:Microsoft.ML.Data.ColumnCursorExtensions.GetColumn``1(Microsoft.ML.Data.IDataView,Microsoft.ML.IHostEnvironment,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreateDataView&lt;TRow&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.IDataView CreateDataView&lt;TRow&gt; (this Microsoft.ML.IHostEnvironment env, System.Collections.Generic.IList&lt;TRow&gt; data, Microsoft.ML.Data.SchemaDefinition schemaDefinition = null) where TRow : class;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.IDataView CreateDataView&lt;class TRow&gt;(class Microsoft.ML.IHostEnvironment env, class System.Collections.Generic.IList`1&lt;!!TRow&gt; data, class Microsoft.ML.Data.SchemaDefinition schemaDefinition) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.ComponentCreation.CreateDataView``1(Microsoft.ML.IHostEnvironment,System.Collections.Generic.IList{``0},Microsoft.ML.Data.SchemaDefinition)" />
        <MemberSignature Language="F#" Value="static member CreateDataView : Microsoft.ML.IHostEnvironment * System.Collections.Generic.IList&lt;'Row (requires 'Row : null)&gt; * Microsoft.ML.Data.SchemaDefinition -&gt; Microsoft.ML.Data.IDataView (requires 'Row : null)" Usage="Microsoft.ML.Data.ComponentCreation.CreateDataView (env, data, schemaDefinition)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.IDataView</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRow">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" RefType="this" />
          <Parameter Name="data" Type="System.Collections.Generic.IList&lt;TRow&gt;" />
          <Parameter Name="schemaDefinition" Type="Microsoft.ML.Data.SchemaDefinition" />
        </Parameters>
        <Docs>
          <typeparam name="TRow">The user-defined item type.</typeparam>
          <param name="env">The host environment to use for data view creation.</param>
          <param name="data">The data to wrap around.</param>
          <param name="schemaDefinition">The optional schema definition of the data view to create. If <c>null</c>,
             the schema definition is inferred from <typeparamref name="TRow" />.</param>
          <summary>
             Create a new <see cref="T:Microsoft.ML.Data.IDataView" /> over an in-memory collection of the items of user-defined type.
             The user maintains ownership of the <paramref name="data" /> and the resulting data view will
             never alter the contents of the <paramref name="data" />.
             Since <see cref="T:Microsoft.ML.Data.IDataView" /> is assumed to be immutable, the user is expected to not
             modify the contents of <paramref name="data" /> while the data view is being actively cursored.
            
             One typical usage for in-memory data view could be: create the data view, train a predictor.
             Once the predictor is fully trained, modify the contents of the underlying collection and
             train another predictor.
             </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.ComponentCreation" Member="M:Microsoft.ML.Data.ComponentCreation.CreateDataView``1(Microsoft.ML.IHostEnvironment,System.Collections.Generic.IList{``0},Microsoft.ML.Data.SchemaDefinition)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreateLoader">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.IDataLoader CreateLoader (this Microsoft.ML.IHostEnvironment env, string settings, Microsoft.ML.Data.IMultiStreamSource files);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.IDataLoader CreateLoader(class Microsoft.ML.IHostEnvironment env, string settings, class Microsoft.ML.Data.IMultiStreamSource files) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.ComponentCreation.CreateLoader(Microsoft.ML.IHostEnvironment,System.String,Microsoft.ML.Data.IMultiStreamSource)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateLoader (env As IHostEnvironment, settings As String, files As IMultiStreamSource) As IDataLoader" />
        <MemberSignature Language="F#" Value="static member CreateLoader : Microsoft.ML.IHostEnvironment * string * Microsoft.ML.Data.IMultiStreamSource -&gt; Microsoft.ML.Data.IDataLoader" Usage="Microsoft.ML.Data.ComponentCreation.CreateLoader (env, settings, files)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.IDataLoader</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" RefType="this" />
          <Parameter Name="settings" Type="System.String" />
          <Parameter Name="files" Type="Microsoft.ML.Data.IMultiStreamSource" />
        </Parameters>
        <Docs>
          <param name="env">To be added.</param>
          <param name="settings">To be added.</param>
          <param name="files">To be added.</param>
          <summary>
            Creates a data loader from the 'LoadName{settings}' string.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.ComponentCreation" Member="M:Microsoft.ML.Data.ComponentCreation.CreateLoader(Microsoft.ML.IHostEnvironment,System.String,Microsoft.ML.Data.IMultiStreamSource)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreateLoader&lt;TArgs&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.IDataLoader CreateLoader&lt;TArgs&gt; (this Microsoft.ML.IHostEnvironment env, TArgs arguments, Microsoft.ML.Data.IMultiStreamSource files) where TArgs : class, new();" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.IDataLoader CreateLoader&lt;class .ctor TArgs&gt;(class Microsoft.ML.IHostEnvironment env, !!TArgs arguments, class Microsoft.ML.Data.IMultiStreamSource files) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.ComponentCreation.CreateLoader``1(Microsoft.ML.IHostEnvironment,``0,Microsoft.ML.Data.IMultiStreamSource)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateLoader(Of TArgs As {Class, New}) (env As IHostEnvironment, arguments As TArgs, files As IMultiStreamSource) As IDataLoader" />
        <MemberSignature Language="F#" Value="static member CreateLoader : Microsoft.ML.IHostEnvironment * 'Args * Microsoft.ML.Data.IMultiStreamSource -&gt; Microsoft.ML.Data.IDataLoader (requires 'Args : null and 'Args : (new : unit -&gt; 'Args))" Usage="Microsoft.ML.Data.ComponentCreation.CreateLoader (env, arguments, files)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.IDataLoader</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TArgs">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" RefType="this" />
          <Parameter Name="arguments" Type="TArgs" />
          <Parameter Name="files" Type="Microsoft.ML.Data.IMultiStreamSource" />
        </Parameters>
        <Docs>
          <typeparam name="TArgs">To be added.</typeparam>
          <param name="env">To be added.</param>
          <param name="arguments">To be added.</param>
          <param name="files">To be added.</param>
          <summary>
            Creates a data loader from the arguments object.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.ComponentCreation" Member="M:Microsoft.ML.Data.ComponentCreation.CreateLoader``1(Microsoft.ML.IHostEnvironment,``0,Microsoft.ML.Data.IMultiStreamSource)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreateSaver">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.IDataSaver CreateSaver (this Microsoft.ML.IHostEnvironment env, string settings);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.IDataSaver CreateSaver(class Microsoft.ML.IHostEnvironment env, string settings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.ComponentCreation.CreateSaver(Microsoft.ML.IHostEnvironment,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateSaver (env As IHostEnvironment, settings As String) As IDataSaver" />
        <MemberSignature Language="F#" Value="static member CreateSaver : Microsoft.ML.IHostEnvironment * string -&gt; Microsoft.ML.Data.IDataSaver" Usage="Microsoft.ML.Data.ComponentCreation.CreateSaver (env, settings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.IDataSaver</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" RefType="this" />
          <Parameter Name="settings" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="env">To be added.</param>
          <param name="settings">To be added.</param>
          <summary>
            Creates a data saver from the 'LoadName{settings}' string.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.ComponentCreation" Member="M:Microsoft.ML.Data.ComponentCreation.CreateSaver(Microsoft.ML.IHostEnvironment,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreateSaver&lt;TArgs&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.IDataSaver CreateSaver&lt;TArgs&gt; (this Microsoft.ML.IHostEnvironment env, TArgs arguments) where TArgs : class, new();" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.IDataSaver CreateSaver&lt;class .ctor TArgs&gt;(class Microsoft.ML.IHostEnvironment env, !!TArgs arguments) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.ComponentCreation.CreateSaver``1(Microsoft.ML.IHostEnvironment,``0)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateSaver(Of TArgs As {Class, New}) (env As IHostEnvironment, arguments As TArgs) As IDataSaver" />
        <MemberSignature Language="F#" Value="static member CreateSaver : Microsoft.ML.IHostEnvironment * 'Args -&gt; Microsoft.ML.Data.IDataSaver (requires 'Args : null and 'Args : (new : unit -&gt; 'Args))" Usage="Microsoft.ML.Data.ComponentCreation.CreateSaver (env, arguments)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.IDataSaver</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TArgs">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" RefType="this" />
          <Parameter Name="arguments" Type="TArgs" />
        </Parameters>
        <Docs>
          <typeparam name="TArgs">To be added.</typeparam>
          <param name="env">To be added.</param>
          <param name="arguments">To be added.</param>
          <summary>
            Creates a data saver from the arguments object.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.ComponentCreation" Member="M:Microsoft.ML.Data.ComponentCreation.CreateSaver``1(Microsoft.ML.IHostEnvironment,``0)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreateStreamingDataView&lt;TRow&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.IDataView CreateStreamingDataView&lt;TRow&gt; (this Microsoft.ML.IHostEnvironment env, System.Collections.Generic.IEnumerable&lt;TRow&gt; data, Microsoft.ML.Data.SchemaDefinition schemaDefinition = null) where TRow : class;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.IDataView CreateStreamingDataView&lt;class TRow&gt;(class Microsoft.ML.IHostEnvironment env, class System.Collections.Generic.IEnumerable`1&lt;!!TRow&gt; data, class Microsoft.ML.Data.SchemaDefinition schemaDefinition) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.ComponentCreation.CreateStreamingDataView``1(Microsoft.ML.IHostEnvironment,System.Collections.Generic.IEnumerable{``0},Microsoft.ML.Data.SchemaDefinition)" />
        <MemberSignature Language="F#" Value="static member CreateStreamingDataView : Microsoft.ML.IHostEnvironment * seq&lt;'Row (requires 'Row : null)&gt; * Microsoft.ML.Data.SchemaDefinition -&gt; Microsoft.ML.Data.IDataView (requires 'Row : null)" Usage="Microsoft.ML.Data.ComponentCreation.CreateStreamingDataView (env, data, schemaDefinition)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.IDataView</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRow">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" RefType="this" />
          <Parameter Name="data" Type="System.Collections.Generic.IEnumerable&lt;TRow&gt;" />
          <Parameter Name="schemaDefinition" Type="Microsoft.ML.Data.SchemaDefinition" />
        </Parameters>
        <Docs>
          <typeparam name="TRow">The user-defined item type.</typeparam>
          <param name="env">The host environment to use for data view creation.</param>
          <param name="data">The data to wrap around.</param>
          <param name="schemaDefinition">The optional schema definition of the data view to create. If <c>null</c>,
             the schema definition is inferred from <typeparamref name="TRow" />.</param>
          <summary>
             Create a new <see cref="T:Microsoft.ML.Data.IDataView" /> over an enumerable of the items of user-defined type.
             The user maintains ownership of the <paramref name="data" /> and the resulting data view will
             never alter the contents of the <paramref name="data" />.
             Since <see cref="T:Microsoft.ML.Data.IDataView" /> is assumed to be immutable, the user is expected to support
             multiple enumeration of the <paramref name="data" /> that would return the same results, unless
             the user knows that the data will only be cursored once.
            
             One typical usage for streaming data view could be: create the data view that lazily loads data
             as needed, then apply pre-trained transformations to it and cursor through it for transformation
             results.
             </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.ComponentCreation" Member="M:Microsoft.ML.Data.ComponentCreation.CreateStreamingDataView``1(Microsoft.ML.IHostEnvironment,System.Collections.Generic.IEnumerable{``0},Microsoft.ML.Data.SchemaDefinition)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreateTransform">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.IDataTransform CreateTransform (this Microsoft.ML.IHostEnvironment env, string settings, Microsoft.ML.Data.IDataView source);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.IDataTransform CreateTransform(class Microsoft.ML.IHostEnvironment env, string settings, class Microsoft.ML.Data.IDataView source) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.ComponentCreation.CreateTransform(Microsoft.ML.IHostEnvironment,System.String,Microsoft.ML.Data.IDataView)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateTransform (env As IHostEnvironment, settings As String, source As IDataView) As IDataTransform" />
        <MemberSignature Language="F#" Value="static member CreateTransform : Microsoft.ML.IHostEnvironment * string * Microsoft.ML.Data.IDataView -&gt; Microsoft.ML.Data.IDataTransform" Usage="Microsoft.ML.Data.ComponentCreation.CreateTransform (env, settings, source)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.IDataTransform</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" RefType="this" />
          <Parameter Name="settings" Type="System.String" />
          <Parameter Name="source" Type="Microsoft.ML.Data.IDataView" />
        </Parameters>
        <Docs>
          <param name="env">To be added.</param>
          <param name="settings">To be added.</param>
          <param name="source">To be added.</param>
          <summary>
            Creates a data transform from the 'LoadName{settings}' string.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.ComponentCreation" Member="M:Microsoft.ML.Data.ComponentCreation.CreateTransform(Microsoft.ML.IHostEnvironment,System.String,Microsoft.ML.Data.IDataView)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreateTransform&lt;TArgs&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.IDataTransform CreateTransform&lt;TArgs&gt; (this Microsoft.ML.IHostEnvironment env, TArgs arguments, Microsoft.ML.Data.IDataView source) where TArgs : class, new();" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.IDataTransform CreateTransform&lt;class .ctor TArgs&gt;(class Microsoft.ML.IHostEnvironment env, !!TArgs arguments, class Microsoft.ML.Data.IDataView source) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.ComponentCreation.CreateTransform``1(Microsoft.ML.IHostEnvironment,``0,Microsoft.ML.Data.IDataView)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateTransform(Of TArgs As {Class, New}) (env As IHostEnvironment, arguments As TArgs, source As IDataView) As IDataTransform" />
        <MemberSignature Language="F#" Value="static member CreateTransform : Microsoft.ML.IHostEnvironment * 'Args * Microsoft.ML.Data.IDataView -&gt; Microsoft.ML.Data.IDataTransform (requires 'Args : null and 'Args : (new : unit -&gt; 'Args))" Usage="Microsoft.ML.Data.ComponentCreation.CreateTransform (env, arguments, source)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.IDataTransform</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TArgs">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" RefType="this" />
          <Parameter Name="arguments" Type="TArgs" />
          <Parameter Name="source" Type="Microsoft.ML.Data.IDataView" />
        </Parameters>
        <Docs>
          <typeparam name="TArgs">To be added.</typeparam>
          <param name="env">To be added.</param>
          <param name="arguments">To be added.</param>
          <param name="source">To be added.</param>
          <summary>
            Creates a data transform from the arguments object.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.ComponentCreation" Member="M:Microsoft.ML.Data.ComponentCreation.CreateTransform``1(Microsoft.ML.IHostEnvironment,``0,Microsoft.ML.Data.IDataView)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IHostEnvironment" />
      </Targets>
      <Member MemberName="LoadPredictorOrNull">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.IPredictor LoadPredictorOrNull (this Microsoft.ML.IHostEnvironment env, System.IO.Stream modelStream);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.IPredictor LoadPredictorOrNull(class Microsoft.ML.IHostEnvironment env, class System.IO.Stream modelStream) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.ComponentCreation.LoadPredictorOrNull(Microsoft.ML.IHostEnvironment,System.IO.Stream)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LoadPredictorOrNull (env As IHostEnvironment, modelStream As Stream) As IPredictor" />
        <MemberSignature Language="F#" Value="static member LoadPredictorOrNull : Microsoft.ML.IHostEnvironment * System.IO.Stream -&gt; Microsoft.ML.IPredictor" Usage="Microsoft.ML.Data.ComponentCreation.LoadPredictorOrNull (env, modelStream)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.IPredictor</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" RefType="this" />
          <Parameter Name="modelStream" Type="System.IO.Stream" />
        </Parameters>
        <Docs>
          <param name="env">The host environment to use.</param>
          <param name="modelStream">The model stream.</param>
          <summary>
            Loads a predictor from the model stream. Returns null iff there's no predictor.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.ComponentCreation" Member="M:Microsoft.ML.Data.ComponentCreation.LoadPredictorOrNull(Microsoft.ML.IHostEnvironment,System.IO.Stream)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IHostEnvironment" />
      </Targets>
      <Member MemberName="LoadTransforms">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.IDataView LoadTransforms (this Microsoft.ML.IHostEnvironment env, System.IO.Stream modelStream, Microsoft.ML.Data.IDataView data);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.IDataView LoadTransforms(class Microsoft.ML.IHostEnvironment env, class System.IO.Stream modelStream, class Microsoft.ML.Data.IDataView data) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.ComponentCreation.LoadTransforms(Microsoft.ML.IHostEnvironment,System.IO.Stream,Microsoft.ML.Data.IDataView)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LoadTransforms (env As IHostEnvironment, modelStream As Stream, data As IDataView) As IDataView" />
        <MemberSignature Language="F#" Value="static member LoadTransforms : Microsoft.ML.IHostEnvironment * System.IO.Stream * Microsoft.ML.Data.IDataView -&gt; Microsoft.ML.Data.IDataView" Usage="Microsoft.ML.Data.ComponentCreation.LoadTransforms (env, modelStream, data)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.IDataView</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" RefType="this" />
          <Parameter Name="modelStream" Type="System.IO.Stream" />
          <Parameter Name="data" Type="Microsoft.ML.Data.IDataView" />
        </Parameters>
        <Docs>
          <param name="env">The host environment to use.</param>
          <param name="modelStream">The model stream to load from.</param>
          <param name="data">The data to apply transforms to.</param>
          <summary>
            Load the transforms (but not loader) from the model steram and apply them to the specified data.
            It is acceptable to have no transforms in the model stream: in this case the original
            <paramref name="data" /> will be returned.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.ComponentCreation" Member="M:Microsoft.ML.Data.ComponentCreation.LoadTransforms(Microsoft.ML.IHostEnvironment,System.IO.Stream,Microsoft.ML.Data.IDataView)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.IHostEnvironment" />
      </Targets>
      <Member MemberName="Zip">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.IDataView Zip (this Microsoft.ML.IHostEnvironment env, System.Collections.Generic.IEnumerable&lt;Microsoft.ML.Data.IDataView&gt; sources);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.IDataView Zip(class Microsoft.ML.IHostEnvironment env, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.ML.Data.IDataView&gt; sources) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.ComponentCreation.Zip(Microsoft.ML.IHostEnvironment,System.Collections.Generic.IEnumerable{Microsoft.ML.Data.IDataView})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Zip (env As IHostEnvironment, sources As IEnumerable(Of IDataView)) As IDataView" />
        <MemberSignature Language="F#" Value="static member Zip : Microsoft.ML.IHostEnvironment * seq&lt;Microsoft.ML.Data.IDataView&gt; -&gt; Microsoft.ML.Data.IDataView" Usage="Microsoft.ML.Data.ComponentCreation.Zip (env, sources)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.IDataView</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" RefType="this" />
          <Parameter Name="sources" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.ML.Data.IDataView&gt;" />
        </Parameters>
        <Docs>
          <param name="env">The host environment to use.</param>
          <param name="sources">A non-empty collection of data views to zip together.</param>
          <summary>
            Create a new data view which is obtained by appending all columns of all the source data views.
            If the data views are of different length, the resulting data view will have the length equal to the
            length of the shortest source.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.ComponentCreation" Member="M:Microsoft.ML.Data.ComponentCreation.Zip(Microsoft.ML.IHostEnvironment,System.Collections.Generic.IEnumerable{Microsoft.ML.Data.IDataView})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.IDataReader`1" />
      </Targets>
      <Member MemberName="SaveTo&lt;TSource&gt;">
        <MemberSignature Language="C#" Value="public static void SaveTo&lt;TSource&gt; (this Microsoft.ML.Core.Data.IDataReader&lt;TSource&gt; reader, Microsoft.ML.IHostEnvironment env, System.IO.Stream outputStream);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SaveTo&lt;TSource&gt;(class Microsoft.ML.Core.Data.IDataReader`1&lt;!!TSource&gt; reader, class Microsoft.ML.IHostEnvironment env, class System.IO.Stream outputStream) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.CompositeDataReader.SaveTo``1(Microsoft.ML.Core.Data.IDataReader{``0},Microsoft.ML.IHostEnvironment,System.IO.Stream)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub SaveTo(Of TSource) (reader As IDataReader(Of TSource), env As IHostEnvironment, outputStream As Stream)" />
        <MemberSignature Language="F#" Value="static member SaveTo : Microsoft.ML.Core.Data.IDataReader&lt;'Source&gt; * Microsoft.ML.IHostEnvironment * System.IO.Stream -&gt; unit" Usage="Microsoft.ML.Data.CompositeDataReader.SaveTo (reader, env, outputStream)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSource" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="reader" Type="Microsoft.ML.Core.Data.IDataReader&lt;TSource&gt;" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" />
          <Parameter Name="outputStream" Type="System.IO.Stream" />
        </Parameters>
        <Docs>
          <typeparam name="TSource">To be added.</typeparam>
          <param name="reader">To be added.</param>
          <param name="env">To be added.</param>
          <param name="outputStream">To be added.</param>
          <summary>
            Save the contents to a stream, as a "model file".
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.CompositeDataReader" Member="M:Microsoft.ML.Data.CompositeDataReader.SaveTo``1(Microsoft.ML.Core.Data.IDataReader{``0},Microsoft.ML.IHostEnvironment,System.IO.Stream)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Data.IDataView" />
      </Targets>
      <Member MemberName="AsCursorable&lt;TRow&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.ICursorable&lt;TRow&gt; AsCursorable&lt;TRow&gt; (this Microsoft.ML.Data.IDataView data, Microsoft.ML.IHostEnvironment env, bool ignoreMissingColumns = false, Microsoft.ML.Data.SchemaDefinition schemaDefinition = null) where TRow : class, new();" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.ICursorable`1&lt;!!TRow&gt; AsCursorable&lt;class .ctor TRow&gt;(class Microsoft.ML.Data.IDataView data, class Microsoft.ML.IHostEnvironment env, bool ignoreMissingColumns, class Microsoft.ML.Data.SchemaDefinition schemaDefinition) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.CursoringUtils.AsCursorable``1(Microsoft.ML.Data.IDataView,Microsoft.ML.IHostEnvironment,System.Boolean,Microsoft.ML.Data.SchemaDefinition)" />
        <MemberSignature Language="F#" Value="static member AsCursorable : Microsoft.ML.Data.IDataView * Microsoft.ML.IHostEnvironment * bool * Microsoft.ML.Data.SchemaDefinition -&gt; Microsoft.ML.Data.ICursorable&lt;'Row (requires 'Row : null and 'Row : (new : unit -&gt; 'Row))&gt; (requires 'Row : null and 'Row : (new : unit -&gt; 'Row))" Usage="Microsoft.ML.Data.CursoringUtils.AsCursorable (data, env, ignoreMissingColumns, schemaDefinition)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.ICursorable&lt;TRow&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRow">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.Data.IDataView" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" />
          <Parameter Name="ignoreMissingColumns" Type="System.Boolean" />
          <Parameter Name="schemaDefinition" Type="Microsoft.ML.Data.SchemaDefinition" />
        </Parameters>
        <Docs>
          <typeparam name="TRow">The user-defined row type.</typeparam>
          <param name="data">The underlying data view.</param>
          <param name="env">The environment.</param>
          <param name="ignoreMissingColumns">Whether to ignore the case when a requested column is not present in the data view.</param>
          <param name="schemaDefinition">Optional user-provided schema definition. If it is not present, the schema is inferred from the definition of T.</param>
          <summary>
            Generate a strongly-typed cursorable wrapper of the <see cref="T:Microsoft.ML.Data.IDataView" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.CursoringUtils" Member="M:Microsoft.ML.Data.CursoringUtils.AsCursorable``1(Microsoft.ML.Data.IDataView,Microsoft.ML.IHostEnvironment,System.Boolean,Microsoft.ML.Data.SchemaDefinition)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Data.IDataView" />
      </Targets>
      <Member MemberName="AsEnumerable&lt;TRow&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TRow&gt; AsEnumerable&lt;TRow&gt; (this Microsoft.ML.Data.IDataView data, Microsoft.ML.IHostEnvironment env, bool reuseRowObject, bool ignoreMissingColumns = false, Microsoft.ML.Data.SchemaDefinition schemaDefinition = null) where TRow : class, new();" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TRow&gt; AsEnumerable&lt;class .ctor TRow&gt;(class Microsoft.ML.Data.IDataView data, class Microsoft.ML.IHostEnvironment env, bool reuseRowObject, bool ignoreMissingColumns, class Microsoft.ML.Data.SchemaDefinition schemaDefinition) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.CursoringUtils.AsEnumerable``1(Microsoft.ML.Data.IDataView,Microsoft.ML.IHostEnvironment,System.Boolean,System.Boolean,Microsoft.ML.Data.SchemaDefinition)" />
        <MemberSignature Language="F#" Value="static member AsEnumerable : Microsoft.ML.Data.IDataView * Microsoft.ML.IHostEnvironment * bool * bool * Microsoft.ML.Data.SchemaDefinition -&gt; seq&lt;'Row (requires 'Row : null and 'Row : (new : unit -&gt; 'Row))&gt; (requires 'Row : null and 'Row : (new : unit -&gt; 'Row))" Usage="Microsoft.ML.Data.CursoringUtils.AsEnumerable (data, env, reuseRowObject, ignoreMissingColumns, schemaDefinition)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;TRow&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRow">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.Data.IDataView" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" />
          <Parameter Name="reuseRowObject" Type="System.Boolean" />
          <Parameter Name="ignoreMissingColumns" Type="System.Boolean" />
          <Parameter Name="schemaDefinition" Type="Microsoft.ML.Data.SchemaDefinition" />
        </Parameters>
        <Docs>
          <typeparam name="TRow">The user-defined row type.</typeparam>
          <param name="data">The underlying data view.</param>
          <param name="env">The environment.</param>
          <param name="reuseRowObject">Whether to return the same object on every row, or allocate a new one per row.</param>
          <param name="ignoreMissingColumns">Whether to ignore the case when a requested column is not present in the data view.</param>
          <param name="schemaDefinition">Optional user-provided schema definition. If it is not present, the schema is inferred from the definition of T.</param>
          <summary>
            Convert an <see cref="T:Microsoft.ML.Data.IDataView" /> into a strongly-typed <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.CursoringUtils" Member="M:Microsoft.ML.Data.CursoringUtils.AsEnumerable``1(Microsoft.ML.Data.IDataView,Microsoft.ML.IHostEnvironment,System.Boolean,System.Boolean,Microsoft.ML.Data.SchemaDefinition)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Data.Schema" />
      </Targets>
      <Member MemberName="GetTempColumnName">
        <MemberSignature Language="C#" Value="public static string GetTempColumnName (this Microsoft.ML.Data.Schema schema, string tag = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempColumnName(class Microsoft.ML.Data.Schema schema, string tag) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.DataViewUtils.GetTempColumnName(Microsoft.ML.Data.Schema,System.String)" />
        <MemberSignature Language="F#" Value="static member GetTempColumnName : Microsoft.ML.Data.Schema * string -&gt; string" Usage="Microsoft.ML.Data.DataViewUtils.GetTempColumnName (schema, tag)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="schema" Type="Microsoft.ML.Data.Schema" RefType="this" />
          <Parameter Name="tag" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="schema">To be added.</param>
          <param name="tag">To be added.</param>
          <summary>
            Generate a unique temporary column name for the given schema.
            Use tag to independently create multiple temporary, unique column
            names for a single transform.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.DataViewUtils" Member="M:Microsoft.ML.Data.DataViewUtils.GetTempColumnName(Microsoft.ML.Data.Schema,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Data.Schema" />
      </Targets>
      <Member MemberName="GetTempColumnNames">
        <MemberSignature Language="C#" Value="public static string[] GetTempColumnNames (this Microsoft.ML.Data.Schema schema, int n, string tag = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetTempColumnNames(class Microsoft.ML.Data.Schema schema, int32 n, string tag) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.DataViewUtils.GetTempColumnNames(Microsoft.ML.Data.Schema,System.Int32,System.String)" />
        <MemberSignature Language="F#" Value="static member GetTempColumnNames : Microsoft.ML.Data.Schema * int * string -&gt; string[]" Usage="Microsoft.ML.Data.DataViewUtils.GetTempColumnNames (schema, n, tag)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="schema" Type="Microsoft.ML.Data.Schema" RefType="this" />
          <Parameter Name="n" Type="System.Int32" />
          <Parameter Name="tag" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="schema">To be added.</param>
          <param name="n">To be added.</param>
          <param name="tag">To be added.</param>
          <summary>
            Generate n unique temporary column names for the given schema.
            Use tag to independently create multiple temporary, unique column
            names for a single transform.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.DataViewUtils" Member="M:Microsoft.ML.Data.DataViewUtils.GetTempColumnNames(Microsoft.ML.Data.Schema,System.Int32,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Data.ColumnType" />
      </Targets>
      <Member MemberName="IsCachable">
        <MemberSignature Language="C#" Value="public static bool IsCachable (this Microsoft.ML.Data.ColumnType type);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsCachable(class Microsoft.ML.Data.ColumnType type) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.DataViewUtils.IsCachable(Microsoft.ML.Data.ColumnType)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsCachable (type As ColumnType) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsCachable : Microsoft.ML.Data.ColumnType -&gt; bool" Usage="Microsoft.ML.Data.DataViewUtils.IsCachable type" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="type" Type="Microsoft.ML.Data.ColumnType" RefType="this" />
        </Parameters>
        <Docs>
          <param name="type">To be added.</param>
          <summary>
            Determine whether the given type is cachable - either a primitive type or a vector type.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.DataViewUtils" Member="M:Microsoft.ML.Data.DataViewUtils.IsCachable(Microsoft.ML.Data.ColumnType)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Data.IO.CompressionKind" />
      </Targets>
      <Member MemberName="CompressStream">
        <MemberSignature Language="C#" Value="public static System.IO.Stream CompressStream (this Microsoft.ML.Data.IO.CompressionKind compression, System.IO.Stream stream);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream CompressStream(valuetype Microsoft.ML.Data.IO.CompressionKind compression, class System.IO.Stream stream) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.IO.CompressionCodecExtension.CompressStream(Microsoft.ML.Data.IO.CompressionKind,System.IO.Stream)" />
        <MemberSignature Language="F#" Value="static member CompressStream : Microsoft.ML.Data.IO.CompressionKind * System.IO.Stream -&gt; System.IO.Stream" Usage="Microsoft.ML.Data.IO.CompressionCodecExtension.CompressStream (compression, stream)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.IO.Stream</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="compression" Type="Microsoft.ML.Data.IO.CompressionKind" RefType="this" />
          <Parameter Name="stream" Type="System.IO.Stream" />
        </Parameters>
        <Docs>
          <param name="compression">The compression codec</param>
          <param name="stream">The stream to which compressed data will be written</param>
          <summary>
            Generate an appropriate wrapping compressing stream for the codec. This
            stream will be closable and disposable, without closing or disposing of
            the passed in stream. The scheme for compression is not in any way
            parameterizable.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.IO.CompressionCodecExtension" Member="M:Microsoft.ML.Data.IO.CompressionCodecExtension.CompressStream(Microsoft.ML.Data.IO.CompressionKind,System.IO.Stream)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Data.IO.CompressionKind" />
      </Targets>
      <Member MemberName="DecompressStream">
        <MemberSignature Language="C#" Value="public static System.IO.Stream DecompressStream (this Microsoft.ML.Data.IO.CompressionKind compression, System.IO.Stream stream);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream DecompressStream(valuetype Microsoft.ML.Data.IO.CompressionKind compression, class System.IO.Stream stream) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.IO.CompressionCodecExtension.DecompressStream(Microsoft.ML.Data.IO.CompressionKind,System.IO.Stream)" />
        <MemberSignature Language="F#" Value="static member DecompressStream : Microsoft.ML.Data.IO.CompressionKind * System.IO.Stream -&gt; System.IO.Stream" Usage="Microsoft.ML.Data.IO.CompressionCodecExtension.DecompressStream (compression, stream)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.IO.Stream</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="compression" Type="Microsoft.ML.Data.IO.CompressionKind" RefType="this" />
          <Parameter Name="stream" Type="System.IO.Stream" />
        </Parameters>
        <Docs>
          <param name="compression">The compression codec</param>
          <param name="stream">The stream from which compressed data will be written</param>
          <summary>
            Generate an appropriate wrapping decompressing stream for the codec.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.IO.CompressionCodecExtension" Member="M:Microsoft.ML.Data.IO.CompressionCodecExtension.DecompressStream(Microsoft.ML.Data.IO.CompressionKind,System.IO.Stream)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Data.Schema" />
      </Targets>
      <Member MemberName="GetMaxMetadataKind">
        <MemberSignature Language="C#" Value="public static uint GetMaxMetadataKind (this Microsoft.ML.Data.Schema schema, out int colMax, string metadataKind, Func&lt;Microsoft.ML.Data.Schema,int,bool&gt; filterFunc = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 GetMaxMetadataKind(class Microsoft.ML.Data.Schema schema, [out] int32&amp; colMax, string metadataKind, class System.Func`3&lt;class Microsoft.ML.Data.Schema, int32, bool&gt; filterFunc) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.MetadataUtils.GetMaxMetadataKind(Microsoft.ML.Data.Schema,System.Int32@,System.String,System.Func{Microsoft.ML.Data.Schema,System.Int32,System.Boolean})" />
        <MemberSignature Language="F#" Value="static member GetMaxMetadataKind : Microsoft.ML.Data.Schema *  * string * Func&lt;Microsoft.ML.Data.Schema, int, bool&gt; -&gt; uint32" Usage="Microsoft.ML.Data.MetadataUtils.GetMaxMetadataKind (schema, colMax, metadataKind, filterFunc)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.UInt32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="schema" Type="Microsoft.ML.Data.Schema" RefType="this" />
          <Parameter Name="colMax" Type="System.Int32" RefType="out" />
          <Parameter Name="metadataKind" Type="System.String" />
          <Parameter Name="filterFunc" Type="System.Func&lt;Microsoft.ML.Data.Schema,System.Int32,System.Boolean&gt;" />
        </Parameters>
        <Docs>
          <param name="schema">To be added.</param>
          <param name="colMax">To be added.</param>
          <param name="metadataKind">To be added.</param>
          <param name="filterFunc">To be added.</param>
          <summary>
            Returns the max value for the specified metadata kind.
            The metadata type should be a KeyType with raw type U4.
            colMax will be set to the first column that has the max value for the specified metadata.
            If no column has the specified metadata, colMax is set to -1 and the method returns zero.
            The filter function is called for each column, passing in the schema and the column index, and returns
            true if the column should be considered, false if the column should be skipped.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.MetadataUtils" Member="M:Microsoft.ML.Data.MetadataUtils.GetMaxMetadataKind(Microsoft.ML.Data.Schema,System.Int32@,System.String,System.Func{Microsoft.ML.Data.Schema,System.Int32,System.Boolean})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Data.Schema.Column" />
      </Targets>
      <Member MemberName="GetSlotNames">
        <MemberSignature Language="C#" Value="public static void GetSlotNames (this Microsoft.ML.Data.Schema.Column column, ref Microsoft.ML.Data.VBuffer&lt;ReadOnlyMemory&lt;char&gt;&gt; slotNames);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetSlotNames(valuetype Microsoft.ML.Data.Schema/Column column, valuetype Microsoft.ML.Data.VBuffer`1&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt;&amp; slotNames) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.MetadataUtils.GetSlotNames(Microsoft.ML.Data.Schema.Column,Microsoft.ML.Data.VBuffer{System.ReadOnlyMemory{System.Char}}@)" />
        <MemberSignature Language="F#" Value="static member GetSlotNames : Microsoft.ML.Data.Schema.Column *  -&gt; unit" Usage="Microsoft.ML.Data.MetadataUtils.GetSlotNames (column, slotNames)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="column" Type="Microsoft.ML.Data.Schema+Column" RefType="this" />
          <Parameter Name="slotNames" Type="Microsoft.ML.Data.VBuffer&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="column">To be added.</param>
          <param name="slotNames">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.MetadataUtils" Member="M:Microsoft.ML.Data.MetadataUtils.GetSlotNames(Microsoft.ML.Data.Schema.Column,Microsoft.ML.Data.VBuffer{System.ReadOnlyMemory{System.Char}}@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.SchemaShape.Column" />
      </Targets>
      <Member MemberName="HasSlotNames">
        <MemberSignature Language="C#" Value="public static bool HasSlotNames (this Microsoft.ML.Core.Data.SchemaShape.Column col);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasSlotNames(valuetype Microsoft.ML.Core.Data.SchemaShape/Column col) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.MetadataUtils.HasSlotNames(Microsoft.ML.Core.Data.SchemaShape.Column)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function HasSlotNames (col As SchemaShape.Column) As Boolean" />
        <MemberSignature Language="F#" Value="static member HasSlotNames : Microsoft.ML.Core.Data.SchemaShape.Column -&gt; bool" Usage="Microsoft.ML.Data.MetadataUtils.HasSlotNames col" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="col" Type="Microsoft.ML.Core.Data.SchemaShape+Column" RefType="this" />
        </Parameters>
        <Docs>
          <param name="col">The schema shape column to query</param>
          <summary>
            Returns whether a column has the <see cref="F:Microsoft.ML.Data.MetadataUtils.Kinds.SlotNames" /> metadata indicated by
            the schema shape.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.MetadataUtils" Member="M:Microsoft.ML.Data.MetadataUtils.HasSlotNames(Microsoft.ML.Core.Data.SchemaShape.Column)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Data.Schema.Column" />
      </Targets>
      <Member MemberName="HasSlotNames">
        <MemberSignature Language="C#" Value="public static bool HasSlotNames (this Microsoft.ML.Data.Schema.Column column);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasSlotNames(valuetype Microsoft.ML.Data.Schema/Column column) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.MetadataUtils.HasSlotNames(Microsoft.ML.Data.Schema.Column)" />
        <MemberSignature Language="F#" Value="static member HasSlotNames : Microsoft.ML.Data.Schema.Column -&gt; bool" Usage="Microsoft.ML.Data.MetadataUtils.HasSlotNames column" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="column" Type="Microsoft.ML.Data.Schema+Column" RefType="this" />
        </Parameters>
        <Docs>
          <param name="column">To be added.</param>
          <summary>
            Returns <c>true</c> if the specified column:
             * is a vector of length N
             * has a SlotNames metadata
             * metadata type is VBuffer&lt;ReadOnlyMemory&lt;char&gt;&gt; of length N
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.MetadataUtils" Member="M:Microsoft.ML.Data.MetadataUtils.HasSlotNames(Microsoft.ML.Data.Schema.Column)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.SchemaShape.Column" />
      </Targets>
      <Member MemberName="IsNormalized">
        <MemberSignature Language="C#" Value="public static bool IsNormalized (this Microsoft.ML.Core.Data.SchemaShape.Column col);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormalized(valuetype Microsoft.ML.Core.Data.SchemaShape/Column col) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.MetadataUtils.IsNormalized(Microsoft.ML.Core.Data.SchemaShape.Column)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsNormalized (col As SchemaShape.Column) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsNormalized : Microsoft.ML.Core.Data.SchemaShape.Column -&gt; bool" Usage="Microsoft.ML.Data.MetadataUtils.IsNormalized col" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="col" Type="Microsoft.ML.Core.Data.SchemaShape+Column" RefType="this" />
        </Parameters>
        <Docs>
          <param name="col">The schema shape column to query</param>
          <summary>
            Returns whether a column has the <see cref="F:Microsoft.ML.Data.MetadataUtils.Kinds.IsNormalized" /> metadata indicated by
            the schema shape.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.MetadataUtils" Member="M:Microsoft.ML.Data.MetadataUtils.IsNormalized(Microsoft.ML.Core.Data.SchemaShape.Column)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Data.Schema.Column" />
      </Targets>
      <Member MemberName="IsNormalized">
        <MemberSignature Language="C#" Value="public static bool IsNormalized (this Microsoft.ML.Data.Schema.Column column);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormalized(valuetype Microsoft.ML.Data.Schema/Column column) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.MetadataUtils.IsNormalized(Microsoft.ML.Data.Schema.Column)" />
        <MemberSignature Language="F#" Value="static member IsNormalized : Microsoft.ML.Data.Schema.Column -&gt; bool" Usage="Microsoft.ML.Data.MetadataUtils.IsNormalized column" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="column" Type="Microsoft.ML.Data.Schema+Column" RefType="this" />
        </Parameters>
        <Docs>
          <param name="column">To be added.</param>
          <summary>
            Returns true iff <paramref name="column" /> has IsNormalized metadata set to true.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.MetadataUtils" Member="M:Microsoft.ML.Data.MetadataUtils.IsNormalized(Microsoft.ML.Data.Schema.Column)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.ITransformer" />
      </Targets>
      <Member MemberName="SaveTo">
        <MemberSignature Language="C#" Value="public static void SaveTo (this Microsoft.ML.Core.Data.ITransformer transformer, Microsoft.ML.IHostEnvironment env, System.IO.Stream outputStream);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SaveTo(class Microsoft.ML.Core.Data.ITransformer transformer, class Microsoft.ML.IHostEnvironment env, class System.IO.Stream outputStream) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.TransformerChain.SaveTo(Microsoft.ML.Core.Data.ITransformer,Microsoft.ML.IHostEnvironment,System.IO.Stream)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub SaveTo (transformer As ITransformer, env As IHostEnvironment, outputStream As Stream)" />
        <MemberSignature Language="F#" Value="static member SaveTo : Microsoft.ML.Core.Data.ITransformer * Microsoft.ML.IHostEnvironment * System.IO.Stream -&gt; unit" Usage="Microsoft.ML.Data.TransformerChain.SaveTo (transformer, env, outputStream)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="transformer" Type="Microsoft.ML.Core.Data.ITransformer" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" />
          <Parameter Name="outputStream" Type="System.IO.Stream" />
        </Parameters>
        <Docs>
          <param name="transformer">To be added.</param>
          <param name="env">To be added.</param>
          <param name="outputStream">To be added.</param>
          <summary>
            Save any transformer to a stream by wrapping it into a transformer chain.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.TransformerChain" Member="M:Microsoft.ML.Data.TransformerChain.SaveTo(Microsoft.ML.Core.Data.ITransformer,Microsoft.ML.IHostEnvironment,System.IO.Stream)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.IEstimator`1" />
      </Targets>
      <Member MemberName="Preview">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.DataDebuggerPreview Preview (this Microsoft.ML.Core.Data.IEstimator&lt;Microsoft.ML.Core.Data.ITransformer&gt; estimator, Microsoft.ML.Data.IDataView data, int maxRows = 100, int maxTrainingRows = 100);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.DataDebuggerPreview Preview(class Microsoft.ML.Core.Data.IEstimator`1&lt;class Microsoft.ML.Core.Data.ITransformer&gt; estimator, class Microsoft.ML.Data.IDataView data, int32 maxRows, int32 maxTrainingRows) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.DebuggerExtensions.Preview(Microsoft.ML.Core.Data.IEstimator{Microsoft.ML.Core.Data.ITransformer},Microsoft.ML.Data.IDataView,System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Preview (estimator As IEstimator(Of ITransformer), data As IDataView, Optional maxRows As Integer = 100, Optional maxTrainingRows As Integer = 100) As DataDebuggerPreview" />
        <MemberSignature Language="F#" Value="static member Preview : Microsoft.ML.Core.Data.IEstimator&lt;Microsoft.ML.Core.Data.ITransformer&gt; * Microsoft.ML.Data.IDataView * int * int -&gt; Microsoft.ML.Data.DataDebuggerPreview" Usage="Microsoft.ML.DebuggerExtensions.Preview (estimator, data, maxRows, maxTrainingRows)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.DataDebuggerPreview</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="estimator" Type="Microsoft.ML.Core.Data.IEstimator&lt;Microsoft.ML.Core.Data.ITransformer&gt;" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.Data.IDataView" />
          <Parameter Name="maxRows" Type="System.Int32" />
          <Parameter Name="maxTrainingRows" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="estimator">The estimnator which effect we are previewing</param>
          <param name="data">The data view to use for preview</param>
          <param name="maxRows">Maximum number of rows to show in preview</param>
          <param name="maxTrainingRows">Maximum number of rows to fit the estimator</param>
          <summary>
            Preview an effect of the <paramref name="estimator" /> on a given <paramref name="data" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.DebuggerExtensions" Member="M:Microsoft.ML.DebuggerExtensions.Preview(Microsoft.ML.Core.Data.IEstimator{Microsoft.ML.Core.Data.ITransformer},Microsoft.ML.Data.IDataView,System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.ITransformer" />
      </Targets>
      <Member MemberName="Preview">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.DataDebuggerPreview Preview (this Microsoft.ML.Core.Data.ITransformer transformer, Microsoft.ML.Data.IDataView data, int maxRows = 100);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.DataDebuggerPreview Preview(class Microsoft.ML.Core.Data.ITransformer transformer, class Microsoft.ML.Data.IDataView data, int32 maxRows) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.DebuggerExtensions.Preview(Microsoft.ML.Core.Data.ITransformer,Microsoft.ML.Data.IDataView,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Preview (transformer As ITransformer, data As IDataView, Optional maxRows As Integer = 100) As DataDebuggerPreview" />
        <MemberSignature Language="F#" Value="static member Preview : Microsoft.ML.Core.Data.ITransformer * Microsoft.ML.Data.IDataView * int -&gt; Microsoft.ML.Data.DataDebuggerPreview" Usage="Microsoft.ML.DebuggerExtensions.Preview (transformer, data, maxRows)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.DataDebuggerPreview</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="transformer" Type="Microsoft.ML.Core.Data.ITransformer" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.Data.IDataView" />
          <Parameter Name="maxRows" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="transformer">The transformer which effect we are previewing</param>
          <param name="data">The data view to use for preview</param>
          <param name="maxRows">Maximum number of rows to pull</param>
          <summary>
            Preview an effect of the <paramref name="transformer" /> on a given <paramref name="data" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.DebuggerExtensions" Member="M:Microsoft.ML.DebuggerExtensions.Preview(Microsoft.ML.Core.Data.ITransformer,Microsoft.ML.Data.IDataView,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Data.IDataView" />
      </Targets>
      <Member MemberName="Preview">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.DataDebuggerPreview Preview (this Microsoft.ML.Data.IDataView data, int maxRows = 100);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.DataDebuggerPreview Preview(class Microsoft.ML.Data.IDataView data, int32 maxRows) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.DebuggerExtensions.Preview(Microsoft.ML.Data.IDataView,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Preview (data As IDataView, Optional maxRows As Integer = 100) As DataDebuggerPreview" />
        <MemberSignature Language="F#" Value="static member Preview : Microsoft.ML.Data.IDataView * int -&gt; Microsoft.ML.Data.DataDebuggerPreview" Usage="Microsoft.ML.DebuggerExtensions.Preview (data, maxRows)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.DataDebuggerPreview</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.Data.IDataView" RefType="this" />
          <Parameter Name="maxRows" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="data">The data view to preview</param>
          <param name="maxRows">Maximum number of rows to pull</param>
          <summary>
            Extract a 'head' of the data view in a view that is convenient to debug.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.DebuggerExtensions" Member="M:Microsoft.ML.DebuggerExtensions.Preview(Microsoft.ML.Data.IDataView,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.IDataReader`1" />
      </Targets>
      <Member MemberName="Preview&lt;TSource&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.DataDebuggerPreview Preview&lt;TSource&gt; (this Microsoft.ML.Core.Data.IDataReader&lt;TSource&gt; reader, TSource source, int maxRows = 100);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.DataDebuggerPreview Preview&lt;TSource&gt;(class Microsoft.ML.Core.Data.IDataReader`1&lt;!!TSource&gt; reader, !!TSource source, int32 maxRows) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.DebuggerExtensions.Preview``1(Microsoft.ML.Core.Data.IDataReader{``0},``0,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Preview(Of TSource) (reader As IDataReader(Of TSource), source As TSource, Optional maxRows As Integer = 100) As DataDebuggerPreview" />
        <MemberSignature Language="F#" Value="static member Preview : Microsoft.ML.Core.Data.IDataReader&lt;'Source&gt; * 'Source * int -&gt; Microsoft.ML.Data.DataDebuggerPreview" Usage="Microsoft.ML.DebuggerExtensions.Preview (reader, source, maxRows)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.DataDebuggerPreview</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSource" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="reader" Type="Microsoft.ML.Core.Data.IDataReader&lt;TSource&gt;" RefType="this" />
          <Parameter Name="source" Type="TSource" />
          <Parameter Name="maxRows" Type="System.Int32" />
        </Parameters>
        <Docs>
          <typeparam name="TSource">To be added.</typeparam>
          <param name="reader">The data reader to preview</param>
          <param name="source">The source to pull the data from</param>
          <param name="maxRows">Maximum number of rows to pull</param>
          <summary>
            Preview an effect of the <paramref name="reader" /> on a given <paramref name="source" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.DebuggerExtensions" Member="M:Microsoft.ML.DebuggerExtensions.Preview``1(Microsoft.ML.Core.Data.IDataReader{``0},``0,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.ModelOperationsCatalog.ExplainabilityTransforms" />
      </Targets>
      <Member MemberName="FeatureContributionCalculation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.FeatureContributionCalculatingEstimator FeatureContributionCalculation (this Microsoft.ML.ModelOperationsCatalog.ExplainabilityTransforms catalog, Microsoft.ML.Internal.Internallearn.ICalculateFeatureContribution modelParameters, string featureColumn = &quot;Features&quot;, int numPositiveContributions = 10, int numNegativeContributions = 10, bool normalize = true);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.FeatureContributionCalculatingEstimator FeatureContributionCalculation(class Microsoft.ML.ModelOperationsCatalog/ExplainabilityTransforms catalog, class Microsoft.ML.Internal.Internallearn.ICalculateFeatureContribution modelParameters, string featureColumn, int32 numPositiveContributions, int32 numNegativeContributions, bool normalize) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ExplainabilityCatalog.FeatureContributionCalculation(Microsoft.ML.ModelOperationsCatalog.ExplainabilityTransforms,Microsoft.ML.Internal.Internallearn.ICalculateFeatureContribution,System.String,System.Int32,System.Int32,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FeatureContributionCalculation (catalog As ModelOperationsCatalog.ExplainabilityTransforms, modelParameters As ICalculateFeatureContribution, Optional featureColumn As String = &quot;Features&quot;, Optional numPositiveContributions As Integer = 10, Optional numNegativeContributions As Integer = 10, Optional normalize As Boolean = true) As FeatureContributionCalculatingEstimator" />
        <MemberSignature Language="F#" Value="static member FeatureContributionCalculation : Microsoft.ML.ModelOperationsCatalog.ExplainabilityTransforms * Microsoft.ML.Internal.Internallearn.ICalculateFeatureContribution * string * int * int * bool -&gt; Microsoft.ML.Data.FeatureContributionCalculatingEstimator" Usage="Microsoft.ML.ExplainabilityCatalog.FeatureContributionCalculation (catalog, modelParameters, featureColumn, numPositiveContributions, numNegativeContributions, normalize)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.FeatureContributionCalculatingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.ModelOperationsCatalog+ExplainabilityTransforms" RefType="this" />
          <Parameter Name="modelParameters" Type="Microsoft.ML.Internal.Internallearn.ICalculateFeatureContribution" />
          <Parameter Name="featureColumn" Type="System.String" />
          <Parameter Name="numPositiveContributions" Type="System.Int32" />
          <Parameter Name="numNegativeContributions" Type="System.Int32" />
          <Parameter Name="normalize" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The model explainability operations catalog.</param>
          <param name="modelParameters">Trained model parameters that support Feature Contribution Calculation and which will be used for scoring.</param>
          <param name="featureColumn">The name of the feature column that will be used as input.</param>
          <param name="numPositiveContributions">The number of positive contributions to report, sorted from highest magnitude to lowest magnitude.
            Note that if there are fewer features with positive contributions than <paramref name="numPositiveContributions" />, the rest will be returned as zeros.</param>
          <param name="numNegativeContributions">The number of negative contributions to report, sorted from highest magnitude to lowest magnitude.
            Note that if there are fewer features with negative contributions than <paramref name="numNegativeContributions" />, the rest will be returned as zeros.</param>
          <param name="normalize">Whether the feature contributions should be normalized to the [-1, 1] interval.</param>
          <summary>
            Feature Contribution Calculation computes model-specific contribution scores for each feature.
            Note that this functionality is not supported by all the models. See <see cref="T:Microsoft.ML.Data.FeatureContributionCalculatingTransformer" /> for a list of the suported models.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ExplainabilityCatalog" Member="M:Microsoft.ML.ExplainabilityCatalog.FeatureContributionCalculation(Microsoft.ML.ModelOperationsCatalog.ExplainabilityTransforms,Microsoft.ML.Internal.Internallearn.ICalculateFeatureContribution,System.String,System.Int32,System.Int32,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="IndicateMissingValues">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.MissingValueIndicatorEstimator IndicateMissingValues (this Microsoft.ML.TransformsCatalog catalog, string inputColumn, string outputColumn = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.MissingValueIndicatorEstimator IndicateMissingValues(class Microsoft.ML.TransformsCatalog catalog, string inputColumn, string outputColumn) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ExtensionsCatalog.IndicateMissingValues(Microsoft.ML.TransformsCatalog,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndicateMissingValues (catalog As TransformsCatalog, inputColumn As String, Optional outputColumn As String = null) As MissingValueIndicatorEstimator" />
        <MemberSignature Language="F#" Value="static member IndicateMissingValues : Microsoft.ML.TransformsCatalog * string * string -&gt; Microsoft.ML.Transforms.MissingValueIndicatorEstimator" Usage="Microsoft.ML.ExtensionsCatalog.IndicateMissingValues (catalog, inputColumn, outputColumn)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.MissingValueIndicatorEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform extensions' catalog.</param>
          <param name="inputColumn">The name of the input column of the transformation.</param>
          <param name="outputColumn">The name of the optional column produced by the transformation.
            If left to <value>null</value> the <paramref name="inputColumn" /> will get replaced.</param>
          <summary>
            Creates a new output column, or replaces the inputColumn with a new column
            (depending on whether the <paramref name="outputColumn" /> is given a value, or left to null)
            of boolean type, with the same number of slots as the input column. The value in the output column
            is true if the value in the input column is missing.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ExtensionsCatalog" Member="M:Microsoft.ML.ExtensionsCatalog.IndicateMissingValues(Microsoft.ML.TransformsCatalog,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="IndicateMissingValues">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.MissingValueIndicatorEstimator IndicateMissingValues (this Microsoft.ML.TransformsCatalog catalog, params ValueTuple&lt;string,string&gt;[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.MissingValueIndicatorEstimator IndicateMissingValues(class Microsoft.ML.TransformsCatalog catalog, valuetype System.ValueTuple`2&lt;string, string&gt;[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ExtensionsCatalog.IndicateMissingValues(Microsoft.ML.TransformsCatalog,System.ValueTuple{System.String,System.String}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndicateMissingValues (catalog As TransformsCatalog, ParamArray columns As ValueTuple(Of String, String)()) As MissingValueIndicatorEstimator" />
        <MemberSignature Language="F#" Value="static member IndicateMissingValues : Microsoft.ML.TransformsCatalog * ValueTuple&lt;string, string&gt;[] -&gt; Microsoft.ML.Transforms.MissingValueIndicatorEstimator" Usage="Microsoft.ML.ExtensionsCatalog.IndicateMissingValues (catalog, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.MissingValueIndicatorEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="columns" Type="System.ValueTuple&lt;System.String,System.String&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
              <Attribute>
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "inputColumn", "outputColumn" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform extensions' catalog.</param>
          <param name="columns">The names of the input columns of the transformation and the corresponding names for the output columns.</param>
          <summary>
            Creates a new output column, of boolean type, with the same number of slots as the input column. The value in the output column
            is true if the value in the input column is missing.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ExtensionsCatalog" Member="M:Microsoft.ML.ExtensionsCatalog.IndicateMissingValues(Microsoft.ML.TransformsCatalog,System.ValueTuple{System.String,System.String}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="ReplaceMissingValues">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.MissingValueReplacingEstimator ReplaceMissingValues (this Microsoft.ML.TransformsCatalog catalog, params Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.MissingValueReplacingEstimator ReplaceMissingValues(class Microsoft.ML.TransformsCatalog catalog, class Microsoft.ML.Transforms.MissingValueReplacingTransformer/ColumnInfo[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ExtensionsCatalog.ReplaceMissingValues(Microsoft.ML.TransformsCatalog,Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReplaceMissingValues (catalog As TransformsCatalog, ParamArray columns As MissingValueReplacingTransformer.ColumnInfo()) As MissingValueReplacingEstimator" />
        <MemberSignature Language="F#" Value="static member ReplaceMissingValues : Microsoft.ML.TransformsCatalog * Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo[] -&gt; Microsoft.ML.Transforms.MissingValueReplacingEstimator" Usage="Microsoft.ML.ExtensionsCatalog.ReplaceMissingValues (catalog, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.MissingValueReplacingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.Transforms.MissingValueReplacingTransformer+ColumnInfo[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform extensions' catalog.</param>
          <param name="columns">The name of the columns to use, and per-column transformation configuraiton.</param>
          <summary>
            Creates a new output column, identical to the input column for everything but the missing values.
            The missing values of the input column, in this new column are replaced with <see cref="F:Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode.DefaultValue" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ExtensionsCatalog" Member="M:Microsoft.ML.ExtensionsCatalog.ReplaceMissingValues(Microsoft.ML.TransformsCatalog,Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="ReplaceMissingValues">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.MissingValueReplacingEstimator ReplaceMissingValues (this Microsoft.ML.TransformsCatalog catalog, string inputColumn, string outputColumn = null, Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode replacementKind = Microsoft.ML.Transforms.MissingValueReplacingTransformer+ColumnInfo+ReplacementMode.DefaultValue);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.MissingValueReplacingEstimator ReplaceMissingValues(class Microsoft.ML.TransformsCatalog catalog, string inputColumn, string outputColumn, valuetype Microsoft.ML.Transforms.MissingValueReplacingTransformer/ColumnInfo/ReplacementMode replacementKind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ExtensionsCatalog.ReplaceMissingValues(Microsoft.ML.TransformsCatalog,System.String,System.String,Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReplaceMissingValues (catalog As TransformsCatalog, inputColumn As String, Optional outputColumn As String = null, Optional replacementKind As MissingValueReplacingTransformer.ColumnInfo.ReplacementMode = Microsoft.ML.Transforms.MissingValueReplacingTransformer+ColumnInfo+ReplacementMode.DefaultValue) As MissingValueReplacingEstimator" />
        <MemberSignature Language="F#" Value="static member ReplaceMissingValues : Microsoft.ML.TransformsCatalog * string * string * Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode -&gt; Microsoft.ML.Transforms.MissingValueReplacingEstimator" Usage="Microsoft.ML.ExtensionsCatalog.ReplaceMissingValues (catalog, inputColumn, outputColumn, replacementKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.MissingValueReplacingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="replacementKind" Type="Microsoft.ML.Transforms.MissingValueReplacingTransformer+ColumnInfo+ReplacementMode" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform extensions' catalog.</param>
          <param name="inputColumn">The name of the input column.</param>
          <param name="outputColumn">The optional name of the output column,
            If not provided, the <paramref name="inputColumn" /> will be replaced with the results of the transforms.</param>
          <param name="replacementKind">The type of replacement to use as specified in <see cref="T:Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode" /></param>
          <summary>
            Creates a new output column, or replaces the inputColumn with a new column
            (depending on whether the <paramref name="outputColumn" /> is given a value, or left to null)
            identical to the input column for everything but the missing values. The missing values of the input column, in this new column are replaced with
            one of the values specifid in the <paramref name="replacementKind" />. The default for the <paramref name="replacementKind" /> is
            <see cref="F:Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode.DefaultValue" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ExtensionsCatalog" Member="M:Microsoft.ML.ExtensionsCatalog.ReplaceMissingValues(Microsoft.ML.TransformsCatalog,System.String,System.String,Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="FieldAwareFactorizationMachine">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineTrainer FieldAwareFactorizationMachine (this Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers ctx, string[] featureColumns, string labelColumn = &quot;Label&quot;, string weights = null, Action&lt;Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineTrainer.Arguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineTrainer FieldAwareFactorizationMachine(class Microsoft.ML.BinaryClassificationContext/BinaryClassificationTrainers ctx, string[] featureColumns, string labelColumn, string weights, class System.Action`1&lt;class Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineTrainer/Arguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.FactorizationMachineExtensions.FieldAwareFactorizationMachine(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,System.String[],System.String,System.String,System.Action{Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineTrainer.Arguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FieldAwareFactorizationMachine (ctx As BinaryClassificationContext.BinaryClassificationTrainers, featureColumns As String(), Optional labelColumn As String = &quot;Label&quot;, Optional weights As String = null, Optional advancedSettings As Action(Of FieldAwareFactorizationMachineTrainer.Arguments) = null) As FieldAwareFactorizationMachineTrainer" />
        <MemberSignature Language="F#" Value="static member FieldAwareFactorizationMachine : Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers * string[] * string * string * Action&lt;Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineTrainer.Arguments&gt; -&gt; Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineTrainer" Usage="Microsoft.ML.FactorizationMachineExtensions.FieldAwareFactorizationMachine (ctx, featureColumns, labelColumn, weights, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="featureColumns" Type="System.String[]" />
          <Parameter Name="labelColumn" Type="System.String" />
          <Parameter Name="weights" Type="System.String" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineTrainer+Arguments&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The binary classification context trainer object.</param>
          <param name="featureColumns">The features, or independent variables.</param>
          <param name="labelColumn">The label, or dependent variable.</param>
          <param name="weights">The optional example weights.</param>
          <param name="advancedSettings">A delegate to set more settings.
            The settings here will override the ones provided in the direct method signature,
            if both are present and have different values.
            The columns names, however need to be provided directly, not through the <paramref name="advancedSettings" />.</param>
          <summary>
            Predict a target using a field-aware factorization machine algorithm.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.FactorizationMachineExtensions" Member="M:Microsoft.ML.FactorizationMachineExtensions.FieldAwareFactorizationMachine(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,System.String[],System.String,System.String,System.Action{Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineTrainer.Arguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnCount">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.FeatureSelection.CountFeatureSelectingEstimator SelectFeaturesBasedOnCount (this Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms catalog, params Microsoft.ML.Transforms.FeatureSelection.CountFeatureSelectingEstimator.ColumnInfo[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.FeatureSelection.CountFeatureSelectingEstimator SelectFeaturesBasedOnCount(class Microsoft.ML.TransformsCatalog/FeatureSelectionTransforms catalog, class Microsoft.ML.Transforms.FeatureSelection.CountFeatureSelectingEstimator/ColumnInfo[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.FeatureSelectionCatalog.SelectFeaturesBasedOnCount(Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms,Microsoft.ML.Transforms.FeatureSelection.CountFeatureSelectingEstimator.ColumnInfo[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnCount (catalog As TransformsCatalog.FeatureSelectionTransforms, ParamArray columns As CountFeatureSelectingEstimator.ColumnInfo()) As CountFeatureSelectingEstimator" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnCount : Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms * Microsoft.ML.Transforms.FeatureSelection.CountFeatureSelectingEstimator.ColumnInfo[] -&gt; Microsoft.ML.Transforms.FeatureSelection.CountFeatureSelectingEstimator" Usage="Microsoft.ML.FeatureSelectionCatalog.SelectFeaturesBasedOnCount (catalog, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.FeatureSelection.CountFeatureSelectingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+FeatureSelectionTransforms" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.Transforms.FeatureSelection.CountFeatureSelectingEstimator+ColumnInfo[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="columns">Describes the parameters of the feature selection process for each column pair.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.FeatureSelectionCatalog" Member="M:Microsoft.ML.FeatureSelectionCatalog.SelectFeaturesBasedOnCount(Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms,Microsoft.ML.Transforms.FeatureSelection.CountFeatureSelectingEstimator.ColumnInfo[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnCount">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.FeatureSelection.CountFeatureSelectingEstimator SelectFeaturesBasedOnCount (this Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms catalog, string inputColumn, string outputColumn = null, long count = 1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.FeatureSelection.CountFeatureSelectingEstimator SelectFeaturesBasedOnCount(class Microsoft.ML.TransformsCatalog/FeatureSelectionTransforms catalog, string inputColumn, string outputColumn, int64 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.FeatureSelectionCatalog.SelectFeaturesBasedOnCount(Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms,System.String,System.String,System.Int64)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnCount (catalog As TransformsCatalog.FeatureSelectionTransforms, inputColumn As String, Optional outputColumn As String = null, Optional count As Long = 1) As CountFeatureSelectingEstimator" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnCount : Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms * string * string * int64 -&gt; Microsoft.ML.Transforms.FeatureSelection.CountFeatureSelectingEstimator" Usage="Microsoft.ML.FeatureSelectionCatalog.SelectFeaturesBasedOnCount (catalog, inputColumn, outputColumn, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.FeatureSelection.CountFeatureSelectingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+FeatureSelectionTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="count" Type="System.Int64" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="inputColumn">Name of the input column.</param>
          <param name="outputColumn">Name of the column resulting from the transformation of <paramref name="inputColumn" />. Null means <paramref name="inputColumn" /> is replaced. </param>
          <param name="count">If the count of non-default values for a slot is greater than or equal to this threshold in the training data, the slot is preserved.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.FeatureSelectionCatalog" Member="M:Microsoft.ML.FeatureSelectionCatalog.SelectFeaturesBasedOnCount(Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms,System.String,System.String,System.Int64)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnMutualInformation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.FeatureSelection.MutualInformationFeatureSelectingEstimator SelectFeaturesBasedOnMutualInformation (this Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms catalog, string labelColumn = &quot;Label&quot;, int slotsInOutput = 1000, int numBins = 256, params ValueTuple&lt;string,string&gt;[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.FeatureSelection.MutualInformationFeatureSelectingEstimator SelectFeaturesBasedOnMutualInformation(class Microsoft.ML.TransformsCatalog/FeatureSelectionTransforms catalog, string labelColumn, int32 slotsInOutput, int32 numBins, valuetype System.ValueTuple`2&lt;string, string&gt;[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.FeatureSelectionCatalog.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms,System.String,System.Int32,System.Int32,System.ValueTuple{System.String,System.String}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnMutualInformation (catalog As TransformsCatalog.FeatureSelectionTransforms, Optional labelColumn As String = &quot;Label&quot;, Optional slotsInOutput As Integer = 1000, Optional numBins As Integer = 256, ParamArray columns As ValueTuple(Of String, String)()) As MutualInformationFeatureSelectingEstimator" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnMutualInformation : Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms * string * int * int * ValueTuple&lt;string, string&gt;[] -&gt; Microsoft.ML.Transforms.FeatureSelection.MutualInformationFeatureSelectingEstimator" Usage="Microsoft.ML.FeatureSelectionCatalog.SelectFeaturesBasedOnMutualInformation (catalog, labelColumn, slotsInOutput, numBins, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.FeatureSelection.MutualInformationFeatureSelectingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+FeatureSelectionTransforms" RefType="this" />
          <Parameter Name="labelColumn" Type="System.String" />
          <Parameter Name="slotsInOutput" Type="System.Int32" />
          <Parameter Name="numBins" Type="System.Int32" />
          <Parameter Name="columns" Type="System.ValueTuple&lt;System.String,System.String&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
              <Attribute>
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "input", "output" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="labelColumn">Name of the column to use for labels.</param>
          <param name="slotsInOutput">The maximum number of slots to preserve in the output. The number of slots to preserve is taken across all input columns.</param>
          <param name="numBins">Max number of bins used to approximate mutual information between each input column and the label column. Power of 2 recommended.</param>
          <param name="columns">Specifies the names of the input columns for the transformation, and their respective output column names.</param>
          <summary>
        Selects the top k slots across all specified columns ordered by their mutual information with the label column.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.FeatureSelectionCatalog" Member="M:Microsoft.ML.FeatureSelectionCatalog.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms,System.String,System.Int32,System.Int32,System.ValueTuple{System.String,System.String}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnMutualInformation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.FeatureSelection.MutualInformationFeatureSelectingEstimator SelectFeaturesBasedOnMutualInformation (this Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms catalog, string inputColumn, string outputColumn = null, string labelColumn = &quot;Label&quot;, int slotsInOutput = 1000, int numBins = 256);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.FeatureSelection.MutualInformationFeatureSelectingEstimator SelectFeaturesBasedOnMutualInformation(class Microsoft.ML.TransformsCatalog/FeatureSelectionTransforms catalog, string inputColumn, string outputColumn, string labelColumn, int32 slotsInOutput, int32 numBins) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.FeatureSelectionCatalog.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms,System.String,System.String,System.String,System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnMutualInformation (catalog As TransformsCatalog.FeatureSelectionTransforms, inputColumn As String, Optional outputColumn As String = null, Optional labelColumn As String = &quot;Label&quot;, Optional slotsInOutput As Integer = 1000, Optional numBins As Integer = 256) As MutualInformationFeatureSelectingEstimator" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnMutualInformation : Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms * string * string * string * int * int -&gt; Microsoft.ML.Transforms.FeatureSelection.MutualInformationFeatureSelectingEstimator" Usage="Microsoft.ML.FeatureSelectionCatalog.SelectFeaturesBasedOnMutualInformation (catalog, inputColumn, outputColumn, labelColumn, slotsInOutput, numBins)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.FeatureSelection.MutualInformationFeatureSelectingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+FeatureSelectionTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="labelColumn" Type="System.String" />
          <Parameter Name="slotsInOutput" Type="System.Int32" />
          <Parameter Name="numBins" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="inputColumn">Name of the input column.</param>
          <param name="outputColumn">Name of the column resulting from the transformation of <paramref name="inputColumn" />. Null means <paramref name="inputColumn" /> is replaced. </param>
          <param name="labelColumn">Name of the column to use for labels.</param>
          <param name="slotsInOutput">The maximum number of slots to preserve in the output. The number of slots to preserve is taken across all input columns.</param>
          <param name="numBins">Max number of bins used to approximate mutual information between each input column and the label column. Power of 2 recommended.</param>
          <summary>
        Selects the top k slots across all specified columns ordered by their mutual information with the label column.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.FeatureSelectionCatalog" Member="M:Microsoft.ML.FeatureSelectionCatalog.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.TransformsCatalog.FeatureSelectionTransforms,System.String,System.String,System.String,System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionContext.RegressionTrainers" />
      </Targets>
      <Member MemberName="OrdinaryLeastSquares">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.HalLearners.OlsLinearRegressionTrainer OrdinaryLeastSquares (this Microsoft.ML.RegressionContext.RegressionTrainers ctx, string labelColumn = &quot;Label&quot;, string featureColumn = &quot;Features&quot;, string weights = null, Action&lt;Microsoft.ML.Trainers.HalLearners.OlsLinearRegressionTrainer.Arguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.HalLearners.OlsLinearRegressionTrainer OrdinaryLeastSquares(class Microsoft.ML.RegressionContext/RegressionTrainers ctx, string labelColumn, string featureColumn, string weights, class System.Action`1&lt;class Microsoft.ML.Trainers.HalLearners.OlsLinearRegressionTrainer/Arguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.HalLearnersCatalog.OrdinaryLeastSquares(Microsoft.ML.RegressionContext.RegressionTrainers,System.String,System.String,System.String,System.Action{Microsoft.ML.Trainers.HalLearners.OlsLinearRegressionTrainer.Arguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrdinaryLeastSquares (ctx As RegressionContext.RegressionTrainers, Optional labelColumn As String = &quot;Label&quot;, Optional featureColumn As String = &quot;Features&quot;, Optional weights As String = null, Optional advancedSettings As Action(Of OlsLinearRegressionTrainer.Arguments) = null) As OlsLinearRegressionTrainer" />
        <MemberSignature Language="F#" Value="static member OrdinaryLeastSquares : Microsoft.ML.RegressionContext.RegressionTrainers * string * string * string * Action&lt;Microsoft.ML.Trainers.HalLearners.OlsLinearRegressionTrainer.Arguments&gt; -&gt; Microsoft.ML.Trainers.HalLearners.OlsLinearRegressionTrainer" Usage="Microsoft.ML.HalLearnersCatalog.OrdinaryLeastSquares (ctx, labelColumn, featureColumn, weights, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.HalLearners.OlsLinearRegressionTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RegressionContext+RegressionTrainers" RefType="this" Index="0" />
          <Parameter Name="labelColumn" Type="System.String" Index="1" FrameworkAlternate="ml-dotnet" />
          <Parameter Name="featureColumn" Type="System.String" Index="2" FrameworkAlternate="ml-dotnet" />
          <Parameter Name="weights" Type="System.String" Index="3" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.HalLearners.OlsLinearRegressionTrainer+Arguments&gt;" Index="4" />
        </Parameters>
        <Docs>
          <param name="ctx">The <see cref="T:Microsoft.ML.RegressionContext" />.</param>
          <param name="labelColumn">The labelColumn column.</param>
          <param name="featureColumn">The features column.</param>
          <param name="weights">The weights column.</param>
          <param name="advancedSettings">Algorithm advanced settings.</param>
          <summary>
            Predict a target using a linear regression model trained with the <see cref="T:Microsoft.ML.Trainers.HalLearners.OlsLinearRegressionTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.HalLearnersCatalog" Member="M:Microsoft.ML.HalLearnersCatalog.OrdinaryLeastSquares(Microsoft.ML.RegressionContext.RegressionTrainers,System.String,System.String,System.String,System.Action{Microsoft.ML.Trainers.HalLearners.OlsLinearRegressionTrainer.Arguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="SymbolicStochasticGradientDescent">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.SymSgd.SymSgdClassificationTrainer SymbolicStochasticGradientDescent (this Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers ctx, string labelColumn = &quot;Label&quot;, string featureColumn = &quot;Features&quot;, Action&lt;Microsoft.ML.Trainers.SymSgd.SymSgdClassificationTrainer.Arguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.SymSgd.SymSgdClassificationTrainer SymbolicStochasticGradientDescent(class Microsoft.ML.BinaryClassificationContext/BinaryClassificationTrainers ctx, string labelColumn, string featureColumn, class System.Action`1&lt;class Microsoft.ML.Trainers.SymSgd.SymSgdClassificationTrainer/Arguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.HalLearnersCatalog.SymbolicStochasticGradientDescent(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,System.String,System.String,System.Action{Microsoft.ML.Trainers.SymSgd.SymSgdClassificationTrainer.Arguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SymbolicStochasticGradientDescent (ctx As BinaryClassificationContext.BinaryClassificationTrainers, Optional labelColumn As String = &quot;Label&quot;, Optional featureColumn As String = &quot;Features&quot;, Optional advancedSettings As Action(Of SymSgdClassificationTrainer.Arguments) = null) As SymSgdClassificationTrainer" />
        <MemberSignature Language="F#" Value="static member SymbolicStochasticGradientDescent : Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers * string * string * Action&lt;Microsoft.ML.Trainers.SymSgd.SymSgdClassificationTrainer.Arguments&gt; -&gt; Microsoft.ML.Trainers.SymSgd.SymSgdClassificationTrainer" Usage="Microsoft.ML.HalLearnersCatalog.SymbolicStochasticGradientDescent (ctx, labelColumn, featureColumn, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.SymSgd.SymSgdClassificationTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumn" Type="System.String" />
          <Parameter Name="featureColumn" Type="System.String" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.SymSgd.SymSgdClassificationTrainer+Arguments&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The <see cref="T:Microsoft.ML.BinaryClassificationContext" />.</param>
          <param name="labelColumn">The labelColumn column.</param>
          <param name="featureColumn">The features column.</param>
          <param name="advancedSettings">Algorithm advanced settings.</param>
          <summary>
             Predict a target using a linear binary classification model trained with the <see cref="T:Microsoft.ML.Trainers.SymSgd.SymSgdClassificationTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.HalLearnersCatalog" Member="M:Microsoft.ML.HalLearnersCatalog.SymbolicStochasticGradientDescent(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,System.String,System.String,System.Action{Microsoft.ML.Trainers.SymSgd.SymSgdClassificationTrainer.Arguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ProjectionTransforms" />
      </Targets>
      <Member MemberName="VectorWhiten">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Projections.VectorWhiteningEstimator VectorWhiten (this Microsoft.ML.TransformsCatalog.ProjectionTransforms catalog, params Microsoft.ML.Transforms.Projections.VectorWhiteningTransformer.ColumnInfo[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Projections.VectorWhiteningEstimator VectorWhiten(class Microsoft.ML.TransformsCatalog/ProjectionTransforms catalog, class Microsoft.ML.Transforms.Projections.VectorWhiteningTransformer/ColumnInfo[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.HalLearnersCatalog.VectorWhiten(Microsoft.ML.TransformsCatalog.ProjectionTransforms,Microsoft.ML.Transforms.Projections.VectorWhiteningTransformer.ColumnInfo[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function VectorWhiten (catalog As TransformsCatalog.ProjectionTransforms, ParamArray columns As VectorWhiteningTransformer.ColumnInfo()) As VectorWhiteningEstimator" />
        <MemberSignature Language="F#" Value="static member VectorWhiten : Microsoft.ML.TransformsCatalog.ProjectionTransforms * Microsoft.ML.Transforms.Projections.VectorWhiteningTransformer.ColumnInfo[] -&gt; Microsoft.ML.Transforms.Projections.VectorWhiteningEstimator" Usage="Microsoft.ML.HalLearnersCatalog.VectorWhiten (catalog, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Projections.VectorWhiteningEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ProjectionTransforms" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.Transforms.Projections.VectorWhiteningTransformer+ColumnInfo[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="columns">Describes the parameters of the whitening process for each column pair.</param>
          <summary>
            Takes columns filled with a vector of random variables with a known covariance matrix into a set of new variables whose covariance is the identity matrix,
            meaning that they are uncorrelated and each have variance 1.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.HalLearnersCatalog" Member="M:Microsoft.ML.HalLearnersCatalog.VectorWhiten(Microsoft.ML.TransformsCatalog.ProjectionTransforms,Microsoft.ML.Transforms.Projections.VectorWhiteningTransformer.ColumnInfo[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ProjectionTransforms" />
      </Targets>
      <Member MemberName="VectorWhiten">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Projections.VectorWhiteningEstimator VectorWhiten (this Microsoft.ML.TransformsCatalog.ProjectionTransforms catalog, string inputColumn, string outputColumn = null, Microsoft.ML.Transforms.Projections.WhiteningKind kind = Microsoft.ML.Transforms.Projections.WhiteningKind.Zca, float eps = 1E-05, int maxRows = 100000, int pcaNum = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Projections.VectorWhiteningEstimator VectorWhiten(class Microsoft.ML.TransformsCatalog/ProjectionTransforms catalog, string inputColumn, string outputColumn, valuetype Microsoft.ML.Transforms.Projections.WhiteningKind kind, float32 eps, int32 maxRows, int32 pcaNum) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.HalLearnersCatalog.VectorWhiten(Microsoft.ML.TransformsCatalog.ProjectionTransforms,System.String,System.String,Microsoft.ML.Transforms.Projections.WhiteningKind,System.Single,System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function VectorWhiten (catalog As TransformsCatalog.ProjectionTransforms, inputColumn As String, Optional outputColumn As String = null, Optional kind As WhiteningKind = Microsoft.ML.Transforms.Projections.WhiteningKind.Zca, Optional eps As Single = 1E-05, Optional maxRows As Integer = 100000, Optional pcaNum As Integer = 0) As VectorWhiteningEstimator" />
        <MemberSignature Language="F#" Value="static member VectorWhiten : Microsoft.ML.TransformsCatalog.ProjectionTransforms * string * string * Microsoft.ML.Transforms.Projections.WhiteningKind * single * int * int -&gt; Microsoft.ML.Transforms.Projections.VectorWhiteningEstimator" Usage="Microsoft.ML.HalLearnersCatalog.VectorWhiten (catalog, inputColumn, outputColumn, kind, eps, maxRows, pcaNum)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Projections.VectorWhiteningEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ProjectionTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="kind" Type="Microsoft.ML.Transforms.Projections.WhiteningKind" />
          <Parameter Name="eps" Type="System.Single" />
          <Parameter Name="maxRows" Type="System.Int32" />
          <Parameter Name="pcaNum" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="inputColumn">Name of the input column.</param>
          <param name="outputColumn">Name of the column resulting from the transformation of <paramref name="inputColumn" />. Null means <paramref name="inputColumn" /> is replaced. </param>
          <param name="kind">Whitening kind (PCA/ZCA).</param>
          <param name="eps">Whitening constant, prevents division by zero.</param>
          <param name="maxRows">Maximum number of rows used to train the transform.</param>
          <param name="pcaNum">In case of PCA whitening, indicates the number of components to retain.</param>
          <summary>
            Takes column filled with a vector of random variables with a known covariance matrix into a set of new variables whose covariance is the identity matrix,
            meaning that they are uncorrelated and each have variance 1.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.HalLearnersCatalog" Member="M:Microsoft.ML.HalLearnersCatalog.VectorWhiten(Microsoft.ML.TransformsCatalog.ProjectionTransforms,System.String,System.String,Microsoft.ML.Transforms.Projections.WhiteningKind,System.Single,System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="ConvertToGrayscale">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.ImageAnalytics.ImageGrayscalingEstimator ConvertToGrayscale (this Microsoft.ML.TransformsCatalog catalog, params ValueTuple&lt;string,string&gt;[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.ImageAnalytics.ImageGrayscalingEstimator ConvertToGrayscale(class Microsoft.ML.TransformsCatalog catalog, valuetype System.ValueTuple`2&lt;string, string&gt;[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ImageEstimatorsCatalog.ConvertToGrayscale(Microsoft.ML.TransformsCatalog,System.ValueTuple{System.String,System.String}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConvertToGrayscale (catalog As TransformsCatalog, ParamArray columns As ValueTuple(Of String, String)()) As ImageGrayscalingEstimator" />
        <MemberSignature Language="F#" Value="static member ConvertToGrayscale : Microsoft.ML.TransformsCatalog * ValueTuple&lt;string, string&gt;[] -&gt; Microsoft.ML.ImageAnalytics.ImageGrayscalingEstimator" Usage="Microsoft.ML.ImageEstimatorsCatalog.ConvertToGrayscale (catalog, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.ImageAnalytics.ImageGrayscalingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="columns" Type="System.ValueTuple&lt;System.String,System.String&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
              <Attribute>
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "input", "output" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="columns">The name of the columns containing the image paths(first item of the tuple), and the name of the resulting output column (second item of the tuple).</param>
          <summary>
            Converts the images to grayscale.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ImageEstimatorsCatalog" Member="M:Microsoft.ML.ImageEstimatorsCatalog.ConvertToGrayscale(Microsoft.ML.TransformsCatalog,System.ValueTuple{System.String,System.String}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="ExtractPixels">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.ImageAnalytics.ImagePixelExtractingEstimator ExtractPixels (this Microsoft.ML.TransformsCatalog catalog, params Microsoft.ML.ImageAnalytics.ImagePixelExtractorTransform.ColumnInfo[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.ImageAnalytics.ImagePixelExtractingEstimator ExtractPixels(class Microsoft.ML.TransformsCatalog catalog, class Microsoft.ML.ImageAnalytics.ImagePixelExtractorTransform/ColumnInfo[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ImageEstimatorsCatalog.ExtractPixels(Microsoft.ML.TransformsCatalog,Microsoft.ML.ImageAnalytics.ImagePixelExtractorTransform.ColumnInfo[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExtractPixels (catalog As TransformsCatalog, ParamArray columns As ImagePixelExtractorTransform.ColumnInfo()) As ImagePixelExtractingEstimator" />
        <MemberSignature Language="F#" Value="static member ExtractPixels : Microsoft.ML.TransformsCatalog * Microsoft.ML.ImageAnalytics.ImagePixelExtractorTransform.ColumnInfo[] -&gt; Microsoft.ML.ImageAnalytics.ImagePixelExtractingEstimator" Usage="Microsoft.ML.ImageEstimatorsCatalog.ExtractPixels (catalog, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.ImageAnalytics.ImagePixelExtractingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.ImageAnalytics.ImagePixelExtractorTransform+ColumnInfo[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="columns">The name of the columns containing the image paths, and per-column configurations.</param>
          <summary>
            Loads the images from a given folder.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ImageEstimatorsCatalog" Member="M:Microsoft.ML.ImageEstimatorsCatalog.ExtractPixels(Microsoft.ML.TransformsCatalog,Microsoft.ML.ImageAnalytics.ImagePixelExtractorTransform.ColumnInfo[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="ExtractPixels">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.ImageAnalytics.ImagePixelExtractingEstimator ExtractPixels (this Microsoft.ML.TransformsCatalog catalog, string inputColumn, string outputColumn, Microsoft.ML.ImageAnalytics.ImagePixelExtractorTransform.ColorBits colors = Microsoft.ML.ImageAnalytics.ImagePixelExtractorTransform+ColorBits.Rgb, bool interleave = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.ImageAnalytics.ImagePixelExtractingEstimator ExtractPixels(class Microsoft.ML.TransformsCatalog catalog, string inputColumn, string outputColumn, valuetype Microsoft.ML.ImageAnalytics.ImagePixelExtractorTransform/ColorBits colors, bool interleave) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ImageEstimatorsCatalog.ExtractPixels(Microsoft.ML.TransformsCatalog,System.String,System.String,Microsoft.ML.ImageAnalytics.ImagePixelExtractorTransform.ColorBits,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExtractPixels (catalog As TransformsCatalog, inputColumn As String, outputColumn As String, Optional colors As ImagePixelExtractorTransform.ColorBits = Microsoft.ML.ImageAnalytics.ImagePixelExtractorTransform+ColorBits.Rgb, Optional interleave As Boolean = false) As ImagePixelExtractingEstimator" />
        <MemberSignature Language="F#" Value="static member ExtractPixels : Microsoft.ML.TransformsCatalog * string * string * Microsoft.ML.ImageAnalytics.ImagePixelExtractorTransform.ColorBits * bool -&gt; Microsoft.ML.ImageAnalytics.ImagePixelExtractingEstimator" Usage="Microsoft.ML.ImageEstimatorsCatalog.ExtractPixels (catalog, inputColumn, outputColumn, colors, interleave)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.ImageAnalytics.ImagePixelExtractingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="colors" Type="Microsoft.ML.ImageAnalytics.ImagePixelExtractorTransform+ColorBits" />
          <Parameter Name="interleave" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="inputColumn">The name of the input column.</param>
          <param name="outputColumn">The name of the output column generated from the estimator.</param>
          <param name="colors">The color schema as defined in <see cref="T:Microsoft.ML.ImageAnalytics.ImagePixelExtractorTransform.ColorBits" />.</param>
          <param name="interleave" />
          <summary>
            Loads the images from a given folder.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ImageEstimatorsCatalog" Member="M:Microsoft.ML.ImageEstimatorsCatalog.ExtractPixels(Microsoft.ML.TransformsCatalog,System.String,System.String,Microsoft.ML.ImageAnalytics.ImagePixelExtractorTransform.ColorBits,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="LoadImages">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.ImageAnalytics.ImageLoadingEstimator LoadImages (this Microsoft.ML.TransformsCatalog catalog, string imageFolder, params ValueTuple&lt;string,string&gt;[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.ImageAnalytics.ImageLoadingEstimator LoadImages(class Microsoft.ML.TransformsCatalog catalog, string imageFolder, valuetype System.ValueTuple`2&lt;string, string&gt;[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ImageEstimatorsCatalog.LoadImages(Microsoft.ML.TransformsCatalog,System.String,System.ValueTuple{System.String,System.String}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LoadImages (catalog As TransformsCatalog, imageFolder As String, ParamArray columns As ValueTuple(Of String, String)()) As ImageLoadingEstimator" />
        <MemberSignature Language="F#" Value="static member LoadImages : Microsoft.ML.TransformsCatalog * string * ValueTuple&lt;string, string&gt;[] -&gt; Microsoft.ML.ImageAnalytics.ImageLoadingEstimator" Usage="Microsoft.ML.ImageEstimatorsCatalog.LoadImages (catalog, imageFolder, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.ImageAnalytics.ImageLoadingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="imageFolder" Type="System.String" />
          <Parameter Name="columns" Type="System.ValueTuple&lt;System.String,System.String&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
              <Attribute>
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "input", "output" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="imageFolder">The images folder.</param>
          <param name="columns">The name of the columns containing the image paths(first item of the tuple), and the name of the resulting output column (second item of the tuple).</param>
          <summary>
            Loads the images from a given folder.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ImageEstimatorsCatalog" Member="M:Microsoft.ML.ImageEstimatorsCatalog.LoadImages(Microsoft.ML.TransformsCatalog,System.String,System.ValueTuple{System.String,System.String}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="Resize">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.ImageAnalytics.ImageResizingEstimator Resize (this Microsoft.ML.TransformsCatalog catalog, params Microsoft.ML.ImageAnalytics.ImageResizerTransform.ColumnInfo[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.ImageAnalytics.ImageResizingEstimator Resize(class Microsoft.ML.TransformsCatalog catalog, class Microsoft.ML.ImageAnalytics.ImageResizerTransform/ColumnInfo[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ImageEstimatorsCatalog.Resize(Microsoft.ML.TransformsCatalog,Microsoft.ML.ImageAnalytics.ImageResizerTransform.ColumnInfo[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Resize (catalog As TransformsCatalog, ParamArray columns As ImageResizerTransform.ColumnInfo()) As ImageResizingEstimator" />
        <MemberSignature Language="F#" Value="static member Resize : Microsoft.ML.TransformsCatalog * Microsoft.ML.ImageAnalytics.ImageResizerTransform.ColumnInfo[] -&gt; Microsoft.ML.ImageAnalytics.ImageResizingEstimator" Usage="Microsoft.ML.ImageEstimatorsCatalog.Resize (catalog, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.ImageAnalytics.ImageResizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.ImageAnalytics.ImageResizerTransform+ColumnInfo[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="columns">The names of the columns to transform.</param>
          <summary>
            Resizes an image.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ImageEstimatorsCatalog" Member="M:Microsoft.ML.ImageEstimatorsCatalog.Resize(Microsoft.ML.TransformsCatalog,Microsoft.ML.ImageAnalytics.ImageResizerTransform.ColumnInfo[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="Resize">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.ImageAnalytics.ImageResizingEstimator Resize (this Microsoft.ML.TransformsCatalog catalog, string inputColumn, string outputColumn, int imageWidth, int imageHeight, Microsoft.ML.ImageAnalytics.ImageResizerTransform.ResizingKind resizing = Microsoft.ML.ImageAnalytics.ImageResizerTransform+ResizingKind.IsoCrop, Microsoft.ML.ImageAnalytics.ImageResizerTransform.Anchor cropAnchor = Microsoft.ML.ImageAnalytics.ImageResizerTransform+Anchor.Center);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.ImageAnalytics.ImageResizingEstimator Resize(class Microsoft.ML.TransformsCatalog catalog, string inputColumn, string outputColumn, int32 imageWidth, int32 imageHeight, valuetype Microsoft.ML.ImageAnalytics.ImageResizerTransform/ResizingKind resizing, valuetype Microsoft.ML.ImageAnalytics.ImageResizerTransform/Anchor cropAnchor) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ImageEstimatorsCatalog.Resize(Microsoft.ML.TransformsCatalog,System.String,System.String,System.Int32,System.Int32,Microsoft.ML.ImageAnalytics.ImageResizerTransform.ResizingKind,Microsoft.ML.ImageAnalytics.ImageResizerTransform.Anchor)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Resize (catalog As TransformsCatalog, inputColumn As String, outputColumn As String, imageWidth As Integer, imageHeight As Integer, Optional resizing As ImageResizerTransform.ResizingKind = Microsoft.ML.ImageAnalytics.ImageResizerTransform+ResizingKind.IsoCrop, Optional cropAnchor As ImageResizerTransform.Anchor = Microsoft.ML.ImageAnalytics.ImageResizerTransform+Anchor.Center) As ImageResizingEstimator" />
        <MemberSignature Language="F#" Value="static member Resize : Microsoft.ML.TransformsCatalog * string * string * int * int * Microsoft.ML.ImageAnalytics.ImageResizerTransform.ResizingKind * Microsoft.ML.ImageAnalytics.ImageResizerTransform.Anchor -&gt; Microsoft.ML.ImageAnalytics.ImageResizingEstimator" Usage="Microsoft.ML.ImageEstimatorsCatalog.Resize (catalog, inputColumn, outputColumn, imageWidth, imageHeight, resizing, cropAnchor)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.ImageAnalytics.ImageResizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="imageWidth" Type="System.Int32" />
          <Parameter Name="imageHeight" Type="System.Int32" />
          <Parameter Name="resizing" Type="Microsoft.ML.ImageAnalytics.ImageResizerTransform+ResizingKind" />
          <Parameter Name="cropAnchor" Type="Microsoft.ML.ImageAnalytics.ImageResizerTransform+Anchor" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="inputColumn">Name of the input column.</param>
          <param name="outputColumn">Name of the resulting output column.</param>
          <param name="imageWidth">The image width.</param>
          <param name="imageHeight">The image height.</param>
          <param name="resizing">The type of image resizing as specified in <see cref="T:Microsoft.ML.ImageAnalytics.ImageResizerTransform.ResizingKind" />.</param>
          <param name="cropAnchor">Where to place the anchor, to start cropping. Options defined in <see cref="T:Microsoft.ML.ImageAnalytics.ImageResizerTransform.Anchor" /></param>
          <summary>
             Resizes an image.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ImageEstimatorsCatalog" Member="M:Microsoft.ML.ImageEstimatorsCatalog.Resize(Microsoft.ML.TransformsCatalog,System.String,System.String,System.Int32,System.Int32,Microsoft.ML.ImageAnalytics.ImageResizerTransform.ResizingKind,Microsoft.ML.ImageAnalytics.ImageResizerTransform.Anchor)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.ClusteringContext.ClusteringTrainers" />
      </Targets>
      <Member MemberName="KMeans">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.KMeans.KMeansPlusPlusTrainer KMeans (this Microsoft.ML.ClusteringContext.ClusteringTrainers ctx, string features, string weights = null, int clustersCount = 5, Action&lt;Microsoft.ML.Trainers.KMeans.KMeansPlusPlusTrainer.Arguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.KMeans.KMeansPlusPlusTrainer KMeans(class Microsoft.ML.ClusteringContext/ClusteringTrainers ctx, string features, string weights, int32 clustersCount, class System.Action`1&lt;class Microsoft.ML.Trainers.KMeans.KMeansPlusPlusTrainer/Arguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.KMeansClusteringExtensions.KMeans(Microsoft.ML.ClusteringContext.ClusteringTrainers,System.String,System.String,System.Int32,System.Action{Microsoft.ML.Trainers.KMeans.KMeansPlusPlusTrainer.Arguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function KMeans (ctx As ClusteringContext.ClusteringTrainers, features As String, Optional weights As String = null, Optional clustersCount As Integer = 5, Optional advancedSettings As Action(Of KMeansPlusPlusTrainer.Arguments) = null) As KMeansPlusPlusTrainer" />
        <MemberSignature Language="F#" Value="static member KMeans : Microsoft.ML.ClusteringContext.ClusteringTrainers * string * string * int * Action&lt;Microsoft.ML.Trainers.KMeans.KMeansPlusPlusTrainer.Arguments&gt; -&gt; Microsoft.ML.Trainers.KMeans.KMeansPlusPlusTrainer" Usage="Microsoft.ML.KMeansClusteringExtensions.KMeans (ctx, features, weights, clustersCount, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.KMeans.KMeansPlusPlusTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.ClusteringContext+ClusteringTrainers" RefType="this" />
          <Parameter Name="features" Type="System.String" />
          <Parameter Name="weights" Type="System.String" />
          <Parameter Name="clustersCount" Type="System.Int32" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.KMeans.KMeansPlusPlusTrainer+Arguments&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The regression context trainer object.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="clustersCount">The number of clusters to use for KMeans.</param>
          <param name="advancedSettings">Algorithm advanced settings.</param>
          <summary>
            Train a KMeans++ clustering algorithm.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.KMeansClusteringExtensions" Member="M:Microsoft.ML.KMeansClusteringExtensions.KMeans(Microsoft.ML.ClusteringContext.ClusteringTrainers,System.String,System.String,System.Int32,System.Action{Microsoft.ML.Trainers.KMeans.KMeansPlusPlusTrainer.Arguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.IEstimator`1" />
      </Targets>
      <Member MemberName="Append&lt;TTrans&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.EstimatorChain&lt;TTrans&gt; Append&lt;TTrans&gt; (this Microsoft.ML.Core.Data.IEstimator&lt;Microsoft.ML.Core.Data.ITransformer&gt; start, Microsoft.ML.Core.Data.IEstimator&lt;TTrans&gt; estimator, Microsoft.ML.Data.TransformerScope scope = Microsoft.ML.Data.TransformerScope.Everything) where TTrans : class, Microsoft.ML.Core.Data.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.EstimatorChain`1&lt;!!TTrans&gt; Append&lt;class (class Microsoft.ML.Core.Data.ITransformer) TTrans&gt;(class Microsoft.ML.Core.Data.IEstimator`1&lt;class Microsoft.ML.Core.Data.ITransformer&gt; start, class Microsoft.ML.Core.Data.IEstimator`1&lt;!!TTrans&gt; estimator, valuetype Microsoft.ML.Data.TransformerScope scope) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LearningPipelineExtensions.Append``1(Microsoft.ML.Core.Data.IEstimator{Microsoft.ML.Core.Data.ITransformer},Microsoft.ML.Core.Data.IEstimator{``0},Microsoft.ML.Data.TransformerScope)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Append(Of TTrans As {Class, ITransformer}) (start As IEstimator(Of ITransformer), estimator As IEstimator(Of TTrans), Optional scope As TransformerScope = Microsoft.ML.Data.TransformerScope.Everything) As EstimatorChain(Of TTrans)" />
        <MemberSignature Language="F#" Value="static member Append : Microsoft.ML.Core.Data.IEstimator&lt;Microsoft.ML.Core.Data.ITransformer&gt; * Microsoft.ML.Core.Data.IEstimator&lt;'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; * Microsoft.ML.Data.TransformerScope -&gt; Microsoft.ML.Data.EstimatorChain&lt;'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)" Usage="Microsoft.ML.LearningPipelineExtensions.Append (start, estimator, scope)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.EstimatorChain&lt;TTrans&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TTrans">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="start" Type="Microsoft.ML.Core.Data.IEstimator&lt;Microsoft.ML.Core.Data.ITransformer&gt;" RefType="this" />
          <Parameter Name="estimator" Type="Microsoft.ML.Core.Data.IEstimator&lt;TTrans&gt;" />
          <Parameter Name="scope" Type="Microsoft.ML.Data.TransformerScope" />
        </Parameters>
        <Docs>
          <typeparam name="TTrans">To be added.</typeparam>
          <param name="start">To be added.</param>
          <param name="estimator">To be added.</param>
          <param name="scope">To be added.</param>
          <summary>
            Create a new estimator chain, by appending another estimator to the end of this estimator.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LearningPipelineExtensions" Member="M:Microsoft.ML.LearningPipelineExtensions.Append``1(Microsoft.ML.Core.Data.IEstimator{Microsoft.ML.Core.Data.ITransformer},Microsoft.ML.Core.Data.IEstimator{``0},Microsoft.ML.Data.TransformerScope)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.ITransformer" />
      </Targets>
      <Member MemberName="Append&lt;TTrans&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.TransformerChain&lt;TTrans&gt; Append&lt;TTrans&gt; (this Microsoft.ML.Core.Data.ITransformer start, TTrans transformer) where TTrans : class, Microsoft.ML.Core.Data.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.TransformerChain`1&lt;!!TTrans&gt; Append&lt;class (class Microsoft.ML.Core.Data.ITransformer) TTrans&gt;(class Microsoft.ML.Core.Data.ITransformer start, !!TTrans transformer) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LearningPipelineExtensions.Append``1(Microsoft.ML.Core.Data.ITransformer,``0)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Append(Of TTrans As {Class, ITransformer}) (start As ITransformer, transformer As TTrans) As TransformerChain(Of TTrans)" />
        <MemberSignature Language="F#" Value="static member Append : Microsoft.ML.Core.Data.ITransformer * 'rans -&gt; Microsoft.ML.Data.TransformerChain&lt;'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)" Usage="Microsoft.ML.LearningPipelineExtensions.Append (start, transformer)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.TransformerChain&lt;TTrans&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TTrans">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="start" Type="Microsoft.ML.Core.Data.ITransformer" RefType="this" />
          <Parameter Name="transformer" Type="TTrans" />
        </Parameters>
        <Docs>
          <typeparam name="TTrans">To be added.</typeparam>
          <param name="start">To be added.</param>
          <param name="transformer">To be added.</param>
          <summary>
            Create a new transformer chain, by appending another transformer to the end of this transformer chain.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LearningPipelineExtensions" Member="M:Microsoft.ML.LearningPipelineExtensions.Append``1(Microsoft.ML.Core.Data.ITransformer,``0)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.IDataReader`1" />
      </Targets>
      <Member MemberName="Append&lt;TSource,TTrans&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.CompositeDataReader&lt;TSource,TTrans&gt; Append&lt;TSource,TTrans&gt; (this Microsoft.ML.Core.Data.IDataReader&lt;TSource&gt; reader, TTrans transformer) where TTrans : class, Microsoft.ML.Core.Data.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.CompositeDataReader`2&lt;!!TSource, !!TTrans&gt; Append&lt;TSource, class (class Microsoft.ML.Core.Data.ITransformer) TTrans&gt;(class Microsoft.ML.Core.Data.IDataReader`1&lt;!!TSource&gt; reader, !!TTrans transformer) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LearningPipelineExtensions.Append``2(Microsoft.ML.Core.Data.IDataReader{``0},``1)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Append(Of TSource, TTrans) (reader As IDataReader(Of TSource), transformer As TTrans) As CompositeDataReader(Of TSource, TTrans)" />
        <MemberSignature Language="F#" Value="static member Append : Microsoft.ML.Core.Data.IDataReader&lt;'Source&gt; * 'rans -&gt; Microsoft.ML.Data.CompositeDataReader&lt;'Source, 'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)" Usage="Microsoft.ML.LearningPipelineExtensions.Append (reader, transformer)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.CompositeDataReader&lt;TSource,TTrans&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSource" />
          <TypeParameter Name="TTrans">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="reader" Type="Microsoft.ML.Core.Data.IDataReader&lt;TSource&gt;" RefType="this" />
          <Parameter Name="transformer" Type="TTrans" />
        </Parameters>
        <Docs>
          <typeparam name="TSource">To be added.</typeparam>
          <typeparam name="TTrans">To be added.</typeparam>
          <param name="reader">To be added.</param>
          <param name="transformer">To be added.</param>
          <summary>
            Create a new composite reader, by appending a transformer to this data reader.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LearningPipelineExtensions" Member="M:Microsoft.ML.LearningPipelineExtensions.Append``2(Microsoft.ML.Core.Data.IDataReader{``0},``1)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.IDataReader`1" />
      </Targets>
      <Member MemberName="Append&lt;TSource,TTrans&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.CompositeReaderEstimator&lt;TSource,TTrans&gt; Append&lt;TSource,TTrans&gt; (this Microsoft.ML.Core.Data.IDataReader&lt;TSource&gt; start, Microsoft.ML.Core.Data.IEstimator&lt;TTrans&gt; estimator) where TTrans : class, Microsoft.ML.Core.Data.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.CompositeReaderEstimator`2&lt;!!TSource, !!TTrans&gt; Append&lt;TSource, class (class Microsoft.ML.Core.Data.ITransformer) TTrans&gt;(class Microsoft.ML.Core.Data.IDataReader`1&lt;!!TSource&gt; start, class Microsoft.ML.Core.Data.IEstimator`1&lt;!!TTrans&gt; estimator) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LearningPipelineExtensions.Append``2(Microsoft.ML.Core.Data.IDataReader{``0},Microsoft.ML.Core.Data.IEstimator{``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Append(Of TSource, TTrans) (start As IDataReader(Of TSource), estimator As IEstimator(Of TTrans)) As CompositeReaderEstimator(Of TSource, TTrans)" />
        <MemberSignature Language="F#" Value="static member Append : Microsoft.ML.Core.Data.IDataReader&lt;'Source&gt; * Microsoft.ML.Core.Data.IEstimator&lt;'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; -&gt; Microsoft.ML.Data.CompositeReaderEstimator&lt;'Source, 'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)" Usage="Microsoft.ML.LearningPipelineExtensions.Append (start, estimator)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.CompositeReaderEstimator&lt;TSource,TTrans&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSource" />
          <TypeParameter Name="TTrans">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="start" Type="Microsoft.ML.Core.Data.IDataReader&lt;TSource&gt;" RefType="this" />
          <Parameter Name="estimator" Type="Microsoft.ML.Core.Data.IEstimator&lt;TTrans&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TSource">To be added.</typeparam>
          <typeparam name="TTrans">To be added.</typeparam>
          <param name="start">To be added.</param>
          <param name="estimator">To be added.</param>
          <summary>
            Create a new composite reader estimator, by appending an estimator to this data reader.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LearningPipelineExtensions" Member="M:Microsoft.ML.LearningPipelineExtensions.Append``2(Microsoft.ML.Core.Data.IDataReader{``0},Microsoft.ML.Core.Data.IEstimator{``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.IDataReaderEstimator`2" />
      </Targets>
      <Member MemberName="Append&lt;TSource,TTrans&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.CompositeReaderEstimator&lt;TSource,TTrans&gt; Append&lt;TSource,TTrans&gt; (this Microsoft.ML.Core.Data.IDataReaderEstimator&lt;TSource,Microsoft.ML.Core.Data.IDataReader&lt;TSource&gt;&gt; start, Microsoft.ML.Core.Data.IEstimator&lt;TTrans&gt; estimator) where TTrans : class, Microsoft.ML.Core.Data.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.CompositeReaderEstimator`2&lt;!!TSource, !!TTrans&gt; Append&lt;TSource, class (class Microsoft.ML.Core.Data.ITransformer) TTrans&gt;(class Microsoft.ML.Core.Data.IDataReaderEstimator`2&lt;!!TSource, class Microsoft.ML.Core.Data.IDataReader`1&lt;!!TSource&gt;&gt; start, class Microsoft.ML.Core.Data.IEstimator`1&lt;!!TTrans&gt; estimator) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LearningPipelineExtensions.Append``2(Microsoft.ML.Core.Data.IDataReaderEstimator{``0,Microsoft.ML.Core.Data.IDataReader{``0}},Microsoft.ML.Core.Data.IEstimator{``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Append(Of TSource, TTrans) (start As IDataReaderEstimator(Of TSource, IDataReader(Of TSource)), estimator As IEstimator(Of TTrans)) As CompositeReaderEstimator(Of TSource, TTrans)" />
        <MemberSignature Language="F#" Value="static member Append : Microsoft.ML.Core.Data.IDataReaderEstimator&lt;'Source, Microsoft.ML.Core.Data.IDataReader&lt;'Source&gt;&gt; * Microsoft.ML.Core.Data.IEstimator&lt;'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; -&gt; Microsoft.ML.Data.CompositeReaderEstimator&lt;'Source, 'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)" Usage="Microsoft.ML.LearningPipelineExtensions.Append (start, estimator)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.CompositeReaderEstimator&lt;TSource,TTrans&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSource" />
          <TypeParameter Name="TTrans">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="start" Type="Microsoft.ML.Core.Data.IDataReaderEstimator&lt;TSource,Microsoft.ML.Core.Data.IDataReader&lt;TSource&gt;&gt;" RefType="this" />
          <Parameter Name="estimator" Type="Microsoft.ML.Core.Data.IEstimator&lt;TTrans&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TSource">To be added.</typeparam>
          <typeparam name="TTrans">To be added.</typeparam>
          <param name="start">To be added.</param>
          <param name="estimator">To be added.</param>
          <summary>
            Create a new composite reader estimator, by appending another estimator to the end of this data reader estimator.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LearningPipelineExtensions" Member="M:Microsoft.ML.LearningPipelineExtensions.Append``2(Microsoft.ML.Core.Data.IDataReaderEstimator{``0,Microsoft.ML.Core.Data.IDataReader{``0}},Microsoft.ML.Core.Data.IEstimator{``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.IEstimator`1" />
      </Targets>
      <Member MemberName="AppendCacheCheckpoint&lt;TTrans&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.EstimatorChain&lt;TTrans&gt; AppendCacheCheckpoint&lt;TTrans&gt; (this Microsoft.ML.Core.Data.IEstimator&lt;TTrans&gt; start, Microsoft.ML.IHostEnvironment env) where TTrans : class, Microsoft.ML.Core.Data.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.EstimatorChain`1&lt;!!TTrans&gt; AppendCacheCheckpoint&lt;class (class Microsoft.ML.Core.Data.ITransformer) TTrans&gt;(class Microsoft.ML.Core.Data.IEstimator`1&lt;!!TTrans&gt; start, class Microsoft.ML.IHostEnvironment env) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LearningPipelineExtensions.AppendCacheCheckpoint``1(Microsoft.ML.Core.Data.IEstimator{``0},Microsoft.ML.IHostEnvironment)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AppendCacheCheckpoint(Of TTrans As {Class, ITransformer}) (start As IEstimator(Of TTrans), env As IHostEnvironment) As EstimatorChain(Of TTrans)" />
        <MemberSignature Language="F#" Value="static member AppendCacheCheckpoint : Microsoft.ML.Core.Data.IEstimator&lt;'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; * Microsoft.ML.IHostEnvironment -&gt; Microsoft.ML.Data.EstimatorChain&lt;'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)" Usage="Microsoft.ML.LearningPipelineExtensions.AppendCacheCheckpoint (start, env)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.EstimatorChain&lt;TTrans&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TTrans">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="start" Type="Microsoft.ML.Core.Data.IEstimator&lt;TTrans&gt;" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" />
        </Parameters>
        <Docs>
          <typeparam name="TTrans">To be added.</typeparam>
          <param name="start">The starting estimator</param>
          <param name="env">The host environment to use for caching.</param>
          <summary>
            Append a 'caching checkpoint' to the estimator chain. This will ensure that the downstream estimators will be trained against
            cached data. It is helpful to have a caching checkpoint before trainers that take multiple data passes.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LearningPipelineExtensions" Member="M:Microsoft.ML.LearningPipelineExtensions.AppendCacheCheckpoint``1(Microsoft.ML.Core.Data.IEstimator{``0},Microsoft.ML.IHostEnvironment)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.IEstimator`1" />
      </Targets>
      <Member MemberName="WithOnFitDelegate&lt;TTransformer&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Core.Data.IEstimator&lt;TTransformer&gt; WithOnFitDelegate&lt;TTransformer&gt; (this Microsoft.ML.Core.Data.IEstimator&lt;TTransformer&gt; estimator, Action&lt;TTransformer&gt; onFit) where TTransformer : class, Microsoft.ML.Core.Data.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Core.Data.IEstimator`1&lt;!!TTransformer&gt; WithOnFitDelegate&lt;class (class Microsoft.ML.Core.Data.ITransformer) TTransformer&gt;(class Microsoft.ML.Core.Data.IEstimator`1&lt;!!TTransformer&gt; estimator, class System.Action`1&lt;!!TTransformer&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LearningPipelineExtensions.WithOnFitDelegate``1(Microsoft.ML.Core.Data.IEstimator{``0},System.Action{``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithOnFitDelegate(Of TTransformer As {Class, ITransformer}) (estimator As IEstimator(Of TTransformer), onFit As Action(Of TTransformer)) As IEstimator(Of TTransformer)" />
        <MemberSignature Language="F#" Value="static member WithOnFitDelegate : Microsoft.ML.Core.Data.IEstimator&lt;'ransformer (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; * Action&lt;'ransformer (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; -&gt; Microsoft.ML.Core.Data.IEstimator&lt;'ransformer (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.Core.Data.ITransformer)" Usage="Microsoft.ML.LearningPipelineExtensions.WithOnFitDelegate (estimator, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Core.Data.IEstimator&lt;TTransformer&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TTransformer">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="estimator" Type="Microsoft.ML.Core.Data.IEstimator&lt;TTransformer&gt;" RefType="this" />
          <Parameter Name="onFit" Type="System.Action&lt;TTransformer&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TTransformer">The type of <see cref="T:Microsoft.ML.Core.Data.ITransformer" /> returned by <paramref name="estimator" /></typeparam>
          <param name="estimator">The estimator to wrap</param>
          <param name="onFit">The delegate that is called with the resulting <typeparamref name="TTransformer" /> instances once
            <see cref="M:Microsoft.ML.Core.Data.IEstimator`1.Fit(Microsoft.ML.Data.IDataView)" /> is called. Because <see cref="M:Microsoft.ML.Core.Data.IEstimator`1.Fit(Microsoft.ML.Data.IDataView)" />
            may be called multiple times, this delegate may also be called multiple times.</param>
          <summary>
            Given an estimator, return a wrapping object that will call a delegate once <see cref="M:Microsoft.ML.Core.Data.IEstimator`1.Fit(Microsoft.ML.Data.IDataView)" />
            is called. It is often important for an estimator to return information about what was fit, which is why the
            <see cref="M:Microsoft.ML.Core.Data.IEstimator`1.Fit(Microsoft.ML.Data.IDataView)" /> method returns a specifically typed object, rather than just a general
            <see cref="T:Microsoft.ML.Core.Data.ITransformer" />. However, at the same time, <see cref="T:Microsoft.ML.Core.Data.IEstimator`1" /> are often formed into pipelines
            with many objects, so we may need to build a chain of estimators via <see cref="T:Microsoft.ML.Data.EstimatorChain`1" /> where the
            estimator for which we want to get the transformer is buried somewhere in this chain. For that scenario, we can through this
            method attach a delegate that will be called once fit is called.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LearningPipelineExtensions" Member="M:Microsoft.ML.LearningPipelineExtensions.WithOnFitDelegate``1(Microsoft.ML.Core.Data.IEstimator{``0},System.Action{``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="LightGbm">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.LightGBM.LightGbmBinaryTrainer LightGbm (this Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers ctx, string labelColumn = &quot;Label&quot;, string featureColumn = &quot;Features&quot;, string weights = null, Nullable&lt;int&gt; numLeaves = null, Nullable&lt;int&gt; minDataPerLeaf = null, Nullable&lt;double&gt; learningRate = null, int numBoostRound = 100, Action&lt;Microsoft.ML.LightGBM.LightGbmArguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.LightGBM.LightGbmBinaryTrainer LightGbm(class Microsoft.ML.BinaryClassificationContext/BinaryClassificationTrainers ctx, string labelColumn, string featureColumn, string weights, valuetype System.Nullable`1&lt;int32&gt; numLeaves, valuetype System.Nullable`1&lt;int32&gt; minDataPerLeaf, valuetype System.Nullable`1&lt;float64&gt; learningRate, int32 numBoostRound, class System.Action`1&lt;class Microsoft.ML.LightGBM.LightGbmArguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LightGbmExtensions.LightGbm(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Int32,System.Action{Microsoft.ML.LightGBM.LightGbmArguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LightGbm (ctx As BinaryClassificationContext.BinaryClassificationTrainers, Optional labelColumn As String = &quot;Label&quot;, Optional featureColumn As String = &quot;Features&quot;, Optional weights As String = null, Optional numLeaves As Nullable(Of Integer) = null, Optional minDataPerLeaf As Nullable(Of Integer) = null, Optional learningRate As Nullable(Of Double) = null, Optional numBoostRound As Integer = 100, Optional advancedSettings As Action(Of LightGbmArguments) = null) As LightGbmBinaryTrainer" />
        <MemberSignature Language="F#" Value="static member LightGbm : Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers * string * string * string * Nullable&lt;int&gt; * Nullable&lt;int&gt; * Nullable&lt;double&gt; * int * Action&lt;Microsoft.ML.LightGBM.LightGbmArguments&gt; -&gt; Microsoft.ML.LightGBM.LightGbmBinaryTrainer" Usage="Microsoft.ML.LightGbmExtensions.LightGbm (ctx, labelColumn, featureColumn, weights, numLeaves, minDataPerLeaf, learningRate, numBoostRound, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.LightGBM.LightGbmBinaryTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumn" Type="System.String" />
          <Parameter Name="featureColumn" Type="System.String" />
          <Parameter Name="weights" Type="System.String" />
          <Parameter Name="numLeaves" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="minDataPerLeaf" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="learningRate" Type="System.Nullable&lt;System.Double&gt;" />
          <Parameter Name="numBoostRound" Type="System.Int32" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.LightGBM.LightGbmArguments&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The <see cref="T:Microsoft.ML.BinaryClassificationContext" />.</param>
          <param name="labelColumn">The labelColumn column.</param>
          <param name="featureColumn">The features column.</param>
          <param name="weights">The weights column.</param>
          <param name="numLeaves">The number of leaves to use.</param>
          <param name="minDataPerLeaf">The minimal number of documents allowed in a leaf of the tree, out of the subsampled data.</param>
          <param name="learningRate">The learning rate.</param>
          <param name="numBoostRound">Number of iterations.</param>
          <param name="advancedSettings">A delegate to set more settings.
            The settings here will override the ones provided in the direct signature,
            if both are present and have different values.
            The columns names, however need to be provided directly, not through the <paramref name="advancedSettings" />.</param>
          <summary>
            Predict a target using a decision tree binary classification model trained with the <see cref="T:Microsoft.ML.LightGBM.LightGbmBinaryTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LightGbmExtensions" Member="M:Microsoft.ML.LightGbmExtensions.LightGbm(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Int32,System.Action{Microsoft.ML.LightGBM.LightGbmArguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="LightGbm">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.LightGBM.LightGbmMulticlassTrainer LightGbm (this Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers ctx, string labelColumn = &quot;Label&quot;, string featureColumn = &quot;Features&quot;, string weights = null, Nullable&lt;int&gt; numLeaves = null, Nullable&lt;int&gt; minDataPerLeaf = null, Nullable&lt;double&gt; learningRate = null, int numBoostRound = 100, Action&lt;Microsoft.ML.LightGBM.LightGbmArguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.LightGBM.LightGbmMulticlassTrainer LightGbm(class Microsoft.ML.MulticlassClassificationContext/MulticlassClassificationTrainers ctx, string labelColumn, string featureColumn, string weights, valuetype System.Nullable`1&lt;int32&gt; numLeaves, valuetype System.Nullable`1&lt;int32&gt; minDataPerLeaf, valuetype System.Nullable`1&lt;float64&gt; learningRate, int32 numBoostRound, class System.Action`1&lt;class Microsoft.ML.LightGBM.LightGbmArguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LightGbmExtensions.LightGbm(Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers,System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Int32,System.Action{Microsoft.ML.LightGBM.LightGbmArguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LightGbm (ctx As MulticlassClassificationContext.MulticlassClassificationTrainers, Optional labelColumn As String = &quot;Label&quot;, Optional featureColumn As String = &quot;Features&quot;, Optional weights As String = null, Optional numLeaves As Nullable(Of Integer) = null, Optional minDataPerLeaf As Nullable(Of Integer) = null, Optional learningRate As Nullable(Of Double) = null, Optional numBoostRound As Integer = 100, Optional advancedSettings As Action(Of LightGbmArguments) = null) As LightGbmMulticlassTrainer" />
        <MemberSignature Language="F#" Value="static member LightGbm : Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers * string * string * string * Nullable&lt;int&gt; * Nullable&lt;int&gt; * Nullable&lt;double&gt; * int * Action&lt;Microsoft.ML.LightGBM.LightGbmArguments&gt; -&gt; Microsoft.ML.LightGBM.LightGbmMulticlassTrainer" Usage="Microsoft.ML.LightGbmExtensions.LightGbm (ctx, labelColumn, featureColumn, weights, numLeaves, minDataPerLeaf, learningRate, numBoostRound, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.LightGBM.LightGbmMulticlassTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.MulticlassClassificationContext+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumn" Type="System.String" />
          <Parameter Name="featureColumn" Type="System.String" />
          <Parameter Name="weights" Type="System.String" />
          <Parameter Name="numLeaves" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="minDataPerLeaf" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="learningRate" Type="System.Nullable&lt;System.Double&gt;" />
          <Parameter Name="numBoostRound" Type="System.Int32" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.LightGBM.LightGbmArguments&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The <see cref="T:Microsoft.ML.RankingContext" />.</param>
          <param name="labelColumn">The labelColumn column.</param>
          <param name="featureColumn">The features column.</param>
          <param name="weights">The weights column.</param>
          <param name="numLeaves">The number of leaves to use.</param>
          <param name="minDataPerLeaf">The minimal number of documents allowed in a leaf of the tree, out of the subsampled data.</param>
          <param name="learningRate">The learning rate.</param>
          <param name="numBoostRound">Number of iterations.</param>
          <param name="advancedSettings">A delegate to set more settings.
            The settings here will override the ones provided in the direct signature,
            if both are present and have different values.
            The columns names, however need to be provided directly, not through the <paramref name="advancedSettings" />.</param>
          <summary>
            Predict a target using a decision tree binary classification model trained with the <see cref="T:Microsoft.ML.LightGBM.LightGbmRankingTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LightGbmExtensions" Member="M:Microsoft.ML.LightGbmExtensions.LightGbm(Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers,System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Int32,System.Action{Microsoft.ML.LightGBM.LightGbmArguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RankingContext.RankingTrainers" />
      </Targets>
      <Member MemberName="LightGbm">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.LightGBM.LightGbmRankingTrainer LightGbm (this Microsoft.ML.RankingContext.RankingTrainers ctx, string labelColumn = &quot;Label&quot;, string featureColumn = &quot;Features&quot;, string groupIdColumn = &quot;GroupId&quot;, string weights = null, Nullable&lt;int&gt; numLeaves = null, Nullable&lt;int&gt; minDataPerLeaf = null, Nullable&lt;double&gt; learningRate = null, int numBoostRound = 100, Action&lt;Microsoft.ML.LightGBM.LightGbmArguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.LightGBM.LightGbmRankingTrainer LightGbm(class Microsoft.ML.RankingContext/RankingTrainers ctx, string labelColumn, string featureColumn, string groupIdColumn, string weights, valuetype System.Nullable`1&lt;int32&gt; numLeaves, valuetype System.Nullable`1&lt;int32&gt; minDataPerLeaf, valuetype System.Nullable`1&lt;float64&gt; learningRate, int32 numBoostRound, class System.Action`1&lt;class Microsoft.ML.LightGBM.LightGbmArguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LightGbmExtensions.LightGbm(Microsoft.ML.RankingContext.RankingTrainers,System.String,System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Int32,System.Action{Microsoft.ML.LightGBM.LightGbmArguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LightGbm (ctx As RankingContext.RankingTrainers, Optional labelColumn As String = &quot;Label&quot;, Optional featureColumn As String = &quot;Features&quot;, Optional groupIdColumn As String = &quot;GroupId&quot;, Optional weights As String = null, Optional numLeaves As Nullable(Of Integer) = null, Optional minDataPerLeaf As Nullable(Of Integer) = null, Optional learningRate As Nullable(Of Double) = null, Optional numBoostRound As Integer = 100, Optional advancedSettings As Action(Of LightGbmArguments) = null) As LightGbmRankingTrainer" />
        <MemberSignature Language="F#" Value="static member LightGbm : Microsoft.ML.RankingContext.RankingTrainers * string * string * string * string * Nullable&lt;int&gt; * Nullable&lt;int&gt; * Nullable&lt;double&gt; * int * Action&lt;Microsoft.ML.LightGBM.LightGbmArguments&gt; -&gt; Microsoft.ML.LightGBM.LightGbmRankingTrainer" Usage="Microsoft.ML.LightGbmExtensions.LightGbm (ctx, labelColumn, featureColumn, groupIdColumn, weights, numLeaves, minDataPerLeaf, learningRate, numBoostRound, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.LightGBM.LightGbmRankingTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RankingContext+RankingTrainers" RefType="this" />
          <Parameter Name="labelColumn" Type="System.String" />
          <Parameter Name="featureColumn" Type="System.String" />
          <Parameter Name="groupIdColumn" Type="System.String" />
          <Parameter Name="weights" Type="System.String" />
          <Parameter Name="numLeaves" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="minDataPerLeaf" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="learningRate" Type="System.Nullable&lt;System.Double&gt;" />
          <Parameter Name="numBoostRound" Type="System.Int32" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.LightGBM.LightGbmArguments&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The <see cref="T:Microsoft.ML.RankingContext" />.</param>
          <param name="labelColumn">The labelColumn column.</param>
          <param name="featureColumn">The features column.</param>
          <param name="groupIdColumn">The groupId column.</param>
          <param name="weights">The weights column.</param>
          <param name="numLeaves">The number of leaves to use.</param>
          <param name="minDataPerLeaf">The minimal number of documents allowed in a leaf of the tree, out of the subsampled data.</param>
          <param name="learningRate">The learning rate.</param>
          <param name="numBoostRound">Number of iterations.</param>
          <param name="advancedSettings">A delegate to set more settings.
            The settings here will override the ones provided in the direct signature,
            if both are present and have different values.
            The columns names, however need to be provided directly, not through the <paramref name="advancedSettings" />.</param>
          <summary>
            Predict a target using a decision tree binary classification model trained with the <see cref="T:Microsoft.ML.LightGBM.LightGbmRankingTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LightGbmExtensions" Member="M:Microsoft.ML.LightGbmExtensions.LightGbm(Microsoft.ML.RankingContext.RankingTrainers,System.String,System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Int32,System.Action{Microsoft.ML.LightGBM.LightGbmArguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionContext.RegressionTrainers" />
      </Targets>
      <Member MemberName="LightGbm">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.LightGBM.LightGbmRegressorTrainer LightGbm (this Microsoft.ML.RegressionContext.RegressionTrainers ctx, string labelColumn = &quot;Label&quot;, string featureColumn = &quot;Features&quot;, string weights = null, Nullable&lt;int&gt; numLeaves = null, Nullable&lt;int&gt; minDataPerLeaf = null, Nullable&lt;double&gt; learningRate = null, int numBoostRound = 100, Action&lt;Microsoft.ML.LightGBM.LightGbmArguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.LightGBM.LightGbmRegressorTrainer LightGbm(class Microsoft.ML.RegressionContext/RegressionTrainers ctx, string labelColumn, string featureColumn, string weights, valuetype System.Nullable`1&lt;int32&gt; numLeaves, valuetype System.Nullable`1&lt;int32&gt; minDataPerLeaf, valuetype System.Nullable`1&lt;float64&gt; learningRate, int32 numBoostRound, class System.Action`1&lt;class Microsoft.ML.LightGBM.LightGbmArguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.LightGbmExtensions.LightGbm(Microsoft.ML.RegressionContext.RegressionTrainers,System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Int32,System.Action{Microsoft.ML.LightGBM.LightGbmArguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LightGbm (ctx As RegressionContext.RegressionTrainers, Optional labelColumn As String = &quot;Label&quot;, Optional featureColumn As String = &quot;Features&quot;, Optional weights As String = null, Optional numLeaves As Nullable(Of Integer) = null, Optional minDataPerLeaf As Nullable(Of Integer) = null, Optional learningRate As Nullable(Of Double) = null, Optional numBoostRound As Integer = 100, Optional advancedSettings As Action(Of LightGbmArguments) = null) As LightGbmRegressorTrainer" />
        <MemberSignature Language="F#" Value="static member LightGbm : Microsoft.ML.RegressionContext.RegressionTrainers * string * string * string * Nullable&lt;int&gt; * Nullable&lt;int&gt; * Nullable&lt;double&gt; * int * Action&lt;Microsoft.ML.LightGBM.LightGbmArguments&gt; -&gt; Microsoft.ML.LightGBM.LightGbmRegressorTrainer" Usage="Microsoft.ML.LightGbmExtensions.LightGbm (ctx, labelColumn, featureColumn, weights, numLeaves, minDataPerLeaf, learningRate, numBoostRound, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.LightGBM.LightGbmRegressorTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RegressionContext+RegressionTrainers" RefType="this" />
          <Parameter Name="labelColumn" Type="System.String" />
          <Parameter Name="featureColumn" Type="System.String" />
          <Parameter Name="weights" Type="System.String" />
          <Parameter Name="numLeaves" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="minDataPerLeaf" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="learningRate" Type="System.Nullable&lt;System.Double&gt;" />
          <Parameter Name="numBoostRound" Type="System.Int32" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.LightGBM.LightGbmArguments&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The <see cref="T:Microsoft.ML.RegressionContext" />.</param>
          <param name="labelColumn">The labelColumn column.</param>
          <param name="featureColumn">The features column.</param>
          <param name="weights">The weights column.</param>
          <param name="numLeaves">The number of leaves to use.</param>
          <param name="minDataPerLeaf">The minimal number of documents allowed in a leaf of the tree, out of the subsampled data.</param>
          <param name="learningRate">The learning rate.</param>
          <param name="numBoostRound">Number of iterations.</param>
          <param name="advancedSettings">A delegate to set more settings.
            The settings here will override the ones provided in the direct signature,
            if both are present and have different values.
            The columns names, however need to be provided directly, not through the <paramref name="advancedSettings" />.</param>
          <summary>
            Predict a target using a decision tree regression model trained with the <see cref="T:Microsoft.ML.LightGBM.LightGbmRegressorTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.LightGbmExtensions" Member="M:Microsoft.ML.LightGbmExtensions.LightGbm(Microsoft.ML.RegressionContext.RegressionTrainers,System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Int32,System.Action{Microsoft.ML.LightGBM.LightGbmArguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="Normalize">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Normalizers.NormalizingEstimator Normalize (this Microsoft.ML.TransformsCatalog catalog, params Microsoft.ML.Transforms.Normalizers.NormalizingEstimator.ColumnBase[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Normalizers.NormalizingEstimator Normalize(class Microsoft.ML.TransformsCatalog catalog, class Microsoft.ML.Transforms.Normalizers.NormalizingEstimator/ColumnBase[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.NormalizerCatalog.Normalize(Microsoft.ML.TransformsCatalog,Microsoft.ML.Transforms.Normalizers.NormalizingEstimator.ColumnBase[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Normalize (catalog As TransformsCatalog, ParamArray columns As NormalizingEstimator.ColumnBase()) As NormalizingEstimator" />
        <MemberSignature Language="F#" Value="static member Normalize : Microsoft.ML.TransformsCatalog * Microsoft.ML.Transforms.Normalizers.NormalizingEstimator.ColumnBase[] -&gt; Microsoft.ML.Transforms.Normalizers.NormalizingEstimator" Usage="Microsoft.ML.NormalizerCatalog.Normalize (catalog, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Normalizers.NormalizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.Transforms.Normalizers.NormalizingEstimator+ColumnBase[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform catalog</param>
          <param name="columns">The normalization settings for all the columns</param>
          <summary>
            Normalize (rescale) columns according to specified custom parameters.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.NormalizerCatalog" Member="M:Microsoft.ML.NormalizerCatalog.Normalize(Microsoft.ML.TransformsCatalog,Microsoft.ML.Transforms.Normalizers.NormalizingEstimator.ColumnBase[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="Normalize">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Normalizers.NormalizingEstimator Normalize (this Microsoft.ML.TransformsCatalog catalog, Microsoft.ML.Transforms.Normalizers.NormalizingEstimator.NormalizerMode mode, params ValueTuple&lt;string,string&gt;[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Normalizers.NormalizingEstimator Normalize(class Microsoft.ML.TransformsCatalog catalog, valuetype Microsoft.ML.Transforms.Normalizers.NormalizingEstimator/NormalizerMode mode, valuetype System.ValueTuple`2&lt;string, string&gt;[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.NormalizerCatalog.Normalize(Microsoft.ML.TransformsCatalog,Microsoft.ML.Transforms.Normalizers.NormalizingEstimator.NormalizerMode,System.ValueTuple{System.String,System.String}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Normalize (catalog As TransformsCatalog, mode As NormalizingEstimator.NormalizerMode, ParamArray columns As ValueTuple(Of String, String)()) As NormalizingEstimator" />
        <MemberSignature Language="F#" Value="static member Normalize : Microsoft.ML.TransformsCatalog * Microsoft.ML.Transforms.Normalizers.NormalizingEstimator.NormalizerMode * ValueTuple&lt;string, string&gt;[] -&gt; Microsoft.ML.Transforms.Normalizers.NormalizingEstimator" Usage="Microsoft.ML.NormalizerCatalog.Normalize (catalog, mode, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Normalizers.NormalizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="mode" Type="Microsoft.ML.Transforms.Normalizers.NormalizingEstimator+NormalizerMode" />
          <Parameter Name="columns" Type="System.ValueTuple&lt;System.String,System.String&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
              <Attribute>
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "input", "output" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform catalog</param>
          <param name="mode">The <see cref="T:Microsoft.ML.Transforms.Normalizers.NormalizingEstimator.NormalizerMode" /> used to map the old values to the new ones. </param>
          <param name="columns">The pairs of input and output columns.</param>
          <summary>
            Normalize (rescale) several columns according to the specified <paramref name="mode" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.NormalizerCatalog" Member="M:Microsoft.ML.NormalizerCatalog.Normalize(Microsoft.ML.TransformsCatalog,Microsoft.ML.Transforms.Normalizers.NormalizingEstimator.NormalizerMode,System.ValueTuple{System.String,System.String}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="Normalize">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Normalizers.NormalizingEstimator Normalize (this Microsoft.ML.TransformsCatalog catalog, string inputName, string outputName = null, Microsoft.ML.Transforms.Normalizers.NormalizingEstimator.NormalizerMode mode = Microsoft.ML.Transforms.Normalizers.NormalizingEstimator+NormalizerMode.MinMax);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Normalizers.NormalizingEstimator Normalize(class Microsoft.ML.TransformsCatalog catalog, string inputName, string outputName, valuetype Microsoft.ML.Transforms.Normalizers.NormalizingEstimator/NormalizerMode mode) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.NormalizerCatalog.Normalize(Microsoft.ML.TransformsCatalog,System.String,System.String,Microsoft.ML.Transforms.Normalizers.NormalizingEstimator.NormalizerMode)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Normalize (catalog As TransformsCatalog, inputName As String, Optional outputName As String = null, Optional mode As NormalizingEstimator.NormalizerMode = Microsoft.ML.Transforms.Normalizers.NormalizingEstimator+NormalizerMode.MinMax) As NormalizingEstimator" />
        <MemberSignature Language="F#" Value="static member Normalize : Microsoft.ML.TransformsCatalog * string * string * Microsoft.ML.Transforms.Normalizers.NormalizingEstimator.NormalizerMode -&gt; Microsoft.ML.Transforms.Normalizers.NormalizingEstimator" Usage="Microsoft.ML.NormalizerCatalog.Normalize (catalog, inputName, outputName, mode)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Normalizers.NormalizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="inputName" Type="System.String" />
          <Parameter Name="outputName" Type="System.String" />
          <Parameter Name="mode" Type="Microsoft.ML.Transforms.Normalizers.NormalizingEstimator+NormalizerMode" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform catalog</param>
          <param name="inputName">The column name</param>
          <param name="outputName">The column name</param>
          <param name="mode">The <see cref="T:Microsoft.ML.Transforms.Normalizers.NormalizingEstimator.NormalizerMode" /> used to map the old values in the new scale. </param>
          <summary>
            Normalize (rescale) the column according to the specified <paramref name="mode" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.NormalizerCatalog" Member="M:Microsoft.ML.NormalizerCatalog.Normalize(Microsoft.ML.TransformsCatalog,System.String,System.String,Microsoft.ML.Transforms.Normalizers.NormalizingEstimator.NormalizerMode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="ApplyOnnxModel">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.OnnxScoringEstimator ApplyOnnxModel (this Microsoft.ML.TransformsCatalog catalog, Microsoft.ML.Transforms.OnnxTransform transformer);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.OnnxScoringEstimator ApplyOnnxModel(class Microsoft.ML.TransformsCatalog catalog, class Microsoft.ML.Transforms.OnnxTransform transformer) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.OnnxCatalog.ApplyOnnxModel(Microsoft.ML.TransformsCatalog,Microsoft.ML.Transforms.OnnxTransform)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ApplyOnnxModel (catalog As TransformsCatalog, transformer As OnnxTransform) As OnnxScoringEstimator" />
        <MemberSignature Language="F#" Value="static member ApplyOnnxModel : Microsoft.ML.TransformsCatalog * Microsoft.ML.Transforms.OnnxTransform -&gt; Microsoft.ML.Transforms.OnnxScoringEstimator" Usage="Microsoft.ML.OnnxCatalog.ApplyOnnxModel (catalog, transformer)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.OnnxScoringEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="transformer" Type="Microsoft.ML.Transforms.OnnxTransform" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="transformer">The ONNX transformer.</param>
          <summary>
            Initializes a new instance of <see cref="T:Microsoft.ML.Transforms.OnnxScoringEstimator" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.OnnxCatalog" Member="M:Microsoft.ML.OnnxCatalog.ApplyOnnxModel(Microsoft.ML.TransformsCatalog,Microsoft.ML.Transforms.OnnxTransform)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="ApplyOnnxModel">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.OnnxScoringEstimator ApplyOnnxModel (this Microsoft.ML.TransformsCatalog catalog, string modelFile, string[] inputColumns, string[] outputColumns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.OnnxScoringEstimator ApplyOnnxModel(class Microsoft.ML.TransformsCatalog catalog, string modelFile, string[] inputColumns, string[] outputColumns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.OnnxCatalog.ApplyOnnxModel(Microsoft.ML.TransformsCatalog,System.String,System.String[],System.String[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ApplyOnnxModel (catalog As TransformsCatalog, modelFile As String, inputColumns As String(), outputColumns As String()) As OnnxScoringEstimator" />
        <MemberSignature Language="F#" Value="static member ApplyOnnxModel : Microsoft.ML.TransformsCatalog * string * string[] * string[] -&gt; Microsoft.ML.Transforms.OnnxScoringEstimator" Usage="Microsoft.ML.OnnxCatalog.ApplyOnnxModel (catalog, modelFile, inputColumns, outputColumns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.OnnxScoringEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="modelFile" Type="System.String" />
          <Parameter Name="inputColumns" Type="System.String[]" />
          <Parameter Name="outputColumns" Type="System.String[]" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="modelFile">The path of the file containing the ONNX model.</param>
          <param name="inputColumns">The input columns.</param>
          <param name="outputColumns">The output columns resulting from the transformation.</param>
          <summary>
            Initializes a new instance of <see cref="T:Microsoft.ML.Transforms.OnnxScoringEstimator" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.OnnxCatalog" Member="M:Microsoft.ML.OnnxCatalog.ApplyOnnxModel(Microsoft.ML.TransformsCatalog,System.String,System.String[],System.String[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.ModelOperationsCatalog" />
      </Targets>
      <Member MemberName="ConvertToOnnx">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.UniversalModelFormat.Onnx.ModelProto ConvertToOnnx (this Microsoft.ML.ModelOperationsCatalog catalog, Microsoft.ML.Core.Data.ITransformer transform, Microsoft.ML.Data.IDataView inputData);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.UniversalModelFormat.Onnx.ModelProto ConvertToOnnx(class Microsoft.ML.ModelOperationsCatalog catalog, class Microsoft.ML.Core.Data.ITransformer transform, class Microsoft.ML.Data.IDataView inputData) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.OnnxExportExtensions.ConvertToOnnx(Microsoft.ML.ModelOperationsCatalog,Microsoft.ML.Core.Data.ITransformer,Microsoft.ML.Data.IDataView)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConvertToOnnx (catalog As ModelOperationsCatalog, transform As ITransformer, inputData As IDataView) As ModelProto" />
        <MemberSignature Language="F#" Value="static member ConvertToOnnx : Microsoft.ML.ModelOperationsCatalog * Microsoft.ML.Core.Data.ITransformer * Microsoft.ML.Data.IDataView -&gt; Microsoft.ML.UniversalModelFormat.Onnx.ModelProto" Usage="Microsoft.ML.OnnxExportExtensions.ConvertToOnnx (catalog, transform, inputData)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.UniversalModelFormat.Onnx.ModelProto</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.ModelOperationsCatalog" RefType="this" />
          <Parameter Name="transform" Type="Microsoft.ML.Core.Data.ITransformer" />
          <Parameter Name="inputData" Type="Microsoft.ML.Data.IDataView" />
        </Parameters>
        <Docs>
          <param name="catalog">The class that <see cref="M:Microsoft.ML.OnnxExportExtensions.ConvertToOnnx(Microsoft.ML.ModelOperationsCatalog,Microsoft.ML.Core.Data.ITransformer,Microsoft.ML.Data.IDataView)" /> attached to.</param>
          <param name="transform">The <see cref="T:Microsoft.ML.Core.Data.ITransformer" /> that will be converted into ONNX format.</param>
          <param name="inputData">The input of the specified transform.</param>
          <summary>
            Convert the specified <see cref="T:Microsoft.ML.Core.Data.ITransformer" /> to ONNX format. Note that ONNX uses Google's Protobuf so the returned value is a Protobuf object.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.OnnxExportExtensions" Member="M:Microsoft.ML.OnnxExportExtensions.ConvertToOnnx(Microsoft.ML.ModelOperationsCatalog,Microsoft.ML.Core.Data.ITransformer,Microsoft.ML.Data.IDataView)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ProjectionTransforms" />
      </Targets>
      <Member MemberName="ProjectToPrincipalComponents">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Projections.PrincipalComponentAnalysisEstimator ProjectToPrincipalComponents (this Microsoft.ML.TransformsCatalog.ProjectionTransforms catalog, params Microsoft.ML.Transforms.Projections.PcaTransform.ColumnInfo[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Projections.PrincipalComponentAnalysisEstimator ProjectToPrincipalComponents(class Microsoft.ML.TransformsCatalog/ProjectionTransforms catalog, class Microsoft.ML.Transforms.Projections.PcaTransform/ColumnInfo[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.PcaCatalog.ProjectToPrincipalComponents(Microsoft.ML.TransformsCatalog.ProjectionTransforms,Microsoft.ML.Transforms.Projections.PcaTransform.ColumnInfo[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProjectToPrincipalComponents (catalog As TransformsCatalog.ProjectionTransforms, ParamArray columns As PcaTransform.ColumnInfo()) As PrincipalComponentAnalysisEstimator" />
        <MemberSignature Language="F#" Value="static member ProjectToPrincipalComponents : Microsoft.ML.TransformsCatalog.ProjectionTransforms * Microsoft.ML.Transforms.Projections.PcaTransform.ColumnInfo[] -&gt; Microsoft.ML.Transforms.Projections.PrincipalComponentAnalysisEstimator" Usage="Microsoft.ML.PcaCatalog.ProjectToPrincipalComponents (catalog, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Projections.PrincipalComponentAnalysisEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ProjectionTransforms" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.Transforms.Projections.PcaTransform+ColumnInfo[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="columns">Input columns to apply PrincipalComponentAnalysis on.</param>
          <summary>Initializes a new instance of <see cref="T:Microsoft.ML.Transforms.Projections.PrincipalComponentAnalysisEstimator" />.</summary>
        </Docs>
        <Link Type="Microsoft.ML.PcaCatalog" Member="M:Microsoft.ML.PcaCatalog.ProjectToPrincipalComponents(Microsoft.ML.TransformsCatalog.ProjectionTransforms,Microsoft.ML.Transforms.Projections.PcaTransform.ColumnInfo[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ProjectionTransforms" />
      </Targets>
      <Member MemberName="ProjectToPrincipalComponents">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Projections.PrincipalComponentAnalysisEstimator ProjectToPrincipalComponents (this Microsoft.ML.TransformsCatalog.ProjectionTransforms catalog, string inputColumn, string outputColumn = null, string weightColumn = null, int rank = 20, int overSampling = 20, bool center = true, Nullable&lt;int&gt; seed = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Projections.PrincipalComponentAnalysisEstimator ProjectToPrincipalComponents(class Microsoft.ML.TransformsCatalog/ProjectionTransforms catalog, string inputColumn, string outputColumn, string weightColumn, int32 rank, int32 overSampling, bool center, valuetype System.Nullable`1&lt;int32&gt; seed) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.PcaCatalog.ProjectToPrincipalComponents(Microsoft.ML.TransformsCatalog.ProjectionTransforms,System.String,System.String,System.String,System.Int32,System.Int32,System.Boolean,System.Nullable{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProjectToPrincipalComponents (catalog As TransformsCatalog.ProjectionTransforms, inputColumn As String, Optional outputColumn As String = null, Optional weightColumn As String = null, Optional rank As Integer = 20, Optional overSampling As Integer = 20, Optional center As Boolean = true, Optional seed As Nullable(Of Integer) = null) As PrincipalComponentAnalysisEstimator" />
        <MemberSignature Language="F#" Value="static member ProjectToPrincipalComponents : Microsoft.ML.TransformsCatalog.ProjectionTransforms * string * string * string * int * int * bool * Nullable&lt;int&gt; -&gt; Microsoft.ML.Transforms.Projections.PrincipalComponentAnalysisEstimator" Usage="Microsoft.ML.PcaCatalog.ProjectToPrincipalComponents (catalog, inputColumn, outputColumn, weightColumn, rank, overSampling, center, seed)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Projections.PrincipalComponentAnalysisEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ProjectionTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="weightColumn" Type="System.String" />
          <Parameter Name="rank" Type="System.Int32" />
          <Parameter Name="overSampling" Type="System.Int32" />
          <Parameter Name="center" Type="System.Boolean" />
          <Parameter Name="seed" Type="System.Nullable&lt;System.Int32&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="inputColumn">Input column to apply PrincipalComponentAnalysis on.</param>
          <param name="outputColumn">Optional output column. Null means <paramref name="inputColumn" /> is replaced.</param>
          <param name="weightColumn">The name of the weight column.</param>
          <param name="rank">The number of principal components.</param>
          <param name="overSampling">Oversampling parameter for randomized PrincipalComponentAnalysis training.</param>
          <param name="center">If enabled, data is centered to be zero mean.</param>
          <param name="seed">The seed for random number generation.</param>
          <summary>Initializes a new instance of <see cref="T:Microsoft.ML.Transforms.Projections.PrincipalComponentAnalysisEstimator" />.</summary>
        </Docs>
        <Link Type="Microsoft.ML.PcaCatalog" Member="M:Microsoft.ML.PcaCatalog.ProjectToPrincipalComponents(Microsoft.ML.TransformsCatalog.ProjectionTransforms,System.String,System.String,System.String,System.Int32,System.Int32,System.Boolean,System.Nullable{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext" />
      </Targets>
      <Member MemberName="PermutationFeatureImportance">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.ML.BinaryClassificationMetricsStatistics&gt; PermutationFeatureImportance (this Microsoft.ML.BinaryClassificationContext ctx, Microsoft.ML.IPredictionTransformer&lt;Microsoft.ML.IPredictor&gt; model, Microsoft.ML.Data.IDataView data, string label = &quot;Label&quot;, string features = &quot;Features&quot;, bool useFeatureWeightFilter = false, Nullable&lt;int&gt; topExamples = null, int permutationCount = 1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.ML.BinaryClassificationMetricsStatistics&gt; PermutationFeatureImportance(class Microsoft.ML.BinaryClassificationContext ctx, class Microsoft.ML.IPredictionTransformer`1&lt;class Microsoft.ML.IPredictor&gt; model, class Microsoft.ML.Data.IDataView data, string label, string features, bool useFeatureWeightFilter, valuetype System.Nullable`1&lt;int32&gt; topExamples, int32 permutationCount) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.PermutationFeatureImportanceExtensions.PermutationFeatureImportance(Microsoft.ML.BinaryClassificationContext,Microsoft.ML.IPredictionTransformer{Microsoft.ML.IPredictor},Microsoft.ML.Data.IDataView,System.String,System.String,System.Boolean,System.Nullable{System.Int32},System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function PermutationFeatureImportance (ctx As BinaryClassificationContext, model As IPredictionTransformer(Of IPredictor), data As IDataView, Optional label As String = &quot;Label&quot;, Optional features As String = &quot;Features&quot;, Optional useFeatureWeightFilter As Boolean = false, Optional topExamples As Nullable(Of Integer) = null, Optional permutationCount As Integer = 1) As ImmutableArray(Of BinaryClassificationMetricsStatistics)" />
        <MemberSignature Language="F#" Value="static member PermutationFeatureImportance : Microsoft.ML.BinaryClassificationContext * Microsoft.ML.IPredictionTransformer&lt;Microsoft.ML.IPredictor&gt; * Microsoft.ML.Data.IDataView * string * string * bool * Nullable&lt;int&gt; * int -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.ML.BinaryClassificationMetricsStatistics&gt;" Usage="Microsoft.ML.PermutationFeatureImportanceExtensions.PermutationFeatureImportance (ctx, model, data, label, features, useFeatureWeightFilter, topExamples, permutationCount)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.ML.BinaryClassificationMetricsStatistics&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext" RefType="this" />
          <Parameter Name="model" Type="Microsoft.ML.IPredictionTransformer&lt;Microsoft.ML.IPredictor&gt;" />
          <Parameter Name="data" Type="Microsoft.ML.Data.IDataView" />
          <Parameter Name="label" Type="System.String" />
          <Parameter Name="features" Type="System.String" />
          <Parameter Name="useFeatureWeightFilter" Type="System.Boolean" />
          <Parameter Name="topExamples" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="permutationCount" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="ctx">The binary classification context.</param>
          <param name="model">The model to evaluate.</param>
          <param name="data">The evaluation data set.</param>
          <param name="label">Label column name.</param>
          <param name="features">Feature column name.</param>
          <param name="useFeatureWeightFilter">Use features weight to pre-filter features.</param>
          <param name="topExamples">Limit the number of examples to evaluate on. null means examples (up to ~ 2 bln) from input will be used.</param>
          <param name="permutationCount">The number of permutations to perform.</param>
          <summary>
            Permutation Feature Importance (PFI) for Binary Classification
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.PermutationFeatureImportanceExtensions" Member="M:Microsoft.ML.PermutationFeatureImportanceExtensions.PermutationFeatureImportance(Microsoft.ML.BinaryClassificationContext,Microsoft.ML.IPredictionTransformer{Microsoft.ML.IPredictor},Microsoft.ML.Data.IDataView,System.String,System.String,System.Boolean,System.Nullable{System.Int32},System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationContext" />
      </Targets>
      <Member MemberName="PermutationFeatureImportance">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.ML.MultiClassClassifierMetricsStatistics&gt; PermutationFeatureImportance (this Microsoft.ML.MulticlassClassificationContext ctx, Microsoft.ML.IPredictionTransformer&lt;Microsoft.ML.IPredictor&gt; model, Microsoft.ML.Data.IDataView data, string label = &quot;Label&quot;, string features = &quot;Features&quot;, bool useFeatureWeightFilter = false, Nullable&lt;int&gt; topExamples = null, int permutationCount = 1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.ML.MultiClassClassifierMetricsStatistics&gt; PermutationFeatureImportance(class Microsoft.ML.MulticlassClassificationContext ctx, class Microsoft.ML.IPredictionTransformer`1&lt;class Microsoft.ML.IPredictor&gt; model, class Microsoft.ML.Data.IDataView data, string label, string features, bool useFeatureWeightFilter, valuetype System.Nullable`1&lt;int32&gt; topExamples, int32 permutationCount) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.PermutationFeatureImportanceExtensions.PermutationFeatureImportance(Microsoft.ML.MulticlassClassificationContext,Microsoft.ML.IPredictionTransformer{Microsoft.ML.IPredictor},Microsoft.ML.Data.IDataView,System.String,System.String,System.Boolean,System.Nullable{System.Int32},System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function PermutationFeatureImportance (ctx As MulticlassClassificationContext, model As IPredictionTransformer(Of IPredictor), data As IDataView, Optional label As String = &quot;Label&quot;, Optional features As String = &quot;Features&quot;, Optional useFeatureWeightFilter As Boolean = false, Optional topExamples As Nullable(Of Integer) = null, Optional permutationCount As Integer = 1) As ImmutableArray(Of MultiClassClassifierMetricsStatistics)" />
        <MemberSignature Language="F#" Value="static member PermutationFeatureImportance : Microsoft.ML.MulticlassClassificationContext * Microsoft.ML.IPredictionTransformer&lt;Microsoft.ML.IPredictor&gt; * Microsoft.ML.Data.IDataView * string * string * bool * Nullable&lt;int&gt; * int -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.ML.MultiClassClassifierMetricsStatistics&gt;" Usage="Microsoft.ML.PermutationFeatureImportanceExtensions.PermutationFeatureImportance (ctx, model, data, label, features, useFeatureWeightFilter, topExamples, permutationCount)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.ML.MultiClassClassifierMetricsStatistics&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.MulticlassClassificationContext" RefType="this" />
          <Parameter Name="model" Type="Microsoft.ML.IPredictionTransformer&lt;Microsoft.ML.IPredictor&gt;" />
          <Parameter Name="data" Type="Microsoft.ML.Data.IDataView" />
          <Parameter Name="label" Type="System.String" />
          <Parameter Name="features" Type="System.String" />
          <Parameter Name="useFeatureWeightFilter" Type="System.Boolean" />
          <Parameter Name="topExamples" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="permutationCount" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="ctx">The clustering context.</param>
          <param name="model">The model to evaluate.</param>
          <param name="data">The evaluation data set.</param>
          <param name="label">Label column name.</param>
          <param name="features">Feature column name.</param>
          <param name="useFeatureWeightFilter">Use features weight to pre-filter features.</param>
          <param name="topExamples">Limit the number of examples to evaluate on. null means examples (up to ~ 2 bln) from input will be used.</param>
          <param name="permutationCount">The number of permutations to perform.</param>
          <summary>
            Permutation Feature Importance (PFI) for MulticlassClassification
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.PermutationFeatureImportanceExtensions" Member="M:Microsoft.ML.PermutationFeatureImportanceExtensions.PermutationFeatureImportance(Microsoft.ML.MulticlassClassificationContext,Microsoft.ML.IPredictionTransformer{Microsoft.ML.IPredictor},Microsoft.ML.Data.IDataView,System.String,System.String,System.Boolean,System.Nullable{System.Int32},System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RankingContext" />
      </Targets>
      <Member MemberName="PermutationFeatureImportance">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.ML.RankerMetricsStatistics&gt; PermutationFeatureImportance (this Microsoft.ML.RankingContext ctx, Microsoft.ML.IPredictionTransformer&lt;Microsoft.ML.IPredictor&gt; model, Microsoft.ML.Data.IDataView data, string label = &quot;Label&quot;, string groupId = &quot;GroupId&quot;, string features = &quot;Features&quot;, bool useFeatureWeightFilter = false, Nullable&lt;int&gt; topExamples = null, int permutationCount = 1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.ML.RankerMetricsStatistics&gt; PermutationFeatureImportance(class Microsoft.ML.RankingContext ctx, class Microsoft.ML.IPredictionTransformer`1&lt;class Microsoft.ML.IPredictor&gt; model, class Microsoft.ML.Data.IDataView data, string label, string groupId, string features, bool useFeatureWeightFilter, valuetype System.Nullable`1&lt;int32&gt; topExamples, int32 permutationCount) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.PermutationFeatureImportanceExtensions.PermutationFeatureImportance(Microsoft.ML.RankingContext,Microsoft.ML.IPredictionTransformer{Microsoft.ML.IPredictor},Microsoft.ML.Data.IDataView,System.String,System.String,System.String,System.Boolean,System.Nullable{System.Int32},System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function PermutationFeatureImportance (ctx As RankingContext, model As IPredictionTransformer(Of IPredictor), data As IDataView, Optional label As String = &quot;Label&quot;, Optional groupId As String = &quot;GroupId&quot;, Optional features As String = &quot;Features&quot;, Optional useFeatureWeightFilter As Boolean = false, Optional topExamples As Nullable(Of Integer) = null, Optional permutationCount As Integer = 1) As ImmutableArray(Of RankerMetricsStatistics)" />
        <MemberSignature Language="F#" Value="static member PermutationFeatureImportance : Microsoft.ML.RankingContext * Microsoft.ML.IPredictionTransformer&lt;Microsoft.ML.IPredictor&gt; * Microsoft.ML.Data.IDataView * string * string * string * bool * Nullable&lt;int&gt; * int -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.ML.RankerMetricsStatistics&gt;" Usage="Microsoft.ML.PermutationFeatureImportanceExtensions.PermutationFeatureImportance (ctx, model, data, label, groupId, features, useFeatureWeightFilter, topExamples, permutationCount)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.ML.RankerMetricsStatistics&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RankingContext" RefType="this" />
          <Parameter Name="model" Type="Microsoft.ML.IPredictionTransformer&lt;Microsoft.ML.IPredictor&gt;" />
          <Parameter Name="data" Type="Microsoft.ML.Data.IDataView" />
          <Parameter Name="label" Type="System.String" />
          <Parameter Name="groupId" Type="System.String" />
          <Parameter Name="features" Type="System.String" />
          <Parameter Name="useFeatureWeightFilter" Type="System.Boolean" />
          <Parameter Name="topExamples" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="permutationCount" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="ctx">The clustering context.</param>
          <param name="model">The model to evaluate.</param>
          <param name="data">The evaluation data set.</param>
          <param name="label">Label column name.</param>
          <param name="groupId">GroupId column name</param>
          <param name="features">Feature column name.</param>
          <param name="useFeatureWeightFilter">Use features weight to pre-filter features.</param>
          <param name="topExamples">Limit the number of examples to evaluate on. null means examples (up to ~ 2 bln) from input will be used.</param>
          <param name="permutationCount">The number of permutations to perform.</param>
          <summary>
            Permutation Feature Importance (PFI) for Ranking
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.PermutationFeatureImportanceExtensions" Member="M:Microsoft.ML.PermutationFeatureImportanceExtensions.PermutationFeatureImportance(Microsoft.ML.RankingContext,Microsoft.ML.IPredictionTransformer{Microsoft.ML.IPredictor},Microsoft.ML.Data.IDataView,System.String,System.String,System.String,System.Boolean,System.Nullable{System.Int32},System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionContext" />
      </Targets>
      <Member MemberName="PermutationFeatureImportance">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.ML.RegressionMetricsStatistics&gt; PermutationFeatureImportance (this Microsoft.ML.RegressionContext ctx, Microsoft.ML.IPredictionTransformer&lt;Microsoft.ML.IPredictor&gt; model, Microsoft.ML.Data.IDataView data, string label = &quot;Label&quot;, string features = &quot;Features&quot;, bool useFeatureWeightFilter = false, Nullable&lt;int&gt; topExamples = null, int permutationCount = 1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.ML.RegressionMetricsStatistics&gt; PermutationFeatureImportance(class Microsoft.ML.RegressionContext ctx, class Microsoft.ML.IPredictionTransformer`1&lt;class Microsoft.ML.IPredictor&gt; model, class Microsoft.ML.Data.IDataView data, string label, string features, bool useFeatureWeightFilter, valuetype System.Nullable`1&lt;int32&gt; topExamples, int32 permutationCount) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.PermutationFeatureImportanceExtensions.PermutationFeatureImportance(Microsoft.ML.RegressionContext,Microsoft.ML.IPredictionTransformer{Microsoft.ML.IPredictor},Microsoft.ML.Data.IDataView,System.String,System.String,System.Boolean,System.Nullable{System.Int32},System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function PermutationFeatureImportance (ctx As RegressionContext, model As IPredictionTransformer(Of IPredictor), data As IDataView, Optional label As String = &quot;Label&quot;, Optional features As String = &quot;Features&quot;, Optional useFeatureWeightFilter As Boolean = false, Optional topExamples As Nullable(Of Integer) = null, Optional permutationCount As Integer = 1) As ImmutableArray(Of RegressionMetricsStatistics)" />
        <MemberSignature Language="F#" Value="static member PermutationFeatureImportance : Microsoft.ML.RegressionContext * Microsoft.ML.IPredictionTransformer&lt;Microsoft.ML.IPredictor&gt; * Microsoft.ML.Data.IDataView * string * string * bool * Nullable&lt;int&gt; * int -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.ML.RegressionMetricsStatistics&gt;" Usage="Microsoft.ML.PermutationFeatureImportanceExtensions.PermutationFeatureImportance (ctx, model, data, label, features, useFeatureWeightFilter, topExamples, permutationCount)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.ML.RegressionMetricsStatistics&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RegressionContext" RefType="this" />
          <Parameter Name="model" Type="Microsoft.ML.IPredictionTransformer&lt;Microsoft.ML.IPredictor&gt;" />
          <Parameter Name="data" Type="Microsoft.ML.Data.IDataView" />
          <Parameter Name="label" Type="System.String" />
          <Parameter Name="features" Type="System.String" />
          <Parameter Name="useFeatureWeightFilter" Type="System.Boolean" />
          <Parameter Name="topExamples" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="permutationCount" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="ctx">The regression context.</param>
          <param name="model">The model to evaluate.</param>
          <param name="data">The evaluation data set.</param>
          <param name="label">Label column name.</param>
          <param name="features">Feature column name.</param>
          <param name="useFeatureWeightFilter">Use features weight to pre-filter features.</param>
          <param name="topExamples">Limit the number of examples to evaluate on. null means examples (up to ~ 2 bln) from input will be used.</param>
          <param name="permutationCount">The number of permutations to perform.</param>
          <summary>
            Permutation Feature Importance (PFI) for Regression
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.PermutationFeatureImportanceExtensions" Member="M:Microsoft.ML.PermutationFeatureImportanceExtensions.PermutationFeatureImportance(Microsoft.ML.RegressionContext,Microsoft.ML.IPredictionTransformer{Microsoft.ML.IPredictor},Microsoft.ML.Data.IDataView,System.String,System.String,System.Boolean,System.Nullable{System.Int32},System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.ITransformer" />
      </Targets>
      <Member MemberName="CreatePredictionEngine&lt;TSrc,TDst&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.PredictionEngine&lt;TSrc,TDst&gt; CreatePredictionEngine&lt;TSrc,TDst&gt; (this Microsoft.ML.Core.Data.ITransformer transformer, Microsoft.ML.IHostEnvironment env, Microsoft.ML.Data.SchemaDefinition inputSchemaDefinition = null, Microsoft.ML.Data.SchemaDefinition outputSchemaDefinition = null) where TSrc : class where TDst : class, new();" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.PredictionEngine`2&lt;!!TSrc, !!TDst&gt; CreatePredictionEngine&lt;class TSrc, class .ctor TDst&gt;(class Microsoft.ML.Core.Data.ITransformer transformer, class Microsoft.ML.IHostEnvironment env, class Microsoft.ML.Data.SchemaDefinition inputSchemaDefinition, class Microsoft.ML.Data.SchemaDefinition outputSchemaDefinition) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.PredictionEngineExtensions.CreatePredictionEngine``2(Microsoft.ML.Core.Data.ITransformer,Microsoft.ML.IHostEnvironment,Microsoft.ML.Data.SchemaDefinition,Microsoft.ML.Data.SchemaDefinition)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreatePredictionEngine(Of TSrc As Class, TDst As Class) (transformer As ITransformer, env As IHostEnvironment, Optional inputSchemaDefinition As SchemaDefinition = null, Optional outputSchemaDefinition As SchemaDefinition = null) As PredictionEngine(Of TSrc, TDst)" />
        <MemberSignature Language="F#" Value="static member CreatePredictionEngine : Microsoft.ML.Core.Data.ITransformer * Microsoft.ML.IHostEnvironment * Microsoft.ML.Data.SchemaDefinition * Microsoft.ML.Data.SchemaDefinition -&gt; Microsoft.ML.PredictionEngine&lt;'Src, 'Dst (requires 'Src : null and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))&gt; (requires 'Src : null and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))" Usage="Microsoft.ML.PredictionEngineExtensions.CreatePredictionEngine (transformer, env, inputSchemaDefinition, outputSchemaDefinition)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.PredictionEngine&lt;TSrc,TDst&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSrc">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
          <TypeParameter Name="TDst">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="transformer" Type="Microsoft.ML.Core.Data.ITransformer" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" />
          <Parameter Name="inputSchemaDefinition" Type="Microsoft.ML.Data.SchemaDefinition" />
          <Parameter Name="outputSchemaDefinition" Type="Microsoft.ML.Data.SchemaDefinition" />
        </Parameters>
        <Docs>
          <typeparam name="TSrc">The class that defines the input data.</typeparam>
          <typeparam name="TDst">The class that defines the output data.</typeparam>
          <param name="transformer">The transformer to use for prediction.</param>
          <param name="env">The environment to use.</param>
          <param name="inputSchemaDefinition">Additional settings of the input schema.</param>
          <param name="outputSchemaDefinition">Additional settings of the output schema.</param>
          <summary>
            Create a prediction engine for one-time prediction.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.PredictionEngineExtensions" Member="M:Microsoft.ML.PredictionEngineExtensions.CreatePredictionEngine``2(Microsoft.ML.Core.Data.ITransformer,Microsoft.ML.IHostEnvironment,Microsoft.ML.Data.SchemaDefinition,Microsoft.ML.Data.SchemaDefinition)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ProjectionTransforms" />
      </Targets>
      <Member MemberName="CreateRandomFourierFeatures">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Projections.RandomFourierFeaturizingEstimator CreateRandomFourierFeatures (this Microsoft.ML.TransformsCatalog.ProjectionTransforms catalog, params Microsoft.ML.Transforms.Projections.RandomFourierFeaturizingTransformer.ColumnInfo[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Projections.RandomFourierFeaturizingEstimator CreateRandomFourierFeatures(class Microsoft.ML.TransformsCatalog/ProjectionTransforms catalog, class Microsoft.ML.Transforms.Projections.RandomFourierFeaturizingTransformer/ColumnInfo[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ProjectionCatalog.CreateRandomFourierFeatures(Microsoft.ML.TransformsCatalog.ProjectionTransforms,Microsoft.ML.Transforms.Projections.RandomFourierFeaturizingTransformer.ColumnInfo[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateRandomFourierFeatures (catalog As TransformsCatalog.ProjectionTransforms, ParamArray columns As RandomFourierFeaturizingTransformer.ColumnInfo()) As RandomFourierFeaturizingEstimator" />
        <MemberSignature Language="F#" Value="static member CreateRandomFourierFeatures : Microsoft.ML.TransformsCatalog.ProjectionTransforms * Microsoft.ML.Transforms.Projections.RandomFourierFeaturizingTransformer.ColumnInfo[] -&gt; Microsoft.ML.Transforms.Projections.RandomFourierFeaturizingEstimator" Usage="Microsoft.ML.ProjectionCatalog.CreateRandomFourierFeatures (catalog, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Projections.RandomFourierFeaturizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ProjectionTransforms" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.Transforms.Projections.RandomFourierFeaturizingTransformer+ColumnInfo[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="columns">The input columns to use for the transformation.</param>
          <summary>
            Takes columns filled with a vector of floats and maps its to a random low-dimensional feature space.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ProjectionCatalog" Member="M:Microsoft.ML.ProjectionCatalog.CreateRandomFourierFeatures(Microsoft.ML.TransformsCatalog.ProjectionTransforms,Microsoft.ML.Transforms.Projections.RandomFourierFeaturizingTransformer.ColumnInfo[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ProjectionTransforms" />
      </Targets>
      <Member MemberName="CreateRandomFourierFeatures">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Projections.RandomFourierFeaturizingEstimator CreateRandomFourierFeatures (this Microsoft.ML.TransformsCatalog.ProjectionTransforms catalog, string inputColumn, string outputColumn = null, int newDim = 1000, bool useSin = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Projections.RandomFourierFeaturizingEstimator CreateRandomFourierFeatures(class Microsoft.ML.TransformsCatalog/ProjectionTransforms catalog, string inputColumn, string outputColumn, int32 newDim, bool useSin) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ProjectionCatalog.CreateRandomFourierFeatures(Microsoft.ML.TransformsCatalog.ProjectionTransforms,System.String,System.String,System.Int32,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateRandomFourierFeatures (catalog As TransformsCatalog.ProjectionTransforms, inputColumn As String, Optional outputColumn As String = null, Optional newDim As Integer = 1000, Optional useSin As Boolean = false) As RandomFourierFeaturizingEstimator" />
        <MemberSignature Language="F#" Value="static member CreateRandomFourierFeatures : Microsoft.ML.TransformsCatalog.ProjectionTransforms * string * string * int * bool -&gt; Microsoft.ML.Transforms.Projections.RandomFourierFeaturizingEstimator" Usage="Microsoft.ML.ProjectionCatalog.CreateRandomFourierFeatures (catalog, inputColumn, outputColumn, newDim, useSin)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Projections.RandomFourierFeaturizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ProjectionTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="newDim" Type="System.Int32" />
          <Parameter Name="useSin" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="inputColumn">Name of the column to be transformed.</param>
          <param name="outputColumn">Name of the output column. If this is null '<paramref name="inputColumn" />' will be used.</param>
          <param name="newDim">The number of random Fourier features to create.</param>
          <param name="useSin">Create two features for every random Fourier frequency? (one for cos and one for sin).</param>
          <summary>
            Takes column filled with a vector of floats and maps its to a random low-dimensional feature space.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ProjectionCatalog" Member="M:Microsoft.ML.ProjectionCatalog.CreateRandomFourierFeatures(Microsoft.ML.TransformsCatalog.ProjectionTransforms,System.String,System.String,System.Int32,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ProjectionTransforms" />
      </Targets>
      <Member MemberName="GlobalContrastNormalize">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Projections.GlobalContrastNormalizingEstimator GlobalContrastNormalize (this Microsoft.ML.TransformsCatalog.ProjectionTransforms catalog, params Microsoft.ML.Transforms.Projections.LpNormalizingTransformer.GcnColumnInfo[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Projections.GlobalContrastNormalizingEstimator GlobalContrastNormalize(class Microsoft.ML.TransformsCatalog/ProjectionTransforms catalog, class Microsoft.ML.Transforms.Projections.LpNormalizingTransformer/GcnColumnInfo[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ProjectionCatalog.GlobalContrastNormalize(Microsoft.ML.TransformsCatalog.ProjectionTransforms,Microsoft.ML.Transforms.Projections.LpNormalizingTransformer.GcnColumnInfo[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GlobalContrastNormalize (catalog As TransformsCatalog.ProjectionTransforms, ParamArray columns As LpNormalizingTransformer.GcnColumnInfo()) As GlobalContrastNormalizingEstimator" />
        <MemberSignature Language="F#" Value="static member GlobalContrastNormalize : Microsoft.ML.TransformsCatalog.ProjectionTransforms * Microsoft.ML.Transforms.Projections.LpNormalizingTransformer.GcnColumnInfo[] -&gt; Microsoft.ML.Transforms.Projections.GlobalContrastNormalizingEstimator" Usage="Microsoft.ML.ProjectionCatalog.GlobalContrastNormalize (catalog, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Projections.GlobalContrastNormalizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ProjectionTransforms" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.Transforms.Projections.LpNormalizingTransformer+GcnColumnInfo[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="columns"> Describes the parameters of the gcn-normaliztion process for each column pair.</param>
          <summary>
            Takes columns filled with a vector of floats and computes global contrast normalization of it.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ProjectionCatalog" Member="M:Microsoft.ML.ProjectionCatalog.GlobalContrastNormalize(Microsoft.ML.TransformsCatalog.ProjectionTransforms,Microsoft.ML.Transforms.Projections.LpNormalizingTransformer.GcnColumnInfo[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ProjectionTransforms" />
      </Targets>
      <Member MemberName="GlobalContrastNormalize">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Projections.GlobalContrastNormalizingEstimator GlobalContrastNormalize (this Microsoft.ML.TransformsCatalog.ProjectionTransforms catalog, string inputColumn, string outputColumn = null, bool substractMean = true, bool useStdDev = false, float scale = 1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Projections.GlobalContrastNormalizingEstimator GlobalContrastNormalize(class Microsoft.ML.TransformsCatalog/ProjectionTransforms catalog, string inputColumn, string outputColumn, bool substractMean, bool useStdDev, float32 scale) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ProjectionCatalog.GlobalContrastNormalize(Microsoft.ML.TransformsCatalog.ProjectionTransforms,System.String,System.String,System.Boolean,System.Boolean,System.Single)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GlobalContrastNormalize (catalog As TransformsCatalog.ProjectionTransforms, inputColumn As String, Optional outputColumn As String = null, Optional substractMean As Boolean = true, Optional useStdDev As Boolean = false, Optional scale As Single = 1) As GlobalContrastNormalizingEstimator" />
        <MemberSignature Language="F#" Value="static member GlobalContrastNormalize : Microsoft.ML.TransformsCatalog.ProjectionTransforms * string * string * bool * bool * single -&gt; Microsoft.ML.Transforms.Projections.GlobalContrastNormalizingEstimator" Usage="Microsoft.ML.ProjectionCatalog.GlobalContrastNormalize (catalog, inputColumn, outputColumn, substractMean, useStdDev, scale)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Projections.GlobalContrastNormalizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ProjectionTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="substractMean" Type="System.Boolean" />
          <Parameter Name="useStdDev" Type="System.Boolean" />
          <Parameter Name="scale" Type="System.Single" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="inputColumn">Name of the input column.</param>
          <param name="outputColumn">Name of the column resulting from the transformation of <paramref name="inputColumn" />. Null means <paramref name="inputColumn" /> is replaced. </param>
          <param name="substractMean">Subtract mean from each value before normalizing.</param>
          <param name="useStdDev">Normalize by standard deviation rather than L2 norm.</param>
          <param name="scale">Scale features by this value.</param>
          <summary>
            Takes column filled with a vector of floats and computes global contrast normalization of it.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ProjectionCatalog" Member="M:Microsoft.ML.ProjectionCatalog.GlobalContrastNormalize(Microsoft.ML.TransformsCatalog.ProjectionTransforms,System.String,System.String,System.Boolean,System.Boolean,System.Single)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ProjectionTransforms" />
      </Targets>
      <Member MemberName="LpNormalize">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Projections.LpNormalizingEstimator LpNormalize (this Microsoft.ML.TransformsCatalog.ProjectionTransforms catalog, params Microsoft.ML.Transforms.Projections.LpNormalizingTransformer.LpNormColumnInfo[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Projections.LpNormalizingEstimator LpNormalize(class Microsoft.ML.TransformsCatalog/ProjectionTransforms catalog, class Microsoft.ML.Transforms.Projections.LpNormalizingTransformer/LpNormColumnInfo[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ProjectionCatalog.LpNormalize(Microsoft.ML.TransformsCatalog.ProjectionTransforms,Microsoft.ML.Transforms.Projections.LpNormalizingTransformer.LpNormColumnInfo[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LpNormalize (catalog As TransformsCatalog.ProjectionTransforms, ParamArray columns As LpNormalizingTransformer.LpNormColumnInfo()) As LpNormalizingEstimator" />
        <MemberSignature Language="F#" Value="static member LpNormalize : Microsoft.ML.TransformsCatalog.ProjectionTransforms * Microsoft.ML.Transforms.Projections.LpNormalizingTransformer.LpNormColumnInfo[] -&gt; Microsoft.ML.Transforms.Projections.LpNormalizingEstimator" Usage="Microsoft.ML.ProjectionCatalog.LpNormalize (catalog, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Projections.LpNormalizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ProjectionTransforms" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.Transforms.Projections.LpNormalizingTransformer+LpNormColumnInfo[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="columns"> Describes the parameters of the lp-normalization process for each column pair.</param>
          <summary>
            Takes columns filled with a vector of floats and computes L-p norm of it.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ProjectionCatalog" Member="M:Microsoft.ML.ProjectionCatalog.LpNormalize(Microsoft.ML.TransformsCatalog.ProjectionTransforms,Microsoft.ML.Transforms.Projections.LpNormalizingTransformer.LpNormColumnInfo[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.ProjectionTransforms" />
      </Targets>
      <Member MemberName="LpNormalize">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Projections.LpNormalizingEstimator LpNormalize (this Microsoft.ML.TransformsCatalog.ProjectionTransforms catalog, string inputColumn, string outputColumn = null, Microsoft.ML.Transforms.Projections.LpNormalizingEstimatorBase.NormalizerKind normKind = Microsoft.ML.Transforms.Projections.LpNormalizingEstimatorBase+NormalizerKind.L2Norm, bool subMean = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Projections.LpNormalizingEstimator LpNormalize(class Microsoft.ML.TransformsCatalog/ProjectionTransforms catalog, string inputColumn, string outputColumn, valuetype Microsoft.ML.Transforms.Projections.LpNormalizingEstimatorBase/NormalizerKind normKind, bool subMean) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.ProjectionCatalog.LpNormalize(Microsoft.ML.TransformsCatalog.ProjectionTransforms,System.String,System.String,Microsoft.ML.Transforms.Projections.LpNormalizingEstimatorBase.NormalizerKind,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LpNormalize (catalog As TransformsCatalog.ProjectionTransforms, inputColumn As String, Optional outputColumn As String = null, Optional normKind As LpNormalizingEstimatorBase.NormalizerKind = Microsoft.ML.Transforms.Projections.LpNormalizingEstimatorBase+NormalizerKind.L2Norm, Optional subMean As Boolean = false) As LpNormalizingEstimator" />
        <MemberSignature Language="F#" Value="static member LpNormalize : Microsoft.ML.TransformsCatalog.ProjectionTransforms * string * string * Microsoft.ML.Transforms.Projections.LpNormalizingEstimatorBase.NormalizerKind * bool -&gt; Microsoft.ML.Transforms.Projections.LpNormalizingEstimator" Usage="Microsoft.ML.ProjectionCatalog.LpNormalize (catalog, inputColumn, outputColumn, normKind, subMean)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Projections.LpNormalizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+ProjectionTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="normKind" Type="Microsoft.ML.Transforms.Projections.LpNormalizingEstimatorBase+NormalizerKind" />
          <Parameter Name="subMean" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="inputColumn">Name of the input column.</param>
          <param name="outputColumn">Name of the column resulting from the transformation of <paramref name="inputColumn" />. Null means <paramref name="inputColumn" /> is replaced. </param>
          <param name="normKind">Type of norm to use to normalize each sample.</param>
          <param name="subMean">Subtract mean from each value before normalizing.</param>
          <summary>
            Takes column filled with a vector of floats and computes L-p norm of it.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.ProjectionCatalog" Member="M:Microsoft.ML.ProjectionCatalog.LpNormalize(Microsoft.ML.TransformsCatalog.ProjectionTransforms,System.String,System.String,Microsoft.ML.Transforms.Projections.LpNormalizingEstimatorBase.NormalizerKind,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MLContext" />
      </Targets>
      <Member MemberName="Recommendation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.RecommendationContext Recommendation (this Microsoft.ML.MLContext ctx);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.RecommendationContext Recommendation(class Microsoft.ML.MLContext ctx) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.RecommenderCatalog.Recommendation(Microsoft.ML.MLContext)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Recommendation (ctx As MLContext) As RecommendationContext" />
        <MemberSignature Language="F#" Value="static member Recommendation : Microsoft.ML.MLContext -&gt; Microsoft.ML.RecommendationContext" Usage="Microsoft.ML.RecommenderCatalog.Recommendation ctx" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.RecommendationContext</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.MLContext" RefType="this" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <summary>
            Trainers and tasks specific to ranking problems.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.RecommenderCatalog" Member="M:Microsoft.ML.RecommenderCatalog.Recommendation(Microsoft.ML.MLContext)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="AveragedPerceptron">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.Online.AveragedPerceptronTrainer AveragedPerceptron (this Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers ctx, string labelColumn = &quot;Label&quot;, string featureColumn = &quot;Features&quot;, string weights = null, Microsoft.ML.IClassificationLoss lossFunction = null, float learningRate = 1, bool decreaseLearningRate = false, float l2RegularizerWeight = 0, int numIterations = 1, Action&lt;Microsoft.ML.Trainers.Online.AveragedPerceptronTrainer.Arguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.Online.AveragedPerceptronTrainer AveragedPerceptron(class Microsoft.ML.BinaryClassificationContext/BinaryClassificationTrainers ctx, string labelColumn, string featureColumn, string weights, class Microsoft.ML.IClassificationLoss lossFunction, float32 learningRate, bool decreaseLearningRate, float32 l2RegularizerWeight, int32 numIterations, class System.Action`1&lt;class Microsoft.ML.Trainers.Online.AveragedPerceptronTrainer/Arguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardLearnersCatalog.AveragedPerceptron(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,System.String,System.String,System.String,Microsoft.ML.IClassificationLoss,System.Single,System.Boolean,System.Single,System.Int32,System.Action{Microsoft.ML.Trainers.Online.AveragedPerceptronTrainer.Arguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AveragedPerceptron (ctx As BinaryClassificationContext.BinaryClassificationTrainers, Optional labelColumn As String = &quot;Label&quot;, Optional featureColumn As String = &quot;Features&quot;, Optional weights As String = null, Optional lossFunction As IClassificationLoss = null, Optional learningRate As Single = 1, Optional decreaseLearningRate As Boolean = false, Optional l2RegularizerWeight As Single = 0, Optional numIterations As Integer = 1, Optional advancedSettings As Action(Of AveragedPerceptronTrainer.Arguments) = null) As AveragedPerceptronTrainer" />
        <MemberSignature Language="F#" Value="static member AveragedPerceptron : Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers * string * string * string * Microsoft.ML.IClassificationLoss * single * bool * single * int * Action&lt;Microsoft.ML.Trainers.Online.AveragedPerceptronTrainer.Arguments&gt; -&gt; Microsoft.ML.Trainers.Online.AveragedPerceptronTrainer" Usage="Microsoft.ML.StandardLearnersCatalog.AveragedPerceptron (ctx, labelColumn, featureColumn, weights, lossFunction, learningRate, decreaseLearningRate, l2RegularizerWeight, numIterations, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.Online.AveragedPerceptronTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumn" Type="System.String" />
          <Parameter Name="featureColumn" Type="System.String" />
          <Parameter Name="weights" Type="System.String" />
          <Parameter Name="lossFunction" Type="Microsoft.ML.IClassificationLoss" />
          <Parameter Name="learningRate" Type="System.Single" />
          <Parameter Name="decreaseLearningRate" Type="System.Boolean" />
          <Parameter Name="l2RegularizerWeight" Type="System.Single" />
          <Parameter Name="numIterations" Type="System.Int32" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.Online.AveragedPerceptronTrainer+Arguments&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The binary classification context trainer object.</param>
          <param name="labelColumn">The name of the label column, or dependent variable.</param>
          <param name="featureColumn">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="lossFunction">The custom loss.</param>
          <param name="learningRate">The learning Rate.</param>
          <param name="decreaseLearningRate">Decrease learning rate as iterations progress.</param>
          <param name="l2RegularizerWeight">L2 regularization weight.</param>
          <param name="numIterations">Number of training iterations through the data.</param>
          <param name="advancedSettings">A delegate to supply more advanced arguments to the algorithm.</param>
          <summary>
            Predict a target using a linear binary classification model trained with the AveragedPerceptron trainer, and a custom loss.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardLearnersCatalog" Member="M:Microsoft.ML.StandardLearnersCatalog.AveragedPerceptron(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,System.String,System.String,System.String,Microsoft.ML.IClassificationLoss,System.Single,System.Boolean,System.Single,System.Int32,System.Action{Microsoft.ML.Trainers.Online.AveragedPerceptronTrainer.Arguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="LinearSupportVectorMachines">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.Online.LinearSvmTrainer LinearSupportVectorMachines (this Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers ctx, string labelColumn = &quot;Label&quot;, string featureColumn = &quot;Features&quot;, string weightsColumn = null, int numIterations = 1, Action&lt;Microsoft.ML.Trainers.Online.LinearSvmTrainer.Arguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.Online.LinearSvmTrainer LinearSupportVectorMachines(class Microsoft.ML.BinaryClassificationContext/BinaryClassificationTrainers ctx, string labelColumn, string featureColumn, string weightsColumn, int32 numIterations, class System.Action`1&lt;class Microsoft.ML.Trainers.Online.LinearSvmTrainer/Arguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardLearnersCatalog.LinearSupportVectorMachines(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,System.String,System.String,System.String,System.Int32,System.Action{Microsoft.ML.Trainers.Online.LinearSvmTrainer.Arguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LinearSupportVectorMachines (ctx As BinaryClassificationContext.BinaryClassificationTrainers, Optional labelColumn As String = &quot;Label&quot;, Optional featureColumn As String = &quot;Features&quot;, Optional weightsColumn As String = null, Optional numIterations As Integer = 1, Optional advancedSettings As Action(Of LinearSvmTrainer.Arguments) = null) As LinearSvmTrainer" />
        <MemberSignature Language="F#" Value="static member LinearSupportVectorMachines : Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers * string * string * string * int * Action&lt;Microsoft.ML.Trainers.Online.LinearSvmTrainer.Arguments&gt; -&gt; Microsoft.ML.Trainers.Online.LinearSvmTrainer" Usage="Microsoft.ML.StandardLearnersCatalog.LinearSupportVectorMachines (ctx, labelColumn, featureColumn, weightsColumn, numIterations, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.Online.LinearSvmTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumn" Type="System.String" />
          <Parameter Name="featureColumn" Type="System.String" />
          <Parameter Name="weightsColumn" Type="System.String" />
          <Parameter Name="numIterations" Type="System.Int32" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.Online.LinearSvmTrainer+Arguments&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The <see cref="T:Microsoft.ML.BinaryClassificationContext" />.</param>
          <param name="labelColumn">The name of the label column. </param>
          <param name="featureColumn">The name of the feature column.</param>
          <param name="weightsColumn">The optional name of the weights column.</param>
          <param name="numIterations">The number of training iteraitons.</param>
          <param name="advancedSettings">A delegate to supply more advanced arguments to the algorithm.</param>
          <summary>
            Predict a target using a linear binary classification model trained with the <see cref="T:Microsoft.ML.Trainers.Online.LinearSvmTrainer" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardLearnersCatalog" Member="M:Microsoft.ML.StandardLearnersCatalog.LinearSupportVectorMachines(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,System.String,System.String,System.String,System.Int32,System.Action{Microsoft.ML.Trainers.Online.LinearSvmTrainer.Arguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="LogisticRegression">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Learners.LogisticRegression LogisticRegression (this Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers ctx, string labelColumn = &quot;Label&quot;, string featureColumn = &quot;Features&quot;, string weights = null, float l1Weight = 1, float l2Weight = 1, float optimizationTolerance = 1E-07, int memorySize = 20, bool enforceNoNegativity = false, Action&lt;Microsoft.ML.Learners.LogisticRegression.Arguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Learners.LogisticRegression LogisticRegression(class Microsoft.ML.BinaryClassificationContext/BinaryClassificationTrainers ctx, string labelColumn, string featureColumn, string weights, float32 l1Weight, float32 l2Weight, float32 optimizationTolerance, int32 memorySize, bool enforceNoNegativity, class System.Action`1&lt;class Microsoft.ML.Learners.LogisticRegression/Arguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardLearnersCatalog.LogisticRegression(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,System.String,System.String,System.String,System.Single,System.Single,System.Single,System.Int32,System.Boolean,System.Action{Microsoft.ML.Learners.LogisticRegression.Arguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LogisticRegression (ctx As BinaryClassificationContext.BinaryClassificationTrainers, Optional labelColumn As String = &quot;Label&quot;, Optional featureColumn As String = &quot;Features&quot;, Optional weights As String = null, Optional l1Weight As Single = 1, Optional l2Weight As Single = 1, Optional optimizationTolerance As Single = 1E-07, Optional memorySize As Integer = 20, Optional enforceNoNegativity As Boolean = false, Optional advancedSettings As Action(Of LogisticRegression.Arguments) = null) As LogisticRegression" />
        <MemberSignature Language="F#" Value="static member LogisticRegression : Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers * string * string * string * single * single * single * int * bool * Action&lt;Microsoft.ML.Learners.LogisticRegression.Arguments&gt; -&gt; Microsoft.ML.Learners.LogisticRegression" Usage="Microsoft.ML.StandardLearnersCatalog.LogisticRegression (ctx, labelColumn, featureColumn, weights, l1Weight, l2Weight, optimizationTolerance, memorySize, enforceNoNegativity, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Learners.LogisticRegression</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumn" Type="System.String" />
          <Parameter Name="featureColumn" Type="System.String" />
          <Parameter Name="weights" Type="System.String" />
          <Parameter Name="l1Weight" Type="System.Single" />
          <Parameter Name="l2Weight" Type="System.Single" />
          <Parameter Name="optimizationTolerance" Type="System.Single" />
          <Parameter Name="memorySize" Type="System.Int32" />
          <Parameter Name="enforceNoNegativity" Type="System.Boolean" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Learners.LogisticRegression+Arguments&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The binary classificaiton context trainer object.</param>
          <param name="labelColumn">The label column name, or dependent variable.</param>
          <param name="featureColumn">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="l1Weight">Weight of L1 regularization term.</param>
          <param name="l2Weight">Weight of L2 regularization term.</param>
          <param name="optimizationTolerance">Threshold for optimizer convergence.</param>
          <param name="memorySize">Memory size for <see cref="T:Microsoft.ML.Learners.LogisticRegression" />. Low=faster, less accurate.</param>
          <param name="enforceNoNegativity">Enforce non-negative weights.</param>
          <param name="advancedSettings">A delegate to apply all the advanced arguments to the algorithm.</param>
          <summary>
             Predict a target using a linear binary classification model trained with the <see cref="T:Microsoft.ML.Learners.LogisticRegression" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardLearnersCatalog" Member="M:Microsoft.ML.StandardLearnersCatalog.LogisticRegression(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,System.String,System.String,System.String,System.Single,System.Single,System.Single,System.Int32,System.Boolean,System.Action{Microsoft.ML.Learners.LogisticRegression.Arguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="LogisticRegression">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Learners.MulticlassLogisticRegression LogisticRegression (this Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers ctx, string labelColumn = &quot;Label&quot;, string featureColumn = &quot;Features&quot;, string weights = null, float l1Weight = 1, float l2Weight = 1, float optimizationTolerance = 1E-07, int memorySize = 20, bool enforceNoNegativity = false, Action&lt;Microsoft.ML.Learners.MulticlassLogisticRegression.Arguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Learners.MulticlassLogisticRegression LogisticRegression(class Microsoft.ML.MulticlassClassificationContext/MulticlassClassificationTrainers ctx, string labelColumn, string featureColumn, string weights, float32 l1Weight, float32 l2Weight, float32 optimizationTolerance, int32 memorySize, bool enforceNoNegativity, class System.Action`1&lt;class Microsoft.ML.Learners.MulticlassLogisticRegression/Arguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardLearnersCatalog.LogisticRegression(Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers,System.String,System.String,System.String,System.Single,System.Single,System.Single,System.Int32,System.Boolean,System.Action{Microsoft.ML.Learners.MulticlassLogisticRegression.Arguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LogisticRegression (ctx As MulticlassClassificationContext.MulticlassClassificationTrainers, Optional labelColumn As String = &quot;Label&quot;, Optional featureColumn As String = &quot;Features&quot;, Optional weights As String = null, Optional l1Weight As Single = 1, Optional l2Weight As Single = 1, Optional optimizationTolerance As Single = 1E-07, Optional memorySize As Integer = 20, Optional enforceNoNegativity As Boolean = false, Optional advancedSettings As Action(Of MulticlassLogisticRegression.Arguments) = null) As MulticlassLogisticRegression" />
        <MemberSignature Language="F#" Value="static member LogisticRegression : Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers * string * string * string * single * single * single * int * bool * Action&lt;Microsoft.ML.Learners.MulticlassLogisticRegression.Arguments&gt; -&gt; Microsoft.ML.Learners.MulticlassLogisticRegression" Usage="Microsoft.ML.StandardLearnersCatalog.LogisticRegression (ctx, labelColumn, featureColumn, weights, l1Weight, l2Weight, optimizationTolerance, memorySize, enforceNoNegativity, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Learners.MulticlassLogisticRegression</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.MulticlassClassificationContext+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumn" Type="System.String" />
          <Parameter Name="featureColumn" Type="System.String" />
          <Parameter Name="weights" Type="System.String" />
          <Parameter Name="l1Weight" Type="System.Single" />
          <Parameter Name="l2Weight" Type="System.Single" />
          <Parameter Name="optimizationTolerance" Type="System.Single" />
          <Parameter Name="memorySize" Type="System.Int32" />
          <Parameter Name="enforceNoNegativity" Type="System.Boolean" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Learners.MulticlassLogisticRegression+Arguments&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The <see cref="T:Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers" />.</param>
          <param name="labelColumn">The labelColumn, or dependent variable.</param>
          <param name="featureColumn">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="l1Weight">Weight of L1 regularization term.</param>
          <param name="l2Weight">Weight of L2 regularization term.</param>
          <param name="optimizationTolerance">Threshold for optimizer convergence.</param>
          <param name="memorySize">Memory size for <see cref="T:Microsoft.ML.Learners.LogisticRegression" />. Low=faster, less accurate.</param>
          <param name="enforceNoNegativity">Enforce non-negative weights.</param>
          <param name="advancedSettings">A delegate to apply all the advanced arguments to the algorithm.</param>
          <summary>
            Predict a target using a linear multiclass classification model trained with the <see cref="T:Microsoft.ML.Learners.MulticlassLogisticRegression" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardLearnersCatalog" Member="M:Microsoft.ML.StandardLearnersCatalog.LogisticRegression(Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers,System.String,System.String,System.String,System.Single,System.Single,System.Single,System.Int32,System.Boolean,System.Action{Microsoft.ML.Learners.MulticlassLogisticRegression.Arguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="NaiveBayes">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.MultiClassNaiveBayesTrainer NaiveBayes (this Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers ctx, string labelColumn = &quot;Label&quot;, string featureColumn = &quot;Features&quot;);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.MultiClassNaiveBayesTrainer NaiveBayes(class Microsoft.ML.MulticlassClassificationContext/MulticlassClassificationTrainers ctx, string labelColumn, string featureColumn) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardLearnersCatalog.NaiveBayes(Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NaiveBayes (ctx As MulticlassClassificationContext.MulticlassClassificationTrainers, Optional labelColumn As String = &quot;Label&quot;, Optional featureColumn As String = &quot;Features&quot;) As MultiClassNaiveBayesTrainer" />
        <MemberSignature Language="F#" Value="static member NaiveBayes : Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers * string * string -&gt; Microsoft.ML.Trainers.MultiClassNaiveBayesTrainer" Usage="Microsoft.ML.StandardLearnersCatalog.NaiveBayes (ctx, labelColumn, featureColumn)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.MultiClassNaiveBayesTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.MulticlassClassificationContext+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumn" Type="System.String" />
          <Parameter Name="featureColumn" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">The <see cref="T:Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers" />.</param>
          <param name="labelColumn">The name of the label column.</param>
          <param name="featureColumn">The name of the feature column.</param>
          <summary>
            Predicts a target using a linear multiclass classification model trained with the <see cref="T:Microsoft.ML.Trainers.MultiClassNaiveBayesTrainer" />.
            The <see cref="T:Microsoft.ML.Trainers.MultiClassNaiveBayesTrainer" /> trains a multiclass Naive Bayes predictor that supports binary feature values.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardLearnersCatalog" Member="M:Microsoft.ML.StandardLearnersCatalog.NaiveBayes(Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="OneVersusAll">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.Ova OneVersusAll (this Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers ctx, Microsoft.ML.Training.ITrainerEstimator&lt;Microsoft.ML.ISingleFeaturePredictionTransformer&lt;Microsoft.ML.IPredictorProducing&lt;float&gt;&gt;,Microsoft.ML.IPredictorProducing&lt;float&gt;&gt; binaryEstimator, string labelColumn = &quot;Label&quot;, bool imputeMissingLabelsAsNegative = false, Microsoft.ML.Internal.Calibration.ICalibratorTrainer calibrator = null, int maxCalibrationExamples = 1000000000, bool useProbabilities = true);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.Ova OneVersusAll(class Microsoft.ML.MulticlassClassificationContext/MulticlassClassificationTrainers ctx, class Microsoft.ML.Training.ITrainerEstimator`2&lt;class Microsoft.ML.ISingleFeaturePredictionTransformer`1&lt;class Microsoft.ML.IPredictorProducing`1&lt;float32&gt;&gt;, class Microsoft.ML.IPredictorProducing`1&lt;float32&gt;&gt; binaryEstimator, string labelColumn, bool imputeMissingLabelsAsNegative, class Microsoft.ML.Internal.Calibration.ICalibratorTrainer calibrator, int32 maxCalibrationExamples, bool useProbabilities) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardLearnersCatalog.OneVersusAll(Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers,Microsoft.ML.Training.ITrainerEstimator{Microsoft.ML.ISingleFeaturePredictionTransformer{Microsoft.ML.IPredictorProducing{System.Single}},Microsoft.ML.IPredictorProducing{System.Single}},System.String,System.Boolean,Microsoft.ML.Internal.Calibration.ICalibratorTrainer,System.Int32,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OneVersusAll (ctx As MulticlassClassificationContext.MulticlassClassificationTrainers, binaryEstimator As ITrainerEstimator(Of ISingleFeaturePredictionTransformer(Of IPredictorProducing(Of Single)), IPredictorProducing(Of Single)), Optional labelColumn As String = &quot;Label&quot;, Optional imputeMissingLabelsAsNegative As Boolean = false, Optional calibrator As ICalibratorTrainer = null, Optional maxCalibrationExamples As Integer = 1000000000, Optional useProbabilities As Boolean = true) As Ova" />
        <MemberSignature Language="F#" Value="static member OneVersusAll : Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers * Microsoft.ML.Training.ITrainerEstimator&lt;Microsoft.ML.ISingleFeaturePredictionTransformer&lt;Microsoft.ML.IPredictorProducing&lt;single&gt;&gt;, Microsoft.ML.IPredictorProducing&lt;single&gt;&gt; * string * bool * Microsoft.ML.Internal.Calibration.ICalibratorTrainer * int * bool -&gt; Microsoft.ML.Trainers.Ova" Usage="Microsoft.ML.StandardLearnersCatalog.OneVersusAll (ctx, binaryEstimator, labelColumn, imputeMissingLabelsAsNegative, calibrator, maxCalibrationExamples, useProbabilities)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.Ova</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.MulticlassClassificationContext+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="binaryEstimator" Type="Microsoft.ML.Training.ITrainerEstimator&lt;Microsoft.ML.ISingleFeaturePredictionTransformer&lt;Microsoft.ML.IPredictorProducing&lt;System.Single&gt;&gt;,Microsoft.ML.IPredictorProducing&lt;System.Single&gt;&gt;" />
          <Parameter Name="labelColumn" Type="System.String" />
          <Parameter Name="imputeMissingLabelsAsNegative" Type="System.Boolean" />
          <Parameter Name="calibrator" Type="Microsoft.ML.Internal.Calibration.ICalibratorTrainer" />
          <Parameter Name="maxCalibrationExamples" Type="System.Int32" />
          <Parameter Name="useProbabilities" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="ctx">The <see cref="T:Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers" />.</param>
          <param name="binaryEstimator">An instance of a binary <see cref="T:Microsoft.ML.Training.ITrainerEstimator`2" /> used as the base trainer.</param>
          <param name="labelColumn">The name of the label colum.</param>
          <param name="imputeMissingLabelsAsNegative">Whether to treat missing labels as having negative labels, instead of keeping them missing.</param>
          <param name="calibrator">The calibrator. If a calibrator is not explicitely provided, it will default to <see cref="T:Microsoft.ML.Internal.Calibration.PlattCalibratorTrainer" /></param>
          <param name="maxCalibrationExamples">Number of instances to train the calibrator.</param>
          <param name="useProbabilities">Use probabilities (vs. raw outputs) to identify top-score category.</param>
          <summary>
            Predicts a target using a linear multiclass classification model trained with the <see cref="T:Microsoft.ML.Trainers.Ova" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardLearnersCatalog" Member="M:Microsoft.ML.StandardLearnersCatalog.OneVersusAll(Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers,Microsoft.ML.Training.ITrainerEstimator{Microsoft.ML.ISingleFeaturePredictionTransformer{Microsoft.ML.IPredictorProducing{System.Single}},Microsoft.ML.IPredictorProducing{System.Single}},System.String,System.Boolean,Microsoft.ML.Internal.Calibration.ICalibratorTrainer,System.Int32,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionContext.RegressionTrainers" />
      </Targets>
      <Member MemberName="OnlineGradientDescent">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.Online.OnlineGradientDescentTrainer OnlineGradientDescent (this Microsoft.ML.RegressionContext.RegressionTrainers ctx, string labelColumn = &quot;Label&quot;, string featureColumn = &quot;Features&quot;, string weights = null, Microsoft.ML.IRegressionLoss lossFunction = null, float learningRate = 0.1, bool decreaseLearningRate = true, float l2RegularizerWeight = 0, int numIterations = 1, Action&lt;Microsoft.ML.Trainers.Online.AveragedLinearArguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.Online.OnlineGradientDescentTrainer OnlineGradientDescent(class Microsoft.ML.RegressionContext/RegressionTrainers ctx, string labelColumn, string featureColumn, string weights, class Microsoft.ML.IRegressionLoss lossFunction, float32 learningRate, bool decreaseLearningRate, float32 l2RegularizerWeight, int32 numIterations, class System.Action`1&lt;class Microsoft.ML.Trainers.Online.AveragedLinearArguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardLearnersCatalog.OnlineGradientDescent(Microsoft.ML.RegressionContext.RegressionTrainers,System.String,System.String,System.String,Microsoft.ML.IRegressionLoss,System.Single,System.Boolean,System.Single,System.Int32,System.Action{Microsoft.ML.Trainers.Online.AveragedLinearArguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OnlineGradientDescent (ctx As RegressionContext.RegressionTrainers, Optional labelColumn As String = &quot;Label&quot;, Optional featureColumn As String = &quot;Features&quot;, Optional weights As String = null, Optional lossFunction As IRegressionLoss = null, Optional learningRate As Single = 0.1, Optional decreaseLearningRate As Boolean = true, Optional l2RegularizerWeight As Single = 0, Optional numIterations As Integer = 1, Optional advancedSettings As Action(Of AveragedLinearArguments) = null) As OnlineGradientDescentTrainer" />
        <MemberSignature Language="F#" Value="static member OnlineGradientDescent : Microsoft.ML.RegressionContext.RegressionTrainers * string * string * string * Microsoft.ML.IRegressionLoss * single * bool * single * int * Action&lt;Microsoft.ML.Trainers.Online.AveragedLinearArguments&gt; -&gt; Microsoft.ML.Trainers.Online.OnlineGradientDescentTrainer" Usage="Microsoft.ML.StandardLearnersCatalog.OnlineGradientDescent (ctx, labelColumn, featureColumn, weights, lossFunction, learningRate, decreaseLearningRate, l2RegularizerWeight, numIterations, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.Online.OnlineGradientDescentTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RegressionContext+RegressionTrainers" RefType="this" />
          <Parameter Name="labelColumn" Type="System.String" />
          <Parameter Name="featureColumn" Type="System.String" />
          <Parameter Name="weights" Type="System.String" />
          <Parameter Name="lossFunction" Type="Microsoft.ML.IRegressionLoss" />
          <Parameter Name="learningRate" Type="System.Single" />
          <Parameter Name="decreaseLearningRate" Type="System.Boolean" />
          <Parameter Name="l2RegularizerWeight" Type="System.Single" />
          <Parameter Name="numIterations" Type="System.Int32" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.Online.AveragedLinearArguments&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The regression context trainer object.</param>
          <param name="labelColumn">The name of the label, or dependent variable.</param>
          <param name="featureColumn">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="lossFunction">The custom loss. Defaults to <see cref="T:Microsoft.ML.SquaredLoss" /> if not provided.</param>
          <param name="learningRate">The learning Rate.</param>
          <param name="decreaseLearningRate">Decrease learning rate as iterations progress.</param>
          <param name="l2RegularizerWeight">L2 regularization weight.</param>
          <param name="numIterations">Number of training iterations through the data.</param>
          <param name="advancedSettings">A delegate to supply more advanced arguments to the algorithm.</param>
          <summary>
            Predict a target using a linear regression model trained with the <see cref="T:Microsoft.ML.Trainers.Online.OnlineGradientDescentTrainer" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardLearnersCatalog" Member="M:Microsoft.ML.StandardLearnersCatalog.OnlineGradientDescent(Microsoft.ML.RegressionContext.RegressionTrainers,System.String,System.String,System.String,Microsoft.ML.IRegressionLoss,System.Single,System.Boolean,System.Single,System.Int32,System.Action{Microsoft.ML.Trainers.Online.AveragedLinearArguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="PairwiseCoupling">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.Pkpd PairwiseCoupling (this Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers ctx, Microsoft.ML.Training.ITrainerEstimator&lt;Microsoft.ML.ISingleFeaturePredictionTransformer&lt;Microsoft.ML.IPredictorProducing&lt;float&gt;&gt;,Microsoft.ML.IPredictorProducing&lt;float&gt;&gt; binaryEstimator, string labelColumn = &quot;Label&quot;, bool imputeMissingLabelsAsNegative = false, Microsoft.ML.Internal.Calibration.ICalibratorTrainer calibrator = null, int maxCalibrationExamples = 1000000000);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.Pkpd PairwiseCoupling(class Microsoft.ML.MulticlassClassificationContext/MulticlassClassificationTrainers ctx, class Microsoft.ML.Training.ITrainerEstimator`2&lt;class Microsoft.ML.ISingleFeaturePredictionTransformer`1&lt;class Microsoft.ML.IPredictorProducing`1&lt;float32&gt;&gt;, class Microsoft.ML.IPredictorProducing`1&lt;float32&gt;&gt; binaryEstimator, string labelColumn, bool imputeMissingLabelsAsNegative, class Microsoft.ML.Internal.Calibration.ICalibratorTrainer calibrator, int32 maxCalibrationExamples) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardLearnersCatalog.PairwiseCoupling(Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers,Microsoft.ML.Training.ITrainerEstimator{Microsoft.ML.ISingleFeaturePredictionTransformer{Microsoft.ML.IPredictorProducing{System.Single}},Microsoft.ML.IPredictorProducing{System.Single}},System.String,System.Boolean,Microsoft.ML.Internal.Calibration.ICalibratorTrainer,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function PairwiseCoupling (ctx As MulticlassClassificationContext.MulticlassClassificationTrainers, binaryEstimator As ITrainerEstimator(Of ISingleFeaturePredictionTransformer(Of IPredictorProducing(Of Single)), IPredictorProducing(Of Single)), Optional labelColumn As String = &quot;Label&quot;, Optional imputeMissingLabelsAsNegative As Boolean = false, Optional calibrator As ICalibratorTrainer = null, Optional maxCalibrationExamples As Integer = 1000000000) As Pkpd" />
        <MemberSignature Language="F#" Value="static member PairwiseCoupling : Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers * Microsoft.ML.Training.ITrainerEstimator&lt;Microsoft.ML.ISingleFeaturePredictionTransformer&lt;Microsoft.ML.IPredictorProducing&lt;single&gt;&gt;, Microsoft.ML.IPredictorProducing&lt;single&gt;&gt; * string * bool * Microsoft.ML.Internal.Calibration.ICalibratorTrainer * int -&gt; Microsoft.ML.Trainers.Pkpd" Usage="Microsoft.ML.StandardLearnersCatalog.PairwiseCoupling (ctx, binaryEstimator, labelColumn, imputeMissingLabelsAsNegative, calibrator, maxCalibrationExamples)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.Pkpd</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.MulticlassClassificationContext+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="binaryEstimator" Type="Microsoft.ML.Training.ITrainerEstimator&lt;Microsoft.ML.ISingleFeaturePredictionTransformer&lt;Microsoft.ML.IPredictorProducing&lt;System.Single&gt;&gt;,Microsoft.ML.IPredictorProducing&lt;System.Single&gt;&gt;" />
          <Parameter Name="labelColumn" Type="System.String" />
          <Parameter Name="imputeMissingLabelsAsNegative" Type="System.Boolean" />
          <Parameter Name="calibrator" Type="Microsoft.ML.Internal.Calibration.ICalibratorTrainer" />
          <Parameter Name="maxCalibrationExamples" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="ctx">The <see cref="T:Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers" />.</param>
          <param name="binaryEstimator">An instance of a binary <see cref="T:Microsoft.ML.Training.ITrainerEstimator`2" /> used as the base trainer.</param>
          <param name="labelColumn">The name of the label colum.</param>
          <param name="imputeMissingLabelsAsNegative">Whether to treat missing labels as having negative labels, instead of keeping them missing.</param>
          <param name="calibrator">The calibrator. If a calibrator is not explicitely provided, it will default to <see cref="T:Microsoft.ML.Internal.Calibration.PlattCalibratorTrainer" /></param>
          <param name="maxCalibrationExamples">Number of instances to train the calibrator.</param>
          <summary>
            Predicts a target using a linear multiclass classification model trained with the <see cref="T:Microsoft.ML.Trainers.Pkpd" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardLearnersCatalog" Member="M:Microsoft.ML.StandardLearnersCatalog.PairwiseCoupling(Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers,Microsoft.ML.Training.ITrainerEstimator{Microsoft.ML.ISingleFeaturePredictionTransformer{Microsoft.ML.IPredictorProducing{System.Single}},Microsoft.ML.IPredictorProducing{System.Single}},System.String,System.Boolean,Microsoft.ML.Internal.Calibration.ICalibratorTrainer,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionContext.RegressionTrainers" />
      </Targets>
      <Member MemberName="PoissonRegression">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.PoissonRegression PoissonRegression (this Microsoft.ML.RegressionContext.RegressionTrainers ctx, string labelColumn = &quot;Label&quot;, string featureColumn = &quot;Features&quot;, string weights = null, float l1Weight = 1, float l2Weight = 1, float optimizationTolerance = 1E-07, int memorySize = 20, bool enforceNoNegativity = false, Action&lt;Microsoft.ML.Trainers.PoissonRegression.Arguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.PoissonRegression PoissonRegression(class Microsoft.ML.RegressionContext/RegressionTrainers ctx, string labelColumn, string featureColumn, string weights, float32 l1Weight, float32 l2Weight, float32 optimizationTolerance, int32 memorySize, bool enforceNoNegativity, class System.Action`1&lt;class Microsoft.ML.Trainers.PoissonRegression/Arguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardLearnersCatalog.PoissonRegression(Microsoft.ML.RegressionContext.RegressionTrainers,System.String,System.String,System.String,System.Single,System.Single,System.Single,System.Int32,System.Boolean,System.Action{Microsoft.ML.Trainers.PoissonRegression.Arguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function PoissonRegression (ctx As RegressionContext.RegressionTrainers, Optional labelColumn As String = &quot;Label&quot;, Optional featureColumn As String = &quot;Features&quot;, Optional weights As String = null, Optional l1Weight As Single = 1, Optional l2Weight As Single = 1, Optional optimizationTolerance As Single = 1E-07, Optional memorySize As Integer = 20, Optional enforceNoNegativity As Boolean = false, Optional advancedSettings As Action(Of PoissonRegression.Arguments) = null) As PoissonRegression" />
        <MemberSignature Language="F#" Value="static member PoissonRegression : Microsoft.ML.RegressionContext.RegressionTrainers * string * string * string * single * single * single * int * bool * Action&lt;Microsoft.ML.Trainers.PoissonRegression.Arguments&gt; -&gt; Microsoft.ML.Trainers.PoissonRegression" Usage="Microsoft.ML.StandardLearnersCatalog.PoissonRegression (ctx, labelColumn, featureColumn, weights, l1Weight, l2Weight, optimizationTolerance, memorySize, enforceNoNegativity, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.PoissonRegression</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RegressionContext+RegressionTrainers" RefType="this" />
          <Parameter Name="labelColumn" Type="System.String" />
          <Parameter Name="featureColumn" Type="System.String" />
          <Parameter Name="weights" Type="System.String" />
          <Parameter Name="l1Weight" Type="System.Single" />
          <Parameter Name="l2Weight" Type="System.Single" />
          <Parameter Name="optimizationTolerance" Type="System.Single" />
          <Parameter Name="memorySize" Type="System.Int32" />
          <Parameter Name="enforceNoNegativity" Type="System.Boolean" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.PoissonRegression+Arguments&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The regression context trainer object.</param>
          <param name="labelColumn">The labelColumn, or dependent variable.</param>
          <param name="featureColumn">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="l1Weight">Weight of L1 regularization term.</param>
          <param name="l2Weight">Weight of L2 regularization term.</param>
          <param name="optimizationTolerance">Threshold for optimizer convergence.</param>
          <param name="memorySize">Memory size for <see cref="T:Microsoft.ML.Learners.LogisticRegression" />. Low=faster, less accurate.</param>
          <param name="enforceNoNegativity">Enforce non-negative weights.</param>
          <param name="advancedSettings">A delegate to apply all the advanced arguments to the algorithm.</param>
          <summary>
            Predict a target using a linear regression model trained with the <see cref="T:Microsoft.ML.Learners.LogisticRegression" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardLearnersCatalog" Member="M:Microsoft.ML.StandardLearnersCatalog.PoissonRegression(Microsoft.ML.RegressionContext.RegressionTrainers,System.String,System.String,System.String,System.Single,System.Single,System.Single,System.Int32,System.Boolean,System.Action{Microsoft.ML.Trainers.PoissonRegression.Arguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="StochasticDualCoordinateAscent">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.SdcaBinaryTrainer StochasticDualCoordinateAscent (this Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers ctx, string labelColumn = &quot;Label&quot;, string featureColumn = &quot;Features&quot;, string weights = null, Microsoft.ML.ISupportSdcaClassificationLoss loss = null, Nullable&lt;float&gt; l2Const = null, Nullable&lt;float&gt; l1Threshold = null, Nullable&lt;int&gt; maxIterations = null, Action&lt;Microsoft.ML.Trainers.SdcaBinaryTrainer.Arguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.SdcaBinaryTrainer StochasticDualCoordinateAscent(class Microsoft.ML.BinaryClassificationContext/BinaryClassificationTrainers ctx, string labelColumn, string featureColumn, string weights, class Microsoft.ML.ISupportSdcaClassificationLoss loss, valuetype System.Nullable`1&lt;float32&gt; l2Const, valuetype System.Nullable`1&lt;float32&gt; l1Threshold, valuetype System.Nullable`1&lt;int32&gt; maxIterations, class System.Action`1&lt;class Microsoft.ML.Trainers.SdcaBinaryTrainer/Arguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardLearnersCatalog.StochasticDualCoordinateAscent(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,System.String,System.String,System.String,Microsoft.ML.ISupportSdcaClassificationLoss,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Trainers.SdcaBinaryTrainer.Arguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function StochasticDualCoordinateAscent (ctx As BinaryClassificationContext.BinaryClassificationTrainers, Optional labelColumn As String = &quot;Label&quot;, Optional featureColumn As String = &quot;Features&quot;, Optional weights As String = null, Optional loss As ISupportSdcaClassificationLoss = null, Optional l2Const As Nullable(Of Single) = null, Optional l1Threshold As Nullable(Of Single) = null, Optional maxIterations As Nullable(Of Integer) = null, Optional advancedSettings As Action(Of SdcaBinaryTrainer.Arguments) = null) As SdcaBinaryTrainer" />
        <MemberSignature Language="F#" Value="static member StochasticDualCoordinateAscent : Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers * string * string * string * Microsoft.ML.ISupportSdcaClassificationLoss * Nullable&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;int&gt; * Action&lt;Microsoft.ML.Trainers.SdcaBinaryTrainer.Arguments&gt; -&gt; Microsoft.ML.Trainers.SdcaBinaryTrainer" Usage="Microsoft.ML.StandardLearnersCatalog.StochasticDualCoordinateAscent (ctx, labelColumn, featureColumn, weights, loss, l2Const, l1Threshold, maxIterations, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.SdcaBinaryTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumn" Type="System.String" />
          <Parameter Name="featureColumn" Type="System.String" />
          <Parameter Name="weights" Type="System.String" />
          <Parameter Name="loss" Type="Microsoft.ML.ISupportSdcaClassificationLoss" />
          <Parameter Name="l2Const" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="l1Threshold" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="maxIterations" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.SdcaBinaryTrainer+Arguments&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The binary classification context trainer object.</param>
          <param name="labelColumn">The labelColumn, or dependent variable.</param>
          <param name="featureColumn">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="loss">The custom loss. Defaults to log-loss if not specified.</param>
          <param name="l2Const">The L2 regularization hyperparameter.</param>
          <param name="l1Threshold">The L1 regularization hyperparameter. Higher values will tend to lead to more sparse model.</param>
          <param name="maxIterations">The maximum number of passes to perform over the data.</param>
          <param name="advancedSettings">A delegate to set more settings.
            The settings here will override the ones provided in the direct method signature,
            if both are present and have different values.
            The columns names, however need to be provided directly, not through the <paramref name="advancedSettings" />.</param>
          <summary>
            Predict a target using a linear binary classification model trained with the SDCA trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardLearnersCatalog" Member="M:Microsoft.ML.StandardLearnersCatalog.StochasticDualCoordinateAscent(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,System.String,System.String,System.String,Microsoft.ML.ISupportSdcaClassificationLoss,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Trainers.SdcaBinaryTrainer.Arguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="StochasticDualCoordinateAscent">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.SdcaMultiClassTrainer StochasticDualCoordinateAscent (this Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers ctx, string labelColumn = &quot;Label&quot;, string featureColumn = &quot;Features&quot;, string weights = null, Microsoft.ML.ISupportSdcaClassificationLoss loss = null, Nullable&lt;float&gt; l2Const = null, Nullable&lt;float&gt; l1Threshold = null, Nullable&lt;int&gt; maxIterations = null, Action&lt;Microsoft.ML.Trainers.SdcaMultiClassTrainer.Arguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.SdcaMultiClassTrainer StochasticDualCoordinateAscent(class Microsoft.ML.MulticlassClassificationContext/MulticlassClassificationTrainers ctx, string labelColumn, string featureColumn, string weights, class Microsoft.ML.ISupportSdcaClassificationLoss loss, valuetype System.Nullable`1&lt;float32&gt; l2Const, valuetype System.Nullable`1&lt;float32&gt; l1Threshold, valuetype System.Nullable`1&lt;int32&gt; maxIterations, class System.Action`1&lt;class Microsoft.ML.Trainers.SdcaMultiClassTrainer/Arguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardLearnersCatalog.StochasticDualCoordinateAscent(Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers,System.String,System.String,System.String,Microsoft.ML.ISupportSdcaClassificationLoss,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Trainers.SdcaMultiClassTrainer.Arguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function StochasticDualCoordinateAscent (ctx As MulticlassClassificationContext.MulticlassClassificationTrainers, Optional labelColumn As String = &quot;Label&quot;, Optional featureColumn As String = &quot;Features&quot;, Optional weights As String = null, Optional loss As ISupportSdcaClassificationLoss = null, Optional l2Const As Nullable(Of Single) = null, Optional l1Threshold As Nullable(Of Single) = null, Optional maxIterations As Nullable(Of Integer) = null, Optional advancedSettings As Action(Of SdcaMultiClassTrainer.Arguments) = null) As SdcaMultiClassTrainer" />
        <MemberSignature Language="F#" Value="static member StochasticDualCoordinateAscent : Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers * string * string * string * Microsoft.ML.ISupportSdcaClassificationLoss * Nullable&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;int&gt; * Action&lt;Microsoft.ML.Trainers.SdcaMultiClassTrainer.Arguments&gt; -&gt; Microsoft.ML.Trainers.SdcaMultiClassTrainer" Usage="Microsoft.ML.StandardLearnersCatalog.StochasticDualCoordinateAscent (ctx, labelColumn, featureColumn, weights, loss, l2Const, l1Threshold, maxIterations, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.SdcaMultiClassTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.MulticlassClassificationContext+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumn" Type="System.String" />
          <Parameter Name="featureColumn" Type="System.String" />
          <Parameter Name="weights" Type="System.String" />
          <Parameter Name="loss" Type="Microsoft.ML.ISupportSdcaClassificationLoss" />
          <Parameter Name="l2Const" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="l1Threshold" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="maxIterations" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.SdcaMultiClassTrainer+Arguments&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The multiclass classification context trainer object.</param>
          <param name="labelColumn">The labelColumn, or dependent variable.</param>
          <param name="featureColumn">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="loss">The optional custom loss.</param>
          <param name="l2Const">The L2 regularization hyperparameter.</param>
          <param name="l1Threshold">The L1 regularization hyperparameter. Higher values will tend to lead to more sparse model.</param>
          <param name="maxIterations">The maximum number of passes to perform over the data.</param>
          <param name="advancedSettings">A delegate to set more settings.
            The settings here will override the ones provided in the direct method signature,
            if both are present and have different values.
            The columns names, however need to be provided directly, not through the <paramref name="advancedSettings" />.</param>
          <summary>
            Predict a target using a linear multiclass classification model trained with the SDCA trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardLearnersCatalog" Member="M:Microsoft.ML.StandardLearnersCatalog.StochasticDualCoordinateAscent(Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers,System.String,System.String,System.String,Microsoft.ML.ISupportSdcaClassificationLoss,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Trainers.SdcaMultiClassTrainer.Arguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionContext.RegressionTrainers" />
      </Targets>
      <Member MemberName="StochasticDualCoordinateAscent">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.SdcaRegressionTrainer StochasticDualCoordinateAscent (this Microsoft.ML.RegressionContext.RegressionTrainers ctx, string labelColumn = &quot;Label&quot;, string featureColumn = &quot;Features&quot;, string weights = null, Microsoft.ML.ISupportSdcaRegressionLoss loss = null, Nullable&lt;float&gt; l2Const = null, Nullable&lt;float&gt; l1Threshold = null, Nullable&lt;int&gt; maxIterations = null, Action&lt;Microsoft.ML.Trainers.SdcaRegressionTrainer.Arguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.SdcaRegressionTrainer StochasticDualCoordinateAscent(class Microsoft.ML.RegressionContext/RegressionTrainers ctx, string labelColumn, string featureColumn, string weights, class Microsoft.ML.ISupportSdcaRegressionLoss loss, valuetype System.Nullable`1&lt;float32&gt; l2Const, valuetype System.Nullable`1&lt;float32&gt; l1Threshold, valuetype System.Nullable`1&lt;int32&gt; maxIterations, class System.Action`1&lt;class Microsoft.ML.Trainers.SdcaRegressionTrainer/Arguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardLearnersCatalog.StochasticDualCoordinateAscent(Microsoft.ML.RegressionContext.RegressionTrainers,System.String,System.String,System.String,Microsoft.ML.ISupportSdcaRegressionLoss,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Trainers.SdcaRegressionTrainer.Arguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function StochasticDualCoordinateAscent (ctx As RegressionContext.RegressionTrainers, Optional labelColumn As String = &quot;Label&quot;, Optional featureColumn As String = &quot;Features&quot;, Optional weights As String = null, Optional loss As ISupportSdcaRegressionLoss = null, Optional l2Const As Nullable(Of Single) = null, Optional l1Threshold As Nullable(Of Single) = null, Optional maxIterations As Nullable(Of Integer) = null, Optional advancedSettings As Action(Of SdcaRegressionTrainer.Arguments) = null) As SdcaRegressionTrainer" />
        <MemberSignature Language="F#" Value="static member StochasticDualCoordinateAscent : Microsoft.ML.RegressionContext.RegressionTrainers * string * string * string * Microsoft.ML.ISupportSdcaRegressionLoss * Nullable&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;int&gt; * Action&lt;Microsoft.ML.Trainers.SdcaRegressionTrainer.Arguments&gt; -&gt; Microsoft.ML.Trainers.SdcaRegressionTrainer" Usage="Microsoft.ML.StandardLearnersCatalog.StochasticDualCoordinateAscent (ctx, labelColumn, featureColumn, weights, loss, l2Const, l1Threshold, maxIterations, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.SdcaRegressionTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RegressionContext+RegressionTrainers" RefType="this" />
          <Parameter Name="labelColumn" Type="System.String" />
          <Parameter Name="featureColumn" Type="System.String" />
          <Parameter Name="weights" Type="System.String" />
          <Parameter Name="loss" Type="Microsoft.ML.ISupportSdcaRegressionLoss" />
          <Parameter Name="l2Const" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="l1Threshold" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="maxIterations" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.SdcaRegressionTrainer+Arguments&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The regression context trainer object.</param>
          <param name="labelColumn">The label column, or dependent variable.</param>
          <param name="featureColumn">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="loss">The custom loss, if unspecified will be <see cref="T:Microsoft.ML.SquaredLoss" />.</param>
          <param name="l2Const">The L2 regularization hyperparameter.</param>
          <param name="l1Threshold">The L1 regularization hyperparameter. Higher values will tend to lead to more sparse model.</param>
          <param name="maxIterations">The maximum number of passes to perform over the data.</param>
          <param name="advancedSettings">A delegate to set more settings.
            The settings here will override the ones provided in the direct method signature,
            if both are present and have different values.
            The columns names, however need to be provided directly, not through the <paramref name="advancedSettings" />.</param>
          <summary>
            Predict a target using a linear regression model trained with the SDCA trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardLearnersCatalog" Member="M:Microsoft.ML.StandardLearnersCatalog.StochasticDualCoordinateAscent(Microsoft.ML.RegressionContext.RegressionTrainers,System.String,System.String,System.String,Microsoft.ML.ISupportSdcaRegressionLoss,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Trainers.SdcaRegressionTrainer.Arguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="StochasticGradientDescent">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.StochasticGradientDescentClassificationTrainer StochasticGradientDescent (this Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers ctx, string labelColumn = &quot;Label&quot;, string featureColumn = &quot;Features&quot;, string weights = null, int maxIterations = 20, double initLearningRate = 0.01, float l2Weight = 1E-06, Microsoft.ML.ISupportClassificationLossFactory loss = null, Action&lt;Microsoft.ML.Trainers.StochasticGradientDescentClassificationTrainer.Arguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.StochasticGradientDescentClassificationTrainer StochasticGradientDescent(class Microsoft.ML.BinaryClassificationContext/BinaryClassificationTrainers ctx, string labelColumn, string featureColumn, string weights, int32 maxIterations, float64 initLearningRate, float32 l2Weight, class Microsoft.ML.ISupportClassificationLossFactory loss, class System.Action`1&lt;class Microsoft.ML.Trainers.StochasticGradientDescentClassificationTrainer/Arguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StandardLearnersCatalog.StochasticGradientDescent(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,System.String,System.String,System.String,System.Int32,System.Double,System.Single,Microsoft.ML.ISupportClassificationLossFactory,System.Action{Microsoft.ML.Trainers.StochasticGradientDescentClassificationTrainer.Arguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function StochasticGradientDescent (ctx As BinaryClassificationContext.BinaryClassificationTrainers, Optional labelColumn As String = &quot;Label&quot;, Optional featureColumn As String = &quot;Features&quot;, Optional weights As String = null, Optional maxIterations As Integer = 20, Optional initLearningRate As Double = 0.01, Optional l2Weight As Single = 1E-06, Optional loss As ISupportClassificationLossFactory = null, Optional advancedSettings As Action(Of StochasticGradientDescentClassificationTrainer.Arguments) = null) As StochasticGradientDescentClassificationTrainer" />
        <MemberSignature Language="F#" Value="static member StochasticGradientDescent : Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers * string * string * string * int * double * single * Microsoft.ML.ISupportClassificationLossFactory * Action&lt;Microsoft.ML.Trainers.StochasticGradientDescentClassificationTrainer.Arguments&gt; -&gt; Microsoft.ML.Trainers.StochasticGradientDescentClassificationTrainer" Usage="Microsoft.ML.StandardLearnersCatalog.StochasticGradientDescent (ctx, labelColumn, featureColumn, weights, maxIterations, initLearningRate, l2Weight, loss, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.StochasticGradientDescentClassificationTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumn" Type="System.String" />
          <Parameter Name="featureColumn" Type="System.String" />
          <Parameter Name="weights" Type="System.String" />
          <Parameter Name="maxIterations" Type="System.Int32" />
          <Parameter Name="initLearningRate" Type="System.Double" />
          <Parameter Name="l2Weight" Type="System.Single" />
          <Parameter Name="loss" Type="Microsoft.ML.ISupportClassificationLossFactory" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.StochasticGradientDescentClassificationTrainer+Arguments&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The binary classificaiton context trainer object.</param>
          <param name="labelColumn">The name of the label column.</param>
          <param name="featureColumn">The name of the feature column.</param>
          <param name="weights">The name for the example weight column.</param>
          <param name="maxIterations">The maximum number of iterations; set to 1 to simulate online learning.</param>
          <param name="initLearningRate">The initial learning rate used by SGD.</param>
          <param name="l2Weight">The L2 regularization constant.</param>
          <param name="loss">The loss function to use.</param>
          <param name="advancedSettings">A delegate to apply all the advanced arguments to the algorithm.</param>
          <summary>
             Predict a target using a linear binary classification model trained with the <see cref="T:Microsoft.ML.Trainers.StochasticGradientDescentClassificationTrainer" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StandardLearnersCatalog" Member="M:Microsoft.ML.StandardLearnersCatalog.StochasticGradientDescent(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,System.String,System.String,System.String,System.Int32,System.Double,System.Single,Microsoft.ML.ISupportClassificationLossFactory,System.Action{Microsoft.ML.Trainers.StochasticGradientDescentClassificationTrainer.Arguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="AveragedPerceptron">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; AveragedPerceptron (this Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers ctx, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, Microsoft.ML.IClassificationLoss lossFunction = null, float learningRate = 1, bool decreaseLearningRate = false, float l2RegularizerWeight = 0, int numIterations = 1, Action&lt;Microsoft.ML.Trainers.Online.AveragedPerceptronTrainer.Arguments&gt; advancedSettings = null, Action&lt;Microsoft.ML.Learners.LinearBinaryModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; AveragedPerceptron(class Microsoft.ML.BinaryClassificationContext/BinaryClassificationTrainers ctx, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, class Microsoft.ML.IClassificationLoss lossFunction, float32 learningRate, bool decreaseLearningRate, float32 l2RegularizerWeight, int32 numIterations, class System.Action`1&lt;class Microsoft.ML.Trainers.Online.AveragedPerceptronTrainer/Arguments&gt; advancedSettings, class System.Action`1&lt;class Microsoft.ML.Learners.LinearBinaryModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.AveragedPerceptronStaticExtensions.AveragedPerceptron(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.IClassificationLoss,System.Single,System.Boolean,System.Single,System.Int32,System.Action{Microsoft.ML.Trainers.Online.AveragedPerceptronTrainer.Arguments},System.Action{Microsoft.ML.Learners.LinearBinaryModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AveragedPerceptron (ctx As BinaryClassificationContext.BinaryClassificationTrainers, label As Scalar(Of Boolean), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional lossFunction As IClassificationLoss = null, Optional learningRate As Single = 1, Optional decreaseLearningRate As Boolean = false, Optional l2RegularizerWeight As Single = 0, Optional numIterations As Integer = 1, Optional advancedSettings As Action(Of AveragedPerceptronTrainer.Arguments) = null, Optional onFit As Action(Of LinearBinaryModelParameters) = null) As ValueTuple(Of Scalar(Of Single), Scalar(Of Boolean))" />
        <MemberSignature Language="F#" Value="static member AveragedPerceptron : Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.IClassificationLoss * single * bool * single * int * Action&lt;Microsoft.ML.Trainers.Online.AveragedPerceptronTrainer.Arguments&gt; * Action&lt;Microsoft.ML.Learners.LinearBinaryModelParameters&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.AveragedPerceptronStaticExtensions.AveragedPerceptron (ctx, label, features, weights, lossFunction, learningRate, decreaseLearningRate, l2RegularizerWeight, numIterations, advancedSettings, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="lossFunction" Type="Microsoft.ML.IClassificationLoss" />
          <Parameter Name="learningRate" Type="System.Single" />
          <Parameter Name="decreaseLearningRate" Type="System.Boolean" />
          <Parameter Name="l2RegularizerWeight" Type="System.Single" />
          <Parameter Name="numIterations" Type="System.Int32" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.Online.AveragedPerceptronTrainer+Arguments&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Learners.LinearBinaryModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The binary classification context trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="lossFunction">The custom loss.</param>
          <param name="learningRate">The learning Rate.</param>
          <param name="decreaseLearningRate">Decrease learning rate as iterations progress.</param>
          <param name="l2RegularizerWeight">L2 regularization weight.</param>
          <param name="numIterations">Number of training iterations through the data.</param>
          <param name="advancedSettings">A delegate to supply more avdanced arguments to the algorithm.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained, as well as the calibrator on top of that model. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear binary classification model trained with the AveragedPerceptron trainer, and a custom loss.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.AveragedPerceptronStaticExtensions" Member="M:Microsoft.ML.StaticPipe.AveragedPerceptronStaticExtensions.AveragedPerceptron(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.IClassificationLoss,System.Single,System.Boolean,System.Single,System.Int32,System.Action{Microsoft.ML.Trainers.Online.AveragedPerceptronTrainer.Arguments},System.Action{Microsoft.ML.Learners.LinearBinaryModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="OneHotHashEncoding">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; OneHotHashEncoding (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashScalarOutputKind outputKind = (Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions+OneHotHashScalarOutputKind) 1, int hashBits = 16, uint seed = 314489979, bool ordered = true, int invertHash = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; OneHotHashEncoding(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, valuetype Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions/OneHotHashScalarOutputKind outputKind, int32 hashBits, unsigned int32 seed, bool ordered, int32 invertHash) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashEncoding(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashScalarOutputKind,System.Int32,System.UInt32,System.Boolean,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OneHotHashEncoding (input As Scalar(Of String), Optional outputKind As CategoricalHashStaticExtensions.OneHotHashScalarOutputKind = (Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions+OneHotHashScalarOutputKind) 1, Optional hashBits As Integer = 16, Optional seed As UInteger = 314489979, Optional ordered As Boolean = true, Optional invertHash As Integer = 0) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member OneHotHashEncoding : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashScalarOutputKind * int * uint32 * bool * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashEncoding (input, outputKind, hashBits, seed, ordered, invertHash)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="outputKind" Type="Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions+OneHotHashScalarOutputKind" />
          <Parameter Name="hashBits" Type="System.Int32" />
          <Parameter Name="seed" Type="System.UInt32" />
          <Parameter Name="ordered" Type="System.Boolean" />
          <Parameter Name="invertHash" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="outputKind">Specify the output type of indicator array: array or binary encoded data.</param>
          <param name="hashBits">Amount of bits to use for hashing.</param>
          <param name="seed">Seed value used for hashing.</param>
          <param name="ordered">Whether the position of each term should be included in the hash.</param>
          <param name="invertHash">During hashing we constuct mappings between original values and the produced hash values.
            Text representation of original values are stored in the slot names of the  metadata for the new column.Hashing, as such, can map many initial values to one.
            <paramref name="invertHash" /> specifies the upper bound of the number of distinct input values mapping to a hash that should be retained.
            <value>0</value> does not retain any input values. <value>-1</value> retains all input values mapping to each hash.</param>
          <summary>
            Converts the categorical value into an indicator array by hashing categories into certain value and using that value as the index in the array.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions" Member="M:Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashEncoding(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashScalarOutputKind,System.Int32,System.UInt32,System.Boolean,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="OneHotHashEncoding">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; OneHotHashEncoding (this Microsoft.ML.StaticPipe.VarVector&lt;string&gt; input, Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashVectorOutputKind outputKind = Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions+OneHotHashVectorOutputKind.Bag, int hashBits = 16, uint seed = 314489979, bool ordered = true, int invertHash = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; OneHotHashEncoding(class Microsoft.ML.StaticPipe.VarVector`1&lt;string&gt; input, valuetype Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions/OneHotHashVectorOutputKind outputKind, int32 hashBits, unsigned int32 seed, bool ordered, int32 invertHash) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashEncoding(Microsoft.ML.StaticPipe.VarVector{System.String},Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashVectorOutputKind,System.Int32,System.UInt32,System.Boolean,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OneHotHashEncoding (input As VarVector(Of String), Optional outputKind As CategoricalHashStaticExtensions.OneHotHashVectorOutputKind = Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions+OneHotHashVectorOutputKind.Bag, Optional hashBits As Integer = 16, Optional seed As UInteger = 314489979, Optional ordered As Boolean = true, Optional invertHash As Integer = 0) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member OneHotHashEncoding : Microsoft.ML.StaticPipe.VarVector&lt;string&gt; * Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashVectorOutputKind * int * uint32 * bool * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashEncoding (input, outputKind, hashBits, seed, ordered, invertHash)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.String&gt;" RefType="this" />
          <Parameter Name="outputKind" Type="Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions+OneHotHashVectorOutputKind" />
          <Parameter Name="hashBits" Type="System.Int32" />
          <Parameter Name="seed" Type="System.UInt32" />
          <Parameter Name="ordered" Type="System.Boolean" />
          <Parameter Name="invertHash" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="outputKind">Specify the output type of indicator array: array or binary encoded data.</param>
          <param name="hashBits">Amount of bits to use for hashing.</param>
          <param name="seed">Seed value used for hashing.</param>
          <param name="ordered">Whether the position of each term should be included in the hash.</param>
          <param name="invertHash">During hashing we constuct mappings between original values and the produced hash values.
            Text representation of original values are stored in the slot names of the  metadata for the new column.Hashing, as such, can map many initial values to one.
            <paramref name="invertHash" /> specifies the upper bound of the number of distinct input values mapping to a hash that should be retained.
            <value>0</value> does not retain any input values. <value>-1</value> retains all input values mapping to each hash.</param>
          <summary>
            Converts the categorical value into an indicator array by building a dictionary of categories based on the data and using the id in the dictionary as the index in the array
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions" Member="M:Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashEncoding(Microsoft.ML.StaticPipe.VarVector{System.String},Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashVectorOutputKind,System.Int32,System.UInt32,System.Boolean,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="OneHotHashEncoding">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; OneHotHashEncoding (this Microsoft.ML.StaticPipe.Vector&lt;string&gt; input, Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashVectorOutputKind outputKind = Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions+OneHotHashVectorOutputKind.Bag, int hashBits = 16, uint seed = 314489979, bool ordered = true, int invertHash = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; OneHotHashEncoding(class Microsoft.ML.StaticPipe.Vector`1&lt;string&gt; input, valuetype Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions/OneHotHashVectorOutputKind outputKind, int32 hashBits, unsigned int32 seed, bool ordered, int32 invertHash) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashEncoding(Microsoft.ML.StaticPipe.Vector{System.String},Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashVectorOutputKind,System.Int32,System.UInt32,System.Boolean,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OneHotHashEncoding (input As Vector(Of String), Optional outputKind As CategoricalHashStaticExtensions.OneHotHashVectorOutputKind = Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions+OneHotHashVectorOutputKind.Bag, Optional hashBits As Integer = 16, Optional seed As UInteger = 314489979, Optional ordered As Boolean = true, Optional invertHash As Integer = 0) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member OneHotHashEncoding : Microsoft.ML.StaticPipe.Vector&lt;string&gt; * Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashVectorOutputKind * int * uint32 * bool * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashEncoding (input, outputKind, hashBits, seed, ordered, invertHash)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.String&gt;" RefType="this" />
          <Parameter Name="outputKind" Type="Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions+OneHotHashVectorOutputKind" />
          <Parameter Name="hashBits" Type="System.Int32" />
          <Parameter Name="seed" Type="System.UInt32" />
          <Parameter Name="ordered" Type="System.Boolean" />
          <Parameter Name="invertHash" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="outputKind">Specify the output type of indicator array: array or binary encoded data.</param>
          <param name="hashBits">Amount of bits to use for hashing.</param>
          <param name="seed">Seed value used for hashing.</param>
          <param name="ordered">Whether the position of each term should be included in the hash.</param>
          <param name="invertHash">During hashing we constuct mappings between original values and the produced hash values.
            Text representation of original values are stored in the slot names of the  metadata for the new column.Hashing, as such, can map many initial values to one.
            <paramref name="invertHash" /> specifies the upper bound of the number of distinct input values mapping to a hash that should be retained.
            <value>0</value> does not retain any input values. <value>-1</value> retains all input values mapping to each hash.</param>
          <summary>
            Converts the categorical value into an indicator array by building a dictionary of categories based on the data and using the id in the dictionary as the index in the array
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions" Member="M:Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashEncoding(Microsoft.ML.StaticPipe.Vector{System.String},Microsoft.ML.StaticPipe.CategoricalHashStaticExtensions.OneHotHashVectorOutputKind,System.Int32,System.UInt32,System.Boolean,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="OneHotEncoding">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; OneHotEncoding (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotScalarOutputKind outputKind = Microsoft.ML.StaticPipe.CategoricalStaticExtensions+OneHotScalarOutputKind.Ind, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; OneHotEncoding(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, valuetype Microsoft.ML.StaticPipe.CategoricalStaticExtensions/OneHotScalarOutputKind outputKind, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotEncoding(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotScalarOutputKind,Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.ReadOnlyMemory{System.Char}})" />
        <MemberSignature Language="F#" Value="static member OneHotEncoding : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotScalarOutputKind * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotEncoding (input, outputKind, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="outputKind" Type="Microsoft.ML.StaticPipe.CategoricalStaticExtensions+OneHotScalarOutputKind" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="outputKind">Specify the output type of indicator array: array or binary encoded data.</param>
          <param name="order">How the Id for each value would be assigined: by occurrence or by value.</param>
          <param name="maxItems">Maximum number of ids to keep during data scanning.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Converts the categorical value into an indicator array by building a dictionary of categories based on the data and using the id in the dictionary as the index in the array.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.CategoricalStaticExtensions" Member="M:Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotEncoding(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotScalarOutputKind,Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="OneHotEncoding">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; OneHotEncoding (this Microsoft.ML.StaticPipe.Vector&lt;string&gt; input, Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotVectorOutputKind outputKind = Microsoft.ML.StaticPipe.CategoricalStaticExtensions+OneHotVectorOutputKind.Ind, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; OneHotEncoding(class Microsoft.ML.StaticPipe.Vector`1&lt;string&gt; input, valuetype Microsoft.ML.StaticPipe.CategoricalStaticExtensions/OneHotVectorOutputKind outputKind, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotEncoding(Microsoft.ML.StaticPipe.Vector{System.String},Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotVectorOutputKind,Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.ReadOnlyMemory{System.Char}})" />
        <MemberSignature Language="F#" Value="static member OneHotEncoding : Microsoft.ML.StaticPipe.Vector&lt;string&gt; * Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotVectorOutputKind * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotEncoding (input, outputKind, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.String&gt;" RefType="this" />
          <Parameter Name="outputKind" Type="Microsoft.ML.StaticPipe.CategoricalStaticExtensions+OneHotVectorOutputKind" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="outputKind">Specify the output type of indicator array: Multiarray, array or binary encoded data.</param>
          <param name="order">How the Id for each value would be assigined: by occurrence or by value.</param>
          <param name="maxItems">Maximum number of ids to keep during data scanning.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Converts the categorical value into an indicator array by building a dictionary of categories based on the data and using the id in the dictionary as the index in the array.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.CategoricalStaticExtensions" Member="M:Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotEncoding(Microsoft.ML.StaticPipe.Vector{System.String},Microsoft.ML.StaticPipe.CategoricalStaticExtensions.OneHotVectorOutputKind,Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="TokenizeIntoCharacters">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;ushort,string&gt;&gt; TokenizeIntoCharacters (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, bool useMarkerCharacters = true);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int16, string&gt;&gt; TokenizeIntoCharacters(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, bool useMarkerCharacters) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.CharacterTokenizerStaticExtensions.TokenizeIntoCharacters(Microsoft.ML.StaticPipe.Scalar{System.String},System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TokenizeIntoCharacters (input As Scalar(Of String), Optional useMarkerCharacters As Boolean = true) As VarVector(Of Key(Of UShort, String))" />
        <MemberSignature Language="F#" Value="static member TokenizeIntoCharacters : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * bool -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint16, string&gt;&gt;" Usage="Microsoft.ML.StaticPipe.CharacterTokenizerStaticExtensions.TokenizeIntoCharacters (input, useMarkerCharacters)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt16,System.String&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="useMarkerCharacters" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="useMarkerCharacters">Whether to use marker characters to separate words.</param>
          <summary>
            Tokenize incoming text into a sequence of characters.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.CharacterTokenizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.CharacterTokenizerStaticExtensions.TokenizeIntoCharacters(Microsoft.ML.StaticPipe.Scalar{System.String},System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="AsVector&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;T&gt; AsVector&lt;T&gt; (this Microsoft.ML.StaticPipe.Scalar&lt;T&gt; me);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;!!T&gt; AsVector&lt;T&gt;(class Microsoft.ML.StaticPipe.Scalar`1&lt;!!T&gt; me) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.AsVector``1(Microsoft.ML.StaticPipe.Scalar{``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsVector(Of T) (me As Scalar(Of T)) As Vector(Of T)" />
        <MemberSignature Language="F#" Value="static member AsVector : Microsoft.ML.StaticPipe.Scalar&lt;'T&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;'T&gt;" Usage="Microsoft.ML.StaticPipe.ConcatStaticExtensions.AsVector me" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="me" Type="Microsoft.ML.StaticPipe.Scalar&lt;T&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="T">The value type.</typeparam>
          <param name="me">The scalar column.</param>
          <summary>
            Given a scalar vector, produce a vector of length one.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConcatStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.AsVector``1(Microsoft.ML.StaticPipe.Scalar{``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.NormVector`1" />
      </Targets>
      <Member MemberName="ConcatWith&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;T&gt; ConcatWith&lt;T&gt; (this Microsoft.ML.StaticPipe.NormVector&lt;T&gt; me, params Microsoft.ML.StaticPipe.NormVector&lt;T&gt;[] others);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;!!T&gt; ConcatWith&lt;T&gt;(class Microsoft.ML.StaticPipe.NormVector`1&lt;!!T&gt; me, class Microsoft.ML.StaticPipe.NormVector`1&lt;!!T&gt;[] others) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.NormVector{``0},Microsoft.ML.StaticPipe.NormVector{``0}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConcatWith(Of T) (me As NormVector(Of T), ParamArray others As NormVector(Of T)()) As NormVector(Of T)" />
        <MemberSignature Language="F#" Value="static member ConcatWith : Microsoft.ML.StaticPipe.NormVector&lt;'T&gt; * Microsoft.ML.StaticPipe.NormVector&lt;'T&gt;[] -&gt; Microsoft.ML.StaticPipe.NormVector&lt;'T&gt;" Usage="Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith (me, others)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="me" Type="Microsoft.ML.StaticPipe.NormVector&lt;T&gt;" RefType="this" />
          <Parameter Name="others" Type="Microsoft.ML.StaticPipe.NormVector&lt;T&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">The value type.</typeparam>
          <param name="me">The first input column.</param>
          <param name="others">Subsequent input columns.</param>
          <summary>
            Given a bunch of normalized vectors, concatenate them together into a normalized vector.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConcatStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.NormVector{``0},Microsoft.ML.StaticPipe.NormVector{``0}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ConcatWith&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;T&gt; ConcatWith&lt;T&gt; (this Microsoft.ML.StaticPipe.Scalar&lt;T&gt; me, params Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVector&lt;T&gt;[] others);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;!!T&gt; ConcatWith&lt;T&gt;(class Microsoft.ML.StaticPipe.Scalar`1&lt;!!T&gt; me, class Microsoft.ML.StaticPipe.ConcatStaticExtensions/ScalarOrVector`1&lt;!!T&gt;[] others) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Scalar{``0},Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVector{``0}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConcatWith(Of T) (me As Scalar(Of T), ParamArray others As ConcatStaticExtensions.ScalarOrVector(Of T)()) As Vector(Of T)" />
        <MemberSignature Language="F#" Value="static member ConcatWith : Microsoft.ML.StaticPipe.Scalar&lt;'T&gt; * Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVector&lt;'T&gt;[] -&gt; Microsoft.ML.StaticPipe.Vector&lt;'T&gt;" Usage="Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith (me, others)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="me" Type="Microsoft.ML.StaticPipe.Scalar&lt;T&gt;" RefType="this" />
          <Parameter Name="others" Type="Microsoft.ML.StaticPipe.ConcatStaticExtensions+ScalarOrVector&lt;T&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">The value type.</typeparam>
          <param name="me">The first input column.</param>
          <param name="others">Subsequent input columns.</param>
          <summary>
            Given a set of columns, concatenate them together into a vector valued column of the same type.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConcatStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Scalar{``0},Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVector{``0}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ConcatWith&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;T&gt; ConcatWith&lt;T&gt; (this Microsoft.ML.StaticPipe.Scalar&lt;T&gt; me, params Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVectorOrVarVector&lt;T&gt;[] others);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;!!T&gt; ConcatWith&lt;T&gt;(class Microsoft.ML.StaticPipe.Scalar`1&lt;!!T&gt; me, class Microsoft.ML.StaticPipe.ConcatStaticExtensions/ScalarOrVectorOrVarVector`1&lt;!!T&gt;[] others) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Scalar{``0},Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVectorOrVarVector{``0}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConcatWith(Of T) (me As Scalar(Of T), ParamArray others As ConcatStaticExtensions.ScalarOrVectorOrVarVector(Of T)()) As VarVector(Of T)" />
        <MemberSignature Language="F#" Value="static member ConcatWith : Microsoft.ML.StaticPipe.Scalar&lt;'T&gt; * Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVectorOrVarVector&lt;'T&gt;[] -&gt; Microsoft.ML.StaticPipe.VarVector&lt;'T&gt;" Usage="Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith (me, others)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="me" Type="Microsoft.ML.StaticPipe.Scalar&lt;T&gt;" RefType="this" />
          <Parameter Name="others" Type="Microsoft.ML.StaticPipe.ConcatStaticExtensions+ScalarOrVectorOrVarVector&lt;T&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">The value type.</typeparam>
          <param name="me">The first input column.</param>
          <param name="others">Subsequent input columns.</param>
          <summary>
            Given a set of columns including at least one variable sized vector column, concatenate them
            together into a vector valued column of the same type.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConcatStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Scalar{``0},Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVectorOrVarVector{``0}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ConcatWith&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;T&gt; ConcatWith&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;T&gt; me, params Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVectorOrVarVector&lt;T&gt;[] others);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;!!T&gt; ConcatWith&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;!!T&gt; me, class Microsoft.ML.StaticPipe.ConcatStaticExtensions/ScalarOrVectorOrVarVector`1&lt;!!T&gt;[] others) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.VarVector{``0},Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVectorOrVarVector{``0}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConcatWith(Of T) (me As VarVector(Of T), ParamArray others As ConcatStaticExtensions.ScalarOrVectorOrVarVector(Of T)()) As VarVector(Of T)" />
        <MemberSignature Language="F#" Value="static member ConcatWith : Microsoft.ML.StaticPipe.VarVector&lt;'T&gt; * Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVectorOrVarVector&lt;'T&gt;[] -&gt; Microsoft.ML.StaticPipe.VarVector&lt;'T&gt;" Usage="Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith (me, others)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="me" Type="Microsoft.ML.StaticPipe.VarVector&lt;T&gt;" RefType="this" />
          <Parameter Name="others" Type="Microsoft.ML.StaticPipe.ConcatStaticExtensions+ScalarOrVectorOrVarVector&lt;T&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">The value type.</typeparam>
          <param name="me">The first input column.</param>
          <param name="others">Subsequent input columns.</param>
          <summary>
            Given a set of columns including at least one variable sized vector column, concatenate them
            together into a vector valued column of the same type.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConcatStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.VarVector{``0},Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVectorOrVarVector{``0}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ConcatWith&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;T&gt; ConcatWith&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;T&gt; me, params Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVector&lt;T&gt;[] others);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;!!T&gt; ConcatWith&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;!!T&gt; me, class Microsoft.ML.StaticPipe.ConcatStaticExtensions/ScalarOrVector`1&lt;!!T&gt;[] others) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Vector{``0},Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVector{``0}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConcatWith(Of T) (me As Vector(Of T), ParamArray others As ConcatStaticExtensions.ScalarOrVector(Of T)()) As Vector(Of T)" />
        <MemberSignature Language="F#" Value="static member ConcatWith : Microsoft.ML.StaticPipe.Vector&lt;'T&gt; * Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVector&lt;'T&gt;[] -&gt; Microsoft.ML.StaticPipe.Vector&lt;'T&gt;" Usage="Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith (me, others)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="me" Type="Microsoft.ML.StaticPipe.Vector&lt;T&gt;" RefType="this" />
          <Parameter Name="others" Type="Microsoft.ML.StaticPipe.ConcatStaticExtensions+ScalarOrVector&lt;T&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">The value type.</typeparam>
          <param name="me">The first input column.</param>
          <param name="others">Subsequent input columns.</param>
          <summary>
            Given a set of columns, concatenate them together into a vector valued column of the same type.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConcatStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Vector{``0},Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVector{``0}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ConcatWith&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;T&gt; ConcatWith&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;T&gt; me, params Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVectorOrVarVector&lt;T&gt;[] others);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;!!T&gt; ConcatWith&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;!!T&gt; me, class Microsoft.ML.StaticPipe.ConcatStaticExtensions/ScalarOrVectorOrVarVector`1&lt;!!T&gt;[] others) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Vector{``0},Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVectorOrVarVector{``0}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConcatWith(Of T) (me As Vector(Of T), ParamArray others As ConcatStaticExtensions.ScalarOrVectorOrVarVector(Of T)()) As VarVector(Of T)" />
        <MemberSignature Language="F#" Value="static member ConcatWith : Microsoft.ML.StaticPipe.Vector&lt;'T&gt; * Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVectorOrVarVector&lt;'T&gt;[] -&gt; Microsoft.ML.StaticPipe.VarVector&lt;'T&gt;" Usage="Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith (me, others)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="me" Type="Microsoft.ML.StaticPipe.Vector&lt;T&gt;" RefType="this" />
          <Parameter Name="others" Type="Microsoft.ML.StaticPipe.ConcatStaticExtensions+ScalarOrVectorOrVarVector&lt;T&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">The value type.</typeparam>
          <param name="me">The first input column.</param>
          <param name="others">Subsequent input columns.</param>
          <summary>
            Given a set of columns including at least one variable sized vector column, concatenate them
            together into a vector valued column of the same type.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConcatStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Vector{``0},Microsoft.ML.StaticPipe.ConcatStaticExtensions.ScalarOrVectorOrVarVector{``0}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.Boolean})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Scalar(Of Boolean)) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to float.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.Boolean})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Scalar&lt;byte&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Scalar`1&lt;unsigned int8&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.Byte})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Scalar(Of Byte)) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Scalar&lt;byte&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Byte&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to float.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.Byte})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Scalar&lt;double&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Scalar`1&lt;float64&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.Double})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Scalar(Of Double)) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Scalar&lt;double&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Double&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to float.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.Double})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Scalar&lt;short&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Scalar`1&lt;int16&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.Int16})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Scalar(Of Short)) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Scalar&lt;int16&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Int16&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to float.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.Int16})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Scalar&lt;int&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Scalar`1&lt;int32&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Scalar(Of Integer)) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Scalar&lt;int&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Int32&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to float.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Scalar&lt;long&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Scalar`1&lt;int64&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.Int64})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Scalar(Of Long)) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Scalar&lt;int64&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Int64&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to float.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.Int64})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Scalar&lt;sbyte&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Scalar`1&lt;int8&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.SByte})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Scalar(Of SByte)) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Scalar&lt;sbyte&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.SByte&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to float.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.SByte})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.String})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Scalar(Of String)) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to float.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.String})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Scalar&lt;ushort&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Scalar`1&lt;unsigned int16&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.UInt16})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Scalar(Of UShort)) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Scalar&lt;uint16&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.UInt16&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to float.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.UInt16})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Scalar&lt;uint&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Scalar`1&lt;unsigned int32&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.UInt32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Scalar(Of UInteger)) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Scalar&lt;uint32&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.UInt32&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to float.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.UInt32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Scalar&lt;ulong&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Scalar`1&lt;unsigned int64&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.UInt64})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Scalar(Of ULong)) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Scalar&lt;uint64&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.UInt64&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to float.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Scalar{System.UInt64})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.VarVector&lt;bool&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.VarVector`1&lt;bool&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.Boolean})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As VarVector(Of Boolean)) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.VarVector&lt;bool&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Boolean&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to variable array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.Boolean})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.VarVector&lt;byte&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.VarVector`1&lt;unsigned int8&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.Byte})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As VarVector(Of Byte)) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.VarVector&lt;byte&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Byte&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to variable array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.Byte})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.VarVector&lt;double&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.VarVector`1&lt;float64&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.Double})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As VarVector(Of Double)) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.VarVector&lt;double&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Double&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to variable array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.Double})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.VarVector&lt;short&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.VarVector`1&lt;int16&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.Int16})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As VarVector(Of Short)) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.VarVector&lt;int16&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Int16&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to variable array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.Int16})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.VarVector&lt;int&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.VarVector`1&lt;int32&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As VarVector(Of Integer)) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.VarVector&lt;int&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Int32&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to variable array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.VarVector&lt;long&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.VarVector`1&lt;int64&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.Int64})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As VarVector(Of Long)) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.VarVector&lt;int64&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Int64&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to variable array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.Int64})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.VarVector&lt;sbyte&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.VarVector`1&lt;int8&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.SByte})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As VarVector(Of SByte)) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.VarVector&lt;sbyte&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.SByte&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to variable array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.SByte})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.VarVector&lt;string&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.VarVector`1&lt;string&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.String})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As VarVector(Of String)) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.VarVector&lt;string&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.String&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to variable array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.String})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.VarVector&lt;ushort&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.VarVector`1&lt;unsigned int16&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.UInt16})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As VarVector(Of UShort)) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.VarVector&lt;uint16&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.UInt16&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to variable array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.UInt16})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.VarVector&lt;uint&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.VarVector`1&lt;unsigned int32&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.UInt32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As VarVector(Of UInteger)) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.VarVector&lt;uint32&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.UInt32&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to variable array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.UInt32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.VarVector&lt;ulong&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.VarVector`1&lt;unsigned int64&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.UInt64})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As VarVector(Of ULong)) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.VarVector&lt;uint64&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.UInt64&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to variable array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.VarVector{System.UInt64})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Vector&lt;bool&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Vector`1&lt;bool&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.Boolean})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Vector(Of Boolean)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Vector&lt;bool&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Boolean&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.Boolean})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Vector&lt;byte&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Vector`1&lt;unsigned int8&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.Byte})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Vector(Of Byte)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Vector&lt;byte&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Byte&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.Byte})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.Double})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Vector(Of Double)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Vector&lt;double&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.Double})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Vector&lt;short&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Vector`1&lt;int16&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.Int16})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Vector(Of Short)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Vector&lt;int16&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Int16&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.Int16})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Vector&lt;int&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Vector`1&lt;int32&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Vector(Of Integer)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Vector&lt;int&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Int32&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Vector&lt;long&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Vector`1&lt;int64&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.Int64})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Vector(Of Long)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Vector&lt;int64&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Int64&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.Int64})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Vector&lt;sbyte&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Vector`1&lt;int8&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.SByte})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Vector(Of SByte)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Vector&lt;sbyte&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.SByte&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.SByte})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Vector&lt;string&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Vector`1&lt;string&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.String})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Vector(Of String)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Vector&lt;string&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.String&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.String})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Vector&lt;ushort&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Vector`1&lt;unsigned int16&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.UInt16})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Vector(Of UShort)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Vector&lt;uint16&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.UInt16&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.UInt16})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Vector&lt;uint&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Vector`1&lt;unsigned int32&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.UInt32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Vector(Of UInteger)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Vector&lt;uint32&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.UInt32&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.UInt32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToFloat (this Microsoft.ML.StaticPipe.Vector&lt;ulong&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToFloat(class Microsoft.ML.StaticPipe.Vector`1&lt;unsigned int64&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.UInt64})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (input As Vector(Of ULong)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : Microsoft.ML.StaticPipe.Vector&lt;uint64&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.UInt64&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Convert to array of floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ConvertStaticExtensions" Member="M:Microsoft.ML.StaticPipe.ConvertStaticExtensions.ToFloat(Microsoft.ML.StaticPipe.Vector{System.UInt64})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnCount">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;double&gt; SelectFeaturesBasedOnCount (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, long count = 1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; SelectFeaturesBasedOnCount(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, int64 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.CountFeatureSelectorStaticExtensions.SelectFeaturesBasedOnCount(Microsoft.ML.StaticPipe.Vector{System.Double},System.Int64)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnCount (input As Vector(Of Double), Optional count As Long = 1) As Vector(Of Double)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnCount : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * int64 -&gt; Microsoft.ML.StaticPipe.Vector&lt;double&gt;" Usage="Microsoft.ML.StaticPipe.CountFeatureSelectorStaticExtensions.SelectFeaturesBasedOnCount (input, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="count" Type="System.Int64" />
        </Parameters>
        <Docs>
          <param name="input">Name of the input column.</param>
          <param name="count">If the count of non-default values for a slot is greater than or equal to this threshold, the slot is preserved.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.CountFeatureSelectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.CountFeatureSelectorStaticExtensions.SelectFeaturesBasedOnCount(Microsoft.ML.StaticPipe.Vector{System.Double},System.Int64)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnCount">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; SelectFeaturesBasedOnCount (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, long count = 1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; SelectFeaturesBasedOnCount(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, int64 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.CountFeatureSelectorStaticExtensions.SelectFeaturesBasedOnCount(Microsoft.ML.StaticPipe.Vector{System.Single},System.Int64)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnCount (input As Vector(Of Single), Optional count As Long = 1) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnCount : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * int64 -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.CountFeatureSelectorStaticExtensions.SelectFeaturesBasedOnCount (input, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="count" Type="System.Int64" />
        </Parameters>
        <Docs>
          <param name="input">Name of the input column.</param>
          <param name="count">If the count of non-default values for a slot is greater than or equal to this threshold, the slot is preserved.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.CountFeatureSelectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.CountFeatureSelectorStaticExtensions.SelectFeaturesBasedOnCount(Microsoft.ML.StaticPipe.Vector{System.Single},System.Int64)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnCount">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;string&gt; SelectFeaturesBasedOnCount (this Microsoft.ML.StaticPipe.Vector&lt;string&gt; input, long count = 1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;string&gt; SelectFeaturesBasedOnCount(class Microsoft.ML.StaticPipe.Vector`1&lt;string&gt; input, int64 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.CountFeatureSelectorStaticExtensions.SelectFeaturesBasedOnCount(Microsoft.ML.StaticPipe.Vector{System.String},System.Int64)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnCount (input As Vector(Of String), Optional count As Long = 1) As Vector(Of String)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnCount : Microsoft.ML.StaticPipe.Vector&lt;string&gt; * int64 -&gt; Microsoft.ML.StaticPipe.Vector&lt;string&gt;" Usage="Microsoft.ML.StaticPipe.CountFeatureSelectorStaticExtensions.SelectFeaturesBasedOnCount (input, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.String&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.String&gt;" RefType="this" />
          <Parameter Name="count" Type="System.Int64" />
        </Parameters>
        <Docs>
          <param name="input">Name of the input column.</param>
          <param name="count">If the count of non-default values for a slot is greater than or equal to this threshold, the slot is preserved.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.CountFeatureSelectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.CountFeatureSelectorStaticExtensions.SelectFeaturesBasedOnCount(Microsoft.ML.StaticPipe.Vector{System.String},System.Int64)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataOperations" />
      </Targets>
      <Member MemberName="CreateTextReader&lt;TShape&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.DataReader&lt;Microsoft.ML.Data.IMultiStreamSource,TShape&gt; CreateTextReader&lt;TShape&gt; (this Microsoft.ML.DataOperations catalog, Func&lt;Microsoft.ML.StaticPipe.TextLoaderStatic.Context,TShape&gt; func, Microsoft.ML.Data.IMultiStreamSource files = null, bool hasHeader = false, char separator = '\t', bool allowQuoting = true, bool allowSparse = true, bool trimWhitspace = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.DataReader`2&lt;class Microsoft.ML.Data.IMultiStreamSource, !!TShape&gt; CreateTextReader&lt;TShape&gt;(class Microsoft.ML.DataOperations catalog, class System.Func`2&lt;class Microsoft.ML.StaticPipe.TextLoaderStatic/Context, !!TShape&gt; func, class Microsoft.ML.Data.IMultiStreamSource files, bool hasHeader, char separator, bool allowQuoting, bool allowSparse, bool trimWhitspace) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.DataLoadSaveOperationsExtensions.CreateTextReader``1(Microsoft.ML.DataOperations,System.Func{Microsoft.ML.StaticPipe.TextLoaderStatic.Context,``0},Microsoft.ML.Data.IMultiStreamSource,System.Boolean,System.Char,System.Boolean,System.Boolean,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateTextReader(Of TShape) (catalog As DataOperations, func As Func(Of TextLoaderStatic.Context, TShape), Optional files As IMultiStreamSource = null, Optional hasHeader As Boolean = false, Optional separator As Char = '\t', Optional allowQuoting As Boolean = true, Optional allowSparse As Boolean = true, Optional trimWhitspace As Boolean = false) As DataReader(Of IMultiStreamSource, TShape)" />
        <MemberSignature Language="F#" Value="static member CreateTextReader : Microsoft.ML.DataOperations * Func&lt;Microsoft.ML.StaticPipe.TextLoaderStatic.Context, 'Shape&gt; * Microsoft.ML.Data.IMultiStreamSource * bool * char * bool * bool * bool -&gt; Microsoft.ML.StaticPipe.DataReader&lt;Microsoft.ML.Data.IMultiStreamSource, 'Shape&gt;" Usage="Microsoft.ML.StaticPipe.DataLoadSaveOperationsExtensions.CreateTextReader (catalog, func, files, hasHeader, separator, allowQuoting, allowSparse, trimWhitspace)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.DataReader&lt;Microsoft.ML.Data.IMultiStreamSource,TShape&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TShape">
            <Attributes>
              <Attribute>
                <AttributeName>Microsoft.ML.StaticPipe.IsShape</AttributeName>
              </Attribute>
            </Attributes>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.DataOperations" RefType="this" />
          <Parameter Name="func" Type="System.Func&lt;Microsoft.ML.StaticPipe.TextLoaderStatic+Context,TShape&gt;" />
          <Parameter Name="files" Type="Microsoft.ML.Data.IMultiStreamSource" />
          <Parameter Name="hasHeader" Type="System.Boolean" />
          <Parameter Name="separator" Type="System.Char" />
          <Parameter Name="allowQuoting" Type="System.Boolean" />
          <Parameter Name="allowSparse" Type="System.Boolean" />
          <Parameter Name="trimWhitspace" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <typeparam name="TShape">The type shape parameter, which must be a valid-schema shape. As a practical
            matter this is generally not explicitly defined from the user, but is instead inferred from the return
            type of the <paramref name="func" /> where one takes an input <see cref="T:Microsoft.ML.StaticPipe.TextLoaderStatic.Context" /> and uses it to compose
            a shape-type instance describing what the columns are and how to load them from the file.</typeparam>
          <param name="catalog">The catalog.</param>
          <param name="func">The delegate that describes what fields to read from the text file, as well as
            describing their input type. The way in which it works is that the delegate is fed a <see cref="T:Microsoft.ML.StaticPipe.TextLoaderStatic.Context" />,
            and the user composes a shape type with <see cref="T:Microsoft.ML.StaticPipe.PipelineColumn" /> instances out of that <see cref="T:Microsoft.ML.StaticPipe.TextLoaderStatic.Context" />.
            The resulting data will have columns with the names corresponding to their names in the shape type.</param>
          <param name="files">Input files.</param>
          <param name="hasHeader">Data file has header with feature names.</param>
          <param name="separator">Text field separator.</param>
          <param name="allowQuoting">Whether the input -may include quoted values, which can contain separator
            characters, colons, and distinguish empty values from missing values. When true, consecutive separators
            denote a missing value and an empty value is denoted by <c>""</c>. When false, consecutive separators
            denote an empty value.</param>
          <param name="allowSparse">Whether the input may include sparse representations.</param>
          <param name="trimWhitspace">Remove trailing whitespace from lines.</param>
          <summary>
            Configures a reader for text files.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.DataLoadSaveOperationsExtensions" Member="M:Microsoft.ML.StaticPipe.DataLoadSaveOperationsExtensions.CreateTextReader``1(Microsoft.ML.DataOperations,System.Func{Microsoft.ML.StaticPipe.TextLoaderStatic.Context,``0},Microsoft.ML.Data.IMultiStreamSource,System.Boolean,System.Char,System.Boolean,System.Boolean,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.DataView`1" />
      </Targets>
      <Member MemberName="GetColumn&lt;TItem,TShape&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TItem&gt; GetColumn&lt;TItem,TShape&gt; (this Microsoft.ML.StaticPipe.DataView&lt;TShape&gt; data, Func&lt;TShape,Microsoft.ML.StaticPipe.Scalar&lt;TItem&gt;&gt; column);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TItem&gt; GetColumn&lt;TItem, TShape&gt;(class Microsoft.ML.StaticPipe.DataView`1&lt;!!TShape&gt; data, class System.Func`2&lt;!!TShape, class Microsoft.ML.StaticPipe.Scalar`1&lt;!!TItem&gt;&gt; column) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn``2(Microsoft.ML.StaticPipe.DataView{``1},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetColumn(Of TItem, TShape) (data As DataView(Of TShape), column As Func(Of TShape, Scalar(Of TItem))) As IEnumerable(Of TItem)" />
        <MemberSignature Language="F#" Value="static member GetColumn : Microsoft.ML.StaticPipe.DataView&lt;'Shape&gt; * Func&lt;'Shape, Microsoft.ML.StaticPipe.Scalar&lt;'Item&gt;&gt; -&gt; seq&lt;'Item&gt;" Usage="Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn (data, column)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;TItem&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TItem" />
          <TypeParameter Name="TShape" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;TShape&gt;" RefType="this" />
          <Parameter Name="column" Type="System.Func&lt;TShape,Microsoft.ML.StaticPipe.Scalar&lt;TItem&gt;&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TItem">To be added.</typeparam>
          <typeparam name="TShape">To be added.</typeparam>
          <param name="data">To be added.</param>
          <param name="column">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.DataViewExtensions" Member="M:Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn``2(Microsoft.ML.StaticPipe.DataView{``1},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.DataView`1" />
      </Targets>
      <Member MemberName="GetColumn&lt;TItem,TShape&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TItem[]&gt; GetColumn&lt;TItem,TShape&gt; (this Microsoft.ML.StaticPipe.DataView&lt;TShape&gt; data, Func&lt;TShape,Microsoft.ML.StaticPipe.VarVector&lt;TItem&gt;&gt; column);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TItem[]&gt; GetColumn&lt;TItem, TShape&gt;(class Microsoft.ML.StaticPipe.DataView`1&lt;!!TShape&gt; data, class System.Func`2&lt;!!TShape, class Microsoft.ML.StaticPipe.VarVector`1&lt;!!TItem&gt;&gt; column) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn``2(Microsoft.ML.StaticPipe.DataView{``1},System.Func{``1,Microsoft.ML.StaticPipe.VarVector{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetColumn(Of TItem, TShape) (data As DataView(Of TShape), column As Func(Of TShape, VarVector(Of TItem))) As IEnumerable(Of TItem())" />
        <MemberSignature Language="F#" Value="static member GetColumn : Microsoft.ML.StaticPipe.DataView&lt;'Shape&gt; * Func&lt;'Shape, Microsoft.ML.StaticPipe.VarVector&lt;'Item&gt;&gt; -&gt; seq&lt;'Item[]&gt;" Usage="Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn (data, column)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;TItem[]&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TItem" />
          <TypeParameter Name="TShape" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;TShape&gt;" RefType="this" />
          <Parameter Name="column" Type="System.Func&lt;TShape,Microsoft.ML.StaticPipe.VarVector&lt;TItem&gt;&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TItem">To be added.</typeparam>
          <typeparam name="TShape">To be added.</typeparam>
          <param name="data">To be added.</param>
          <param name="column">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.DataViewExtensions" Member="M:Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn``2(Microsoft.ML.StaticPipe.DataView{``1},System.Func{``1,Microsoft.ML.StaticPipe.VarVector{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.DataView`1" />
      </Targets>
      <Member MemberName="GetColumn&lt;TItem,TShape&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TItem[]&gt; GetColumn&lt;TItem,TShape&gt; (this Microsoft.ML.StaticPipe.DataView&lt;TShape&gt; data, Func&lt;TShape,Microsoft.ML.StaticPipe.Vector&lt;TItem&gt;&gt; column);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TItem[]&gt; GetColumn&lt;TItem, TShape&gt;(class Microsoft.ML.StaticPipe.DataView`1&lt;!!TShape&gt; data, class System.Func`2&lt;!!TShape, class Microsoft.ML.StaticPipe.Vector`1&lt;!!TItem&gt;&gt; column) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn``2(Microsoft.ML.StaticPipe.DataView{``1},System.Func{``1,Microsoft.ML.StaticPipe.Vector{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetColumn(Of TItem, TShape) (data As DataView(Of TShape), column As Func(Of TShape, Vector(Of TItem))) As IEnumerable(Of TItem())" />
        <MemberSignature Language="F#" Value="static member GetColumn : Microsoft.ML.StaticPipe.DataView&lt;'Shape&gt; * Func&lt;'Shape, Microsoft.ML.StaticPipe.Vector&lt;'Item&gt;&gt; -&gt; seq&lt;'Item[]&gt;" Usage="Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn (data, column)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;TItem[]&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TItem" />
          <TypeParameter Name="TShape" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;TShape&gt;" RefType="this" />
          <Parameter Name="column" Type="System.Func&lt;TShape,Microsoft.ML.StaticPipe.Vector&lt;TItem&gt;&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TItem">To be added.</typeparam>
          <typeparam name="TShape">To be added.</typeparam>
          <param name="data">To be added.</param>
          <param name="column">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.DataViewExtensions" Member="M:Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn``2(Microsoft.ML.StaticPipe.DataView{``1},System.Func{``1,Microsoft.ML.StaticPipe.Vector{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext" />
      </Targets>
      <Member MemberName="Evaluate&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.BinaryClassificationMetrics Evaluate&lt;T&gt; (this Microsoft.ML.BinaryClassificationContext ctx, Microsoft.ML.StaticPipe.DataView&lt;T&gt; data, Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; label, Func&lt;T,ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;&gt; pred);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.BinaryClassificationMetrics Evaluate&lt;T&gt;(class Microsoft.ML.BinaryClassificationContext ctx, class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt; data, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; label, class System.Func`2&lt;!!T, valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt;&gt; pred) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.BinaryClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Func{``0,System.ValueTuple{Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Boolean}}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Evaluate(Of T) (ctx As BinaryClassificationContext, data As DataView(Of T), label As Func(Of T, Scalar(Of Boolean)), pred As Func(Of T, ValueTuple(Of Scalar(Of Single), Scalar(Of Boolean)))) As BinaryClassificationMetrics" />
        <MemberSignature Language="F#" Value="static member Evaluate : Microsoft.ML.BinaryClassificationContext * Microsoft.ML.StaticPipe.DataView&lt;'T&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; * Func&lt;'T, ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;&gt; -&gt; Microsoft.ML.Data.BinaryClassificationMetrics" Usage="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate (ctx, data, label, pred)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.BinaryClassificationMetrics</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;T&gt;" />
          <Parameter Name="label" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;" />
          <Parameter Name="pred" Type="System.Func&lt;T,System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;&gt;">
            <Attributes>
              <Attribute>
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">The shape type for the input data.</typeparam>
          <param name="ctx">The binary classification context.</param>
          <param name="data">The data to evaluate.</param>
          <param name="label">The index delegate for the label column.</param>
          <param name="pred">The index delegate for columns from uncalibrated prediction of a binary classifier.
            Under typical scenarios, this will just be the same tuple of results returned from the trainer.</param>
          <summary>
            Evaluates scored binary classification data, if the predictions are not calibrated.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.BinaryClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Func{``0,System.ValueTuple{Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Boolean}}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext" />
      </Targets>
      <Member MemberName="Evaluate&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.CalibratedBinaryClassificationMetrics Evaluate&lt;T&gt; (this Microsoft.ML.BinaryClassificationContext ctx, Microsoft.ML.StaticPipe.DataView&lt;T&gt; data, Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; label, Func&lt;T,ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;&gt; pred);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.CalibratedBinaryClassificationMetrics Evaluate&lt;T&gt;(class Microsoft.ML.BinaryClassificationContext ctx, class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt; data, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; label, class System.Func`2&lt;!!T, valuetype System.ValueTuple`3&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt;&gt; pred) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.BinaryClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Func{``0,System.ValueTuple{Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Boolean}}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Evaluate(Of T) (ctx As BinaryClassificationContext, data As DataView(Of T), label As Func(Of T, Scalar(Of Boolean)), pred As Func(Of T, ValueTuple(Of Scalar(Of Single), Scalar(Of Single), Scalar(Of Boolean)))) As CalibratedBinaryClassificationMetrics" />
        <MemberSignature Language="F#" Value="static member Evaluate : Microsoft.ML.BinaryClassificationContext * Microsoft.ML.StaticPipe.DataView&lt;'T&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; * Func&lt;'T, ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;&gt; -&gt; Microsoft.ML.Data.CalibratedBinaryClassificationMetrics" Usage="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate (ctx, data, label, pred)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.CalibratedBinaryClassificationMetrics</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;T&gt;" />
          <Parameter Name="label" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;" />
          <Parameter Name="pred" Type="System.Func&lt;T,System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;&gt;">
            <Attributes>
              <Attribute>
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "probability", "predictedLabel" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">The shape type for the input data.</typeparam>
          <param name="ctx">The binary classification context.</param>
          <param name="data">The data to evaluate.</param>
          <param name="label">The index delegate for the label column.</param>
          <param name="pred">The index delegate for columns from calibrated prediction of a binary classifier.
            Under typical scenarios, this will just be the same tuple of results returned from the trainer.</param>
          <summary>
            Evaluates scored binary classification data.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.BinaryClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Func{``0,System.ValueTuple{Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Boolean}}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.ClusteringContext" />
      </Targets>
      <Member MemberName="Evaluate&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.ClusteringMetrics Evaluate&lt;T&gt; (this Microsoft.ML.ClusteringContext ctx, Microsoft.ML.StaticPipe.DataView&lt;T&gt; data, Func&lt;T,Microsoft.ML.StaticPipe.Vector&lt;float&gt;&gt; score, Func&lt;T,Microsoft.ML.StaticPipe.Key&lt;uint&gt;&gt; label = null, Func&lt;T,Microsoft.ML.StaticPipe.Vector&lt;float&gt;&gt; features = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.ClusteringMetrics Evaluate&lt;T&gt;(class Microsoft.ML.ClusteringContext ctx, class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt; data, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;&gt; score, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Key`1&lt;unsigned int32&gt;&gt; label, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;&gt; features) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.ClusteringContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Vector{System.Single}},System.Func{``0,Microsoft.ML.StaticPipe.Key{System.UInt32}},System.Func{``0,Microsoft.ML.StaticPipe.Vector{System.Single}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Evaluate(Of T) (ctx As ClusteringContext, data As DataView(Of T), score As Func(Of T, Vector(Of Single)), Optional label As Func(Of T, Key(Of UInteger)) = null, Optional features As Func(Of T, Vector(Of Single)) = null) As ClusteringMetrics" />
        <MemberSignature Language="F#" Value="static member Evaluate : Microsoft.ML.ClusteringContext * Microsoft.ML.StaticPipe.DataView&lt;'T&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Vector&lt;single&gt;&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Key&lt;uint32&gt;&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Vector&lt;single&gt;&gt; -&gt; Microsoft.ML.Data.ClusteringMetrics" Usage="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate (ctx, data, score, label, features)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.ClusteringMetrics</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.ClusteringContext" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;T&gt;" />
          <Parameter Name="score" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;&gt;" />
          <Parameter Name="label" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Key&lt;System.UInt32&gt;&gt;" />
          <Parameter Name="features" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="T">The shape type for the input data.</typeparam>
          <param name="ctx">The clustering context.</param>
          <param name="data">The data to evaluate.</param>
          <param name="score">The index delegate for the predicted score column.</param>
          <param name="label">The optional index delegate for the label column.</param>
          <param name="features">The optional index delegate for the features column.</param>
          <summary>
            Evaluates scored clustering prediction data.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.ClusteringContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Vector{System.Single}},System.Func{``0,Microsoft.ML.StaticPipe.Key{System.UInt32}},System.Func{``0,Microsoft.ML.StaticPipe.Vector{System.Single}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionContext" />
      </Targets>
      <Member MemberName="Evaluate&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.RegressionMetrics Evaluate&lt;T&gt; (this Microsoft.ML.RegressionContext ctx, Microsoft.ML.StaticPipe.DataView&lt;T&gt; data, Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;&gt; label, Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;&gt; score, Microsoft.ML.IRegressionLoss loss = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.RegressionMetrics Evaluate&lt;T&gt;(class Microsoft.ML.RegressionContext ctx, class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt; data, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;&gt; label, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;&gt; score, class Microsoft.ML.IRegressionLoss loss) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.RegressionContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Single}},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Single}},Microsoft.ML.IRegressionLoss)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Evaluate(Of T) (ctx As RegressionContext, data As DataView(Of T), label As Func(Of T, Scalar(Of Single)), score As Func(Of T, Scalar(Of Single)), Optional loss As IRegressionLoss = null) As RegressionMetrics" />
        <MemberSignature Language="F#" Value="static member Evaluate : Microsoft.ML.RegressionContext * Microsoft.ML.StaticPipe.DataView&lt;'T&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;&gt; * Microsoft.ML.IRegressionLoss -&gt; Microsoft.ML.Data.RegressionMetrics" Usage="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate (ctx, data, label, score, loss)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.RegressionMetrics</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RegressionContext" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;T&gt;" />
          <Parameter Name="label" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;&gt;" />
          <Parameter Name="score" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;&gt;" />
          <Parameter Name="loss" Type="Microsoft.ML.IRegressionLoss" />
        </Parameters>
        <Docs>
          <typeparam name="T">The shape type for the input data.</typeparam>
          <param name="ctx">The regression context.</param>
          <param name="data">The data to evaluate.</param>
          <param name="label">The index delegate for the label column.</param>
          <param name="score">The index delegate for predicted score column.</param>
          <param name="loss">Potentially custom loss function. If left unspecified defaults to <see cref="T:Microsoft.ML.SquaredLoss" />.</param>
          <summary>
            Evaluates scored regression data.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.RegressionContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Single}},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Single}},Microsoft.ML.IRegressionLoss)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationContext" />
      </Targets>
      <Member MemberName="Evaluate&lt;T,TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.MultiClassClassifierMetrics Evaluate&lt;T,TKey&gt; (this Microsoft.ML.MulticlassClassificationContext ctx, Microsoft.ML.StaticPipe.DataView&lt;T&gt; data, Func&lt;T,Microsoft.ML.StaticPipe.Key&lt;uint,TKey&gt;&gt; label, Func&lt;T,ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;float&gt;,Microsoft.ML.StaticPipe.Key&lt;uint,TKey&gt;&gt;&gt; pred, int topK = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.MultiClassClassifierMetrics Evaluate&lt;T, TKey&gt;(class Microsoft.ML.MulticlassClassificationContext ctx, class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt; data, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TKey&gt;&gt; label, class System.Func`2&lt;!!T, valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TKey&gt;&gt;&gt; pred, int32 topK) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate``2(Microsoft.ML.MulticlassClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Key{System.UInt32,``1}},System.Func{``0,System.ValueTuple{Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Key{System.UInt32,``1}}},System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Evaluate(Of T, TKey) (ctx As MulticlassClassificationContext, data As DataView(Of T), label As Func(Of T, Key(Of UInteger, TKey)), pred As Func(Of T, ValueTuple(Of Vector(Of Single), Key(Of UInteger, TKey))), Optional topK As Integer = 0) As MultiClassClassifierMetrics" />
        <MemberSignature Language="F#" Value="static member Evaluate : Microsoft.ML.MulticlassClassificationContext * Microsoft.ML.StaticPipe.DataView&lt;'T&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Key&lt;uint32, 'Key&gt;&gt; * Func&lt;'T, ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;single&gt;, Microsoft.ML.StaticPipe.Key&lt;uint32, 'Key&gt;&gt;&gt; * int -&gt; Microsoft.ML.Data.MultiClassClassifierMetrics" Usage="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate (ctx, data, label, pred, topK)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.MultiClassClassifierMetrics</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.MulticlassClassificationContext" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;T&gt;" />
          <Parameter Name="label" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TKey&gt;&gt;" />
          <Parameter Name="pred" Type="System.Func&lt;T,System.ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TKey&gt;&gt;&gt;">
            <Attributes>
              <Attribute>
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
          <Parameter Name="topK" Type="System.Int32" />
        </Parameters>
        <Docs>
          <typeparam name="T">The shape type for the input data.</typeparam>
          <typeparam name="TKey">The value type for the key label.</typeparam>
          <param name="ctx">The multiclass classification context.</param>
          <param name="data">The data to evaluate.</param>
          <param name="label">The index delegate for the label column.</param>
          <param name="pred">The index delegate for columns from the prediction of a multiclass classifier.
            Under typical scenarios, this will just be the same tuple of results returned from the trainer.</param>
          <param name="topK">If given a positive value, the <see cref="P:Microsoft.ML.Data.MultiClassClassifierMetrics.TopKAccuracy" /> will be filled with
            the top-K accuracy, that is, the accuracy assuming we consider an example with the correct class within
            the top-K values as being stored "correctly."</param>
          <summary>
            Evaluates scored multiclass classification data.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate``2(Microsoft.ML.MulticlassClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Key{System.UInt32,``1}},System.Func{``0,System.ValueTuple{Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Key{System.UInt32,``1}}},System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RankingContext" />
      </Targets>
      <Member MemberName="Evaluate&lt;T,TVal&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.RankerMetrics Evaluate&lt;T,TVal&gt; (this Microsoft.ML.RankingContext ctx, Microsoft.ML.StaticPipe.DataView&lt;T&gt; data, Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;&gt; label, Func&lt;T,Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt;&gt; groupId, Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;&gt; score);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.RankerMetrics Evaluate&lt;T, TVal&gt;(class Microsoft.ML.RankingContext ctx, class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt; data, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;&gt; label, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt;&gt; groupId, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;&gt; score) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate``2(Microsoft.ML.RankingContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Single}},System.Func{``0,Microsoft.ML.StaticPipe.Key{System.UInt32,``1}},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Single}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Evaluate(Of T, TVal) (ctx As RankingContext, data As DataView(Of T), label As Func(Of T, Scalar(Of Single)), groupId As Func(Of T, Key(Of UInteger, TVal)), score As Func(Of T, Scalar(Of Single))) As RankerMetrics" />
        <MemberSignature Language="F#" Value="static member Evaluate : Microsoft.ML.RankingContext * Microsoft.ML.StaticPipe.DataView&lt;'T&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt;&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;&gt; -&gt; Microsoft.ML.Data.RankerMetrics" Usage="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate (ctx, data, label, groupId, score)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.RankerMetrics</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
          <TypeParameter Name="TVal" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RankingContext" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;T&gt;" />
          <Parameter Name="label" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;&gt;" />
          <Parameter Name="groupId" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;&gt;" />
          <Parameter Name="score" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="T">The shape type for the input data.</typeparam>
          <typeparam name="TVal">The type of data, before being converted to a key.</typeparam>
          <param name="ctx">The ranking context.</param>
          <param name="data">The data to evaluate.</param>
          <param name="label">The index delegate for the label column.</param>
          <param name="groupId">The index delegate for the groupId column. </param>
          <param name="score">The index delegate for predicted score column.</param>
          <summary>
            Evaluates scored ranking data.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.EvaluatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.EvaluatorStaticExtensions.Evaluate``2(Microsoft.ML.RankingContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Single}},System.Func{``0,Microsoft.ML.StaticPipe.Key{System.UInt32,``1}},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Single}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="FieldAwareFactorizationMachine">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; FieldAwareFactorizationMachine (this Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers ctx, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt;[] features, float learningRate = 0.1, int numIterations = 5, int numLatentDimensions = 20, Action&lt;Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineTrainer.Arguments&gt; advancedSettings = null, Action&lt;Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; FieldAwareFactorizationMachine(class Microsoft.ML.BinaryClassificationContext/BinaryClassificationTrainers ctx, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;[] features, float32 learningRate, int32 numIterations, int32 numLatentDimensions, class System.Action`1&lt;class Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineTrainer/Arguments&gt; advancedSettings, class System.Action`1&lt;class Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.FactorizationMachineExtensions.FieldAwareFactorizationMachine(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single}[],System.Single,System.Int32,System.Int32,System.Action{Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineTrainer.Arguments},System.Action{Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FieldAwareFactorizationMachine (ctx As BinaryClassificationContext.BinaryClassificationTrainers, label As Scalar(Of Boolean), features As Vector(Of Single)(), Optional learningRate As Single = 0.1, Optional numIterations As Integer = 5, Optional numLatentDimensions As Integer = 20, Optional advancedSettings As Action(Of FieldAwareFactorizationMachineTrainer.Arguments) = null, Optional onFit As Action(Of FieldAwareFactorizationMachineModelParameters) = null) As ValueTuple(Of Scalar(Of Single), Scalar(Of Boolean))" />
        <MemberSignature Language="F#" Value="static member FieldAwareFactorizationMachine : Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt;[] * single * int * int * Action&lt;Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineTrainer.Arguments&gt; * Action&lt;Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineModelParameters&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.FactorizationMachineExtensions.FieldAwareFactorizationMachine (ctx, label, features, learningRate, numIterations, numLatentDimensions, advancedSettings, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;[]" />
          <Parameter Name="learningRate" Type="System.Single" />
          <Parameter Name="numIterations" Type="System.Int32" />
          <Parameter Name="numLatentDimensions" Type="System.Int32" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineTrainer+Arguments&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The binary classifier context trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="learningRate">Initial learning rate.</param>
          <param name="numIterations">Number of training iterations.</param>
          <param name="numLatentDimensions">Latent space dimensions.</param>
          <param name="advancedSettings">A delegate to set more settings.
            The settings here will override the ones provided in the direct method signature,
            if both are present and have different values.
            The columns names, however need to be provided directly, not through the <paramref name="advancedSettings" />.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the model that was trained.  Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
            Predict a target using a field-aware factorization machine.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.FactorizationMachineExtensions" Member="M:Microsoft.ML.StaticPipe.FactorizationMachineExtensions.FieldAwareFactorizationMachine(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single}[],System.Single,System.Int32,System.Int32,System.Action{Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineTrainer.Arguments},System.Action{Microsoft.ML.FactorizationMachine.FieldAwareFactorizationMachineModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="GlobalContrastNormalize">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; GlobalContrastNormalize (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, bool subMean = true, bool useStdDev = false, float scale = 1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; GlobalContrastNormalize(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, bool subMean, bool useStdDev, float32 scale) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.GlobalContrastNormalizerStaticExtensions.GlobalContrastNormalize(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Boolean,System.Single)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GlobalContrastNormalize (input As Vector(Of Single), Optional subMean As Boolean = true, Optional useStdDev As Boolean = false, Optional scale As Single = 1) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member GlobalContrastNormalize : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * bool * bool * single -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.GlobalContrastNormalizerStaticExtensions.GlobalContrastNormalize (input, subMean, useStdDev, scale)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="subMean" Type="System.Boolean" />
          <Parameter Name="useStdDev" Type="System.Boolean" />
          <Parameter Name="scale" Type="System.Single" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="subMean">Subtract mean from each value before normalizing.</param>
          <param name="useStdDev">Normalize by standard deviation rather than L2 norm.</param>
          <param name="scale">Scale features by this value.</param>
          <summary>
            <para>Performs a global contrast normalization on input values:</para>
            <para>Y = (s * X - M) / D</para>
            <para>where s is a scale, M is mean and D is either the L2 norm or standard deviation.</para>
          </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.GlobalContrastNormalizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.GlobalContrastNormalizerStaticExtensions.GlobalContrastNormalize(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Boolean,System.Single)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Custom`1" />
      </Targets>
      <Member MemberName="AsGrayscale">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Custom&lt;Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt; AsGrayscale (this Microsoft.ML.StaticPipe.Custom&lt;Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Custom`1&lt;class Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt; AsGrayscale(class Microsoft.ML.StaticPipe.Custom`1&lt;class Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ImageStaticPipe.AsGrayscale(Microsoft.ML.StaticPipe.Custom{Microsoft.ML.StaticPipe.UnknownSizeBitmap})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsGrayscale (input As Custom(Of UnknownSizeBitmap)) As Custom(Of UnknownSizeBitmap)" />
        <MemberSignature Language="F#" Value="static member AsGrayscale : Microsoft.ML.StaticPipe.Custom&lt;Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt; -&gt; Microsoft.ML.StaticPipe.Custom&lt;Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt;" Usage="Microsoft.ML.StaticPipe.ImageStaticPipe.AsGrayscale input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Custom&lt;Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Custom&lt;Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The image to convert</param>
          <summary>
            Converts the image to grayscale.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ImageStaticPipe" Member="M:Microsoft.ML.StaticPipe.ImageStaticPipe.AsGrayscale(Microsoft.ML.StaticPipe.Custom{Microsoft.ML.StaticPipe.UnknownSizeBitmap})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Custom`1" />
      </Targets>
      <Member MemberName="AsGrayscale">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt; AsGrayscale (this Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Custom`1&lt;class System.Drawing.Bitmap&gt; AsGrayscale(class Microsoft.ML.StaticPipe.Custom`1&lt;class System.Drawing.Bitmap&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ImageStaticPipe.AsGrayscale(Microsoft.ML.StaticPipe.Custom{System.Drawing.Bitmap})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsGrayscale (input As Custom(Of Bitmap)) As Custom(Of Bitmap)" />
        <MemberSignature Language="F#" Value="static member AsGrayscale : Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt; -&gt; Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt;" Usage="Microsoft.ML.StaticPipe.ImageStaticPipe.AsGrayscale input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The image to convert</param>
          <summary>
            Converts the image to grayscale.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ImageStaticPipe" Member="M:Microsoft.ML.StaticPipe.ImageStaticPipe.AsGrayscale(Microsoft.ML.StaticPipe.Custom{System.Drawing.Bitmap})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Custom`1" />
      </Targets>
      <Member MemberName="ExtractPixels">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ExtractPixels (this Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt; input, bool useAlpha = false, bool useRed = true, bool useGreen = true, bool useBlue = true, bool interleaveArgb = false, float scale = 1, float offset = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ExtractPixels(class Microsoft.ML.StaticPipe.Custom`1&lt;class System.Drawing.Bitmap&gt; input, bool useAlpha, bool useRed, bool useGreen, bool useBlue, bool interleaveArgb, float32 scale, float32 offset) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ImageStaticPipe.ExtractPixels(Microsoft.ML.StaticPipe.Custom{System.Drawing.Bitmap},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Single,System.Single)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExtractPixels (input As Custom(Of Bitmap), Optional useAlpha As Boolean = false, Optional useRed As Boolean = true, Optional useGreen As Boolean = true, Optional useBlue As Boolean = true, Optional interleaveArgb As Boolean = false, Optional scale As Single = 1, Optional offset As Single = 0) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ExtractPixels : Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt; * bool * bool * bool * bool * bool * single * single -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.ImageStaticPipe.ExtractPixels (input, useAlpha, useRed, useGreen, useBlue, interleaveArgb, scale, offset)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt;" RefType="this" />
          <Parameter Name="useAlpha" Type="System.Boolean" />
          <Parameter Name="useRed" Type="System.Boolean" />
          <Parameter Name="useGreen" Type="System.Boolean" />
          <Parameter Name="useBlue" Type="System.Boolean" />
          <Parameter Name="interleaveArgb" Type="System.Boolean" />
          <Parameter Name="scale" Type="System.Single" />
          <Parameter Name="offset" Type="System.Single" />
        </Parameters>
        <Docs>
          <param name="input">The input image to extract</param>
          <param name="useAlpha">Whether the alpha channel should be extracted</param>
          <param name="useRed">Whether the red channel should be extracted</param>
          <param name="useGreen">Whether the green channel should be extracted</param>
          <param name="useBlue">Whether the blue channel should be extracted</param>
          <param name="interleaveArgb">Whether the pixel values should be interleaved, as opposed to being separated by channel</param>
          <param name="scale">Scale the normally 0 through 255 pixel values by this amount</param>
          <param name="offset">Add this amount to the pixel values, before scaling</param>
          <summary>
            Vectorizes the image as the numeric values of its pixels converted and possibly transformed to floating point values.
            The output vector is output in height then width major order, with the channels being the most minor (if
            <paramref name="interleaveArgb" /> is true) or major (if <paramref name="interleaveArgb" /> is false) dimension.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ImageStaticPipe" Member="M:Microsoft.ML.StaticPipe.ImageStaticPipe.ExtractPixels(Microsoft.ML.StaticPipe.Custom{System.Drawing.Bitmap},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Single,System.Single)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Custom`1" />
      </Targets>
      <Member MemberName="ExtractPixelsAsBytes">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;byte&gt; ExtractPixelsAsBytes (this Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt; input, bool useAlpha = false, bool useRed = true, bool useGreen = true, bool useBlue = true, bool interleaveArgb = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;unsigned int8&gt; ExtractPixelsAsBytes(class Microsoft.ML.StaticPipe.Custom`1&lt;class System.Drawing.Bitmap&gt; input, bool useAlpha, bool useRed, bool useGreen, bool useBlue, bool interleaveArgb) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ImageStaticPipe.ExtractPixelsAsBytes(Microsoft.ML.StaticPipe.Custom{System.Drawing.Bitmap},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExtractPixelsAsBytes (input As Custom(Of Bitmap), Optional useAlpha As Boolean = false, Optional useRed As Boolean = true, Optional useGreen As Boolean = true, Optional useBlue As Boolean = true, Optional interleaveArgb As Boolean = false) As Vector(Of Byte)" />
        <MemberSignature Language="F#" Value="static member ExtractPixelsAsBytes : Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt; * bool * bool * bool * bool * bool -&gt; Microsoft.ML.StaticPipe.Vector&lt;byte&gt;" Usage="Microsoft.ML.StaticPipe.ImageStaticPipe.ExtractPixelsAsBytes (input, useAlpha, useRed, useGreen, useBlue, interleaveArgb)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Byte&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt;" RefType="this" />
          <Parameter Name="useAlpha" Type="System.Boolean" />
          <Parameter Name="useRed" Type="System.Boolean" />
          <Parameter Name="useGreen" Type="System.Boolean" />
          <Parameter Name="useBlue" Type="System.Boolean" />
          <Parameter Name="interleaveArgb" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="input">The input image to extract</param>
          <param name="useAlpha">Whether the alpha channel should be extracted</param>
          <param name="useRed">Whether the red channel should be extracted</param>
          <param name="useGreen">Whether the green channel should be extracted</param>
          <param name="useBlue">Whether the blue channel should be extracted</param>
          <param name="interleaveArgb">Whether the pixel values should be interleaved, as opposed to being separated by channel</param>
          <summary>
            Vectorizes the image as the numeric byte values of its pixels.
            The output vector is output in height then width major order, with the channels being the most minor (if
            <paramref name="interleaveArgb" /> is true) or major (if <paramref name="interleaveArgb" /> is false) dimension.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ImageStaticPipe" Member="M:Microsoft.ML.StaticPipe.ImageStaticPipe.ExtractPixelsAsBytes(Microsoft.ML.StaticPipe.Custom{System.Drawing.Bitmap},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="LoadAsImage">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Custom&lt;Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt; LoadAsImage (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; path, string relativeTo = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Custom`1&lt;class Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt; LoadAsImage(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; path, string relativeTo) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ImageStaticPipe.LoadAsImage(Microsoft.ML.StaticPipe.Scalar{System.String},System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LoadAsImage (path As Scalar(Of String), Optional relativeTo As String = null) As Custom(Of UnknownSizeBitmap)" />
        <MemberSignature Language="F#" Value="static member LoadAsImage : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * string -&gt; Microsoft.ML.StaticPipe.Custom&lt;Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt;" Usage="Microsoft.ML.StaticPipe.ImageStaticPipe.LoadAsImage (path, relativeTo)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Custom&lt;Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="path" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="relativeTo" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="path">The scalar text column that holds paths to the images</param>
          <param name="relativeTo">If specified, paths are considered to be relative to this directory.
            However, since the transform can be persisted across machines, it is generally considered more
            safe for users to simply always make their input paths absolute.</param>
          <summary>
            Load an image from an input column that holds the paths to images.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ImageStaticPipe" Member="M:Microsoft.ML.StaticPipe.ImageStaticPipe.LoadAsImage(Microsoft.ML.StaticPipe.Scalar{System.String},System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Custom`1" />
      </Targets>
      <Member MemberName="Resize">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt; Resize (this Microsoft.ML.StaticPipe.Custom&lt;Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt; input, int width, int height, Microsoft.ML.ImageAnalytics.ImageResizerTransform.ResizingKind resizing = Microsoft.ML.ImageAnalytics.ImageResizerTransform+ResizingKind.IsoCrop, Microsoft.ML.ImageAnalytics.ImageResizerTransform.Anchor cropAnchor = Microsoft.ML.ImageAnalytics.ImageResizerTransform+Anchor.Center);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Custom`1&lt;class System.Drawing.Bitmap&gt; Resize(class Microsoft.ML.StaticPipe.Custom`1&lt;class Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt; input, int32 width, int32 height, valuetype Microsoft.ML.ImageAnalytics.ImageResizerTransform/ResizingKind resizing, valuetype Microsoft.ML.ImageAnalytics.ImageResizerTransform/Anchor cropAnchor) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ImageStaticPipe.Resize(Microsoft.ML.StaticPipe.Custom{Microsoft.ML.StaticPipe.UnknownSizeBitmap},System.Int32,System.Int32,Microsoft.ML.ImageAnalytics.ImageResizerTransform.ResizingKind,Microsoft.ML.ImageAnalytics.ImageResizerTransform.Anchor)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Resize (input As Custom(Of UnknownSizeBitmap), width As Integer, height As Integer, Optional resizing As ImageResizerTransform.ResizingKind = Microsoft.ML.ImageAnalytics.ImageResizerTransform+ResizingKind.IsoCrop, Optional cropAnchor As ImageResizerTransform.Anchor = Microsoft.ML.ImageAnalytics.ImageResizerTransform+Anchor.Center) As Custom(Of Bitmap)" />
        <MemberSignature Language="F#" Value="static member Resize : Microsoft.ML.StaticPipe.Custom&lt;Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt; * int * int * Microsoft.ML.ImageAnalytics.ImageResizerTransform.ResizingKind * Microsoft.ML.ImageAnalytics.ImageResizerTransform.Anchor -&gt; Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt;" Usage="Microsoft.ML.StaticPipe.ImageStaticPipe.Resize (input, width, height, resizing, cropAnchor)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Custom&lt;Microsoft.ML.StaticPipe.UnknownSizeBitmap&gt;" RefType="this" />
          <Parameter Name="width" Type="System.Int32" />
          <Parameter Name="height" Type="System.Int32" />
          <Parameter Name="resizing" Type="Microsoft.ML.ImageAnalytics.ImageResizerTransform+ResizingKind" />
          <Parameter Name="cropAnchor" Type="Microsoft.ML.ImageAnalytics.ImageResizerTransform+Anchor" />
        </Parameters>
        <Docs>
          <param name="input">The input images</param>
          <param name="width">The width to resize to</param>
          <param name="height">The height to resize to</param>
          <param name="resizing">The type of resizing to do</param>
          <param name="cropAnchor">If cropping is necessary, at what position will the image be fixed?</param>
          <summary>
            Given a column of images of unfixed size, resize the images so they have uniform size.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ImageStaticPipe" Member="M:Microsoft.ML.StaticPipe.ImageStaticPipe.Resize(Microsoft.ML.StaticPipe.Custom{Microsoft.ML.StaticPipe.UnknownSizeBitmap},System.Int32,System.Int32,Microsoft.ML.ImageAnalytics.ImageResizerTransform.ResizingKind,Microsoft.ML.ImageAnalytics.ImageResizerTransform.Anchor)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Custom`1" />
      </Targets>
      <Member MemberName="Resize">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt; Resize (this Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt; input, int width, int height, Microsoft.ML.ImageAnalytics.ImageResizerTransform.ResizingKind resizing = Microsoft.ML.ImageAnalytics.ImageResizerTransform+ResizingKind.IsoCrop, Microsoft.ML.ImageAnalytics.ImageResizerTransform.Anchor cropAnchor = Microsoft.ML.ImageAnalytics.ImageResizerTransform+Anchor.Center);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Custom`1&lt;class System.Drawing.Bitmap&gt; Resize(class Microsoft.ML.StaticPipe.Custom`1&lt;class System.Drawing.Bitmap&gt; input, int32 width, int32 height, valuetype Microsoft.ML.ImageAnalytics.ImageResizerTransform/ResizingKind resizing, valuetype Microsoft.ML.ImageAnalytics.ImageResizerTransform/Anchor cropAnchor) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ImageStaticPipe.Resize(Microsoft.ML.StaticPipe.Custom{System.Drawing.Bitmap},System.Int32,System.Int32,Microsoft.ML.ImageAnalytics.ImageResizerTransform.ResizingKind,Microsoft.ML.ImageAnalytics.ImageResizerTransform.Anchor)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Resize (input As Custom(Of Bitmap), width As Integer, height As Integer, Optional resizing As ImageResizerTransform.ResizingKind = Microsoft.ML.ImageAnalytics.ImageResizerTransform+ResizingKind.IsoCrop, Optional cropAnchor As ImageResizerTransform.Anchor = Microsoft.ML.ImageAnalytics.ImageResizerTransform+Anchor.Center) As Custom(Of Bitmap)" />
        <MemberSignature Language="F#" Value="static member Resize : Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt; * int * int * Microsoft.ML.ImageAnalytics.ImageResizerTransform.ResizingKind * Microsoft.ML.ImageAnalytics.ImageResizerTransform.Anchor -&gt; Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt;" Usage="Microsoft.ML.StaticPipe.ImageStaticPipe.Resize (input, width, height, resizing, cropAnchor)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Custom&lt;System.Drawing.Bitmap&gt;" RefType="this" />
          <Parameter Name="width" Type="System.Int32" />
          <Parameter Name="height" Type="System.Int32" />
          <Parameter Name="resizing" Type="Microsoft.ML.ImageAnalytics.ImageResizerTransform+ResizingKind" />
          <Parameter Name="cropAnchor" Type="Microsoft.ML.ImageAnalytics.ImageResizerTransform+Anchor" />
        </Parameters>
        <Docs>
          <param name="input">The input images</param>
          <param name="width">The width to resize to</param>
          <param name="height">The height to resize to</param>
          <param name="resizing">The type of resizing to do</param>
          <param name="cropAnchor">If cropping is necessary, at what </param>
          <summary>
            Given a column of images, resize them to a new fixed size.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ImageStaticPipe" Member="M:Microsoft.ML.StaticPipe.ImageStaticPipe.Resize(Microsoft.ML.StaticPipe.Custom{System.Drawing.Bitmap},System.Int32,System.Int32,Microsoft.ML.ImageAnalytics.ImageResizerTransform.ResizingKind,Microsoft.ML.ImageAnalytics.ImageResizerTransform.Anchor)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`1" />
      </Targets>
      <Member MemberName="ToBinaryVector&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBinaryVector&lt;TKey&gt; (this Microsoft.ML.StaticPipe.Key&lt;TKey&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBinaryVector&lt;TKey&gt;(class Microsoft.ML.StaticPipe.Key`1&lt;!!TKey&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector``1(Microsoft.ML.StaticPipe.Key{``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBinaryVector(Of TKey) (input As Key(Of TKey)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBinaryVector : Microsoft.ML.StaticPipe.Key&lt;'Key&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;TKey&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces a vector of bits representing the key in binary form.
            The first value is encoded as all zeros and missing values are encoded as all ones.
            In the case where a vector has multiple keys, the encoded values are concatenated.
            Number of bits per key is determined as the number of bits needed to represent the cardinality of the keys plus one.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector``1(Microsoft.ML.StaticPipe.Key{``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToBinaryVector&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToBinaryVector&lt;TKey&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToBinaryVector&lt;TKey&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`1&lt;!!TKey&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBinaryVector(Of TKey) (input As VarVector(Of Key(Of TKey))) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBinaryVector : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key&gt;&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces a vector of bits representing the key in binary form.
            The first value is encoded as all zeros and missing values are encoded as all ones.
            In the case where a vector has multiple keys, the encoded values are concatenated.
            Number of bits per key is determined as the number of bits needed to represent the cardinality of the keys plus one.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToBinaryVector&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBinaryVector&lt;TKey&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBinaryVector&lt;TKey&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`1&lt;!!TKey&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBinaryVector(Of TKey) (input As Vector(Of Key(Of TKey))) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBinaryVector : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces a vector of bits representing the key in binary form.
            The first value is encoded as all zeros and missing values are encoded as all ones.
            In the case where a vector has multiple keys, the encoded values are concatenated.
            Number of bits per key is determined as the number of bits needed to represent the cardinality of the keys plus one.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToBinaryVector&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBinaryVector&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBinaryVector&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector``2(Microsoft.ML.StaticPipe.Key{``0,``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBinaryVector(Of TKey, TValue) (input As Key(Of TKey, TValue)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBinaryVector : Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces a vector of bits representing the key in binary form.
            The first value is encoded as all zeros and missing values are encoded as all ones.
            In the case where a vector has multiple keys, the encoded values are concatenated.
            Number of bits per key is determined as the number of bits needed to represent the cardinality of the keys plus one.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector``2(Microsoft.ML.StaticPipe.Key{``0,``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToBinaryVector&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToBinaryVector&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToBinaryVector&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBinaryVector(Of TKey, TValue) (input As VarVector(Of Key(Of TKey, TValue))) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBinaryVector : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt;&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces a vector of bits representing the key in binary form.
            The first value is encoded as all zeros and missing values are encoded as all ones.
            In the case where a vector has multiple keys, the encoded values are concatenated.
            Number of bits per key is determined as the number of bits needed to represent the cardinality of the keys plus one.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToBinaryVector&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBinaryVector&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBinaryVector&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBinaryVector(Of TKey, TValue) (input As Vector(Of Key(Of TKey, TValue))) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBinaryVector : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces a vector of bits representing the key in binary form.
            The first value is encoded as all zeros and missing values are encoded as all ones.
            In the case where a vector has multiple keys, the encoded values are concatenated.
            Number of bits per key is determined as the number of bits needed to represent the cardinality of the keys plus one.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToBinaryVectorStaticExtensions.ToBinaryVector``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToValue&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;TValue&gt; ToValue&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;!!TValue&gt; ToValue&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.Key{``0,``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToValue(Of TKey, TValue) (input As Key(Of TKey, TValue)) As Scalar(Of TValue)" />
        <MemberSignature Language="F#" Value="static member ToValue : Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;'Value&gt;" Usage="Microsoft.ML.StaticPipe.KeyToValueStaticExtensions.ToValue input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;TValue&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Convert a key column to a column containing the corresponding value.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToValueStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.Key{``0,``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToValue&lt;TOuterKey,TInnerKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;TInnerKey&gt; ToValue&lt;TOuterKey,TInnerKey&gt; (this Microsoft.ML.StaticPipe.Key&lt;TOuterKey,Microsoft.ML.StaticPipe.Key&lt;TInnerKey&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`1&lt;!!TInnerKey&gt; ToValue&lt;TOuterKey, TInnerKey&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!TOuterKey, class Microsoft.ML.StaticPipe.Key`1&lt;!!TInnerKey&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.Key{``0,Microsoft.ML.StaticPipe.Key{``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToValue(Of TOuterKey, TInnerKey) (input As Key(Of TOuterKey, Key(Of TInnerKey))) As Key(Of TInnerKey)" />
        <MemberSignature Language="F#" Value="static member ToValue : Microsoft.ML.StaticPipe.Key&lt;'OuterKey, Microsoft.ML.StaticPipe.Key&lt;'InnerKey&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Key&lt;'InnerKey&gt;" Usage="Microsoft.ML.StaticPipe.KeyToValueStaticExtensions.ToValue input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;TInnerKey&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TOuterKey" />
          <TypeParameter Name="TInnerKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;TOuterKey,Microsoft.ML.StaticPipe.Key&lt;TInnerKey&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TOuterKey">To be added.</typeparam>
          <typeparam name="TInnerKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Convert a key column to a column containing the corresponding value.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToValueStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.Key{``0,Microsoft.ML.StaticPipe.Key{``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToValue&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;TValue&gt; ToValue&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;!!TValue&gt; ToValue&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToValue(Of TKey, TValue) (input As VarVector(Of Key(Of TKey, TValue))) As VarVector(Of TValue)" />
        <MemberSignature Language="F#" Value="static member ToValue : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt;&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;'Value&gt;" Usage="Microsoft.ML.StaticPipe.KeyToValueStaticExtensions.ToValue input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;TValue&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Convert a key column to a column containing the corresponding value.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToValueStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToValue&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;TValue&gt; ToValue&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;!!TValue&gt; ToValue&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToValue(Of TKey, TValue) (input As Vector(Of Key(Of TKey, TValue))) As Vector(Of TValue)" />
        <MemberSignature Language="F#" Value="static member ToValue : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;'Value&gt;" Usage="Microsoft.ML.StaticPipe.KeyToValueStaticExtensions.ToValue input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;TValue&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Convert a key column to a column containing the corresponding value.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToValueStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToBaggedVector&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBaggedVector&lt;TKey&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBaggedVector&lt;TKey&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`1&lt;!!TKey&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToBaggedVector``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBaggedVector(Of TKey) (input As VarVector(Of Key(Of TKey))) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBaggedVector : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToBaggedVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            In this case then the indicator vectors for all values in the column will be simply added together,
            to produce the final vector with type equal to the key cardinality; so, in all cases, whether vector or scalar,
            the output column will be a vector type of length equal to that cardinality.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToBaggedVector``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToBaggedVector&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBaggedVector&lt;TKey&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBaggedVector&lt;TKey&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`1&lt;!!TKey&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToBaggedVector``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBaggedVector(Of TKey) (input As Vector(Of Key(Of TKey))) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBaggedVector : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToBaggedVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            In this case then the indicator vectors for all values in the column will be simply added together,
            to produce the final vector with type equal to the key cardinality; so, in all cases, whether vector or scalar,
            the output column will be a vector type of length equal to that cardinality.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToBaggedVector``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToBaggedVector&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBaggedVector&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBaggedVector&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToBaggedVector``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBaggedVector(Of TKey, TValue) (input As VarVector(Of Key(Of TKey, TValue))) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBaggedVector : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToBaggedVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            In this case then the indicator vectors for all values in the column will be simply added together,
            to produce the final vector with type equal to the key cardinality; so, in all cases, whether vector or scalar,
            the output column will be a vector type of length equal to that cardinality.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToBaggedVector``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToBaggedVector&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBaggedVector&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBaggedVector&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToBaggedVector``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBaggedVector(Of TKey, TValue) (input As Vector(Of Key(Of TKey, TValue))) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBaggedVector : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToBaggedVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            In this case then the indicator vectors for all values in the column will be simply added together,
            to produce the final vector with type equal to the key cardinality; so, in all cases, whether vector or scalar,
            the output column will be a vector type of length equal to that cardinality.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToBaggedVector``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`1" />
      </Targets>
      <Member MemberName="ToVector&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToVector&lt;TKey&gt; (this Microsoft.ML.StaticPipe.Key&lt;TKey&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToVector&lt;TKey&gt;(class Microsoft.ML.StaticPipe.Key`1&lt;!!TKey&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector``1(Microsoft.ML.StaticPipe.Key{``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToVector(Of TKey) (input As Key(Of TKey)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToVector : Microsoft.ML.StaticPipe.Key&lt;'Key&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;TKey&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector``1(Microsoft.ML.StaticPipe.Key{``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToVector&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToVector&lt;TKey&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToVector&lt;TKey&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`1&lt;!!TKey&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToVector(Of TKey) (input As VarVector(Of Key(Of TKey))) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToVector : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key&gt;&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            In this case then the indicator vectors for all values in the column will be simply added together,
            to produce the final vector with type equal to the key cardinality; so, in all cases, whether vector or scalar,
            the output column will be a vector type of length equal to that cardinality.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToVector&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToVector&lt;TKey&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToVector&lt;TKey&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`1&lt;!!TKey&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToVector(Of TKey) (input As Vector(Of Key(Of TKey))) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToVector : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToVector&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToVector&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToVector&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector``2(Microsoft.ML.StaticPipe.Key{``0,``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToVector(Of TKey, TValue) (input As Key(Of TKey, TValue)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToVector : Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector``2(Microsoft.ML.StaticPipe.Key{``0,``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToVector&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToVector&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToVector&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToVector(Of TKey, TValue) (input As VarVector(Of Key(Of TKey, TValue))) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToVector : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt;&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            In this case then the indicator vectors for all values in the column will be simply added together,
            to produce the final vector with type equal to the key cardinality; so, in all cases, whether vector or scalar,
            the output column will be a vector type of length equal to that cardinality.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToVector&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToVector&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToVector&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToVector(Of TKey, TValue) (input As Vector(Of Key(Of TKey, TValue))) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToVector : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.KeyToVectorStaticExtensions.ToVector``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.ClusteringContext.ClusteringTrainers" />
      </Targets>
      <Member MemberName="KMeans">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;float&gt;,Microsoft.ML.StaticPipe.Key&lt;uint&gt;&gt; KMeans (this Microsoft.ML.ClusteringContext.ClusteringTrainers ctx, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, int clustersCount = 5, Action&lt;Microsoft.ML.Trainers.KMeans.KMeansPlusPlusTrainer.Arguments&gt; advancedSettings = null, Action&lt;Microsoft.ML.Trainers.KMeans.KMeansModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Key`1&lt;unsigned int32&gt;&gt; KMeans(class Microsoft.ML.ClusteringContext/ClusteringTrainers ctx, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, int32 clustersCount, class System.Action`1&lt;class Microsoft.ML.Trainers.KMeans.KMeansPlusPlusTrainer/Arguments&gt; advancedSettings, class System.Action`1&lt;class Microsoft.ML.Trainers.KMeans.KMeansModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.KMeansClusteringExtensions.KMeans(Microsoft.ML.ClusteringContext.ClusteringTrainers,Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Action{Microsoft.ML.Trainers.KMeans.KMeansPlusPlusTrainer.Arguments},System.Action{Microsoft.ML.Trainers.KMeans.KMeansModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function KMeans (ctx As ClusteringContext.ClusteringTrainers, features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional clustersCount As Integer = 5, Optional advancedSettings As Action(Of KMeansPlusPlusTrainer.Arguments) = null, Optional onFit As Action(Of KMeansModelParameters) = null) As ValueTuple(Of Vector(Of Single), Key(Of UInteger))" />
        <MemberSignature Language="F#" Value="static member KMeans : Microsoft.ML.ClusteringContext.ClusteringTrainers * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * int * Action&lt;Microsoft.ML.Trainers.KMeans.KMeansPlusPlusTrainer.Arguments&gt; * Action&lt;Microsoft.ML.Trainers.KMeans.KMeansModelParameters&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;single&gt;, Microsoft.ML.StaticPipe.Key&lt;uint32&gt;&gt;" Usage="Microsoft.ML.StaticPipe.KMeansClusteringExtensions.KMeans (ctx, features, weights, clustersCount, advancedSettings, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Key&lt;System.UInt32&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.ClusteringContext+ClusteringTrainers" RefType="this" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="clustersCount" Type="System.Int32" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.KMeans.KMeansPlusPlusTrainer+Arguments&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.KMeans.KMeansModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The regression context trainer object.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="clustersCount">The number of clusters to use for KMeans.</param>
          <param name="advancedSettings">Algorithm advanced settings.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained.  Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
            KMeans <see cref="T:Microsoft.ML.ClusteringContext" /> extension method.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.KMeansClusteringExtensions" Member="M:Microsoft.ML.StaticPipe.KMeansClusteringExtensions.KMeans(Microsoft.ML.ClusteringContext.ClusteringTrainers,Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Action{Microsoft.ML.Trainers.KMeans.KMeansPlusPlusTrainer.Arguments},System.Action{Microsoft.ML.Trainers.KMeans.KMeansModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="LogisticRegressionBinaryClassifier">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; LogisticRegressionBinaryClassifier (this Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers ctx, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, float l1Weight = 1, float l2Weight = 1, float optimizationTolerance = 1E-07, int memorySize = 20, bool enoforceNoNegativity = false, Action&lt;Microsoft.ML.Learners.LogisticRegression.Arguments&gt; advancedSettings = null, Action&lt;Microsoft.ML.Internal.Calibration.ParameterMixingCalibratedPredictor&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; LogisticRegressionBinaryClassifier(class Microsoft.ML.BinaryClassificationContext/BinaryClassificationTrainers ctx, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, float32 l1Weight, float32 l2Weight, float32 optimizationTolerance, int32 memorySize, bool enoforceNoNegativity, class System.Action`1&lt;class Microsoft.ML.Learners.LogisticRegression/Arguments&gt; advancedSettings, class System.Action`1&lt;class Microsoft.ML.Internal.Calibration.ParameterMixingCalibratedPredictor&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.LbfgsBinaryClassificationStaticExtensions.LogisticRegressionBinaryClassifier(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Single,System.Single,System.Single,System.Int32,System.Boolean,System.Action{Microsoft.ML.Learners.LogisticRegression.Arguments},System.Action{Microsoft.ML.Internal.Calibration.ParameterMixingCalibratedPredictor})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LogisticRegressionBinaryClassifier (ctx As BinaryClassificationContext.BinaryClassificationTrainers, label As Scalar(Of Boolean), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional l1Weight As Single = 1, Optional l2Weight As Single = 1, Optional optimizationTolerance As Single = 1E-07, Optional memorySize As Integer = 20, Optional enoforceNoNegativity As Boolean = false, Optional advancedSettings As Action(Of LogisticRegression.Arguments) = null, Optional onFit As Action(Of ParameterMixingCalibratedPredictor) = null) As ValueTuple(Of Scalar(Of Single), Scalar(Of Single), Scalar(Of Boolean))" />
        <MemberSignature Language="F#" Value="static member LogisticRegressionBinaryClassifier : Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * single * single * single * int * bool * Action&lt;Microsoft.ML.Learners.LogisticRegression.Arguments&gt; * Action&lt;Microsoft.ML.Internal.Calibration.ParameterMixingCalibratedPredictor&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.LbfgsBinaryClassificationStaticExtensions.LogisticRegressionBinaryClassifier (ctx, label, features, weights, l1Weight, l2Weight, optimizationTolerance, memorySize, enoforceNoNegativity, advancedSettings, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "probability", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="l1Weight" Type="System.Single" />
          <Parameter Name="l2Weight" Type="System.Single" />
          <Parameter Name="optimizationTolerance" Type="System.Single" />
          <Parameter Name="memorySize" Type="System.Int32" />
          <Parameter Name="enoforceNoNegativity" Type="System.Boolean" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Learners.LogisticRegression+Arguments&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Internal.Calibration.ParameterMixingCalibratedPredictor&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The binary classificaiton context trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="l1Weight">Weight of L1 regularization term.</param>
          <param name="l2Weight">Weight of L2 regularization term.</param>
          <param name="optimizationTolerance">Threshold for optimizer convergence.</param>
          <param name="memorySize">Memory size for <see cref="T:Microsoft.ML.Learners.LogisticRegression" />. Low=faster, less accurate.</param>
          <param name="enoforceNoNegativity">Enforce non-negative weights.</param>
          <param name="advancedSettings">A delegate to apply all the advanced arguments to the algorithm.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained.  Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
             Predict a target using a linear binary classification model trained with the <see cref="T:Microsoft.ML.Learners.LogisticRegression" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.LbfgsBinaryClassificationStaticExtensions" Member="M:Microsoft.ML.StaticPipe.LbfgsBinaryClassificationStaticExtensions.LogisticRegressionBinaryClassifier(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Single,System.Single,System.Single,System.Int32,System.Boolean,System.Action{Microsoft.ML.Learners.LogisticRegression.Arguments},System.Action{Microsoft.ML.Internal.Calibration.ParameterMixingCalibratedPredictor})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="MultiClassLogisticRegression&lt;TVal&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;float&gt;,Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt;&gt; MultiClassLogisticRegression&lt;TVal&gt; (this Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers ctx, Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, float l1Weight = 1, float l2Weight = 1, float optimizationTolerance = 1E-07, int memorySize = 20, bool enoforceNoNegativity = false, Action&lt;Microsoft.ML.Learners.LogisticRegression.Arguments&gt; advancedSettings = null, Action&lt;Microsoft.ML.Learners.MulticlassLogisticRegressionModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt;&gt; MultiClassLogisticRegression&lt;TVal&gt;(class Microsoft.ML.MulticlassClassificationContext/MulticlassClassificationTrainers ctx, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, float32 l1Weight, float32 l2Weight, float32 optimizationTolerance, int32 memorySize, bool enoforceNoNegativity, class System.Action`1&lt;class Microsoft.ML.Learners.LogisticRegression/Arguments&gt; advancedSettings, class System.Action`1&lt;class Microsoft.ML.Learners.MulticlassLogisticRegressionModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.LbfgsMulticlassExtensions.MultiClassLogisticRegression``1(Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Single,System.Single,System.Single,System.Int32,System.Boolean,System.Action{Microsoft.ML.Learners.LogisticRegression.Arguments},System.Action{Microsoft.ML.Learners.MulticlassLogisticRegressionModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function MultiClassLogisticRegression(Of TVal) (ctx As MulticlassClassificationContext.MulticlassClassificationTrainers, label As Key(Of UInteger, TVal), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional l1Weight As Single = 1, Optional l2Weight As Single = 1, Optional optimizationTolerance As Single = 1E-07, Optional memorySize As Integer = 20, Optional enoforceNoNegativity As Boolean = false, Optional advancedSettings As Action(Of LogisticRegression.Arguments) = null, Optional onFit As Action(Of MulticlassLogisticRegressionModelParameters) = null) As ValueTuple(Of Vector(Of Single), Key(Of UInteger, TVal))" />
        <MemberSignature Language="F#" Value="static member MultiClassLogisticRegression : Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers * Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * single * single * single * int * bool * Action&lt;Microsoft.ML.Learners.LogisticRegression.Arguments&gt; * Action&lt;Microsoft.ML.Learners.MulticlassLogisticRegressionModelParameters&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;single&gt;, Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt;&gt;" Usage="Microsoft.ML.StaticPipe.LbfgsMulticlassExtensions.MultiClassLogisticRegression (ctx, label, features, weights, l1Weight, l2Weight, optimizationTolerance, memorySize, enoforceNoNegativity, advancedSettings, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TVal" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.MulticlassClassificationContext+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="l1Weight" Type="System.Single" />
          <Parameter Name="l2Weight" Type="System.Single" />
          <Parameter Name="optimizationTolerance" Type="System.Single" />
          <Parameter Name="memorySize" Type="System.Int32" />
          <Parameter Name="enoforceNoNegativity" Type="System.Boolean" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Learners.LogisticRegression+Arguments&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Learners.MulticlassLogisticRegressionModelParameters&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TVal">To be added.</typeparam>
          <param name="ctx">The multiclass classification context trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="l1Weight">Weight of L1 regularization term.</param>
          <param name="l2Weight">Weight of L2 regularization term.</param>
          <param name="optimizationTolerance">Threshold for optimizer convergence.</param>
          <param name="memorySize">Memory size for <see cref="T:Microsoft.ML.Learners.LogisticRegression" />. Low=faster, less accurate.</param>
          <param name="enoforceNoNegativity">Enforce non-negative weights.</param>
          <param name="advancedSettings">A delegate to apply all the advanced arguments to the algorithm.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear multiclass classification model trained with the <see cref="T:Microsoft.ML.Learners.MulticlassLogisticRegression" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.LbfgsMulticlassExtensions" Member="M:Microsoft.ML.StaticPipe.LbfgsMulticlassExtensions.MultiClassLogisticRegression``1(Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Single,System.Single,System.Single,System.Int32,System.Boolean,System.Action{Microsoft.ML.Learners.LogisticRegression.Arguments},System.Action{Microsoft.ML.Learners.MulticlassLogisticRegressionModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionContext.RegressionTrainers" />
      </Targets>
      <Member MemberName="PoissonRegression">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; PoissonRegression (this Microsoft.ML.RegressionContext.RegressionTrainers ctx, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, float l1Weight = 1, float l2Weight = 1, float optimizationTolerance = 1E-07, int memorySize = 20, bool enoforceNoNegativity = false, Action&lt;Microsoft.ML.Learners.LogisticRegression.Arguments&gt; advancedSettings = null, Action&lt;Microsoft.ML.Learners.PoissonRegressionModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; PoissonRegression(class Microsoft.ML.RegressionContext/RegressionTrainers ctx, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, float32 l1Weight, float32 l2Weight, float32 optimizationTolerance, int32 memorySize, bool enoforceNoNegativity, class System.Action`1&lt;class Microsoft.ML.Learners.LogisticRegression/Arguments&gt; advancedSettings, class System.Action`1&lt;class Microsoft.ML.Learners.PoissonRegressionModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.LbfgsRegressionExtensions.PoissonRegression(Microsoft.ML.RegressionContext.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Single,System.Single,System.Single,System.Int32,System.Boolean,System.Action{Microsoft.ML.Learners.LogisticRegression.Arguments},System.Action{Microsoft.ML.Learners.PoissonRegressionModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function PoissonRegression (ctx As RegressionContext.RegressionTrainers, label As Scalar(Of Single), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional l1Weight As Single = 1, Optional l2Weight As Single = 1, Optional optimizationTolerance As Single = 1E-07, Optional memorySize As Integer = 20, Optional enoforceNoNegativity As Boolean = false, Optional advancedSettings As Action(Of LogisticRegression.Arguments) = null, Optional onFit As Action(Of PoissonRegressionModelParameters) = null) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member PoissonRegression : Microsoft.ML.RegressionContext.RegressionTrainers * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * single * single * single * int * bool * Action&lt;Microsoft.ML.Learners.LogisticRegression.Arguments&gt; * Action&lt;Microsoft.ML.Learners.PoissonRegressionModelParameters&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.LbfgsRegressionExtensions.PoissonRegression (ctx, label, features, weights, l1Weight, l2Weight, optimizationTolerance, memorySize, enoforceNoNegativity, advancedSettings, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RegressionContext+RegressionTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="l1Weight" Type="System.Single" />
          <Parameter Name="l2Weight" Type="System.Single" />
          <Parameter Name="optimizationTolerance" Type="System.Single" />
          <Parameter Name="memorySize" Type="System.Int32" />
          <Parameter Name="enoforceNoNegativity" Type="System.Boolean" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Learners.LogisticRegression+Arguments&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Learners.PoissonRegressionModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The regression context trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="l1Weight">Weight of L1 regularization term.</param>
          <param name="l2Weight">Weight of L2 regularization term.</param>
          <param name="optimizationTolerance">Threshold for optimizer convergence.</param>
          <param name="memorySize">Memory size for <see cref="T:Microsoft.ML.Learners.LogisticRegression" />. Low=faster, less accurate.</param>
          <param name="enoforceNoNegativity">Enforce non-negative weights.</param>
          <param name="advancedSettings">A delegate to apply all the advanced arguments to the algorithm.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained.  Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear regression model trained with the <see cref="T:Microsoft.ML.Learners.LogisticRegression" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.LbfgsRegressionExtensions" Member="M:Microsoft.ML.StaticPipe.LbfgsRegressionExtensions.PoissonRegression(Microsoft.ML.RegressionContext.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Single,System.Single,System.Single,System.Int32,System.Boolean,System.Action{Microsoft.ML.Learners.LogisticRegression.Arguments},System.Action{Microsoft.ML.Learners.PoissonRegressionModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToLdaTopicVector">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToLdaTopicVector (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, int numTopic = 100, float alphaSum = 100, float beta = 0.01, int mhstep = 4, int numIterations = 200, int likelihoodInterval = 5, int numThreads = 0, int numMaxDocToken = 512, int numSummaryTermPerTopic = 10, int numBurninIterations = 10, bool resetRandomGenerator = false, Microsoft.ML.StaticPipe.LdaFitResult.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToLdaTopicVector(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, int32 numTopic, float32 alphaSum, float32 beta, int32 mhstep, int32 numIterations, int32 likelihoodInterval, int32 numThreads, int32 numMaxDocToken, int32 numSummaryTermPerTopic, int32 numBurninIterations, bool resetRandomGenerator, class Microsoft.ML.StaticPipe.LdaFitResult/OnFit onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.LdaStaticExtensions.ToLdaTopicVector(Microsoft.ML.StaticPipe.Vector{System.Single},System.Int32,System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,Microsoft.ML.StaticPipe.LdaFitResult.OnFit)" />
        <MemberSignature Language="F#" Value="static member ToLdaTopicVector : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * int * single * single * int * int * int * int * int * int * int * bool * Microsoft.ML.StaticPipe.LdaFitResult.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.LdaStaticExtensions.ToLdaTopicVector (input, numTopic, alphaSum, beta, mhstep, numIterations, likelihoodInterval, numThreads, numMaxDocToken, numSummaryTermPerTopic, numBurninIterations, resetRandomGenerator, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="numTopic" Type="System.Int32" />
          <Parameter Name="alphaSum" Type="System.Single" />
          <Parameter Name="beta" Type="System.Single" />
          <Parameter Name="mhstep" Type="System.Int32" />
          <Parameter Name="numIterations" Type="System.Int32" />
          <Parameter Name="likelihoodInterval" Type="System.Int32" />
          <Parameter Name="numThreads" Type="System.Int32" />
          <Parameter Name="numMaxDocToken" Type="System.Int32" />
          <Parameter Name="numSummaryTermPerTopic" Type="System.Int32" />
          <Parameter Name="numBurninIterations" Type="System.Int32" />
          <Parameter Name="resetRandomGenerator" Type="System.Boolean" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.LdaFitResult+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">A vector of floats representing the document.</param>
          <param name="numTopic">The number of topics.</param>
          <param name="alphaSum">Dirichlet prior on document-topic vectors.</param>
          <param name="beta">Dirichlet prior on vocab-topic vectors.</param>
          <param name="mhstep">Number of Metropolis Hasting step.</param>
          <param name="numIterations">Number of iterations.</param>
          <param name="likelihoodInterval">Compute log likelihood over local dataset on this iteration interval.</param>
          <param name="numThreads">The number of training threads. Default value depends on number of logical processors.</param>
          <param name="numMaxDocToken">The threshold of maximum count of tokens per doc.</param>
          <param name="numSummaryTermPerTopic">The number of words to summarize the topic.</param>
          <param name="numBurninIterations">The number of burn-in iterations.</param>
          <param name="resetRandomGenerator">Reset the random number generator for each document.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
        The LDA transform implements LightLDA, a state-of-the-art implementation of Latent Dirichlet Allocation.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.LdaStaticExtensions" Member="M:Microsoft.ML.StaticPipe.LdaStaticExtensions.ToLdaTopicVector(Microsoft.ML.StaticPipe.Vector{System.Single},System.Int32,System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,Microsoft.ML.StaticPipe.LdaFitResult.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.IDataReader`1" />
      </Targets>
      <Member MemberName="Read">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.IDataView Read (this Microsoft.ML.Core.Data.IDataReader&lt;Microsoft.ML.Data.IMultiStreamSource&gt; reader, params string[] path);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.IDataView Read(class Microsoft.ML.Core.Data.IDataReader`1&lt;class Microsoft.ML.Data.IMultiStreamSource&gt; reader, string[] path) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.LocalPathReader.Read(Microsoft.ML.Core.Data.IDataReader{Microsoft.ML.Data.IMultiStreamSource},System.String[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Read (reader As IDataReader(Of IMultiStreamSource), ParamArray path As String()) As IDataView" />
        <MemberSignature Language="F#" Value="static member Read : Microsoft.ML.Core.Data.IDataReader&lt;Microsoft.ML.Data.IMultiStreamSource&gt; * string[] -&gt; Microsoft.ML.Data.IDataView" Usage="Microsoft.ML.StaticPipe.LocalPathReader.Read (reader, path)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.IDataView</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="Microsoft.ML.Core.Data.IDataReader&lt;Microsoft.ML.Data.IMultiStreamSource&gt;" RefType="this" />
          <Parameter Name="path" Type="System.String[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <param name="path">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.LocalPathReader" Member="M:Microsoft.ML.StaticPipe.LocalPathReader.Read(Microsoft.ML.Core.Data.IDataReader{Microsoft.ML.Data.IMultiStreamSource},System.String[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.DataReader`2" />
      </Targets>
      <Member MemberName="Read&lt;TShape&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.DataView&lt;TShape&gt; Read&lt;TShape&gt; (this Microsoft.ML.StaticPipe.DataReader&lt;Microsoft.ML.Data.IMultiStreamSource,TShape&gt; reader, params string[] path);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.DataView`1&lt;!!TShape&gt; Read&lt;TShape&gt;(class Microsoft.ML.StaticPipe.DataReader`2&lt;class Microsoft.ML.Data.IMultiStreamSource, !!TShape&gt; reader, string[] path) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.LocalPathReader.Read``1(Microsoft.ML.StaticPipe.DataReader{Microsoft.ML.Data.IMultiStreamSource,``0},System.String[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Read(Of TShape) (reader As DataReader(Of IMultiStreamSource, TShape), ParamArray path As String()) As DataView(Of TShape)" />
        <MemberSignature Language="F#" Value="static member Read : Microsoft.ML.StaticPipe.DataReader&lt;Microsoft.ML.Data.IMultiStreamSource, 'Shape&gt; * string[] -&gt; Microsoft.ML.StaticPipe.DataView&lt;'Shape&gt;" Usage="Microsoft.ML.StaticPipe.LocalPathReader.Read (reader, path)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.DataView&lt;TShape&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TShape" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="reader" Type="Microsoft.ML.StaticPipe.DataReader&lt;Microsoft.ML.Data.IMultiStreamSource,TShape&gt;" RefType="this" />
          <Parameter Name="path" Type="System.String[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="TShape">To be added.</typeparam>
          <param name="reader">To be added.</param>
          <param name="path">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.LocalPathReader" Member="M:Microsoft.ML.StaticPipe.LocalPathReader.Read``1(Microsoft.ML.StaticPipe.DataReader{Microsoft.ML.Data.IMultiStreamSource,``0},System.String[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="LpNormalize">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; LpNormalize (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, Microsoft.ML.Transforms.Projections.LpNormalizingEstimatorBase.NormalizerKind normKind = Microsoft.ML.Transforms.Projections.LpNormalizingEstimatorBase+NormalizerKind.L2Norm, bool subMean = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; LpNormalize(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, valuetype Microsoft.ML.Transforms.Projections.LpNormalizingEstimatorBase/NormalizerKind normKind, bool subMean) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.LpNormalizerStaticExtensions.LpNormalize(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.Transforms.Projections.LpNormalizingEstimatorBase.NormalizerKind,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LpNormalize (input As Vector(Of Single), Optional normKind As LpNormalizingEstimatorBase.NormalizerKind = Microsoft.ML.Transforms.Projections.LpNormalizingEstimatorBase+NormalizerKind.L2Norm, Optional subMean As Boolean = false) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member LpNormalize : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.Transforms.Projections.LpNormalizingEstimatorBase.NormalizerKind * bool -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.LpNormalizerStaticExtensions.LpNormalize (input, normKind, subMean)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="normKind" Type="Microsoft.ML.Transforms.Projections.LpNormalizingEstimatorBase+NormalizerKind" />
          <Parameter Name="subMean" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="normKind">Type of norm to use to normalize each sample.</param>
          <param name="subMean">Subtract mean from each value before normalizing.</param>
          <summary>
         The LpNormalizer transforms, normalizes vectors (rows) individually by rescaling them to unit norm (L2, L1 or LInf). 
         <para>Performs the following operation on a vector X:</para><para>Y = (X - M) / D</para><para>where M is mean and D is either L2 norm, L1 norm or LInf norm.</para></summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.LpNormalizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.LpNormalizerStaticExtensions.LpNormalize(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.Transforms.Projections.LpNormalizingEstimatorBase.NormalizerKind,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionContext.RegressionTrainers" />
      </Targets>
      <Member MemberName="MatrixFactorization&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; MatrixFactorization&lt;T&gt; (this Microsoft.ML.RegressionContext.RegressionTrainers ctx, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; label, Microsoft.ML.StaticPipe.Key&lt;T&gt; matrixColumnIndex, Microsoft.ML.StaticPipe.Key&lt;T&gt; matrixRowIndex, float regularizationCoefficient = 0.1, int approximationRank = 8, float learningRate = 0.1, int numIterations = 20, Action&lt;Microsoft.ML.Trainers.MatrixFactorizationTrainer.Arguments&gt; advancedSettings = null, Action&lt;Microsoft.ML.Trainers.Recommender.MatrixFactorizationPredictor&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; MatrixFactorization&lt;T&gt;(class Microsoft.ML.RegressionContext/RegressionTrainers ctx, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; label, class Microsoft.ML.StaticPipe.Key`1&lt;!!T&gt; matrixColumnIndex, class Microsoft.ML.StaticPipe.Key`1&lt;!!T&gt; matrixRowIndex, float32 regularizationCoefficient, int32 approximationRank, float32 learningRate, int32 numIterations, class System.Action`1&lt;class Microsoft.ML.Trainers.MatrixFactorizationTrainer/Arguments&gt; advancedSettings, class System.Action`1&lt;class Microsoft.ML.Trainers.Recommender.MatrixFactorizationPredictor&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.MatrixFactorizationExtensions.MatrixFactorization``1(Microsoft.ML.RegressionContext.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Key{``0},Microsoft.ML.StaticPipe.Key{``0},System.Single,System.Int32,System.Single,System.Int32,System.Action{Microsoft.ML.Trainers.MatrixFactorizationTrainer.Arguments},System.Action{Microsoft.ML.Trainers.Recommender.MatrixFactorizationPredictor})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function MatrixFactorization(Of T) (ctx As RegressionContext.RegressionTrainers, label As Scalar(Of Single), matrixColumnIndex As Key(Of T), matrixRowIndex As Key(Of T), Optional regularizationCoefficient As Single = 0.1, Optional approximationRank As Integer = 8, Optional learningRate As Single = 0.1, Optional numIterations As Integer = 20, Optional advancedSettings As Action(Of MatrixFactorizationTrainer.Arguments) = null, Optional onFit As Action(Of MatrixFactorizationPredictor) = null) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member MatrixFactorization : Microsoft.ML.RegressionContext.RegressionTrainers * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.StaticPipe.Key&lt;'T&gt; * Microsoft.ML.StaticPipe.Key&lt;'T&gt; * single * int * single * int * Action&lt;Microsoft.ML.Trainers.MatrixFactorizationTrainer.Arguments&gt; * Action&lt;Microsoft.ML.Trainers.Recommender.MatrixFactorizationPredictor&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.MatrixFactorizationExtensions.MatrixFactorization (ctx, label, matrixColumnIndex, matrixRowIndex, regularizationCoefficient, approximationRank, learningRate, numIterations, advancedSettings, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RegressionContext+RegressionTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="matrixColumnIndex" Type="Microsoft.ML.StaticPipe.Key&lt;T&gt;" />
          <Parameter Name="matrixRowIndex" Type="Microsoft.ML.StaticPipe.Key&lt;T&gt;" />
          <Parameter Name="regularizationCoefficient" Type="System.Single" />
          <Parameter Name="approximationRank" Type="System.Int32" />
          <Parameter Name="learningRate" Type="System.Single" />
          <Parameter Name="numIterations" Type="System.Int32" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.MatrixFactorizationTrainer+Arguments&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.Recommender.MatrixFactorizationPredictor&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="T">The type of physical value of matrix's row and column index. It must be an integer type such as uint.</typeparam>
          <param name="ctx">The regression context trainer object.</param>
          <param name="label">The label variable.</param>
          <param name="matrixColumnIndex">The column index of the considered matrix.</param>
          <param name="matrixRowIndex">The row index of the considered matrix.</param>
          <param name="regularizationCoefficient">The frobenius norms of factor matrices.</param>
          <param name="approximationRank">Rank of the two factor matrices whose product is used to approximate the consdered matrix</param>
          <param name="learningRate">Initial learning rate.</param>
          <param name="numIterations">Number of training iterations.</param>
          <param name="advancedSettings">A delegate to set more settings.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the model that was trained.  Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
            Predict matrix entry using matrix factorization
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.MatrixFactorizationExtensions" Member="M:Microsoft.ML.StaticPipe.MatrixFactorizationExtensions.MatrixFactorization``1(Microsoft.ML.RegressionContext.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Key{``0},Microsoft.ML.StaticPipe.Key{``0},System.Single,System.Int32,System.Single,System.Int32,System.Action{Microsoft.ML.Trainers.MatrixFactorizationTrainer.Arguments},System.Action{Microsoft.ML.Trainers.Recommender.MatrixFactorizationPredictor})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="MultiClassNaiveBayesTrainer&lt;TVal&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;float&gt;,Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt;&gt; MultiClassNaiveBayesTrainer&lt;TVal&gt; (this Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers ctx, Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Action&lt;Microsoft.ML.Trainers.MultiClassNaiveBayesModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt;&gt; MultiClassNaiveBayesTrainer&lt;TVal&gt;(class Microsoft.ML.MulticlassClassificationContext/MulticlassClassificationTrainers ctx, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class System.Action`1&lt;class Microsoft.ML.Trainers.MultiClassNaiveBayesModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.MultiClassClassificationStaticExtensions.MultiClassNaiveBayesTrainer``1(Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},System.Action{Microsoft.ML.Trainers.MultiClassNaiveBayesModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function MultiClassNaiveBayesTrainer(Of TVal) (ctx As MulticlassClassificationContext.MulticlassClassificationTrainers, label As Key(Of UInteger, TVal), features As Vector(Of Single), Optional onFit As Action(Of MultiClassNaiveBayesModelParameters) = null) As ValueTuple(Of Vector(Of Single), Key(Of UInteger, TVal))" />
        <MemberSignature Language="F#" Value="static member MultiClassNaiveBayesTrainer : Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers * Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Action&lt;Microsoft.ML.Trainers.MultiClassNaiveBayesModelParameters&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;single&gt;, Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt;&gt;" Usage="Microsoft.ML.StaticPipe.MultiClassClassificationStaticExtensions.MultiClassNaiveBayesTrainer (ctx, label, features, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TVal" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.MulticlassClassificationContext+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.MultiClassNaiveBayesModelParameters&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TVal">To be added.</typeparam>
          <param name="ctx">The multiclass classification context trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear multiclass classification model trained with the <see cref="M:Microsoft.ML.StaticPipe.MultiClassClassificationStaticExtensions.MultiClassNaiveBayesTrainer``1(Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},System.Action{Microsoft.ML.Trainers.MultiClassNaiveBayesModelParameters})" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.MultiClassClassificationStaticExtensions" Member="M:Microsoft.ML.StaticPipe.MultiClassClassificationStaticExtensions.MultiClassNaiveBayesTrainer``1(Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},System.Action{Microsoft.ML.Trainers.MultiClassNaiveBayesModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnMutualInformation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;bool&gt; SelectFeaturesBasedOnMutualInformation (this Microsoft.ML.StaticPipe.Vector&lt;bool&gt; input, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; labelColumn, int slotsInOutput = 1000, int numBins = 256);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;bool&gt; SelectFeaturesBasedOnMutualInformation(class Microsoft.ML.StaticPipe.Vector`1&lt;bool&gt; input, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; labelColumn, int32 slotsInOutput, int32 numBins) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Boolean},Microsoft.ML.StaticPipe.Scalar{System.Boolean},System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnMutualInformation (input As Vector(Of Boolean), labelColumn As Scalar(Of Boolean), Optional slotsInOutput As Integer = 1000, Optional numBins As Integer = 256) As Vector(Of Boolean)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnMutualInformation : Microsoft.ML.StaticPipe.Vector&lt;bool&gt; * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * int * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;bool&gt;" Usage="Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation (input, labelColumn, slotsInOutput, numBins)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Boolean&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Boolean&gt;" RefType="this" />
          <Parameter Name="labelColumn" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="slotsInOutput" Type="System.Int32" />
          <Parameter Name="numBins" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">Name of the input column.</param>
          <param name="labelColumn">Name of the column to use for labels.</param>
          <param name="slotsInOutput">The maximum number of slots to preserve in the output. The number of slots to preserve is taken across all input columns.</param>
          <param name="numBins">Max number of bins used to approximate mutual information between each input column and the label column. Power of 2 recommended.</param>
          <summary>
        Selects the top k slots across all specified columns ordered by their mutual information with the label column.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Boolean},Microsoft.ML.StaticPipe.Scalar{System.Boolean},System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnMutualInformation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;bool&gt; SelectFeaturesBasedOnMutualInformation (this Microsoft.ML.StaticPipe.Vector&lt;bool&gt; input, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; labelColumn, int slotsInOutput = 1000, int numBins = 256);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;bool&gt; SelectFeaturesBasedOnMutualInformation(class Microsoft.ML.StaticPipe.Vector`1&lt;bool&gt; input, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; labelColumn, int32 slotsInOutput, int32 numBins) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Boolean},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnMutualInformation (input As Vector(Of Boolean), labelColumn As Scalar(Of Single), Optional slotsInOutput As Integer = 1000, Optional numBins As Integer = 256) As Vector(Of Boolean)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnMutualInformation : Microsoft.ML.StaticPipe.Vector&lt;bool&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * int * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;bool&gt;" Usage="Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation (input, labelColumn, slotsInOutput, numBins)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Boolean&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Boolean&gt;" RefType="this" />
          <Parameter Name="labelColumn" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="slotsInOutput" Type="System.Int32" />
          <Parameter Name="numBins" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">Name of the input column.</param>
          <param name="labelColumn">Name of the column to use for labels.</param>
          <param name="slotsInOutput">The maximum number of slots to preserve in the output. The number of slots to preserve is taken across all input columns.</param>
          <param name="numBins">Max number of bins used to approximate mutual information between each input column and the label column. Power of 2 recommended.</param>
          <summary>
        Selects the top k slots across all specified columns ordered by their mutual information with the label column.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Boolean},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnMutualInformation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;double&gt; SelectFeaturesBasedOnMutualInformation (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; labelColumn, int slotsInOutput = 1000, int numBins = 256);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; SelectFeaturesBasedOnMutualInformation(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; labelColumn, int32 slotsInOutput, int32 numBins) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Double},Microsoft.ML.StaticPipe.Scalar{System.Boolean},System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnMutualInformation (input As Vector(Of Double), labelColumn As Scalar(Of Boolean), Optional slotsInOutput As Integer = 1000, Optional numBins As Integer = 256) As Vector(Of Double)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnMutualInformation : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * int * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;double&gt;" Usage="Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation (input, labelColumn, slotsInOutput, numBins)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="labelColumn" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="slotsInOutput" Type="System.Int32" />
          <Parameter Name="numBins" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">Name of the input column.</param>
          <param name="labelColumn">Name of the column to use for labels.</param>
          <param name="slotsInOutput">The maximum number of slots to preserve in the output. The number of slots to preserve is taken across all input columns.</param>
          <param name="numBins">Max number of bins used to approximate mutual information between each input column and the label column. Power of 2 recommended.</param>
          <summary>
        Selects the top k slots across all specified columns ordered by their mutual information with the label column.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Double},Microsoft.ML.StaticPipe.Scalar{System.Boolean},System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnMutualInformation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;double&gt; SelectFeaturesBasedOnMutualInformation (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; labelColumn, int slotsInOutput = 1000, int numBins = 256);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; SelectFeaturesBasedOnMutualInformation(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; labelColumn, int32 slotsInOutput, int32 numBins) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Double},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnMutualInformation (input As Vector(Of Double), labelColumn As Scalar(Of Single), Optional slotsInOutput As Integer = 1000, Optional numBins As Integer = 256) As Vector(Of Double)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnMutualInformation : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * int * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;double&gt;" Usage="Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation (input, labelColumn, slotsInOutput, numBins)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="labelColumn" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="slotsInOutput" Type="System.Int32" />
          <Parameter Name="numBins" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">Name of the input column.</param>
          <param name="labelColumn">Name of the column to use for labels.</param>
          <param name="slotsInOutput">The maximum number of slots to preserve in the output. The number of slots to preserve is taken across all input columns.</param>
          <param name="numBins">Max number of bins used to approximate mutual information between each input column and the label column. Power of 2 recommended.</param>
          <summary>
        Selects the top k slots across all specified columns ordered by their mutual information with the label column.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Double},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnMutualInformation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; SelectFeaturesBasedOnMutualInformation (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; labelColumn, int slotsInOutput = 1000, int numBins = 256);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; SelectFeaturesBasedOnMutualInformation(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; labelColumn, int32 slotsInOutput, int32 numBins) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Boolean},System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnMutualInformation (input As Vector(Of Single), labelColumn As Scalar(Of Boolean), Optional slotsInOutput As Integer = 1000, Optional numBins As Integer = 256) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnMutualInformation : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * int * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation (input, labelColumn, slotsInOutput, numBins)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="labelColumn" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="slotsInOutput" Type="System.Int32" />
          <Parameter Name="numBins" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">Name of the input column.</param>
          <param name="labelColumn">Name of the column to use for labels.</param>
          <param name="slotsInOutput">The maximum number of slots to preserve in the output. The number of slots to preserve is taken across all input columns.</param>
          <param name="numBins">Max number of bins used to approximate mutual information between each input column and the label column. Power of 2 recommended.</param>
          <summary>
        Selects the top k slots across all specified columns ordered by their mutual information with the label column.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Boolean},System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnMutualInformation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; SelectFeaturesBasedOnMutualInformation (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; labelColumn, int slotsInOutput = 1000, int numBins = 256);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; SelectFeaturesBasedOnMutualInformation(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; labelColumn, int32 slotsInOutput, int32 numBins) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnMutualInformation (input As Vector(Of Single), labelColumn As Scalar(Of Single), Optional slotsInOutput As Integer = 1000, Optional numBins As Integer = 256) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnMutualInformation : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * int * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation (input, labelColumn, slotsInOutput, numBins)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="labelColumn" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="slotsInOutput" Type="System.Int32" />
          <Parameter Name="numBins" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">Name of the input column.</param>
          <param name="labelColumn">Name of the column to use for labels.</param>
          <param name="slotsInOutput">The maximum number of slots to preserve in the output. The number of slots to preserve is taken across all input columns.</param>
          <param name="numBins">Max number of bins used to approximate mutual information between each input column and the label column. Power of 2 recommended.</param>
          <summary>
        Selects the top k slots across all specified columns ordered by their mutual information with the label column.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.MutualInformationFeatureSelectorStaticExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="IsMissingValue">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; IsMissingValue (this Microsoft.ML.StaticPipe.Scalar&lt;double&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; IsMissingValue(class Microsoft.ML.StaticPipe.Scalar`1&lt;float64&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue(Microsoft.ML.StaticPipe.Scalar{System.Double})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsMissingValue (input As Scalar(Of Double)) As Scalar(Of Boolean)" />
        <MemberSignature Language="F#" Value="static member IsMissingValue : Microsoft.ML.StaticPipe.Scalar&lt;double&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;" Usage="Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Double&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Produces a column of boolean entries indicating whether input column entries were missing.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue(Microsoft.ML.StaticPipe.Scalar{System.Double})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="IsMissingValue">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; IsMissingValue (this Microsoft.ML.StaticPipe.Scalar&lt;float&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; IsMissingValue(class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue(Microsoft.ML.StaticPipe.Scalar{System.Single})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsMissingValue (input As Scalar(Of Single)) As Scalar(Of Boolean)" />
        <MemberSignature Language="F#" Value="static member IsMissingValue : Microsoft.ML.StaticPipe.Scalar&lt;single&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;" Usage="Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Produces a column of boolean entries indicating whether input column entries were missing.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue(Microsoft.ML.StaticPipe.Scalar{System.Single})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="IsMissingValue">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;bool&gt; IsMissingValue (this Microsoft.ML.StaticPipe.VarVector&lt;double&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;bool&gt; IsMissingValue(class Microsoft.ML.StaticPipe.VarVector`1&lt;float64&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue(Microsoft.ML.StaticPipe.VarVector{System.Double})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsMissingValue (input As VarVector(Of Double)) As VarVector(Of Boolean)" />
        <MemberSignature Language="F#" Value="static member IsMissingValue : Microsoft.ML.StaticPipe.VarVector&lt;double&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;bool&gt;" Usage="Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Boolean&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Double&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Produces a column of boolean entries indicating whether input column entries were missing.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue(Microsoft.ML.StaticPipe.VarVector{System.Double})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="IsMissingValue">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;bool&gt; IsMissingValue (this Microsoft.ML.StaticPipe.VarVector&lt;float&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;bool&gt; IsMissingValue(class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue(Microsoft.ML.StaticPipe.VarVector{System.Single})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsMissingValue (input As VarVector(Of Single)) As VarVector(Of Boolean)" />
        <MemberSignature Language="F#" Value="static member IsMissingValue : Microsoft.ML.StaticPipe.VarVector&lt;single&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;bool&gt;" Usage="Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Boolean&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Produces a column of boolean entries indicating whether input column entries were missing.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue(Microsoft.ML.StaticPipe.VarVector{System.Single})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="IsMissingValue">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;bool&gt; IsMissingValue (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;bool&gt; IsMissingValue(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue(Microsoft.ML.StaticPipe.Vector{System.Double})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsMissingValue (input As Vector(Of Double)) As Vector(Of Boolean)" />
        <MemberSignature Language="F#" Value="static member IsMissingValue : Microsoft.ML.StaticPipe.Vector&lt;double&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;bool&gt;" Usage="Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Boolean&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Produces a column of boolean entries indicating whether input column entries were missing.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue(Microsoft.ML.StaticPipe.Vector{System.Double})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="IsMissingValue">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;bool&gt; IsMissingValue (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;bool&gt; IsMissingValue(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue(Microsoft.ML.StaticPipe.Vector{System.Single})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsMissingValue (input As Vector(Of Single)) As Vector(Of Boolean)" />
        <MemberSignature Language="F#" Value="static member IsMissingValue : Microsoft.ML.StaticPipe.Vector&lt;single&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;bool&gt;" Usage="Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Boolean&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <summary>
            Produces a column of boolean entries indicating whether input column entries were missing.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NAIndicatorStaticExtensions.IsMissingValue(Microsoft.ML.StaticPipe.Vector{System.Single})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ReplaceNaNValues">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;double&gt; ReplaceNaNValues (this Microsoft.ML.StaticPipe.Scalar&lt;double&gt; input, Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode replacementMode = Microsoft.ML.Transforms.MissingValueReplacingTransformer+ColumnInfo+ReplacementMode.DefaultValue);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float64&gt; ReplaceNaNValues(class Microsoft.ML.StaticPipe.Scalar`1&lt;float64&gt; input, valuetype Microsoft.ML.Transforms.MissingValueReplacingTransformer/ColumnInfo/ReplacementMode replacementMode) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.Scalar{System.Double},Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode)" />
        <MemberSignature Language="F#" Value="static member ReplaceNaNValues : Microsoft.ML.StaticPipe.Scalar&lt;double&gt; * Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode -&gt; Microsoft.ML.StaticPipe.Scalar&lt;double&gt;" Usage="Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues (input, replacementMode)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="replacementMode" Type="Microsoft.ML.Transforms.MissingValueReplacingTransformer+ColumnInfo+ReplacementMode" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="replacementMode">How NaN should be replaced</param>
          <summary>
            Scan through all rows and replace NaN values according to replacement strategy.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NAReplacerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.Scalar{System.Double},Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ReplaceNaNValues">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; ReplaceNaNValues (this Microsoft.ML.StaticPipe.Scalar&lt;float&gt; input, Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode replacementMode = Microsoft.ML.Transforms.MissingValueReplacingTransformer+ColumnInfo+ReplacementMode.DefaultValue);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; ReplaceNaNValues(class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; input, valuetype Microsoft.ML.Transforms.MissingValueReplacingTransformer/ColumnInfo/ReplacementMode replacementMode) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode)" />
        <MemberSignature Language="F#" Value="static member ReplaceNaNValues : Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues (input, replacementMode)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="replacementMode" Type="Microsoft.ML.Transforms.MissingValueReplacingTransformer+ColumnInfo+ReplacementMode" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="replacementMode">How NaN should be replaced</param>
          <summary>
            Scan through all rows and replace NaN values according to replacement strategy.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NAReplacerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ReplaceNaNValues">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;double&gt; ReplaceNaNValues (this Microsoft.ML.StaticPipe.VarVector&lt;double&gt; input, Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode replacementMode = Microsoft.ML.Transforms.MissingValueReplacingTransformer+ColumnInfo+ReplacementMode.DefaultValue);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float64&gt; ReplaceNaNValues(class Microsoft.ML.StaticPipe.VarVector`1&lt;float64&gt; input, valuetype Microsoft.ML.Transforms.MissingValueReplacingTransformer/ColumnInfo/ReplacementMode replacementMode) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.VarVector{System.Double},Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode)" />
        <MemberSignature Language="F#" Value="static member ReplaceNaNValues : Microsoft.ML.StaticPipe.VarVector&lt;double&gt; * Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode -&gt; Microsoft.ML.StaticPipe.VarVector&lt;double&gt;" Usage="Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues (input, replacementMode)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="replacementMode" Type="Microsoft.ML.Transforms.MissingValueReplacingTransformer+ColumnInfo+ReplacementMode" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="replacementMode">How NaN should be replaced</param>
          <summary>
            Scan through all rows and replace NaN values according to replacement strategy.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NAReplacerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.VarVector{System.Double},Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ReplaceNaNValues">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ReplaceNaNValues (this Microsoft.ML.StaticPipe.VarVector&lt;float&gt; input, Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode replacementMode = Microsoft.ML.Transforms.MissingValueReplacingTransformer+ColumnInfo+ReplacementMode.DefaultValue);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ReplaceNaNValues(class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; input, valuetype Microsoft.ML.Transforms.MissingValueReplacingTransformer/ColumnInfo/ReplacementMode replacementMode) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.VarVector{System.Single},Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode)" />
        <MemberSignature Language="F#" Value="static member ReplaceNaNValues : Microsoft.ML.StaticPipe.VarVector&lt;single&gt; * Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues (input, replacementMode)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="replacementMode" Type="Microsoft.ML.Transforms.MissingValueReplacingTransformer+ColumnInfo+ReplacementMode" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="replacementMode">How NaN should be replaced</param>
          <summary>
            Scan through all rows and replace NaN values according to replacement strategy.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NAReplacerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.VarVector{System.Single},Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ReplaceNaNValues">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;double&gt; ReplaceNaNValues (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode replacementMode = Microsoft.ML.Transforms.MissingValueReplacingTransformer+ColumnInfo+ReplacementMode.DefaultValue, bool imputeBySlot = true);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; ReplaceNaNValues(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, valuetype Microsoft.ML.Transforms.MissingValueReplacingTransformer/ColumnInfo/ReplacementMode replacementMode, bool imputeBySlot) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.Vector{System.Double},Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode,System.Boolean)" />
        <MemberSignature Language="F#" Value="static member ReplaceNaNValues : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode * bool -&gt; Microsoft.ML.StaticPipe.Vector&lt;double&gt;" Usage="Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues (input, replacementMode, imputeBySlot)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="replacementMode" Type="Microsoft.ML.Transforms.MissingValueReplacingTransformer+ColumnInfo+ReplacementMode" />
          <Parameter Name="imputeBySlot" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="replacementMode">How NaN should be replaced</param>
          <param name="imputeBySlot">If true, per-slot imputation of replacement is performed.
            Otherwise, replacement value is imputed for the entire vector column. This setting is ignored for scalars and variable vectors,
            where imputation is always for the entire column.</param>
          <summary>
            Scan through all rows and replace NaN values according to replacement strategy.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NAReplacerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.Vector{System.Double},Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ReplaceNaNValues">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ReplaceNaNValues (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode replacementMode = Microsoft.ML.Transforms.MissingValueReplacingTransformer+ColumnInfo+ReplacementMode.DefaultValue, bool imputeBySlot = true);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ReplaceNaNValues(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, valuetype Microsoft.ML.Transforms.MissingValueReplacingTransformer/ColumnInfo/ReplacementMode replacementMode, bool imputeBySlot) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode,System.Boolean)" />
        <MemberSignature Language="F#" Value="static member ReplaceNaNValues : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode * bool -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues (input, replacementMode, imputeBySlot)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="replacementMode" Type="Microsoft.ML.Transforms.MissingValueReplacingTransformer+ColumnInfo+ReplacementMode" />
          <Parameter Name="imputeBySlot" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="replacementMode">How NaN should be replaced</param>
          <param name="imputeBySlot">If true, per-slot imputation of replacement is performed.
            Otherwise, replacement value is imputed for the entire vector column. This setting is ignored for scalars and variable vectors,
            where imputation is always for the entire column.</param>
          <summary>
            Scan through all rows and replace NaN values according to replacement strategy.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NAReplacerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NAReplacerStaticExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.Transforms.MissingValueReplacingTransformer.ColumnInfo.ReplacementMode,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToNgrams&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToNgrams&lt;TKey&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,string&gt;&gt; input, int ngramLength = 1, int skipLength = 0, bool allLengths = true, int maxNumTerms = 10000000, Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria weighting = Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria.Tf);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToNgrams&lt;TKey&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, string&gt;&gt; input, int32 ngramLength, int32 skipLength, bool allLengths, int32 maxNumTerms, valuetype Microsoft.ML.Transforms.Text.NgramExtractingEstimator/WeightingCriteria weighting) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NgramEstimatorStaticExtensions.ToNgrams``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.String}},System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToNgrams(Of TKey) (input As VarVector(Of Key(Of TKey, String)), Optional ngramLength As Integer = 1, Optional skipLength As Integer = 0, Optional allLengths As Boolean = true, Optional maxNumTerms As Integer = 10000000, Optional weighting As NgramExtractingEstimator.WeightingCriteria = Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria.Tf) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToNgrams : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, string&gt;&gt; * int * int * bool * int * Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.NgramEstimatorStaticExtensions.ToNgrams (input, ngramLength, skipLength, allLengths, maxNumTerms, weighting)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,System.String&gt;&gt;" RefType="this" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="allLengths" Type="System.Boolean" />
          <Parameter Name="maxNumTerms" Type="System.Int32" />
          <Parameter Name="weighting" Type="Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">The column to apply to.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="allLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="maxNumTerms">Maximum number of ngrams to store in the dictionary.</param>
          <param name="weighting">Statistical measure used to evaluate how important a word is to a document in a corpus.</param>
          <summary>
             Produces a bag of counts of ngrams (sequences of consecutive words ) in a given tokenized text.
             It does so by building a dictionary of ngrams and using the id in the dictionary as the index in the bag.
            
             /// <see cref="M:Microsoft.ML.StaticPipe.NgramEstimatorStaticExtensions.ToNgrams``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.String}},System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" /> is different from <see cref="M:Microsoft.ML.StaticPipe.WordBagEstimatorStaticExtensions.ToBagofWords(Microsoft.ML.StaticPipe.Scalar{System.String},System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
             in a way that <see cref="M:Microsoft.ML.StaticPipe.NgramEstimatorStaticExtensions.ToNgrams``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.String}},System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" /> takes tokenized text as input while <see cref="M:Microsoft.ML.StaticPipe.WordBagEstimatorStaticExtensions.ToBagofWords(Microsoft.ML.StaticPipe.Scalar{System.String},System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" /> tokenizes text internally.
             </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NgramEstimatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NgramEstimatorStaticExtensions.ToNgrams``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.String}},System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToNgramsHash">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToNgramsHash (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,string&gt;&gt; input, int hashBits = 16, int ngramLength = 2, int skipLength = 0, bool allLengths = true, uint seed = 314489979, bool ordered = true, int invertHash = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToNgramsHash(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, string&gt;&gt; input, int32 hashBits, int32 ngramLength, int32 skipLength, bool allLengths, unsigned int32 seed, bool ordered, int32 invertHash) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NgramHashEstimatorStaticExtensions.ToNgramsHash(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{System.UInt32,System.String}},System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToNgramsHash (input As VarVector(Of Key(Of UInteger, String)), Optional hashBits As Integer = 16, Optional ngramLength As Integer = 2, Optional skipLength As Integer = 0, Optional allLengths As Boolean = true, Optional seed As UInteger = 314489979, Optional ordered As Boolean = true, Optional invertHash As Integer = 0) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToNgramsHash : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, string&gt;&gt; * int * int * int * bool * uint32 * bool * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.NgramHashEstimatorStaticExtensions.ToNgramsHash (input, hashBits, ngramLength, skipLength, allLengths, seed, ordered, invertHash)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.String&gt;&gt;" RefType="this" />
          <Parameter Name="hashBits" Type="System.Int32" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="allLengths" Type="System.Boolean" />
          <Parameter Name="seed" Type="System.UInt32" />
          <Parameter Name="ordered" Type="System.Boolean" />
          <Parameter Name="invertHash" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="hashBits">Number of bits to hash into. Must be between 1 and 30, inclusive.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="allLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="seed">Hashing seed.</param>
          <param name="ordered">Whether the position of each source column should be included in the hash (when there are multiple source columns).</param>
          <param name="invertHash">During hashing we constuct mappings between original values and the produced hash values.
             Text representation of original values are stored in the slot names of the  metadata for the new column.Hashing, as such, can map many initial values to one.
             <paramref name="invertHash" /> specifies the upper bound of the number of distinct input values mapping to a hash that should be retained.
             <value>0</value> does not retain any input values. <value>-1</value> retains all input values mapping to each hash.</param>
          <summary>
             Produces a bag of counts of ngrams (sequences of consecutive words of length 1-n) in a given tokenized text.
             It does so by hashing each ngram and using the hash value as the index in the bag.
            
             <see cref="M:Microsoft.ML.StaticPipe.NgramHashEstimatorStaticExtensions.ToNgramsHash(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{System.UInt32,System.String}},System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" /> is different from <see cref="M:Microsoft.ML.StaticPipe.WordHashBagEstimatorStaticExtensions.ToBagofHashedWords(Microsoft.ML.StaticPipe.Scalar{System.String},System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
             in a way that <see cref="M:Microsoft.ML.StaticPipe.NgramHashEstimatorStaticExtensions.ToNgramsHash(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{System.UInt32,System.String}},System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" /> takes tokenized text as input while <see cref="M:Microsoft.ML.StaticPipe.WordHashBagEstimatorStaticExtensions.ToBagofHashedWords(Microsoft.ML.StaticPipe.Scalar{System.String},System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" /> tokenizes text internally.
             </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NgramHashEstimatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NgramHashEstimatorStaticExtensions.ToNgramsHash(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{System.UInt32,System.String}},System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="Normalize">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;double&gt; Normalize (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, bool fixZero = true, long maxTrainingExamples = 1000000000, Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;double&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;float64&gt; Normalize(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, bool fixZero, int64 maxTrainingExamples, class Microsoft.ML.StaticPipe.NormalizerStaticExtensions/OnFitAffine`1&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;float64&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.Normalize(Microsoft.ML.StaticPipe.Vector{System.Double},System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Double}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Normalize (input As Vector(Of Double), Optional fixZero As Boolean = true, Optional maxTrainingExamples As Long = 1000000000, Optional onFit As NormalizerStaticExtensions.OnFitAffine(Of ImmutableArray(Of Double)) = null) As NormVector(Of Double)" />
        <MemberSignature Language="F#" Value="static member Normalize : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * bool * int64 * Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;double&gt;&gt; -&gt; Microsoft.ML.StaticPipe.NormVector&lt;double&gt;" Usage="Microsoft.ML.StaticPipe.NormalizerStaticExtensions.Normalize (input, fixZero, maxTrainingExamples, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="fixZero" Type="System.Boolean" />
          <Parameter Name="maxTrainingExamples" Type="System.Int64" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions+OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;System.Double&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="fixZero">If set to <c>false</c>, then the observed minimum and maximum during fitting
            will map to -1 and 1 respectively, exactly. If however set to <c>true</c>, then 0 will always map to 0.
            This is valuable for the sake of sparsity preservation, if normalizing sparse vectors.</param>
          <param name="maxTrainingExamples">When gathering statistics only look at most this many examples.</param>
          <param name="onFit">A delegate called whenever the estimator is fit, with the learned slopes
            and, if <paramref name="fixZero" /> is <c>false</c>, the offsets as well.</param>
          <summary>
            Learns an affine function based on the minimum and maximum, so that all values between the minimum and
            maximum observed during fitting fall into the range of -1 to 1.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.Normalize(Microsoft.ML.StaticPipe.Vector{System.Double},System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Double}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="Normalize">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;float&gt; Normalize (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, bool fixZero = true, long maxTrainingExamples = 1000000000, Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;float&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;float32&gt; Normalize(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, bool fixZero, int64 maxTrainingExamples, class Microsoft.ML.StaticPipe.NormalizerStaticExtensions/OnFitAffine`1&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;float32&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.Normalize(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Single}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Normalize (input As Vector(Of Single), Optional fixZero As Boolean = true, Optional maxTrainingExamples As Long = 1000000000, Optional onFit As NormalizerStaticExtensions.OnFitAffine(Of ImmutableArray(Of Single)) = null) As NormVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member Normalize : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * bool * int64 * Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;single&gt;&gt; -&gt; Microsoft.ML.StaticPipe.NormVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.NormalizerStaticExtensions.Normalize (input, fixZero, maxTrainingExamples, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="fixZero" Type="System.Boolean" />
          <Parameter Name="maxTrainingExamples" Type="System.Int64" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions+OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;System.Single&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="fixZero">If set to <c>false</c>, then the observed minimum and maximum during fitting
            will map to -1 and 1 respectively, exactly. If however set to <c>true</c>, then 0 will always map to 0.
            This is valuable for the sake of sparsity preservation, if normalizing sparse vectors.</param>
          <param name="maxTrainingExamples">When gathering statistics only look at most this many examples.</param>
          <param name="onFit">A delegate that can be called whenever the function is fit, with the learned slopes
            and, if <paramref name="fixZero" /> is <c>false</c>, the offsets as well.</param>
          <summary>
            Learns an affine function based on the minimum and maximum, so that all values between the minimum and
            maximum observed during fitting fall into the range of -1 to 1.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.Normalize(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Single}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="NormalizeByBinning">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;double&gt; NormalizeByBinning (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, int maxBins = 1024, bool fixZero = true, long maxTrainingExamples = 1000000000, Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitBinned&lt;System.Collections.Immutable.ImmutableArray&lt;double&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;float64&gt; NormalizeByBinning(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, int32 maxBins, bool fixZero, int64 maxTrainingExamples, class Microsoft.ML.StaticPipe.NormalizerStaticExtensions/OnFitBinned`1&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;float64&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByBinning(Microsoft.ML.StaticPipe.Vector{System.Double},System.Int32,System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitBinned{System.Collections.Immutable.ImmutableArray{System.Double}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeByBinning (input As Vector(Of Double), Optional maxBins As Integer = 1024, Optional fixZero As Boolean = true, Optional maxTrainingExamples As Long = 1000000000, Optional onFit As NormalizerStaticExtensions.OnFitBinned(Of ImmutableArray(Of Double)) = null) As NormVector(Of Double)" />
        <MemberSignature Language="F#" Value="static member NormalizeByBinning : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * int * bool * int64 * Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitBinned&lt;System.Collections.Immutable.ImmutableArray&lt;double&gt;&gt; -&gt; Microsoft.ML.StaticPipe.NormVector&lt;double&gt;" Usage="Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByBinning (input, maxBins, fixZero, maxTrainingExamples, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="maxBins" Type="System.Int32" />
          <Parameter Name="fixZero" Type="System.Boolean" />
          <Parameter Name="maxTrainingExamples" Type="System.Int64" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions+OnFitBinned&lt;System.Collections.Immutable.ImmutableArray&lt;System.Double&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="maxBins">The maximum number of discretization points to learn per slot.</param>
          <param name="fixZero">Normally the output is in the range of 0 to 1, but if set to <c>true</c>, then what
            would have been the output for a zero input is subtracted off the value.
            This is valuable for the sake of sparsity preservation, if normalizing sparse vectors.</param>
          <param name="maxTrainingExamples">When gathering statistics only look at most this many examples.</param>
          <param name="onFit">A delegate called whenever the estimator is fit, with the bin upper bounds for each slot.</param>
          <summary>
            Learns a function based on a discretization of the input values. The observed values for each slot are
            analyzed, and the range of numbers is partitioned into monotonically increasing bins. An attempt is made
            to make these bins equal in population, but under some circumstances this may be impossible (for example, a slot
            with a very dominant mode). The way the mapping works is, if there are <c>N</c> bins in a slot, and a value
            falls in the range of bin <c>n</c> (indexed from 0), the output value is <c>n / (N - 1)</c>, and then possibly
            subtracting off the binned value for what 0 would have been if <paramref name="fixZero" /> is true.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByBinning(Microsoft.ML.StaticPipe.Vector{System.Double},System.Int32,System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitBinned{System.Collections.Immutable.ImmutableArray{System.Double}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="NormalizeByBinning">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;float&gt; NormalizeByBinning (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, int maxBins = 1024, bool fixZero = true, long maxTrainingExamples = 1000000000, Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitBinned&lt;System.Collections.Immutable.ImmutableArray&lt;float&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;float32&gt; NormalizeByBinning(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, int32 maxBins, bool fixZero, int64 maxTrainingExamples, class Microsoft.ML.StaticPipe.NormalizerStaticExtensions/OnFitBinned`1&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;float32&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByBinning(Microsoft.ML.StaticPipe.Vector{System.Single},System.Int32,System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitBinned{System.Collections.Immutable.ImmutableArray{System.Single}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeByBinning (input As Vector(Of Single), Optional maxBins As Integer = 1024, Optional fixZero As Boolean = true, Optional maxTrainingExamples As Long = 1000000000, Optional onFit As NormalizerStaticExtensions.OnFitBinned(Of ImmutableArray(Of Single)) = null) As NormVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member NormalizeByBinning : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * int * bool * int64 * Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitBinned&lt;System.Collections.Immutable.ImmutableArray&lt;single&gt;&gt; -&gt; Microsoft.ML.StaticPipe.NormVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByBinning (input, maxBins, fixZero, maxTrainingExamples, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="maxBins" Type="System.Int32" />
          <Parameter Name="fixZero" Type="System.Boolean" />
          <Parameter Name="maxTrainingExamples" Type="System.Int64" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions+OnFitBinned&lt;System.Collections.Immutable.ImmutableArray&lt;System.Single&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="maxBins">The maximum number of discretization points to learn per slot.</param>
          <param name="fixZero">Normally the output is in the range of 0 to 1, but if set to <c>true</c>, then what
            would have been the output for a zero input is subtracted off the value.
            This is valuable for the sake of sparsity preservation, if normalizing sparse vectors.</param>
          <param name="maxTrainingExamples">When gathering statistics only look at most this many examples.</param>
          <param name="onFit">A delegate called whenever the estimator is fit, with the bin upper bounds for each slot.</param>
          <summary>
            Learns a function based on a discretization of the input values. The observed values for each slot are
            analyzed, and the range of numbers is partitioned into monotonically increasing bins. An attempt is made
            to make these bins equal in population, but under some circumstances this may be impossible (for example, a slot
            with a very dominant mode). The way the mapping works is, if there are <c>N</c> bins in a slot, and a value
            falls in the range of bin <c>n</c> (indexed from 0), the output value is <c>n / (N - 1)</c>, and then possibly
            subtracting off the binned value for what 0 would have been if <paramref name="fixZero" /> is true.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByBinning(Microsoft.ML.StaticPipe.Vector{System.Single},System.Int32,System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitBinned{System.Collections.Immutable.ImmutableArray{System.Single}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="NormalizeByCumulativeDistribution">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;double&gt; NormalizeByCumulativeDistribution (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, bool fixZero = true, bool useLog = false, long maxTrainingExamples = 1000000000, Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitCumulativeDistribution&lt;System.Collections.Immutable.ImmutableArray&lt;double&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;float64&gt; NormalizeByCumulativeDistribution(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, bool fixZero, bool useLog, int64 maxTrainingExamples, class Microsoft.ML.StaticPipe.NormalizerStaticExtensions/OnFitCumulativeDistribution`1&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;float64&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByCumulativeDistribution(Microsoft.ML.StaticPipe.Vector{System.Double},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitCumulativeDistribution{System.Collections.Immutable.ImmutableArray{System.Double}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeByCumulativeDistribution (input As Vector(Of Double), Optional fixZero As Boolean = true, Optional useLog As Boolean = false, Optional maxTrainingExamples As Long = 1000000000, Optional onFit As NormalizerStaticExtensions.OnFitCumulativeDistribution(Of ImmutableArray(Of Double)) = null) As NormVector(Of Double)" />
        <MemberSignature Language="F#" Value="static member NormalizeByCumulativeDistribution : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * bool * bool * int64 * Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitCumulativeDistribution&lt;System.Collections.Immutable.ImmutableArray&lt;double&gt;&gt; -&gt; Microsoft.ML.StaticPipe.NormVector&lt;double&gt;" Usage="Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByCumulativeDistribution (input, fixZero, useLog, maxTrainingExamples, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="fixZero" Type="System.Boolean" />
          <Parameter Name="useLog" Type="System.Boolean" />
          <Parameter Name="maxTrainingExamples" Type="System.Int64" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions+OnFitCumulativeDistribution&lt;System.Collections.Immutable.ImmutableArray&lt;System.Double&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="fixZero">If set to <c>false</c>, then the learned distributional parameters will be
            adjusted in such a way as to ensure that the input 0 maps to the output 0.
            This is valuable for the sake of sparsity preservation, if normalizing sparse vectors.</param>
          <param name="useLog">If set to true then we transform over the logarithm of the values, rather
            than just the raw values. If this is set to <c>true</c> then <paramref name="fixZero" /> is ignored.</param>
          <param name="maxTrainingExamples">When gathering statistics only look at most this many examples.</param>
          <param name="onFit">A delegate called whenever the estimator is fit, with the learned mean and standard
            deviation for all slots.</param>
          <summary>
            Learns a function based on the cumulative density function of a normal distribution parameterized by
            a mean and variance as observed during fitting.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByCumulativeDistribution(Microsoft.ML.StaticPipe.Vector{System.Double},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitCumulativeDistribution{System.Collections.Immutable.ImmutableArray{System.Double}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="NormalizeByCumulativeDistribution">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;float&gt; NormalizeByCumulativeDistribution (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, bool fixZero = true, bool useLog = false, long maxTrainingExamples = 1000000000, Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitCumulativeDistribution&lt;System.Collections.Immutable.ImmutableArray&lt;float&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;float32&gt; NormalizeByCumulativeDistribution(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, bool fixZero, bool useLog, int64 maxTrainingExamples, class Microsoft.ML.StaticPipe.NormalizerStaticExtensions/OnFitCumulativeDistribution`1&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;float32&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByCumulativeDistribution(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitCumulativeDistribution{System.Collections.Immutable.ImmutableArray{System.Single}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeByCumulativeDistribution (input As Vector(Of Single), Optional fixZero As Boolean = true, Optional useLog As Boolean = false, Optional maxTrainingExamples As Long = 1000000000, Optional onFit As NormalizerStaticExtensions.OnFitCumulativeDistribution(Of ImmutableArray(Of Single)) = null) As NormVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member NormalizeByCumulativeDistribution : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * bool * bool * int64 * Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitCumulativeDistribution&lt;System.Collections.Immutable.ImmutableArray&lt;single&gt;&gt; -&gt; Microsoft.ML.StaticPipe.NormVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByCumulativeDistribution (input, fixZero, useLog, maxTrainingExamples, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="fixZero" Type="System.Boolean" />
          <Parameter Name="useLog" Type="System.Boolean" />
          <Parameter Name="maxTrainingExamples" Type="System.Int64" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions+OnFitCumulativeDistribution&lt;System.Collections.Immutable.ImmutableArray&lt;System.Single&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="fixZero">If set to <c>false</c>, then the learned distributional parameters will be
            adjusted in such a way as to ensure that the input 0 maps to the output 0.
            This is valuable for the sake of sparsity preservation, if normalizing sparse vectors.</param>
          <param name="useLog">If set to true then we transform over the logarithm of the values, rather
            than just the raw values. If this is set to <c>true</c> then <paramref name="fixZero" /> is ignored.</param>
          <param name="maxTrainingExamples">When gathering statistics only look at most this many examples.</param>
          <param name="onFit">A delegate called whenever the estimator is fit, with the learned mean and standard
            deviation for all slots.</param>
          <summary>
            Learns a function based on the cumulative density function of a normal distribution parameterized by
            a mean and variance as observed during fitting.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByCumulativeDistribution(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitCumulativeDistribution{System.Collections.Immutable.ImmutableArray{System.Single}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="NormalizeByMeanVar">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;double&gt; NormalizeByMeanVar (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, bool fixZero = true, bool useLog = false, long maxTrainingExamples = 1000000000, Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;double&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;float64&gt; NormalizeByMeanVar(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, bool fixZero, bool useLog, int64 maxTrainingExamples, class Microsoft.ML.StaticPipe.NormalizerStaticExtensions/OnFitAffine`1&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;float64&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByMeanVar(Microsoft.ML.StaticPipe.Vector{System.Double},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Double}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeByMeanVar (input As Vector(Of Double), Optional fixZero As Boolean = true, Optional useLog As Boolean = false, Optional maxTrainingExamples As Long = 1000000000, Optional onFit As NormalizerStaticExtensions.OnFitAffine(Of ImmutableArray(Of Double)) = null) As NormVector(Of Double)" />
        <MemberSignature Language="F#" Value="static member NormalizeByMeanVar : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * bool * bool * int64 * Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;double&gt;&gt; -&gt; Microsoft.ML.StaticPipe.NormVector&lt;double&gt;" Usage="Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByMeanVar (input, fixZero, useLog, maxTrainingExamples, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="fixZero" Type="System.Boolean" />
          <Parameter Name="useLog" Type="System.Boolean" />
          <Parameter Name="maxTrainingExamples" Type="System.Int64" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions+OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;System.Double&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="fixZero">If set to <c>true</c> then the offset will always be considered zero.</param>
          <param name="useLog">If set to true then we transform over the logarithm of the values, rather
            than just the raw values. If this is set to <c>true</c> then <paramref name="fixZero" /> is ignored.</param>
          <param name="maxTrainingExamples">When gathering statistics only look at most this many examples.</param>
          <param name="onFit">A delegate called whenever the estimator is fit, with the learned slopes
            and, if <paramref name="fixZero" /> is <c>false</c>, the offsets as well.</param>
          <summary>
            Learns an affine function based on the observed mean and standard deviation. This is less susceptible
            to outliers as compared to <see cref="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.Normalize(Microsoft.ML.StaticPipe.Vector{System.Double},System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Double}})" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByMeanVar(Microsoft.ML.StaticPipe.Vector{System.Double},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Double}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="NormalizeByMeanVar">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;float&gt; NormalizeByMeanVar (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, bool fixZero = true, bool useLog = false, long maxTrainingExamples = 1000000000, Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;float&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;float32&gt; NormalizeByMeanVar(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, bool fixZero, bool useLog, int64 maxTrainingExamples, class Microsoft.ML.StaticPipe.NormalizerStaticExtensions/OnFitAffine`1&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;float32&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByMeanVar(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Single}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeByMeanVar (input As Vector(Of Single), Optional fixZero As Boolean = true, Optional useLog As Boolean = false, Optional maxTrainingExamples As Long = 1000000000, Optional onFit As NormalizerStaticExtensions.OnFitAffine(Of ImmutableArray(Of Single)) = null) As NormVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member NormalizeByMeanVar : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * bool * bool * int64 * Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;single&gt;&gt; -&gt; Microsoft.ML.StaticPipe.NormVector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByMeanVar (input, fixZero, useLog, maxTrainingExamples, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="fixZero" Type="System.Boolean" />
          <Parameter Name="useLog" Type="System.Boolean" />
          <Parameter Name="maxTrainingExamples" Type="System.Int64" />
          <Parameter Name="onFit" Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions+OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;System.Single&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="fixZero">If set to <c>true</c> then the offset will always be considered zero.</param>
          <param name="useLog">If set to true then we transform over the logarithm of the values, rather
            than just the raw values. If this is set to <c>true</c> then <paramref name="fixZero" /> is ignored.</param>
          <param name="maxTrainingExamples">When gathering statistics only look at most this many examples.</param>
          <param name="onFit">A delegate called whenever the estimator is fit, with the learned slopes
            and, if <paramref name="fixZero" /> is <c>false</c>, the offsets as well.</param>
          <summary>
            Learns an affine function based on the observed mean and standard deviation. This is less susceptible
            to outliers as compared to <see cref="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.Normalize(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Single}})" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.NormalizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.NormalizerStaticExtensions.NormalizeByMeanVar(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.StaticPipe.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Single}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionContext.RegressionTrainers" />
      </Targets>
      <Member MemberName="OnlineGradientDescent">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; OnlineGradientDescent (this Microsoft.ML.RegressionContext.RegressionTrainers ctx, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, Microsoft.ML.IRegressionLoss lossFunction = null, float learningRate = 0.1, bool decreaseLearningRate = true, float l2RegularizerWeight = 0, int numIterations = 1, Action&lt;Microsoft.ML.Trainers.Online.AveragedLinearArguments&gt; advancedSettings = null, Action&lt;Microsoft.ML.Learners.LinearRegressionModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; OnlineGradientDescent(class Microsoft.ML.RegressionContext/RegressionTrainers ctx, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, class Microsoft.ML.IRegressionLoss lossFunction, float32 learningRate, bool decreaseLearningRate, float32 l2RegularizerWeight, int32 numIterations, class System.Action`1&lt;class Microsoft.ML.Trainers.Online.AveragedLinearArguments&gt; advancedSettings, class System.Action`1&lt;class Microsoft.ML.Learners.LinearRegressionModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.OnlineGradientDescentExtensions.OnlineGradientDescent(Microsoft.ML.RegressionContext.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.IRegressionLoss,System.Single,System.Boolean,System.Single,System.Int32,System.Action{Microsoft.ML.Trainers.Online.AveragedLinearArguments},System.Action{Microsoft.ML.Learners.LinearRegressionModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OnlineGradientDescent (ctx As RegressionContext.RegressionTrainers, label As Scalar(Of Single), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional lossFunction As IRegressionLoss = null, Optional learningRate As Single = 0.1, Optional decreaseLearningRate As Boolean = true, Optional l2RegularizerWeight As Single = 0, Optional numIterations As Integer = 1, Optional advancedSettings As Action(Of AveragedLinearArguments) = null, Optional onFit As Action(Of LinearRegressionModelParameters) = null) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member OnlineGradientDescent : Microsoft.ML.RegressionContext.RegressionTrainers * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.IRegressionLoss * single * bool * single * int * Action&lt;Microsoft.ML.Trainers.Online.AveragedLinearArguments&gt; * Action&lt;Microsoft.ML.Learners.LinearRegressionModelParameters&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.OnlineGradientDescentExtensions.OnlineGradientDescent (ctx, label, features, weights, lossFunction, learningRate, decreaseLearningRate, l2RegularizerWeight, numIterations, advancedSettings, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RegressionContext+RegressionTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="lossFunction" Type="Microsoft.ML.IRegressionLoss" />
          <Parameter Name="learningRate" Type="System.Single" />
          <Parameter Name="decreaseLearningRate" Type="System.Boolean" />
          <Parameter Name="l2RegularizerWeight" Type="System.Single" />
          <Parameter Name="numIterations" Type="System.Int32" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.Online.AveragedLinearArguments&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Learners.LinearRegressionModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The regression context trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="lossFunction">The custom loss. Defaults to <see cref="T:Microsoft.ML.SquaredLoss" /> if not provided.</param>
          <param name="learningRate">The learning Rate.</param>
          <param name="decreaseLearningRate">Decrease learning rate as iterations progress.</param>
          <param name="l2RegularizerWeight">L2 regularization weight.</param>
          <param name="numIterations">Number of training iterations through the data.</param>
          <param name="advancedSettings">A delegate to supply more advanced arguments to the algorithm.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained, as well as the calibrator on top of that model. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear regression model trained with the <see cref="T:Microsoft.ML.Trainers.Online.OnlineGradientDescentTrainer" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.OnlineGradientDescentExtensions" Member="M:Microsoft.ML.StaticPipe.OnlineGradientDescentExtensions.OnlineGradientDescent(Microsoft.ML.RegressionContext.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.IRegressionLoss,System.Single,System.Boolean,System.Single,System.Int32,System.Action{Microsoft.ML.Trainers.Online.AveragedLinearArguments},System.Action{Microsoft.ML.Learners.LinearRegressionModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToPrincipalComponents">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToPrincipalComponents (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, string weightColumn = null, int rank = 20, int overSampling = 20, bool center = true, Nullable&lt;int&gt; seed = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToPrincipalComponents(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, string weightColumn, int32 rank, int32 overSampling, bool center, valuetype System.Nullable`1&lt;int32&gt; seed) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.PcaEstimatorExtensions.ToPrincipalComponents(Microsoft.ML.StaticPipe.Vector{System.Single},System.String,System.Int32,System.Int32,System.Boolean,System.Nullable{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToPrincipalComponents (input As Vector(Of Single), Optional weightColumn As String = null, Optional rank As Integer = 20, Optional overSampling As Integer = 20, Optional center As Boolean = true, Optional seed As Nullable(Of Integer) = null) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToPrincipalComponents : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * string * int * int * bool * Nullable&lt;int&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.PcaEstimatorExtensions.ToPrincipalComponents (input, weightColumn, rank, overSampling, center, seed)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="weightColumn" Type="System.String" />
          <Parameter Name="rank" Type="System.Int32" />
          <Parameter Name="overSampling" Type="System.Int32" />
          <Parameter Name="center" Type="System.Boolean" />
          <Parameter Name="seed" Type="System.Nullable&lt;System.Int32&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply PCA to.</param>
          <param name="weightColumn">The name of the weight column.</param>
          <param name="rank">The number of components in the PCA.</param>
          <param name="overSampling">Oversampling parameter for randomized PCA training.</param>
          <param name="center">If enabled, data is centered to be zero mean.</param>
          <param name="seed">The seed for random number generation</param>
          <summary>
            Replaces the input vector with its projection to the principal component subspace,
            which can significantly reduce size of vector.
            </summary>
          <summary>
        PCA is a dimensionality-reduction transform which computes the projection of the feature vector onto a low-rank subspace. 
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.PcaEstimatorExtensions" Member="M:Microsoft.ML.StaticPipe.PcaEstimatorExtensions.ToPrincipalComponents(Microsoft.ML.StaticPipe.Vector{System.Single},System.String,System.Int32,System.Int32,System.Boolean,System.Nullable{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="LowerVectorSizeWithRandomFourierTransformation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; LowerVectorSizeWithRandomFourierTransformation (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, int newDim = 1000, bool useSin = false, Microsoft.ML.IComponentFactory&lt;float,Microsoft.ML.Transforms.IFourierDistributionSampler&gt; generator = null, Nullable&lt;int&gt; seed = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; LowerVectorSizeWithRandomFourierTransformation(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, int32 newDim, bool useSin, class Microsoft.ML.IComponentFactory`2&lt;float32, class Microsoft.ML.Transforms.IFourierDistributionSampler&gt; generator, valuetype System.Nullable`1&lt;int32&gt; seed) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.RffStaticExtenensions.LowerVectorSizeWithRandomFourierTransformation(Microsoft.ML.StaticPipe.Vector{System.Single},System.Int32,System.Boolean,Microsoft.ML.IComponentFactory{System.Single,Microsoft.ML.Transforms.IFourierDistributionSampler},System.Nullable{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LowerVectorSizeWithRandomFourierTransformation (input As Vector(Of Single), Optional newDim As Integer = 1000, Optional useSin As Boolean = false, Optional generator As IComponentFactory(Of Single, IFourierDistributionSampler) = null, Optional seed As Nullable(Of Integer) = null) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member LowerVectorSizeWithRandomFourierTransformation : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * int * bool * Microsoft.ML.IComponentFactory&lt;single, Microsoft.ML.Transforms.IFourierDistributionSampler&gt; * Nullable&lt;int&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.RffStaticExtenensions.LowerVectorSizeWithRandomFourierTransformation (input, newDim, useSin, generator, seed)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="newDim" Type="System.Int32" />
          <Parameter Name="useSin" Type="System.Boolean" />
          <Parameter Name="generator" Type="Microsoft.ML.IComponentFactory&lt;System.Single,Microsoft.ML.Transforms.IFourierDistributionSampler&gt;" />
          <Parameter Name="seed" Type="System.Nullable&lt;System.Int32&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply Random Fourier transfomration.</param>
          <param name="newDim">Expected size of new vector.</param>
          <param name="useSin">Create two features for every random Fourier frequency? (one for cos and one for sin) </param>
          <param name="generator">Which kernel to use. (<see cref="T:Microsoft.ML.Transforms.GaussianFourierSampler" /> by default)</param>
          <param name="seed">The seed of the random number generator for generating the new features. If not specified global random would be used.</param>
          <summary>
            It maps input to a random low-dimensional feature space. It is useful when data has non-linear features, since the transform
            is designed so that the inner products of the transformed data are approximately equal to those in the feature space of a user
            speciﬁed shift-invariant kernel. With this transform, we are able to use linear methods (which are scalable) to approximate more complex kernel SVM models.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.RffStaticExtenensions" Member="M:Microsoft.ML.StaticPipe.RffStaticExtenensions.LowerVectorSizeWithRandomFourierTransformation(Microsoft.ML.StaticPipe.Vector{System.Single},System.Int32,System.Boolean,Microsoft.ML.IComponentFactory{System.Single,Microsoft.ML.Transforms.IFourierDistributionSampler},System.Nullable{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="Sdca">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; Sdca (this Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers ctx, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.ISupportSdcaClassificationLoss loss, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, Nullable&lt;float&gt; l2Const = null, Nullable&lt;float&gt; l1Threshold = null, Nullable&lt;int&gt; maxIterations = null, Action&lt;Microsoft.ML.Trainers.SdcaBinaryTrainer.Arguments&gt; advancedSettings = null, Action&lt;Microsoft.ML.Learners.LinearBinaryModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; Sdca(class Microsoft.ML.BinaryClassificationContext/BinaryClassificationTrainers ctx, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.ISupportSdcaClassificationLoss loss, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, valuetype System.Nullable`1&lt;float32&gt; l2Const, valuetype System.Nullable`1&lt;float32&gt; l1Threshold, valuetype System.Nullable`1&lt;int32&gt; maxIterations, class System.Action`1&lt;class Microsoft.ML.Trainers.SdcaBinaryTrainer/Arguments&gt; advancedSettings, class System.Action`1&lt;class Microsoft.ML.Learners.LinearBinaryModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.ISupportSdcaClassificationLoss,Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Trainers.SdcaBinaryTrainer.Arguments},System.Action{Microsoft.ML.Learners.LinearBinaryModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sdca (ctx As BinaryClassificationContext.BinaryClassificationTrainers, label As Scalar(Of Boolean), features As Vector(Of Single), loss As ISupportSdcaClassificationLoss, Optional weights As Scalar(Of Single) = null, Optional l2Const As Nullable(Of Single) = null, Optional l1Threshold As Nullable(Of Single) = null, Optional maxIterations As Nullable(Of Integer) = null, Optional advancedSettings As Action(Of SdcaBinaryTrainer.Arguments) = null, Optional onFit As Action(Of LinearBinaryModelParameters) = null) As ValueTuple(Of Scalar(Of Single), Scalar(Of Boolean))" />
        <MemberSignature Language="F#" Value="static member Sdca : Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.ISupportSdcaClassificationLoss * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;int&gt; * Action&lt;Microsoft.ML.Trainers.SdcaBinaryTrainer.Arguments&gt; * Action&lt;Microsoft.ML.Learners.LinearBinaryModelParameters&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca (ctx, label, features, loss, weights, l2Const, l1Threshold, maxIterations, advancedSettings, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="loss" Type="Microsoft.ML.ISupportSdcaClassificationLoss" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="l2Const" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="l1Threshold" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="maxIterations" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.SdcaBinaryTrainer+Arguments&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Learners.LinearBinaryModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The binary classification context trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="loss">The custom loss.</param>
          <param name="weights">The optional example weights.</param>
          <param name="l2Const">The L2 regularization hyperparameter.</param>
          <param name="l1Threshold">The L1 regularization hyperparameter. Higher values will tend to lead to more sparse model.</param>
          <param name="maxIterations">The maximum number of passes to perform over the data.</param>
          <param name="advancedSettings">A delegate to set more settings.
            The settings here will override the ones provided in the direct method signature,
            if both are present and have different values.
            The columns names, however need to be provided directly, not through the <paramref name="advancedSettings" />.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained, as well as the calibrator on top of that model. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear binary classification model trained with the SDCA trainer, and a custom loss.
            Note that because we cannot be sure that all loss functions will produce naturally calibrated outputs, setting
            a custom loss function will not produce a calibrated probability column.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.SdcaStaticExtensions" Member="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.ISupportSdcaClassificationLoss,Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Trainers.SdcaBinaryTrainer.Arguments},System.Action{Microsoft.ML.Learners.LinearBinaryModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="Sdca">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; Sdca (this Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers ctx, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, Nullable&lt;float&gt; l2Const = null, Nullable&lt;float&gt; l1Threshold = null, Nullable&lt;int&gt; maxIterations = null, Action&lt;Microsoft.ML.Trainers.SdcaBinaryTrainer.Arguments&gt; advancedSettings = null, Action&lt;Microsoft.ML.Learners.LinearBinaryModelParameters,Microsoft.ML.Internal.Calibration.ParameterMixingCalibratedPredictor&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; Sdca(class Microsoft.ML.BinaryClassificationContext/BinaryClassificationTrainers ctx, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, valuetype System.Nullable`1&lt;float32&gt; l2Const, valuetype System.Nullable`1&lt;float32&gt; l1Threshold, valuetype System.Nullable`1&lt;int32&gt; maxIterations, class System.Action`1&lt;class Microsoft.ML.Trainers.SdcaBinaryTrainer/Arguments&gt; advancedSettings, class System.Action`2&lt;class Microsoft.ML.Learners.LinearBinaryModelParameters, class Microsoft.ML.Internal.Calibration.ParameterMixingCalibratedPredictor&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Trainers.SdcaBinaryTrainer.Arguments},System.Action{Microsoft.ML.Learners.LinearBinaryModelParameters,Microsoft.ML.Internal.Calibration.ParameterMixingCalibratedPredictor})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sdca (ctx As BinaryClassificationContext.BinaryClassificationTrainers, label As Scalar(Of Boolean), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional l2Const As Nullable(Of Single) = null, Optional l1Threshold As Nullable(Of Single) = null, Optional maxIterations As Nullable(Of Integer) = null, Optional advancedSettings As Action(Of SdcaBinaryTrainer.Arguments) = null, Optional onFit As Action(Of LinearBinaryModelParameters, ParameterMixingCalibratedPredictor) = null) As ValueTuple(Of Scalar(Of Single), Scalar(Of Single), Scalar(Of Boolean))" />
        <MemberSignature Language="F#" Value="static member Sdca : Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;int&gt; * Action&lt;Microsoft.ML.Trainers.SdcaBinaryTrainer.Arguments&gt; * Action&lt;Microsoft.ML.Learners.LinearBinaryModelParameters, Microsoft.ML.Internal.Calibration.ParameterMixingCalibratedPredictor&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca (ctx, label, features, weights, l2Const, l1Threshold, maxIterations, advancedSettings, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "probability", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="l2Const" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="l1Threshold" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="maxIterations" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.SdcaBinaryTrainer+Arguments&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Learners.LinearBinaryModelParameters,Microsoft.ML.Internal.Calibration.ParameterMixingCalibratedPredictor&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The binary classification context trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="l2Const">The L2 regularization hyperparameter.</param>
          <param name="l1Threshold">The L1 regularization hyperparameter. Higher values will tend to lead to more sparse model.</param>
          <param name="maxIterations">The maximum number of passes to perform over the data.</param>
          <param name="advancedSettings">A delegate to set more settings.
            The settings here will override the ones provided in the direct method signature,
            if both are present and have different values.
            The columns names, however need to be provided directly, not through the <paramref name="advancedSettings" />.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained, as well as the calibrator on top of that model. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear binary classification model trained with the SDCA trainer, and log-loss.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.SdcaStaticExtensions" Member="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Trainers.SdcaBinaryTrainer.Arguments},System.Action{Microsoft.ML.Learners.LinearBinaryModelParameters,Microsoft.ML.Internal.Calibration.ParameterMixingCalibratedPredictor})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionContext.RegressionTrainers" />
      </Targets>
      <Member MemberName="Sdca">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; Sdca (this Microsoft.ML.RegressionContext.RegressionTrainers ctx, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, Nullable&lt;float&gt; l2Const = null, Nullable&lt;float&gt; l1Threshold = null, Nullable&lt;int&gt; maxIterations = null, Microsoft.ML.ISupportSdcaRegressionLoss loss = null, Action&lt;Microsoft.ML.Trainers.SdcaRegressionTrainer.Arguments&gt; advancedSettings = null, Action&lt;Microsoft.ML.Learners.LinearRegressionModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; Sdca(class Microsoft.ML.RegressionContext/RegressionTrainers ctx, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, valuetype System.Nullable`1&lt;float32&gt; l2Const, valuetype System.Nullable`1&lt;float32&gt; l1Threshold, valuetype System.Nullable`1&lt;int32&gt; maxIterations, class Microsoft.ML.ISupportSdcaRegressionLoss loss, class System.Action`1&lt;class Microsoft.ML.Trainers.SdcaRegressionTrainer/Arguments&gt; advancedSettings, class System.Action`1&lt;class Microsoft.ML.Learners.LinearRegressionModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca(Microsoft.ML.RegressionContext.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},Microsoft.ML.ISupportSdcaRegressionLoss,System.Action{Microsoft.ML.Trainers.SdcaRegressionTrainer.Arguments},System.Action{Microsoft.ML.Learners.LinearRegressionModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sdca (ctx As RegressionContext.RegressionTrainers, label As Scalar(Of Single), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional l2Const As Nullable(Of Single) = null, Optional l1Threshold As Nullable(Of Single) = null, Optional maxIterations As Nullable(Of Integer) = null, Optional loss As ISupportSdcaRegressionLoss = null, Optional advancedSettings As Action(Of SdcaRegressionTrainer.Arguments) = null, Optional onFit As Action(Of LinearRegressionModelParameters) = null) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member Sdca : Microsoft.ML.RegressionContext.RegressionTrainers * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;int&gt; * Microsoft.ML.ISupportSdcaRegressionLoss * Action&lt;Microsoft.ML.Trainers.SdcaRegressionTrainer.Arguments&gt; * Action&lt;Microsoft.ML.Learners.LinearRegressionModelParameters&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca (ctx, label, features, weights, l2Const, l1Threshold, maxIterations, loss, advancedSettings, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RegressionContext+RegressionTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="l2Const" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="l1Threshold" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="maxIterations" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="loss" Type="Microsoft.ML.ISupportSdcaRegressionLoss" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.SdcaRegressionTrainer+Arguments&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Learners.LinearRegressionModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The regression context trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="l2Const">The L2 regularization hyperparameter.</param>
          <param name="l1Threshold">The L1 regularization hyperparameter. Higher values will tend to lead to more sparse model.</param>
          <param name="maxIterations">The maximum number of passes to perform over the data.</param>
          <param name="loss">The custom loss, if unspecified will be <see cref="T:Microsoft.ML.SquaredLoss" />.</param>
          <param name="advancedSettings">A delegate to set more settings.
            The settings here will override the ones provided in the direct method signature,
            if both are present and have different values.
            The columns names, however need to be provided directly, not through the <paramref name="advancedSettings" />.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained.  Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear regression model trained with the SDCA trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.SdcaStaticExtensions" Member="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca(Microsoft.ML.RegressionContext.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},Microsoft.ML.ISupportSdcaRegressionLoss,System.Action{Microsoft.ML.Trainers.SdcaRegressionTrainer.Arguments},System.Action{Microsoft.ML.Learners.LinearRegressionModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="Sdca&lt;TVal&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;float&gt;,Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt;&gt; Sdca&lt;TVal&gt; (this Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers ctx, Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.ISupportSdcaClassificationLoss loss = null, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, Nullable&lt;float&gt; l2Const = null, Nullable&lt;float&gt; l1Threshold = null, Nullable&lt;int&gt; maxIterations = null, Action&lt;Microsoft.ML.Trainers.SdcaMultiClassTrainer.Arguments&gt; advancedSettings = null, Action&lt;Microsoft.ML.Learners.MulticlassLogisticRegressionModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt;&gt; Sdca&lt;TVal&gt;(class Microsoft.ML.MulticlassClassificationContext/MulticlassClassificationTrainers ctx, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.ISupportSdcaClassificationLoss loss, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, valuetype System.Nullable`1&lt;float32&gt; l2Const, valuetype System.Nullable`1&lt;float32&gt; l1Threshold, valuetype System.Nullable`1&lt;int32&gt; maxIterations, class System.Action`1&lt;class Microsoft.ML.Trainers.SdcaMultiClassTrainer/Arguments&gt; advancedSettings, class System.Action`1&lt;class Microsoft.ML.Learners.MulticlassLogisticRegressionModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca``1(Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.ISupportSdcaClassificationLoss,Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Trainers.SdcaMultiClassTrainer.Arguments},System.Action{Microsoft.ML.Learners.MulticlassLogisticRegressionModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sdca(Of TVal) (ctx As MulticlassClassificationContext.MulticlassClassificationTrainers, label As Key(Of UInteger, TVal), features As Vector(Of Single), Optional loss As ISupportSdcaClassificationLoss = null, Optional weights As Scalar(Of Single) = null, Optional l2Const As Nullable(Of Single) = null, Optional l1Threshold As Nullable(Of Single) = null, Optional maxIterations As Nullable(Of Integer) = null, Optional advancedSettings As Action(Of SdcaMultiClassTrainer.Arguments) = null, Optional onFit As Action(Of MulticlassLogisticRegressionModelParameters) = null) As ValueTuple(Of Vector(Of Single), Key(Of UInteger, TVal))" />
        <MemberSignature Language="F#" Value="static member Sdca : Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers * Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.ISupportSdcaClassificationLoss * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;int&gt; * Action&lt;Microsoft.ML.Trainers.SdcaMultiClassTrainer.Arguments&gt; * Action&lt;Microsoft.ML.Learners.MulticlassLogisticRegressionModelParameters&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;single&gt;, Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt;&gt;" Usage="Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca (ctx, label, features, loss, weights, l2Const, l1Threshold, maxIterations, advancedSettings, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TVal" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.MulticlassClassificationContext+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="loss" Type="Microsoft.ML.ISupportSdcaClassificationLoss" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="l2Const" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="l1Threshold" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="maxIterations" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.SdcaMultiClassTrainer+Arguments&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Learners.MulticlassLogisticRegressionModelParameters&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TVal">To be added.</typeparam>
          <param name="ctx">The multiclass classification context trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="loss">The custom loss.</param>
          <param name="weights">The optional example weights.</param>
          <param name="l2Const">The L2 regularization hyperparameter.</param>
          <param name="l1Threshold">The L1 regularization hyperparameter. Higher values will tend to lead to more sparse model.</param>
          <param name="maxIterations">The maximum number of passes to perform over the data.</param>
          <param name="advancedSettings">A delegate to set more settings.
            The settings here will override the ones provided in the direct method signature,
            if both are present and have different values.
            The columns names, however need to be provided directly, not through the <paramref name="advancedSettings" />.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear multiclass classification model trained with the SDCA trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.SdcaStaticExtensions" Member="M:Microsoft.ML.StaticPipe.SdcaStaticExtensions.Sdca``1(Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.ISupportSdcaClassificationLoss,Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Trainers.SdcaMultiClassTrainer.Arguments},System.Action{Microsoft.ML.Learners.MulticlassLogisticRegressionModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="StochasticGradientDescentClassificationTrainer">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; StochasticGradientDescentClassificationTrainer (this Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers ctx, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, int maxIterations = 20, double initLearningRate = 0.01, float l2Weight = 1E-06, Microsoft.ML.ISupportClassificationLossFactory loss = null, Action&lt;Microsoft.ML.Trainers.StochasticGradientDescentClassificationTrainer.Arguments&gt; advancedSettings = null, Action&lt;Microsoft.ML.Internal.Internallearn.IPredictorWithFeatureWeights&lt;float&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; StochasticGradientDescentClassificationTrainer(class Microsoft.ML.BinaryClassificationContext/BinaryClassificationTrainers ctx, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, int32 maxIterations, float64 initLearningRate, float32 l2Weight, class Microsoft.ML.ISupportClassificationLossFactory loss, class System.Action`1&lt;class Microsoft.ML.Trainers.StochasticGradientDescentClassificationTrainer/Arguments&gt; advancedSettings, class System.Action`1&lt;class Microsoft.ML.Internal.Internallearn.IPredictorWithFeatureWeights`1&lt;float32&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.SgdStaticExtensions.StochasticGradientDescentClassificationTrainer(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Double,System.Single,Microsoft.ML.ISupportClassificationLossFactory,System.Action{Microsoft.ML.Trainers.StochasticGradientDescentClassificationTrainer.Arguments},System.Action{Microsoft.ML.Internal.Internallearn.IPredictorWithFeatureWeights{System.Single}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function StochasticGradientDescentClassificationTrainer (ctx As BinaryClassificationContext.BinaryClassificationTrainers, label As Scalar(Of Boolean), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional maxIterations As Integer = 20, Optional initLearningRate As Double = 0.01, Optional l2Weight As Single = 1E-06, Optional loss As ISupportClassificationLossFactory = null, Optional advancedSettings As Action(Of StochasticGradientDescentClassificationTrainer.Arguments) = null, Optional onFit As Action(Of IPredictorWithFeatureWeights(Of Single)) = null) As ValueTuple(Of Scalar(Of Single), Scalar(Of Single), Scalar(Of Boolean))" />
        <MemberSignature Language="F#" Value="static member StochasticGradientDescentClassificationTrainer : Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * int * double * single * Microsoft.ML.ISupportClassificationLossFactory * Action&lt;Microsoft.ML.Trainers.StochasticGradientDescentClassificationTrainer.Arguments&gt; * Action&lt;Microsoft.ML.Internal.Internallearn.IPredictorWithFeatureWeights&lt;single&gt;&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.SgdStaticExtensions.StochasticGradientDescentClassificationTrainer (ctx, label, features, weights, maxIterations, initLearningRate, l2Weight, loss, advancedSettings, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "probability", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="maxIterations" Type="System.Int32" />
          <Parameter Name="initLearningRate" Type="System.Double" />
          <Parameter Name="l2Weight" Type="System.Single" />
          <Parameter Name="loss" Type="Microsoft.ML.ISupportClassificationLossFactory" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.StochasticGradientDescentClassificationTrainer+Arguments&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Internal.Internallearn.IPredictorWithFeatureWeights&lt;System.Single&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The binary classificaiton context trainer object.</param>
          <param name="label">The name of the label column.</param>
          <param name="features">The name of the feature column.</param>
          <param name="weights">The name for the example weight column.</param>
          <param name="maxIterations">The maximum number of iterations; set to 1 to simulate online learning.</param>
          <param name="initLearningRate">The initial learning rate used by SGD.</param>
          <param name="l2Weight">The L2 regularization constant.</param>
          <param name="loss">The loss function to use.</param>
          <param name="advancedSettings">A delegate to apply all the advanced arguments to the algorithm.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained.  Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
             Predict a target using a linear binary classification model trained with the <see cref="T:Microsoft.ML.Trainers.StochasticGradientDescentClassificationTrainer" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.SgdStaticExtensions" Member="M:Microsoft.ML.StaticPipe.SgdStaticExtensions.StochasticGradientDescentClassificationTrainer(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Double,System.Single,Microsoft.ML.ISupportClassificationLossFactory,System.Action{Microsoft.ML.Trainers.StochasticGradientDescentClassificationTrainer.Arguments},System.Action{Microsoft.ML.Internal.Internallearn.IPredictorWithFeatureWeights{System.Single}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Data.IDataView" />
      </Targets>
      <Member MemberName="AssertStatic&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.DataView&lt;T&gt; AssertStatic&lt;T&gt; (this Microsoft.ML.Data.IDataView view, Microsoft.ML.IHostEnvironment env, Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,T&gt; outputDecl);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt; AssertStatic&lt;T&gt;(class Microsoft.ML.Data.IDataView view, class Microsoft.ML.IHostEnvironment env, class System.Func`2&lt;class Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, !!T&gt; outputDecl) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``1(Microsoft.ML.Data.IDataView,Microsoft.ML.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AssertStatic(Of T) (view As IDataView, env As IHostEnvironment, outputDecl As Func(Of SchemaAssertionContext, T)) As DataView(Of T)" />
        <MemberSignature Language="F#" Value="static member AssertStatic : Microsoft.ML.Data.IDataView * Microsoft.ML.IHostEnvironment * Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, 'T&gt; -&gt; Microsoft.ML.StaticPipe.DataView&lt;'T&gt;" Usage="Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic (view, env, outputDecl)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.DataView&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Attributes>
              <Attribute>
                <AttributeName>Microsoft.ML.StaticPipe.IsShape</AttributeName>
              </Attribute>
            </Attributes>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="view" Type="Microsoft.ML.Data.IDataView" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" />
          <Parameter Name="outputDecl" Type="System.Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,T&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="T">The type representing the view's schema shape</typeparam>
          <param name="view">The view to assert the static schema on</param>
          <param name="env">The host environment to keep in the statically typed variant</param>
          <param name="outputDecl">The delegate through which we declare the schema, which ought to
            use the input <see cref="T:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext" /> to declare a <see cref="T:System.ValueTuple" />
            of the <see cref="T:Microsoft.ML.StaticPipe.PipelineColumn" /> indices, properly named</param>
          <summary>
            Asserts that a given data view has the indicated schema. If this method returns without
            throwing then the view has been validated to have columns with the indicated names and types.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.StaticPipeExtensions" Member="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``1(Microsoft.ML.Data.IDataView,Microsoft.ML.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.IDataReader`1" />
      </Targets>
      <Member MemberName="AssertStatic&lt;TIn,T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.DataReader&lt;TIn,T&gt; AssertStatic&lt;TIn,T&gt; (this Microsoft.ML.Core.Data.IDataReader&lt;TIn&gt; reader, Microsoft.ML.IHostEnvironment env, Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,T&gt; outputDecl);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.DataReader`2&lt;!!TIn, !!T&gt; AssertStatic&lt;TIn, T&gt;(class Microsoft.ML.Core.Data.IDataReader`1&lt;!!TIn&gt; reader, class Microsoft.ML.IHostEnvironment env, class System.Func`2&lt;class Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, !!T&gt; outputDecl) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``2(Microsoft.ML.Core.Data.IDataReader{``0},Microsoft.ML.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AssertStatic(Of TIn, T) (reader As IDataReader(Of TIn), env As IHostEnvironment, outputDecl As Func(Of SchemaAssertionContext, T)) As DataReader(Of TIn, T)" />
        <MemberSignature Language="F#" Value="static member AssertStatic : Microsoft.ML.Core.Data.IDataReader&lt;'In&gt; * Microsoft.ML.IHostEnvironment * Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, 'T&gt; -&gt; Microsoft.ML.StaticPipe.DataReader&lt;'In, 'T&gt;" Usage="Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic (reader, env, outputDecl)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.DataReader&lt;TIn,T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TIn" />
          <TypeParameter Name="T">
            <Attributes>
              <Attribute>
                <AttributeName>Microsoft.ML.StaticPipe.IsShape</AttributeName>
              </Attribute>
            </Attributes>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="reader" Type="Microsoft.ML.Core.Data.IDataReader&lt;TIn&gt;" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" />
          <Parameter Name="outputDecl" Type="System.Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,T&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TIn">To be added.</typeparam>
          <typeparam name="T">To be added.</typeparam>
          <param name="reader">To be added.</param>
          <param name="env">To be added.</param>
          <param name="outputDecl">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.StaticPipeExtensions" Member="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``2(Microsoft.ML.Core.Data.IDataReader{``0},Microsoft.ML.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.ITransformer" />
      </Targets>
      <Member MemberName="AssertStatic&lt;TIn,TOut,TTrans&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Transformer&lt;TIn,TOut,TTrans&gt; AssertStatic&lt;TIn,TOut,TTrans&gt; (this TTrans transformer, Microsoft.ML.IHostEnvironment env, Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,TIn&gt; inputDecl, Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,TOut&gt; outputDecl) where TTrans : class, Microsoft.ML.Core.Data.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Transformer`3&lt;!!TIn, !!TOut, !!TTrans&gt; AssertStatic&lt;TIn, TOut, class (class Microsoft.ML.Core.Data.ITransformer) TTrans&gt;(!!TTrans transformer, class Microsoft.ML.IHostEnvironment env, class System.Func`2&lt;class Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, !!TIn&gt; inputDecl, class System.Func`2&lt;class Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, !!TOut&gt; outputDecl) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``3(``2,Microsoft.ML.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``0},System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AssertStatic(Of TIn, TOut, TTrans) (transformer As TTrans, env As IHostEnvironment, inputDecl As Func(Of SchemaAssertionContext, TIn), outputDecl As Func(Of SchemaAssertionContext, TOut)) As Transformer(Of TIn, TOut, TTrans)" />
        <MemberSignature Language="F#" Value="static member AssertStatic : 'rans * Microsoft.ML.IHostEnvironment * Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, 'In&gt; * Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, 'Out&gt; -&gt; Microsoft.ML.StaticPipe.Transformer&lt;'In, 'Out, 'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)" Usage="Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic (transformer, env, inputDecl, outputDecl)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Transformer&lt;TIn,TOut,TTrans&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TIn">
            <Attributes>
              <Attribute>
                <AttributeName>Microsoft.ML.StaticPipe.IsShape</AttributeName>
              </Attribute>
            </Attributes>
          </TypeParameter>
          <TypeParameter Name="TOut">
            <Attributes>
              <Attribute>
                <AttributeName>Microsoft.ML.StaticPipe.IsShape</AttributeName>
              </Attribute>
            </Attributes>
          </TypeParameter>
          <TypeParameter Name="TTrans">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="transformer" Type="TTrans" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" />
          <Parameter Name="inputDecl" Type="System.Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,TIn&gt;" />
          <Parameter Name="outputDecl" Type="System.Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,TOut&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TIn">To be added.</typeparam>
          <typeparam name="TOut">To be added.</typeparam>
          <typeparam name="TTrans">To be added.</typeparam>
          <param name="transformer">To be added.</param>
          <param name="env">To be added.</param>
          <param name="inputDecl">To be added.</param>
          <param name="outputDecl">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.StaticPipeExtensions" Member="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``3(``2,Microsoft.ML.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``0},System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.IDataReaderEstimator`2" />
      </Targets>
      <Member MemberName="AssertStatic&lt;TIn,T,TReader&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.DataReaderEstimator&lt;TIn,T,TReader&gt; AssertStatic&lt;TIn,T,TReader&gt; (this Microsoft.ML.Core.Data.IDataReaderEstimator&lt;TIn,TReader&gt; readerEstimator, Microsoft.ML.IHostEnvironment env, Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,T&gt; outputDecl) where TReader : class, Microsoft.ML.Core.Data.IDataReader&lt;TIn&gt;;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.DataReaderEstimator`3&lt;!!TIn, !!T, !!TReader&gt; AssertStatic&lt;TIn, T, class (class Microsoft.ML.Core.Data.IDataReader`1&lt;!!TIn&gt;) TReader&gt;(class Microsoft.ML.Core.Data.IDataReaderEstimator`2&lt;!!TIn, !!TReader&gt; readerEstimator, class Microsoft.ML.IHostEnvironment env, class System.Func`2&lt;class Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, !!T&gt; outputDecl) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``3(Microsoft.ML.Core.Data.IDataReaderEstimator{``0,``2},Microsoft.ML.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AssertStatic(Of TIn, T, TReader) (readerEstimator As IDataReaderEstimator(Of TIn, TReader), env As IHostEnvironment, outputDecl As Func(Of SchemaAssertionContext, T)) As DataReaderEstimator(Of TIn, T, TReader)" />
        <MemberSignature Language="F#" Value="static member AssertStatic : Microsoft.ML.Core.Data.IDataReaderEstimator&lt;'In, 'Reader (requires 'Reader : null and 'Reader :&gt; Microsoft.ML.Core.Data.IDataReader&lt;'In&gt;)&gt; * Microsoft.ML.IHostEnvironment * Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, 'T&gt; -&gt; Microsoft.ML.StaticPipe.DataReaderEstimator&lt;'In, 'T, 'Reader (requires 'Reader : null and 'Reader :&gt; Microsoft.ML.Core.Data.IDataReader&lt;'In&gt;)&gt; (requires 'Reader : null and 'Reader :&gt; Microsoft.ML.Core.Data.IDataReader&lt;'In&gt;)" Usage="Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic (readerEstimator, env, outputDecl)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.DataReaderEstimator&lt;TIn,T,TReader&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TIn" />
          <TypeParameter Name="T">
            <Attributes>
              <Attribute>
                <AttributeName>Microsoft.ML.StaticPipe.IsShape</AttributeName>
              </Attribute>
            </Attributes>
          </TypeParameter>
          <TypeParameter Name="TReader">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.IDataReader&lt;TIn&gt;</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="readerEstimator" Type="Microsoft.ML.Core.Data.IDataReaderEstimator&lt;TIn,TReader&gt;" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" />
          <Parameter Name="outputDecl" Type="System.Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,T&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TIn">To be added.</typeparam>
          <typeparam name="T">To be added.</typeparam>
          <typeparam name="TReader">To be added.</typeparam>
          <param name="readerEstimator">To be added.</param>
          <param name="env">To be added.</param>
          <param name="outputDecl">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.StaticPipeExtensions" Member="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``3(Microsoft.ML.Core.Data.IDataReaderEstimator{``0,``2},Microsoft.ML.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.IEstimator`1" />
      </Targets>
      <Member MemberName="AssertStatic&lt;TIn,TOut,TTrans&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Estimator&lt;TIn,TOut,TTrans&gt; AssertStatic&lt;TIn,TOut,TTrans&gt; (this Microsoft.ML.Core.Data.IEstimator&lt;TTrans&gt; estimator, Microsoft.ML.IHostEnvironment env, Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,TIn&gt; inputDecl, Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,TOut&gt; outputDecl) where TTrans : class, Microsoft.ML.Core.Data.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Estimator`3&lt;!!TIn, !!TOut, !!TTrans&gt; AssertStatic&lt;TIn, TOut, class (class Microsoft.ML.Core.Data.ITransformer) TTrans&gt;(class Microsoft.ML.Core.Data.IEstimator`1&lt;!!TTrans&gt; estimator, class Microsoft.ML.IHostEnvironment env, class System.Func`2&lt;class Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, !!TIn&gt; inputDecl, class System.Func`2&lt;class Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, !!TOut&gt; outputDecl) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``3(Microsoft.ML.Core.Data.IEstimator{``2},Microsoft.ML.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``0},System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AssertStatic(Of TIn, TOut, TTrans) (estimator As IEstimator(Of TTrans), env As IHostEnvironment, inputDecl As Func(Of SchemaAssertionContext, TIn), outputDecl As Func(Of SchemaAssertionContext, TOut)) As Estimator(Of TIn, TOut, TTrans)" />
        <MemberSignature Language="F#" Value="static member AssertStatic : Microsoft.ML.Core.Data.IEstimator&lt;'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; * Microsoft.ML.IHostEnvironment * Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, 'In&gt; * Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, 'Out&gt; -&gt; Microsoft.ML.StaticPipe.Estimator&lt;'In, 'Out, 'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)" Usage="Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic (estimator, env, inputDecl, outputDecl)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Estimator&lt;TIn,TOut,TTrans&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TIn">
            <Attributes>
              <Attribute>
                <AttributeName>Microsoft.ML.StaticPipe.IsShape</AttributeName>
              </Attribute>
            </Attributes>
          </TypeParameter>
          <TypeParameter Name="TOut">
            <Attributes>
              <Attribute>
                <AttributeName>Microsoft.ML.StaticPipe.IsShape</AttributeName>
              </Attribute>
            </Attributes>
          </TypeParameter>
          <TypeParameter Name="TTrans">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="estimator" Type="Microsoft.ML.Core.Data.IEstimator&lt;TTrans&gt;" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" />
          <Parameter Name="inputDecl" Type="System.Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,TIn&gt;" />
          <Parameter Name="outputDecl" Type="System.Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,TOut&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TIn">To be added.</typeparam>
          <typeparam name="TOut">To be added.</typeparam>
          <typeparam name="TTrans">To be added.</typeparam>
          <param name="estimator">To be added.</param>
          <param name="env">To be added.</param>
          <param name="inputDecl">To be added.</param>
          <param name="outputDecl">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.StaticPipeExtensions" Member="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``3(Microsoft.ML.Core.Data.IEstimator{``2},Microsoft.ML.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``0},System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="RemoveStopwords">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;string&gt; RemoveStopwords (this Microsoft.ML.StaticPipe.VarVector&lt;string&gt; input, Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator.Language language = Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator+Language.English);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;string&gt; RemoveStopwords(class Microsoft.ML.StaticPipe.VarVector`1&lt;string&gt; input, valuetype Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator/Language language) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.StopwordRemoverStaticExtensions.RemoveStopwords(Microsoft.ML.StaticPipe.VarVector{System.String},Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator.Language)" />
        <MemberSignature Language="F#" Value="static member RemoveStopwords : Microsoft.ML.StaticPipe.VarVector&lt;string&gt; * Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator.Language -&gt; Microsoft.ML.StaticPipe.VarVector&lt;string&gt;" Usage="Microsoft.ML.StaticPipe.StopwordRemoverStaticExtensions.RemoveStopwords (input, language)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.String&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.String&gt;" RefType="this" />
          <Parameter Name="language" Type="Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator+Language" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="language">Langauge of the input text.</param>
          <summary>
            Remove stop words from incoming text.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.StopwordRemoverStaticExtensions" Member="M:Microsoft.ML.StaticPipe.StopwordRemoverStaticExtensions.RemoveStopwords(Microsoft.ML.StaticPipe.VarVector{System.String},Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator.Language)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,bool&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;bool&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, bool&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;bool&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Boolean})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;bool&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, bool&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Boolean&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Boolean&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Boolean}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,byte&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;byte&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;byte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int8&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;unsigned int8&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;unsigned int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Byte},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Byte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;byte&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;byte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, byte&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Byte&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Byte&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Byte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Byte},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Byte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,double&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;double&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;double&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float64&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;float64&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;float64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Double},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Double})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;double&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;double&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, double&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Double&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Double},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Double}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,short&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;short&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;short&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int16&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;int16&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Int16},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Int16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;int16&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;int16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, int16&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int16&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Int16&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Int16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Int16},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Int16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,int&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;int&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;int&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int32&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;int32&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Int32},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Int32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;int&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;int&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, int&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int32&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Int32&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Int32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Int32},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Int32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,long&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;long&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;long&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int64&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;int64&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Int64},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Int64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;int64&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;int64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, int64&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int64&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Int64&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Int64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Int64},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Int64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,sbyte&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;sbyte&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;sbyte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int8&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;int8&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.SByte},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.SByte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;sbyte&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;sbyte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, sbyte&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.SByte&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.SByte&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.SByte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.SByte},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.SByte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,float&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;float&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;float&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float32&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;float32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Single})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;single&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, single&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Single&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Single}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,string&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, string&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.ReadOnlyMemory{System.Char}})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, string&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.String&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because the empty string is never entered into the dictionary, it will always map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,ushort&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;ushort&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ushort&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int16&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;unsigned int16&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;unsigned int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.UInt16},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.UInt16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;uint16&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;uint16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, uint16&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt16&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.UInt16&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.UInt16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.UInt16},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.UInt16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,uint&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;uint&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;uint&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int32&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;unsigned int32&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;unsigned int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.UInt32},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.UInt32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;uint32&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;uint32&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, uint32&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt32&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.UInt32&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.UInt32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.UInt32},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.UInt32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,ulong&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;ulong&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ulong&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int64&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;unsigned int64&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;unsigned int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.UInt64},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.UInt64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;uint64&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;uint64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, uint64&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt64&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.UInt64&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.UInt64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.UInt64},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.UInt64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,bool&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;bool&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;bool&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, bool&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;bool&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;bool&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Boolean},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Boolean})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;bool&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;bool&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Boolean&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Boolean&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Boolean&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Boolean},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Boolean}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,byte&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;byte&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;byte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int8&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;unsigned int8&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;unsigned int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Byte},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Byte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;byte&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;byte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, byte&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Byte&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Byte&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Byte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Byte},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Byte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,double&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;double&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;double&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float64&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;float64&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;float64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Double},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Double})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;double&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;double&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, double&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Double&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Double&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Double},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Double}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,short&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;short&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;short&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int16&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;int16&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Int16},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Int16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;int16&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;int16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int16&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int16&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Int16&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Int16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Int16},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Int16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,int&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;int&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;int&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int32&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;int32&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Int32},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Int32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;int&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;int&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int32&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Int32&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Int32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Int32},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Int32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,long&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;long&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;long&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int64&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;int64&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Int64},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Int64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;int64&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;int64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int64&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int64&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Int64&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Int64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Int64},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Int64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,sbyte&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;sbyte&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;sbyte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int8&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;int8&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.SByte},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.SByte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;sbyte&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;sbyte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, sbyte&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.SByte&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.SByte&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.SByte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.SByte},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.SByte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,float&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;float&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;float&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float32&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;float32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Single},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Single})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;single&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;single&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, single&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Single&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Single&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Single},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Single}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,string&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;string&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, string&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;string&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.String},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.ReadOnlyMemory{System.Char}})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;string&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, string&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.String&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.String&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because the empty string is never entered into the dictionary, it will always map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.String},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,ushort&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;ushort&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ushort&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int16&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;unsigned int16&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;unsigned int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.UInt16},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.UInt16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;uint16&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;uint16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint16&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt16&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.UInt16&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.UInt16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.UInt16},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.UInt16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,uint&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;uint&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;uint&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int32&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;unsigned int32&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;unsigned int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.UInt32},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.UInt32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;uint32&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;uint32&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint32&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt32&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.UInt32&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.UInt32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.UInt32},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.UInt32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,ulong&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;ulong&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ulong&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int64&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;unsigned int64&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;unsigned int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.UInt64},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.UInt64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;uint64&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;uint64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint64&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt64&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.UInt64&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.UInt64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.UInt64},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.UInt64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,bool&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;bool&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;bool&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, bool&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;bool&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;bool&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Boolean},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Boolean})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;bool&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;bool&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Boolean&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Boolean&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Boolean&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Boolean},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Boolean}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,byte&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;byte&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;byte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int8&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;unsigned int8&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;unsigned int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Byte},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Byte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;byte&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;byte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, byte&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Byte&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Byte&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Byte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Byte},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Byte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,double&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;double&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float64&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;float64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Double},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Double})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;double&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, double&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Double&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Double&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Double},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Double}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,short&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;short&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;short&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int16&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;int16&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Int16},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Int16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;int16&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;int16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int16&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int16&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Int16&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Int16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Int16},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Int16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,int&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;int&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;int&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int32&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;int32&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Int32},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Int32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;int&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;int&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int32&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Int32&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Int32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Int32},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Int32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,long&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;long&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;long&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int64&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;int64&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Int64},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Int64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;int64&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;int64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int64&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int64&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Int64&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Int64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Int64},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Int64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,sbyte&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;sbyte&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;sbyte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int8&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;int8&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.SByte},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.SByte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;sbyte&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;sbyte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, sbyte&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.SByte&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.SByte&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.SByte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.SByte},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.SByte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,float&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;float&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float32&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;float32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Single})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;single&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, single&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Single&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Single&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Single}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,string&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;string&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, string&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;string&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.String},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.ReadOnlyMemory{System.Char}})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;string&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, string&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.String&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.String&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because the empty string is never entered into the dictionary, it will always map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.String},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,ushort&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;ushort&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ushort&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int16&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;unsigned int16&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;unsigned int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.UInt16},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.UInt16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;uint16&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;uint16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint16&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt16&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.UInt16&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.UInt16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.UInt16},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.UInt16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,uint&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;uint&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;uint&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int32&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;unsigned int32&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;unsigned int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.UInt32},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.UInt32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;uint32&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;uint32&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint32&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt32&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.UInt32&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.UInt32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.UInt32},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.UInt32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,ulong&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;ulong&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ulong&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int64&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;unsigned int64&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;unsigned int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.UInt64},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.UInt64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;uint64&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;uint64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint64&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt64&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.UInt64&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.UInt64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.UInt64},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.UInt64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,bool&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,bool&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;bool&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, bool&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, bool&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;bool&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Boolean},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Boolean})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, bool&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;bool&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, bool&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Boolean&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.Boolean&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Boolean&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Boolean},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Boolean}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,byte&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,byte&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;byte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int8&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int8&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;unsigned int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Byte},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Byte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, byte&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;byte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, byte&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Byte&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.Byte&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Byte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Byte},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Byte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,double&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,double&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;double&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float64&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, float64&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;float64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Double},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Double})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, double&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;double&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, double&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Double&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.Double&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Double&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Double},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Double}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,short&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,short&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;short&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int16&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int16&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Int16},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Int16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, int16&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;int16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, int16&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int16&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.Int16&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Int16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Int16},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Int16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,int&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,int&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;int&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int32&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int32&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Int32},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Int32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, int&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;int&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, int&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int32&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.Int32&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Int32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Int32},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Int32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,long&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,long&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;long&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int64&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int64&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Int64},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Int64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, int64&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;int64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, int64&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int64&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.Int64&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Int64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Int64},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Int64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,sbyte&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,sbyte&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;sbyte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int8&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int8&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.SByte},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.SByte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, sbyte&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;sbyte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, sbyte&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.SByte&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.SByte&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.SByte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.SByte},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.SByte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,float&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,float&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;float&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float32&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, float32&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;float32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Single},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Single})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, single&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;single&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, single&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.Single&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Single&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Single},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Single}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,string&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,string&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, string&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, string&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.String},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.ReadOnlyMemory{System.Char}})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, string&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, string&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.String&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.String&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because the empty string is never entered into the dictionary, it will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.String},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,ushort&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,ushort&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ushort&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int16&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int16&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;unsigned int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.UInt16},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.UInt16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, uint16&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;uint16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, uint16&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt16&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.UInt16&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.UInt16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.UInt16},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.UInt16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,uint&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,uint&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;uint&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int32&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int32&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;unsigned int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.UInt32},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.UInt32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, uint32&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;uint32&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, uint32&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt32&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.UInt32&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.UInt32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.UInt32},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.UInt32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,ulong&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,ulong&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ulong&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int64&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int64&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;unsigned int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.UInt64},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.UInt64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, uint64&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;uint64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, uint64&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt64&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.UInt64&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.UInt64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.UInt64},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.UInt64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,bool&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,bool&gt;&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;bool&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, bool&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, bool&gt;&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;bool&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Boolean}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Boolean})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, bool&gt;&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;bool&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Boolean&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Boolean&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Boolean&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Boolean}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Boolean}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,byte&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,byte&gt;&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;byte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int8&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int8&gt;&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;unsigned int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Byte}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Byte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, byte&gt;&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;byte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, byte&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Byte&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Byte&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Byte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Byte}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Byte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,double&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,double&gt;&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;double&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float64&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, float64&gt;&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;float64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Double}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Double})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, double&gt;&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;double&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, double&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Double&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Double&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Double&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Double}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Double}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,short&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,short&gt;&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;short&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int16&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int16&gt;&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Int16}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Int16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, int16&gt;&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;int16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int16&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int16&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Int16&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Int16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Int16}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Int16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,int&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,int&gt;&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;int&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int32&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int32&gt;&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Int32}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Int32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, int&gt;&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;int&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int32&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Int32&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Int32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Int32}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Int32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,long&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,long&gt;&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;long&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int64&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int64&gt;&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Int64}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Int64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, int64&gt;&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;int64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int64&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int64&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Int64&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Int64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Int64}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Int64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,sbyte&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,sbyte&gt;&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;sbyte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int8&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int8&gt;&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.SByte}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.SByte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, sbyte&gt;&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;sbyte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, sbyte&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.SByte&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.SByte&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.SByte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.SByte}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.SByte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,float&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,float&gt;&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;float&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float32&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, float32&gt;&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;float32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Single}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Single})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, single&gt;&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;single&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, single&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Single&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Single&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Single&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Single}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Single}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,string&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,string&gt;&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, string&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, string&gt;&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.String}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.ReadOnlyMemory{System.Char}})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, string&gt;&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, string&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.String&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.String&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because the empty string is never entered into the dictionary, it will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.String}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,ushort&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,ushort&gt;&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ushort&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int16&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int16&gt;&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;unsigned int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.UInt16}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.UInt16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, uint16&gt;&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;uint16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint16&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt16&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.UInt16&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.UInt16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.UInt16}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.UInt16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,uint&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,uint&gt;&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;uint&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int32&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int32&gt;&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;unsigned int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.UInt32}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.UInt32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, uint32&gt;&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;uint32&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint32&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt32&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.UInt32&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.UInt32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.UInt32}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.UInt32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,ulong&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,ulong&gt;&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ulong&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int64&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int64&gt;&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;unsigned int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.UInt64}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.UInt64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, uint64&gt;&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;uint64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint64&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt64&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.UInt64&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.UInt64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.UInt64}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.UInt64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,bool&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,bool&gt;&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;bool&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, bool&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, bool&gt;&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;bool&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Boolean}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Boolean})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, bool&gt;&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;bool&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Boolean&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Boolean&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Boolean&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Boolean}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Boolean}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,byte&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,byte&gt;&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;byte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int8&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int8&gt;&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;unsigned int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Byte}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Byte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, byte&gt;&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;byte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, byte&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Byte&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Byte&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Byte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Byte}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Byte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,double&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,double&gt;&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;double&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float64&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, float64&gt;&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;float64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Double}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Double})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, double&gt;&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;double&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, double&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Double&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Double&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Double&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Double}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Double}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,short&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,short&gt;&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;short&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int16&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int16&gt;&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Int16}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Int16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, int16&gt;&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;int16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int16&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int16&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Int16&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Int16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Int16}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Int16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,int&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,int&gt;&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;int&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int32&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int32&gt;&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Int32}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Int32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, int&gt;&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;int&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int32&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Int32&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Int32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Int32}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Int32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,long&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,long&gt;&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;long&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int64&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int64&gt;&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Int64}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Int64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, int64&gt;&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;int64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int64&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int64&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Int64&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Int64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Int64}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Int64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,sbyte&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,sbyte&gt;&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;sbyte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int8&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int8&gt;&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.SByte}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.SByte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, sbyte&gt;&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;sbyte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, sbyte&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.SByte&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.SByte&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.SByte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.SByte}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.SByte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,float&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,float&gt;&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;float&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float32&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, float32&gt;&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;float32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Single}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.Single})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, single&gt;&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;single&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, single&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Single&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Single&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.Single&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Single}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.Single}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,string&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,string&gt;&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, string&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, string&gt;&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.String}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.ReadOnlyMemory{System.Char}})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, string&gt;&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, string&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.String&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.String&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because the empty string is never entered into the dictionary, it will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.String}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,ushort&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,ushort&gt;&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ushort&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int16&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int16&gt;&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;unsigned int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.UInt16}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.UInt16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, uint16&gt;&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;uint16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint16&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt16&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.UInt16&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.UInt16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.UInt16}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.UInt16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,uint&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,uint&gt;&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;uint&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int32&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int32&gt;&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;unsigned int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.UInt32}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.UInt32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, uint32&gt;&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;uint32&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint32&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt32&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.UInt32&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.UInt32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.UInt32}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.UInt32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,ulong&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,ulong&gt;&gt; input, Microsoft.ML.Transforms.Conversions.KeyValueOrder order = Microsoft.ML.Transforms.Conversions.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;ulong&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int64&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int64&gt;&gt; input, valuetype Microsoft.ML.Transforms.Conversions.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1/OnFit&lt;unsigned int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.UInt64}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult`1.OnFit{System.UInt64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, uint64&gt;&gt; * Microsoft.ML.Transforms.Conversions.KeyValueOrder * int * Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;uint64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint64&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt64&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.UInt64&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Transforms.Conversions.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Transforms.Conversions.ToKeyFitResult&lt;System.UInt64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TermStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.UInt64}},Microsoft.ML.Transforms.Conversions.KeyValueOrder,System.Int32,Microsoft.ML.Transforms.Conversions.ToKeyFitResult{System.UInt64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="FeaturizeText">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; FeaturizeText (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, Microsoft.ML.StaticPipe.Scalar&lt;string&gt;[] otherInputs = null, Action&lt;Microsoft.ML.Transforms.Text.TextFeaturizingEstimator.Settings&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; FeaturizeText(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt;[] otherInputs, class System.Action`1&lt;class Microsoft.ML.Transforms.Text.TextFeaturizingEstimator/Settings&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TextFeaturizerStaticExtensions.FeaturizeText(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.StaticPipe.Scalar{System.String}[],System.Action{Microsoft.ML.Transforms.Text.TextFeaturizingEstimator.Settings})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FeaturizeText (input As Scalar(Of String), Optional otherInputs As Scalar(Of String)() = null, Optional advancedSettings As Action(Of TextFeaturizingEstimator.Settings) = null) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member FeaturizeText : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * Microsoft.ML.StaticPipe.Scalar&lt;string&gt;[] * Action&lt;Microsoft.ML.Transforms.Text.TextFeaturizingEstimator.Settings&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.TextFeaturizerStaticExtensions.FeaturizeText (input, otherInputs, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="otherInputs" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;[]" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Transforms.Text.TextFeaturizingEstimator+Settings&gt;" />
        </Parameters>
        <Docs>
          <param name="input">Input data.</param>
          <param name="otherInputs">Additional data.</param>
          <param name="advancedSettings">Delegate which allows you to set transformation settings.</param>
          <summary>
            Accept text data and converts it to array which represent combinations of ngram/skip-gram token counts.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TextFeaturizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TextFeaturizerStaticExtensions.FeaturizeText(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.StaticPipe.Scalar{System.String}[],System.Action{Microsoft.ML.Transforms.Text.TextFeaturizingEstimator.Settings})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="NormalizeText">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;string&gt; NormalizeText (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, Microsoft.ML.Transforms.Text.TextNormalizingEstimator.CaseNormalizationMode textCase = Microsoft.ML.Transforms.Text.TextNormalizingEstimator+CaseNormalizationMode.Lower, bool keepDiacritics = false, bool keepPunctuations = true, bool keepNumbers = true);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; NormalizeText(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, valuetype Microsoft.ML.Transforms.Text.TextNormalizingEstimator/CaseNormalizationMode textCase, bool keepDiacritics, bool keepPunctuations, bool keepNumbers) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TextNormalizerStaticExtensions.NormalizeText(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.Transforms.Text.TextNormalizingEstimator.CaseNormalizationMode,System.Boolean,System.Boolean,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeText (input As Scalar(Of String), Optional textCase As TextNormalizingEstimator.CaseNormalizationMode = Microsoft.ML.Transforms.Text.TextNormalizingEstimator+CaseNormalizationMode.Lower, Optional keepDiacritics As Boolean = false, Optional keepPunctuations As Boolean = true, Optional keepNumbers As Boolean = true) As Scalar(Of String)" />
        <MemberSignature Language="F#" Value="static member NormalizeText : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * Microsoft.ML.Transforms.Text.TextNormalizingEstimator.CaseNormalizationMode * bool * bool * bool -&gt; Microsoft.ML.StaticPipe.Scalar&lt;string&gt;" Usage="Microsoft.ML.StaticPipe.TextNormalizerStaticExtensions.NormalizeText (input, textCase, keepDiacritics, keepPunctuations, keepNumbers)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="textCase" Type="Microsoft.ML.Transforms.Text.TextNormalizingEstimator+CaseNormalizationMode" />
          <Parameter Name="keepDiacritics" Type="System.Boolean" />
          <Parameter Name="keepPunctuations" Type="System.Boolean" />
          <Parameter Name="keepNumbers" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="textCase">Casing text using the rules of the invariant culture.</param>
          <param name="keepDiacritics">Whether to keep diacritical marks or remove them.</param>
          <param name="keepPunctuations">Whether to keep punctuation marks or remove them.</param>
          <param name="keepNumbers">Whether to keep numbers or remove them.</param>
          <summary>
            Normalizes input text by changing case, removing diacritical marks, punctuation marks and/or numbers.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TextNormalizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TextNormalizerStaticExtensions.NormalizeText(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.Transforms.Text.TextNormalizingEstimator.CaseNormalizationMode,System.Boolean,System.Boolean,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext" />
      </Targets>
      <Member MemberName="CrossValidate&lt;TInShape,TOutShape,TTransformer&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.Data.CalibratedBinaryClassificationMetrics,Microsoft.ML.StaticPipe.Transformer&lt;TInShape,TOutShape,TTransformer&gt;,Microsoft.ML.StaticPipe.DataView&lt;TOutShape&gt;&gt;[] CrossValidate&lt;TInShape,TOutShape,TTransformer&gt; (this Microsoft.ML.BinaryClassificationContext context, Microsoft.ML.StaticPipe.DataView&lt;TInShape&gt; data, Microsoft.ML.StaticPipe.Estimator&lt;TInShape,TOutShape,TTransformer&gt; estimator, Func&lt;TOutShape,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; label, int numFolds = 5, Func&lt;TInShape,Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn = null, Nullable&lt;uint&gt; seed = null) where TTransformer : class, Microsoft.ML.Core.Data.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.Data.CalibratedBinaryClassificationMetrics, class Microsoft.ML.StaticPipe.Transformer`3&lt;!!TInShape, !!TOutShape, !!TTransformer&gt;, class Microsoft.ML.StaticPipe.DataView`1&lt;!!TOutShape&gt;&gt;[] CrossValidate&lt;TInShape, TOutShape, class (class Microsoft.ML.Core.Data.ITransformer) TTransformer&gt;(class Microsoft.ML.BinaryClassificationContext context, class Microsoft.ML.StaticPipe.DataView`1&lt;!!TInShape&gt; data, class Microsoft.ML.StaticPipe.Estimator`3&lt;!!TInShape, !!TOutShape, !!TTransformer&gt; estimator, class System.Func`2&lt;!!TOutShape, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; label, int32 numFolds, class System.Func`2&lt;!!TInShape, class Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn, valuetype System.Nullable`1&lt;unsigned int32&gt; seed) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TrainingStaticExtensions.CrossValidate``3(Microsoft.ML.BinaryClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn},System.Nullable{System.UInt32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CrossValidate(Of TInShape, TOutShape, TTransformer) (context As BinaryClassificationContext, data As DataView(Of TInShape), estimator As Estimator(Of TInShape, TOutShape, TTransformer), label As Func(Of TOutShape, Scalar(Of Boolean)), Optional numFolds As Integer = 5, Optional stratificationColumn As Func(Of TInShape, PipelineColumn) = null, Optional seed As Nullable(Of UInteger) = null) As ValueTuple(Of CalibratedBinaryClassificationMetrics, Transformer(Of TInShape, TOutShape, TTransformer), DataView(Of TOutShape))()" />
        <MemberSignature Language="F#" Value="static member CrossValidate : Microsoft.ML.BinaryClassificationContext * Microsoft.ML.StaticPipe.DataView&lt;'InShape&gt; * Microsoft.ML.StaticPipe.Estimator&lt;'InShape, 'OutShape, 'ransformer (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; * Func&lt;'OutShape, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; * int * Func&lt;'InShape, Microsoft.ML.StaticPipe.PipelineColumn&gt; * Nullable&lt;uint32&gt; -&gt; ValueTuple&lt;Microsoft.ML.Data.CalibratedBinaryClassificationMetrics, Microsoft.ML.StaticPipe.Transformer&lt;'InShape, 'OutShape, 'ransformer&gt;, Microsoft.ML.StaticPipe.DataView&lt;'OutShape&gt;&gt;[] (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.Core.Data.ITransformer)" Usage="Microsoft.ML.StaticPipe.TrainingStaticExtensions.CrossValidate (context, data, estimator, label, numFolds, stratificationColumn, seed)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.Data.CalibratedBinaryClassificationMetrics,Microsoft.ML.StaticPipe.Transformer&lt;TInShape,TOutShape,TTransformer&gt;,Microsoft.ML.StaticPipe.DataView&lt;TOutShape&gt;&gt;[]</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "metrics", "model", "scoredTestData" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TInShape" />
          <TypeParameter Name="TOutShape" />
          <TypeParameter Name="TTransformer">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="context" Type="Microsoft.ML.BinaryClassificationContext" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;TInShape&gt;" />
          <Parameter Name="estimator" Type="Microsoft.ML.StaticPipe.Estimator&lt;TInShape,TOutShape,TTransformer&gt;" />
          <Parameter Name="label" Type="System.Func&lt;TOutShape,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;" />
          <Parameter Name="numFolds" Type="System.Int32" />
          <Parameter Name="stratificationColumn" Type="System.Func&lt;TInShape,Microsoft.ML.StaticPipe.PipelineColumn&gt;" />
          <Parameter Name="seed" Type="System.Nullable&lt;System.UInt32&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TInShape">The input schema shape.</typeparam>
          <typeparam name="TOutShape">The output schema shape.</typeparam>
          <typeparam name="TTransformer">The type of the trained model.</typeparam>
          <param name="context">The training context.</param>
          <param name="data">The data to run cross-validation on.</param>
          <param name="estimator">The estimator to fit.</param>
          <param name="label">The label column (for evaluation).</param>
          <param name="numFolds">Number of cross-validation folds.</param>
          <param name="stratificationColumn">Optional selector for the column to use as a stratification column. If two examples share the same value of the <paramref name="stratificationColumn" />
            (if provided), they are guaranteed to appear in the same subset (train or test). Use this to make sure there is no label leakage from train to the test set.
            If this optional parameter is not provided, a stratification columns will be generated, and its values will be random numbers .</param>
          <param name="seed">Optional parameter used in combination with the <paramref name="stratificationColumn" />.
            If the <paramref name="stratificationColumn" /> is not provided, the random numbers generated to create it, will use this seed as value.
            And if it is not provided, the default value will be used.</param>
          <summary>
            Run cross-validation over <paramref name="numFolds" /> folds of <paramref name="data" />, by fitting <paramref name="estimator" />,
            and respecting <paramref name="stratificationColumn" /> if provided.
            Then evaluate each sub-model against <paramref name="label" /> and return metrics.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TrainingStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TrainingStaticExtensions.CrossValidate``3(Microsoft.ML.BinaryClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn},System.Nullable{System.UInt32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationContext" />
      </Targets>
      <Member MemberName="CrossValidate&lt;TInShape,TOutShape,TTransformer&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.Data.MultiClassClassifierMetrics,Microsoft.ML.StaticPipe.Transformer&lt;TInShape,TOutShape,TTransformer&gt;,Microsoft.ML.StaticPipe.DataView&lt;TOutShape&gt;&gt;[] CrossValidate&lt;TInShape,TOutShape,TTransformer&gt; (this Microsoft.ML.MulticlassClassificationContext context, Microsoft.ML.StaticPipe.DataView&lt;TInShape&gt; data, Microsoft.ML.StaticPipe.Estimator&lt;TInShape,TOutShape,TTransformer&gt; estimator, Func&lt;TOutShape,Microsoft.ML.StaticPipe.Key&lt;uint&gt;&gt; label, int numFolds = 5, Func&lt;TInShape,Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn = null, Nullable&lt;uint&gt; seed = null) where TTransformer : class, Microsoft.ML.Core.Data.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.Data.MultiClassClassifierMetrics, class Microsoft.ML.StaticPipe.Transformer`3&lt;!!TInShape, !!TOutShape, !!TTransformer&gt;, class Microsoft.ML.StaticPipe.DataView`1&lt;!!TOutShape&gt;&gt;[] CrossValidate&lt;TInShape, TOutShape, class (class Microsoft.ML.Core.Data.ITransformer) TTransformer&gt;(class Microsoft.ML.MulticlassClassificationContext context, class Microsoft.ML.StaticPipe.DataView`1&lt;!!TInShape&gt; data, class Microsoft.ML.StaticPipe.Estimator`3&lt;!!TInShape, !!TOutShape, !!TTransformer&gt; estimator, class System.Func`2&lt;!!TOutShape, class Microsoft.ML.StaticPipe.Key`1&lt;unsigned int32&gt;&gt; label, int32 numFolds, class System.Func`2&lt;!!TInShape, class Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn, valuetype System.Nullable`1&lt;unsigned int32&gt; seed) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TrainingStaticExtensions.CrossValidate``3(Microsoft.ML.MulticlassClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Key{System.UInt32}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn},System.Nullable{System.UInt32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CrossValidate(Of TInShape, TOutShape, TTransformer) (context As MulticlassClassificationContext, data As DataView(Of TInShape), estimator As Estimator(Of TInShape, TOutShape, TTransformer), label As Func(Of TOutShape, Key(Of UInteger)), Optional numFolds As Integer = 5, Optional stratificationColumn As Func(Of TInShape, PipelineColumn) = null, Optional seed As Nullable(Of UInteger) = null) As ValueTuple(Of MultiClassClassifierMetrics, Transformer(Of TInShape, TOutShape, TTransformer), DataView(Of TOutShape))()" />
        <MemberSignature Language="F#" Value="static member CrossValidate : Microsoft.ML.MulticlassClassificationContext * Microsoft.ML.StaticPipe.DataView&lt;'InShape&gt; * Microsoft.ML.StaticPipe.Estimator&lt;'InShape, 'OutShape, 'ransformer (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; * Func&lt;'OutShape, Microsoft.ML.StaticPipe.Key&lt;uint32&gt;&gt; * int * Func&lt;'InShape, Microsoft.ML.StaticPipe.PipelineColumn&gt; * Nullable&lt;uint32&gt; -&gt; ValueTuple&lt;Microsoft.ML.Data.MultiClassClassifierMetrics, Microsoft.ML.StaticPipe.Transformer&lt;'InShape, 'OutShape, 'ransformer&gt;, Microsoft.ML.StaticPipe.DataView&lt;'OutShape&gt;&gt;[] (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.Core.Data.ITransformer)" Usage="Microsoft.ML.StaticPipe.TrainingStaticExtensions.CrossValidate (context, data, estimator, label, numFolds, stratificationColumn, seed)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.Data.MultiClassClassifierMetrics,Microsoft.ML.StaticPipe.Transformer&lt;TInShape,TOutShape,TTransformer&gt;,Microsoft.ML.StaticPipe.DataView&lt;TOutShape&gt;&gt;[]</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "metrics", "model", "scoredTestData" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TInShape" />
          <TypeParameter Name="TOutShape" />
          <TypeParameter Name="TTransformer">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="context" Type="Microsoft.ML.MulticlassClassificationContext" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;TInShape&gt;" />
          <Parameter Name="estimator" Type="Microsoft.ML.StaticPipe.Estimator&lt;TInShape,TOutShape,TTransformer&gt;" />
          <Parameter Name="label" Type="System.Func&lt;TOutShape,Microsoft.ML.StaticPipe.Key&lt;System.UInt32&gt;&gt;" />
          <Parameter Name="numFolds" Type="System.Int32" />
          <Parameter Name="stratificationColumn" Type="System.Func&lt;TInShape,Microsoft.ML.StaticPipe.PipelineColumn&gt;" />
          <Parameter Name="seed" Type="System.Nullable&lt;System.UInt32&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TInShape">The input schema shape.</typeparam>
          <typeparam name="TOutShape">The output schema shape.</typeparam>
          <typeparam name="TTransformer">The type of the trained model.</typeparam>
          <param name="context">The training context.</param>
          <param name="data">The data to run cross-validation on.</param>
          <param name="estimator">The estimator to fit.</param>
          <param name="label">The label column (for evaluation).</param>
          <param name="numFolds">Number of cross-validation folds.</param>
          <param name="stratificationColumn">Optional selector for the column to use as a stratification column. If two examples share the same value of the <paramref name="stratificationColumn" />
            (if provided), they are guaranteed to appear in the same subset (train or test). Use this to make sure there is no label leakage from train to the test set.
            If this optional parameter is not provided, a stratification columns will be generated, and its values will be random numbers .</param>
          <param name="seed">Optional parameter used in combination with the <paramref name="stratificationColumn" />.
            If the <paramref name="stratificationColumn" /> is not provided, the random numbers generated to create it, will use this seed as value.
            And if it is not provided, the default value will be used.</param>
          <summary>
            Run cross-validation over <paramref name="numFolds" /> folds of <paramref name="data" />, by fitting <paramref name="estimator" />,
            and respecting <paramref name="stratificationColumn" /> if provided.
            Then evaluate each sub-model against <paramref name="label" /> and return metrics.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TrainingStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TrainingStaticExtensions.CrossValidate``3(Microsoft.ML.MulticlassClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Key{System.UInt32}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn},System.Nullable{System.UInt32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionContext" />
      </Targets>
      <Member MemberName="CrossValidate&lt;TInShape,TOutShape,TTransformer&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.Data.RegressionMetrics,Microsoft.ML.StaticPipe.Transformer&lt;TInShape,TOutShape,TTransformer&gt;,Microsoft.ML.StaticPipe.DataView&lt;TOutShape&gt;&gt;[] CrossValidate&lt;TInShape,TOutShape,TTransformer&gt; (this Microsoft.ML.RegressionContext context, Microsoft.ML.StaticPipe.DataView&lt;TInShape&gt; data, Microsoft.ML.StaticPipe.Estimator&lt;TInShape,TOutShape,TTransformer&gt; estimator, Func&lt;TOutShape,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;&gt; label, int numFolds = 5, Func&lt;TInShape,Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn = null, Nullable&lt;uint&gt; seed = null) where TTransformer : class, Microsoft.ML.Core.Data.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.Data.RegressionMetrics, class Microsoft.ML.StaticPipe.Transformer`3&lt;!!TInShape, !!TOutShape, !!TTransformer&gt;, class Microsoft.ML.StaticPipe.DataView`1&lt;!!TOutShape&gt;&gt;[] CrossValidate&lt;TInShape, TOutShape, class (class Microsoft.ML.Core.Data.ITransformer) TTransformer&gt;(class Microsoft.ML.RegressionContext context, class Microsoft.ML.StaticPipe.DataView`1&lt;!!TInShape&gt; data, class Microsoft.ML.StaticPipe.Estimator`3&lt;!!TInShape, !!TOutShape, !!TTransformer&gt; estimator, class System.Func`2&lt;!!TOutShape, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;&gt; label, int32 numFolds, class System.Func`2&lt;!!TInShape, class Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn, valuetype System.Nullable`1&lt;unsigned int32&gt; seed) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TrainingStaticExtensions.CrossValidate``3(Microsoft.ML.RegressionContext,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{System.Single}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn},System.Nullable{System.UInt32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CrossValidate(Of TInShape, TOutShape, TTransformer) (context As RegressionContext, data As DataView(Of TInShape), estimator As Estimator(Of TInShape, TOutShape, TTransformer), label As Func(Of TOutShape, Scalar(Of Single)), Optional numFolds As Integer = 5, Optional stratificationColumn As Func(Of TInShape, PipelineColumn) = null, Optional seed As Nullable(Of UInteger) = null) As ValueTuple(Of RegressionMetrics, Transformer(Of TInShape, TOutShape, TTransformer), DataView(Of TOutShape))()" />
        <MemberSignature Language="F#" Value="static member CrossValidate : Microsoft.ML.RegressionContext * Microsoft.ML.StaticPipe.DataView&lt;'InShape&gt; * Microsoft.ML.StaticPipe.Estimator&lt;'InShape, 'OutShape, 'ransformer (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; * Func&lt;'OutShape, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;&gt; * int * Func&lt;'InShape, Microsoft.ML.StaticPipe.PipelineColumn&gt; * Nullable&lt;uint32&gt; -&gt; ValueTuple&lt;Microsoft.ML.Data.RegressionMetrics, Microsoft.ML.StaticPipe.Transformer&lt;'InShape, 'OutShape, 'ransformer&gt;, Microsoft.ML.StaticPipe.DataView&lt;'OutShape&gt;&gt;[] (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.Core.Data.ITransformer)" Usage="Microsoft.ML.StaticPipe.TrainingStaticExtensions.CrossValidate (context, data, estimator, label, numFolds, stratificationColumn, seed)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.Data.RegressionMetrics,Microsoft.ML.StaticPipe.Transformer&lt;TInShape,TOutShape,TTransformer&gt;,Microsoft.ML.StaticPipe.DataView&lt;TOutShape&gt;&gt;[]</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "metrics", "model", "scoredTestData" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TInShape" />
          <TypeParameter Name="TOutShape" />
          <TypeParameter Name="TTransformer">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="context" Type="Microsoft.ML.RegressionContext" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;TInShape&gt;" />
          <Parameter Name="estimator" Type="Microsoft.ML.StaticPipe.Estimator&lt;TInShape,TOutShape,TTransformer&gt;" />
          <Parameter Name="label" Type="System.Func&lt;TOutShape,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;&gt;" />
          <Parameter Name="numFolds" Type="System.Int32" />
          <Parameter Name="stratificationColumn" Type="System.Func&lt;TInShape,Microsoft.ML.StaticPipe.PipelineColumn&gt;" />
          <Parameter Name="seed" Type="System.Nullable&lt;System.UInt32&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TInShape">The input schema shape.</typeparam>
          <typeparam name="TOutShape">The output schema shape.</typeparam>
          <typeparam name="TTransformer">The type of the trained model.</typeparam>
          <param name="context">The training context.</param>
          <param name="data">The data to run cross-validation on.</param>
          <param name="estimator">The estimator to fit.</param>
          <param name="label">The label column (for evaluation).</param>
          <param name="numFolds">Number of cross-validation folds.</param>
          <param name="stratificationColumn">Optional selector for the column to use as a stratification column. If two examples share the same value of the <paramref name="stratificationColumn" />
            (if provided), they are guaranteed to appear in the same subset (train or test). Use this to make sure there is no label leakage from train to the test set.
            If this optional parameter is not provided, a stratification columns will be generated, and its values will be random numbers .</param>
          <param name="seed">Optional parameter used in combination with the <paramref name="stratificationColumn" />.
            If the <paramref name="stratificationColumn" /> is not provided, the random numbers generated to create it, will use this seed as value.
            And if it is not provided, the default value will be used.</param>
          <summary>
            Run cross-validation over <paramref name="numFolds" /> folds of <paramref name="data" />, by fitting <paramref name="estimator" />,
            and respecting <paramref name="stratificationColumn" /> if provided.
            Then evaluate each sub-model against <paramref name="label" /> and return metrics.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TrainingStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TrainingStaticExtensions.CrossValidate``3(Microsoft.ML.RegressionContext,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{System.Single}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn},System.Nullable{System.UInt32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext" />
      </Targets>
      <Member MemberName="CrossValidateNonCalibrated&lt;TInShape,TOutShape,TTransformer&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.Data.BinaryClassificationMetrics,Microsoft.ML.StaticPipe.Transformer&lt;TInShape,TOutShape,TTransformer&gt;,Microsoft.ML.StaticPipe.DataView&lt;TOutShape&gt;&gt;[] CrossValidateNonCalibrated&lt;TInShape,TOutShape,TTransformer&gt; (this Microsoft.ML.BinaryClassificationContext context, Microsoft.ML.StaticPipe.DataView&lt;TInShape&gt; data, Microsoft.ML.StaticPipe.Estimator&lt;TInShape,TOutShape,TTransformer&gt; estimator, Func&lt;TOutShape,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; label, int numFolds = 5, Func&lt;TInShape,Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn = null, Nullable&lt;uint&gt; seed = null) where TTransformer : class, Microsoft.ML.Core.Data.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.Data.BinaryClassificationMetrics, class Microsoft.ML.StaticPipe.Transformer`3&lt;!!TInShape, !!TOutShape, !!TTransformer&gt;, class Microsoft.ML.StaticPipe.DataView`1&lt;!!TOutShape&gt;&gt;[] CrossValidateNonCalibrated&lt;TInShape, TOutShape, class (class Microsoft.ML.Core.Data.ITransformer) TTransformer&gt;(class Microsoft.ML.BinaryClassificationContext context, class Microsoft.ML.StaticPipe.DataView`1&lt;!!TInShape&gt; data, class Microsoft.ML.StaticPipe.Estimator`3&lt;!!TInShape, !!TOutShape, !!TTransformer&gt; estimator, class System.Func`2&lt;!!TOutShape, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; label, int32 numFolds, class System.Func`2&lt;!!TInShape, class Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn, valuetype System.Nullable`1&lt;unsigned int32&gt; seed) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TrainingStaticExtensions.CrossValidateNonCalibrated``3(Microsoft.ML.BinaryClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn},System.Nullable{System.UInt32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CrossValidateNonCalibrated(Of TInShape, TOutShape, TTransformer) (context As BinaryClassificationContext, data As DataView(Of TInShape), estimator As Estimator(Of TInShape, TOutShape, TTransformer), label As Func(Of TOutShape, Scalar(Of Boolean)), Optional numFolds As Integer = 5, Optional stratificationColumn As Func(Of TInShape, PipelineColumn) = null, Optional seed As Nullable(Of UInteger) = null) As ValueTuple(Of BinaryClassificationMetrics, Transformer(Of TInShape, TOutShape, TTransformer), DataView(Of TOutShape))()" />
        <MemberSignature Language="F#" Value="static member CrossValidateNonCalibrated : Microsoft.ML.BinaryClassificationContext * Microsoft.ML.StaticPipe.DataView&lt;'InShape&gt; * Microsoft.ML.StaticPipe.Estimator&lt;'InShape, 'OutShape, 'ransformer (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; * Func&lt;'OutShape, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; * int * Func&lt;'InShape, Microsoft.ML.StaticPipe.PipelineColumn&gt; * Nullable&lt;uint32&gt; -&gt; ValueTuple&lt;Microsoft.ML.Data.BinaryClassificationMetrics, Microsoft.ML.StaticPipe.Transformer&lt;'InShape, 'OutShape, 'ransformer&gt;, Microsoft.ML.StaticPipe.DataView&lt;'OutShape&gt;&gt;[] (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.Core.Data.ITransformer)" Usage="Microsoft.ML.StaticPipe.TrainingStaticExtensions.CrossValidateNonCalibrated (context, data, estimator, label, numFolds, stratificationColumn, seed)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.Data.BinaryClassificationMetrics,Microsoft.ML.StaticPipe.Transformer&lt;TInShape,TOutShape,TTransformer&gt;,Microsoft.ML.StaticPipe.DataView&lt;TOutShape&gt;&gt;[]</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "metrics", "model", "scoredTestData" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TInShape" />
          <TypeParameter Name="TOutShape" />
          <TypeParameter Name="TTransformer">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="context" Type="Microsoft.ML.BinaryClassificationContext" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;TInShape&gt;" />
          <Parameter Name="estimator" Type="Microsoft.ML.StaticPipe.Estimator&lt;TInShape,TOutShape,TTransformer&gt;" />
          <Parameter Name="label" Type="System.Func&lt;TOutShape,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;" />
          <Parameter Name="numFolds" Type="System.Int32" />
          <Parameter Name="stratificationColumn" Type="System.Func&lt;TInShape,Microsoft.ML.StaticPipe.PipelineColumn&gt;" />
          <Parameter Name="seed" Type="System.Nullable&lt;System.UInt32&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TInShape">The input schema shape.</typeparam>
          <typeparam name="TOutShape">The output schema shape.</typeparam>
          <typeparam name="TTransformer">The type of the trained model.</typeparam>
          <param name="context">The training context.</param>
          <param name="data">The data to run cross-validation on.</param>
          <param name="estimator">The estimator to fit.</param>
          <param name="label">The label column (for evaluation).</param>
          <param name="numFolds">Number of cross-validation folds.</param>
          <param name="stratificationColumn">Optional selector for the column to use as a stratification column. If two examples share the same value of the <paramref name="stratificationColumn" />
            (if provided), they are guaranteed to appear in the same subset (train or test). Use this to make sure there is no label leakage from train to the test set.
            If this optional parameter is not provided, a stratification columns will be generated, and its values will be random numbers .</param>
          <param name="seed">Optional parameter used in combination with the <paramref name="stratificationColumn" />.
            If the <paramref name="stratificationColumn" /> is not provided, the random numbers generated to create it, will use this seed as value.
            And if it is not provided, the default value will be used.</param>
          <summary>
            Run cross-validation over <paramref name="numFolds" /> folds of <paramref name="data" />, by fitting <paramref name="estimator" />,
            and respecting <paramref name="stratificationColumn" /> if provided.
            Then evaluate each sub-model against <paramref name="label" /> and return metrics.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TrainingStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TrainingStaticExtensions.CrossValidateNonCalibrated``3(Microsoft.ML.BinaryClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn},System.Nullable{System.UInt32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TrainContextBase" />
      </Targets>
      <Member MemberName="TrainTestSplit&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.DataView&lt;T&gt;,Microsoft.ML.StaticPipe.DataView&lt;T&gt;&gt; TrainTestSplit&lt;T&gt; (this Microsoft.ML.TrainContextBase context, Microsoft.ML.StaticPipe.DataView&lt;T&gt; data, double testFraction = 0.1, Func&lt;T,Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn = null, Nullable&lt;uint&gt; seed = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt;, class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt;&gt; TrainTestSplit&lt;T&gt;(class Microsoft.ML.TrainContextBase context, class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt; data, float64 testFraction, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn, valuetype System.Nullable`1&lt;unsigned int32&gt; seed) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TrainingStaticExtensions.TrainTestSplit``1(Microsoft.ML.TrainContextBase,Microsoft.ML.StaticPipe.DataView{``0},System.Double,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn},System.Nullable{System.UInt32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrainTestSplit(Of T) (context As TrainContextBase, data As DataView(Of T), Optional testFraction As Double = 0.1, Optional stratificationColumn As Func(Of T, PipelineColumn) = null, Optional seed As Nullable(Of UInteger) = null) As ValueTuple(Of DataView(Of T), DataView(Of T))" />
        <MemberSignature Language="F#" Value="static member TrainTestSplit : Microsoft.ML.TrainContextBase * Microsoft.ML.StaticPipe.DataView&lt;'T&gt; * double * Func&lt;'T, Microsoft.ML.StaticPipe.PipelineColumn&gt; * Nullable&lt;uint32&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.DataView&lt;'T&gt;, Microsoft.ML.StaticPipe.DataView&lt;'T&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TrainingStaticExtensions.TrainTestSplit (context, data, testFraction, stratificationColumn, seed)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.DataView&lt;T&gt;,Microsoft.ML.StaticPipe.DataView&lt;T&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "trainSet", "testSet" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="context" Type="Microsoft.ML.TrainContextBase" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;T&gt;" />
          <Parameter Name="testFraction" Type="System.Double" />
          <Parameter Name="stratificationColumn" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.PipelineColumn&gt;" />
          <Parameter Name="seed" Type="System.Nullable&lt;System.UInt32&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="T">The tuple describing the data schema.</typeparam>
          <param name="context">The training context.</param>
          <param name="data">The dataset to split.</param>
          <param name="testFraction">The fraction of data to go into the test set.</param>
          <param name="stratificationColumn">Optional selector for the column to use as a stratification column. If two examples share the same value of the <paramref name="stratificationColumn" />
            (if provided), they are guaranteed to appear in the same subset (train or test). Use this to make sure there is no label leakage from train to the test set.
            If this optional parameter is not provided, a stratification columns will be generated, and its values will be random numbers .</param>
          <param name="seed">Optional parameter used in combination with the <paramref name="stratificationColumn" />.
            If the <paramref name="stratificationColumn" /> is not provided, the random numbers generated to create it, will use this seed as value.
            And if it is not provided, the default value will be used.</param>
          <summary>
            Split the dataset into the train set and test set according to the given fraction.
            Respects the <paramref name="stratificationColumn" /> if provided.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TrainingStaticExtensions" Member="M:Microsoft.ML.StaticPipe.TrainingStaticExtensions.TrainTestSplit``1(Microsoft.ML.TrainContextBase,Microsoft.ML.StaticPipe.DataView{``0},System.Double,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn},System.Nullable{System.UInt32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="FastTree">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; FastTree (this Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers ctx, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, int numLeaves = 20, int numTrees = 100, int minDatapointsInLeaves = 10, double learningRate = 0.2, Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeBinaryClassificationTrainer.Arguments&gt; advancedSettings = null, Action&lt;Microsoft.ML.Internal.Internallearn.IPredictorWithFeatureWeights&lt;float&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; FastTree(class Microsoft.ML.BinaryClassificationContext/BinaryClassificationTrainers ctx, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, int32 numLeaves, int32 numTrees, int32 minDatapointsInLeaves, float64 learningRate, class System.Action`1&lt;class Microsoft.ML.Trainers.FastTree.FastTreeBinaryClassificationTrainer/Arguments&gt; advancedSettings, class System.Action`1&lt;class Microsoft.ML.Internal.Internallearn.IPredictorWithFeatureWeights`1&lt;float32&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Trainers.FastTree.FastTreeBinaryClassificationTrainer.Arguments},System.Action{Microsoft.ML.Internal.Internallearn.IPredictorWithFeatureWeights{System.Single}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FastTree (ctx As BinaryClassificationContext.BinaryClassificationTrainers, label As Scalar(Of Boolean), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional numLeaves As Integer = 20, Optional numTrees As Integer = 100, Optional minDatapointsInLeaves As Integer = 10, Optional learningRate As Double = 0.2, Optional advancedSettings As Action(Of FastTreeBinaryClassificationTrainer.Arguments) = null, Optional onFit As Action(Of IPredictorWithFeatureWeights(Of Single)) = null) As ValueTuple(Of Scalar(Of Single), Scalar(Of Single), Scalar(Of Boolean))" />
        <MemberSignature Language="F#" Value="static member FastTree : Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * int * int * int * double * Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeBinaryClassificationTrainer.Arguments&gt; * Action&lt;Microsoft.ML.Internal.Internallearn.IPredictorWithFeatureWeights&lt;single&gt;&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree (ctx, label, features, weights, numLeaves, numTrees, minDatapointsInLeaves, learningRate, advancedSettings, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "probability", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="numLeaves" Type="System.Int32" />
          <Parameter Name="numTrees" Type="System.Int32" />
          <Parameter Name="minDatapointsInLeaves" Type="System.Int32" />
          <Parameter Name="learningRate" Type="System.Double" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeBinaryClassificationTrainer+Arguments&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Internal.Internallearn.IPredictorWithFeatureWeights&lt;System.Single&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The <see cref="T:Microsoft.ML.BinaryClassificationContext" />.</param>
          <param name="label">The label column.</param>
          <param name="features">The features column.</param>
          <param name="weights">The optional weights column.</param>
          <param name="numLeaves">The maximum number of leaves per decision tree.</param>
          <param name="numTrees">Total number of decision trees to create in the ensemble.</param>
          <param name="minDatapointsInLeaves">The minimal number of datapoints allowed in a leaf of the tree, out of the subsampled data.</param>
          <param name="learningRate">The learning rate.</param>
          <param name="advancedSettings">Algorithm advanced settings.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained. Note that this action cannot change the result in any way;
            it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            FastTree <see cref="T:Microsoft.ML.BinaryClassificationContext" /> extension method.
            Predict a target using a decision tree binary classificaiton model trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.FastTreeBinaryClassificationTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TreeRegressionExtensions" Member="M:Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Trainers.FastTree.FastTreeBinaryClassificationTrainer.Arguments},System.Action{Microsoft.ML.Internal.Internallearn.IPredictorWithFeatureWeights{System.Single}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionContext.RegressionTrainers" />
      </Targets>
      <Member MemberName="FastTree">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; FastTree (this Microsoft.ML.RegressionContext.RegressionTrainers ctx, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, int numLeaves = 20, int numTrees = 100, int minDatapointsInLeaves = 10, double learningRate = 0.2, Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer.Arguments&gt; advancedSettings = null, Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRegressionModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; FastTree(class Microsoft.ML.RegressionContext/RegressionTrainers ctx, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, int32 numLeaves, int32 numTrees, int32 minDatapointsInLeaves, float64 learningRate, class System.Action`1&lt;class Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer/Arguments&gt; advancedSettings, class System.Action`1&lt;class Microsoft.ML.Trainers.FastTree.FastTreeRegressionModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree(Microsoft.ML.RegressionContext.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer.Arguments},System.Action{Microsoft.ML.Trainers.FastTree.FastTreeRegressionModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FastTree (ctx As RegressionContext.RegressionTrainers, label As Scalar(Of Single), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional numLeaves As Integer = 20, Optional numTrees As Integer = 100, Optional minDatapointsInLeaves As Integer = 10, Optional learningRate As Double = 0.2, Optional advancedSettings As Action(Of FastTreeRegressionTrainer.Arguments) = null, Optional onFit As Action(Of FastTreeRegressionModelParameters) = null) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member FastTree : Microsoft.ML.RegressionContext.RegressionTrainers * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * int * int * int * double * Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer.Arguments&gt; * Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRegressionModelParameters&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree (ctx, label, features, weights, numLeaves, numTrees, minDatapointsInLeaves, learningRate, advancedSettings, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RegressionContext+RegressionTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="numLeaves" Type="System.Int32" />
          <Parameter Name="numTrees" Type="System.Int32" />
          <Parameter Name="minDatapointsInLeaves" Type="System.Int32" />
          <Parameter Name="learningRate" Type="System.Double" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer+Arguments&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRegressionModelParameters&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The <see cref="T:Microsoft.ML.RegressionContext" />.</param>
          <param name="label">The label column.</param>
          <param name="features">The features column.</param>
          <param name="weights">The optional weights column.</param>
          <param name="numLeaves">The maximum number of leaves per decision tree.</param>
          <param name="numTrees">Total number of decision trees to create in the ensemble.</param>
          <param name="minDatapointsInLeaves">The minimal number of datapoints allowed in a leaf of a regression tree, out of the subsampled data.</param>
          <param name="learningRate">The learning rate.</param>
          <param name="advancedSettings">Algorithm advanced settings.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained. Note that this action cannot change the result in any way;
            it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            FastTree <see cref="T:Microsoft.ML.RegressionContext" /> extension method.
            Predicts a target using a decision tree regression model trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TreeRegressionExtensions" Member="M:Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree(Microsoft.ML.RegressionContext.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer.Arguments},System.Action{Microsoft.ML.Trainers.FastTree.FastTreeRegressionModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RankingContext.RankingTrainers" />
      </Targets>
      <Member MemberName="FastTree&lt;TVal&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; FastTree&lt;TVal&gt; (this Microsoft.ML.RankingContext.RankingTrainers ctx, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt; groupId, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, int numLeaves = 20, int numTrees = 100, int minDatapointsInLeaves = 10, double learningRate = 0.2, Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer.Arguments&gt; advancedSettings = null, Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRankingModelParameters&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; FastTree&lt;TVal&gt;(class Microsoft.ML.RankingContext/RankingTrainers ctx, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt; groupId, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, int32 numLeaves, int32 numTrees, int32 minDatapointsInLeaves, float64 learningRate, class System.Action`1&lt;class Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer/Arguments&gt; advancedSettings, class System.Action`1&lt;class Microsoft.ML.Trainers.FastTree.FastTreeRankingModelParameters&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree``1(Microsoft.ML.RankingContext.RankingTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer.Arguments},System.Action{Microsoft.ML.Trainers.FastTree.FastTreeRankingModelParameters})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FastTree(Of TVal) (ctx As RankingContext.RankingTrainers, label As Scalar(Of Single), features As Vector(Of Single), groupId As Key(Of UInteger, TVal), Optional weights As Scalar(Of Single) = null, Optional numLeaves As Integer = 20, Optional numTrees As Integer = 100, Optional minDatapointsInLeaves As Integer = 10, Optional learningRate As Double = 0.2, Optional advancedSettings As Action(Of FastTreeRankingTrainer.Arguments) = null, Optional onFit As Action(Of FastTreeRankingModelParameters) = null) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member FastTree : Microsoft.ML.RankingContext.RankingTrainers * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * int * int * int * double * Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer.Arguments&gt; * Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRankingModelParameters&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree (ctx, label, features, groupId, weights, numLeaves, numTrees, minDatapointsInLeaves, learningRate, advancedSettings, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TVal" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RankingContext+RankingTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="groupId" Type="Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="numLeaves" Type="System.Int32" />
          <Parameter Name="numTrees" Type="System.Int32" />
          <Parameter Name="minDatapointsInLeaves" Type="System.Int32" />
          <Parameter Name="learningRate" Type="System.Double" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer+Arguments&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRankingModelParameters&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TVal">To be added.</typeparam>
          <param name="ctx">The <see cref="T:Microsoft.ML.RegressionContext" />.</param>
          <param name="label">The label column.</param>
          <param name="features">The features column.</param>
          <param name="groupId">The groupId column.</param>
          <param name="weights">The optional weights column.</param>
          <param name="numLeaves">The maximum number of leaves per decision tree.</param>
          <param name="numTrees">Total number of decision trees to create in the ensemble.</param>
          <param name="minDatapointsInLeaves">The minimal number of datapoints allowed in a leaf of a regression tree, out of the subsampled data.</param>
          <param name="learningRate">The learning rate.</param>
          <param name="advancedSettings">Algorithm advanced settings.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained. Note that this action cannot change the result in any way;
            it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            FastTree <see cref="T:Microsoft.ML.RankingContext" />.
            Ranks a series of inputs based on their relevance, training a decision tree ranking model through the <see cref="T:Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.TreeRegressionExtensions" Member="M:Microsoft.ML.StaticPipe.TreeRegressionExtensions.FastTree``1(Microsoft.ML.RankingContext.RankingTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer.Arguments},System.Action{Microsoft.ML.Trainers.FastTree.FastTreeRankingModelParameters})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToBagofWords">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBagofWords (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, int ngramLength = 1, int skipLength = 0, bool allLengths = true, int maxNumTerms = 10000000, Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria weighting = Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria.Tf);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBagofWords(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, int32 ngramLength, int32 skipLength, bool allLengths, int32 maxNumTerms, valuetype Microsoft.ML.Transforms.Text.NgramExtractingEstimator/WeightingCriteria weighting) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.WordBagEstimatorStaticExtensions.ToBagofWords(Microsoft.ML.StaticPipe.Scalar{System.String},System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBagofWords (input As Scalar(Of String), Optional ngramLength As Integer = 1, Optional skipLength As Integer = 0, Optional allLengths As Boolean = true, Optional maxNumTerms As Integer = 10000000, Optional weighting As NgramExtractingEstimator.WeightingCriteria = Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria.Tf) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBagofWords : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * int * int * bool * int * Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.WordBagEstimatorStaticExtensions.ToBagofWords (input, ngramLength, skipLength, allLengths, maxNumTerms, weighting)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="allLengths" Type="System.Boolean" />
          <Parameter Name="maxNumTerms" Type="System.Int32" />
          <Parameter Name="weighting" Type="Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="allLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="maxNumTerms">Maximum number of ngrams to store in the dictionary.</param>
          <param name="weighting">Statistical measure used to evaluate how important a word is to a document in a corpus.</param>
          <summary>
            Produces a bag of counts of ngrams (sequences of consecutive words ) in a given text.
            It does so by building a dictionary of ngrams and using the id in the dictionary as the index in the bag.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.WordBagEstimatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.WordBagEstimatorStaticExtensions.ToBagofWords(Microsoft.ML.StaticPipe.Scalar{System.String},System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="WordEmbeddings">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; WordEmbeddings (this Microsoft.ML.StaticPipe.VarVector&lt;string&gt; input, Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer.PretrainedModelKind modelKind = Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer+PretrainedModelKind.Sswe);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; WordEmbeddings(class Microsoft.ML.StaticPipe.VarVector`1&lt;string&gt; input, valuetype Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer/PretrainedModelKind modelKind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.WordEmbeddingsStaticExtensions.WordEmbeddings(Microsoft.ML.StaticPipe.VarVector{System.String},Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer.PretrainedModelKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WordEmbeddings (input As VarVector(Of String), Optional modelKind As WordEmbeddingsExtractingTransformer.PretrainedModelKind = Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer+PretrainedModelKind.Sswe) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member WordEmbeddings : Microsoft.ML.StaticPipe.VarVector&lt;string&gt; * Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer.PretrainedModelKind -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.WordEmbeddingsStaticExtensions.WordEmbeddings (input, modelKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.String&gt;" RefType="this" />
          <Parameter Name="modelKind" Type="Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer+PretrainedModelKind" />
        </Parameters>
        <Docs>
          <param name="input">Vector of tokenized text.</param>
          <param name="modelKind">The pretrained word embedding model.</param>
          <summary>
        Word Embeddings transform is a text featurizer which converts vectors of text tokens into sentence vectors using a pre-trained model.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.WordEmbeddingsStaticExtensions" Member="M:Microsoft.ML.StaticPipe.WordEmbeddingsStaticExtensions.WordEmbeddings(Microsoft.ML.StaticPipe.VarVector{System.String},Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer.PretrainedModelKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="WordEmbeddings">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; WordEmbeddings (this Microsoft.ML.StaticPipe.VarVector&lt;string&gt; input, string customModelFile);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; WordEmbeddings(class Microsoft.ML.StaticPipe.VarVector`1&lt;string&gt; input, string customModelFile) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.WordEmbeddingsStaticExtensions.WordEmbeddings(Microsoft.ML.StaticPipe.VarVector{System.String},System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WordEmbeddings (input As VarVector(Of String), customModelFile As String) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member WordEmbeddings : Microsoft.ML.StaticPipe.VarVector&lt;string&gt; * string -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.WordEmbeddingsStaticExtensions.WordEmbeddings (input, customModelFile)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.String&gt;" RefType="this" />
          <Parameter Name="customModelFile" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="input">Vector of tokenized text.</param>
          <param name="customModelFile">The custom word embedding model file.</param>
          <summary>
        Word Embeddings transform is a text featurizer which converts vectors of text tokens into sentence vectors using a pre-trained model.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.WordEmbeddingsStaticExtensions" Member="M:Microsoft.ML.StaticPipe.WordEmbeddingsStaticExtensions.WordEmbeddings(Microsoft.ML.StaticPipe.VarVector{System.String},System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToBagofHashedWords">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBagofHashedWords (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, int hashBits = 16, int ngramLength = 1, int skipLength = 0, bool allLengths = true, uint seed = 314489979, bool ordered = true, int invertHash = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBagofHashedWords(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, int32 hashBits, int32 ngramLength, int32 skipLength, bool allLengths, unsigned int32 seed, bool ordered, int32 invertHash) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.WordHashBagEstimatorStaticExtensions.ToBagofHashedWords(Microsoft.ML.StaticPipe.Scalar{System.String},System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBagofHashedWords (input As Scalar(Of String), Optional hashBits As Integer = 16, Optional ngramLength As Integer = 1, Optional skipLength As Integer = 0, Optional allLengths As Boolean = true, Optional seed As UInteger = 314489979, Optional ordered As Boolean = true, Optional invertHash As Integer = 0) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBagofHashedWords : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * int * int * int * bool * uint32 * bool * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.WordHashBagEstimatorStaticExtensions.ToBagofHashedWords (input, hashBits, ngramLength, skipLength, allLengths, seed, ordered, invertHash)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="hashBits" Type="System.Int32" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="allLengths" Type="System.Boolean" />
          <Parameter Name="seed" Type="System.UInt32" />
          <Parameter Name="ordered" Type="System.Boolean" />
          <Parameter Name="invertHash" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="hashBits">Number of bits to hash into. Must be between 1 and 30, inclusive.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="allLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="seed">Hashing seed.</param>
          <param name="ordered">Whether the position of each source column should be included in the hash (when there are multiple source columns).</param>
          <param name="invertHash">During hashing we constuct mappings between original values and the produced hash values.
            Text representation of original values are stored in the slot names of the  metadata for the new column.Hashing, as such, can map many initial values to one.
            <paramref name="invertHash" /> specifies the upper bound of the number of distinct input values mapping to a hash that should be retained.
            <value>0</value> does not retain any input values. <value>-1</value> retains all input values mapping to each hash.</param>
          <summary>
            Produces a bag of counts of ngrams (sequences of consecutive words of length 1-n) in a given text.
            It does so by hashing each ngram and using the hash value as the index in the bag.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.WordHashBagEstimatorStaticExtensions" Member="M:Microsoft.ML.StaticPipe.WordHashBagEstimatorStaticExtensions.ToBagofHashedWords(Microsoft.ML.StaticPipe.Scalar{System.String},System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="TokenizeText">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;string&gt; TokenizeText (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, char[] separators = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;string&gt; TokenizeText(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, char[] separators) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.WordTokenizerStaticExtensions.TokenizeText(Microsoft.ML.StaticPipe.Scalar{System.String},System.Char[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TokenizeText (input As Scalar(Of String), Optional separators As Char() = null) As VarVector(Of String)" />
        <MemberSignature Language="F#" Value="static member TokenizeText : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * char[] -&gt; Microsoft.ML.StaticPipe.VarVector&lt;string&gt;" Usage="Microsoft.ML.StaticPipe.WordTokenizerStaticExtensions.TokenizeText (input, separators)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.String&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="separators" Type="System.Char[]" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="separators">The separators to use (uses space character by default).</param>
          <summary>
            Tokenize incoming text using <paramref name="separators" /> and output the tokens.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.WordTokenizerStaticExtensions" Member="M:Microsoft.ML.StaticPipe.WordTokenizerStaticExtensions.TokenizeText(Microsoft.ML.StaticPipe.Scalar{System.String},System.Char[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="ScoreTensorFlowModel">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.TensorFlowEstimator ScoreTensorFlowModel (this Microsoft.ML.TransformsCatalog catalog, Microsoft.ML.Transforms.TensorFlowModelInfo tensorFlowModel, string[] inputs, string[] outputs);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.TensorFlowEstimator ScoreTensorFlowModel(class Microsoft.ML.TransformsCatalog catalog, class Microsoft.ML.Transforms.TensorFlowModelInfo tensorFlowModel, string[] inputs, string[] outputs) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TensorflowCatalog.ScoreTensorFlowModel(Microsoft.ML.TransformsCatalog,Microsoft.ML.Transforms.TensorFlowModelInfo,System.String[],System.String[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ScoreTensorFlowModel (catalog As TransformsCatalog, tensorFlowModel As TensorFlowModelInfo, inputs As String(), outputs As String()) As TensorFlowEstimator" />
        <MemberSignature Language="F#" Value="static member ScoreTensorFlowModel : Microsoft.ML.TransformsCatalog * Microsoft.ML.Transforms.TensorFlowModelInfo * string[] * string[] -&gt; Microsoft.ML.Transforms.TensorFlowEstimator" Usage="Microsoft.ML.TensorflowCatalog.ScoreTensorFlowModel (catalog, tensorFlowModel, inputs, outputs)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.TensorFlowEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="tensorFlowModel" Type="Microsoft.ML.Transforms.TensorFlowModelInfo" />
          <Parameter Name="inputs" Type="System.String[]" />
          <Parameter Name="outputs" Type="System.String[]" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="tensorFlowModel">The pre-trained TensorFlow model.</param>
          <param name="inputs"> The names of the model inputs.</param>
          <param name="outputs">The names of the requested model outputs.</param>
          <summary>
            Scores a dataset using a pre-traiend TensorFlow model specified via <paramref name="tensorFlowModel" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TensorflowCatalog" Member="M:Microsoft.ML.TensorflowCatalog.ScoreTensorFlowModel(Microsoft.ML.TransformsCatalog,Microsoft.ML.Transforms.TensorFlowModelInfo,System.String[],System.String[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="ScoreTensorFlowModel">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.TensorFlowEstimator ScoreTensorFlowModel (this Microsoft.ML.TransformsCatalog catalog, string modelLocation, string[] inputs, string[] outputs);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.TensorFlowEstimator ScoreTensorFlowModel(class Microsoft.ML.TransformsCatalog catalog, string modelLocation, string[] inputs, string[] outputs) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TensorflowCatalog.ScoreTensorFlowModel(Microsoft.ML.TransformsCatalog,System.String,System.String[],System.String[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ScoreTensorFlowModel (catalog As TransformsCatalog, modelLocation As String, inputs As String(), outputs As String()) As TensorFlowEstimator" />
        <MemberSignature Language="F#" Value="static member ScoreTensorFlowModel : Microsoft.ML.TransformsCatalog * string * string[] * string[] -&gt; Microsoft.ML.Transforms.TensorFlowEstimator" Usage="Microsoft.ML.TensorflowCatalog.ScoreTensorFlowModel (catalog, modelLocation, inputs, outputs)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.TensorFlowEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="modelLocation" Type="System.String" />
          <Parameter Name="inputs" Type="System.String[]" />
          <Parameter Name="outputs" Type="System.String[]" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="modelLocation">Location of the TensorFlow model.</param>
          <param name="inputs"> The names of the model inputs.</param>
          <param name="outputs">The names of the requested model outputs.</param>
          <summary>
            Scores a dataset using a pre-traiend TensorFlow model located in <paramref name="modelLocation" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TensorflowCatalog" Member="M:Microsoft.ML.TensorflowCatalog.ScoreTensorFlowModel(Microsoft.ML.TransformsCatalog,System.String,System.String[],System.String[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="TensorFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.TensorFlowEstimator TensorFlow (this Microsoft.ML.TransformsCatalog catalog, Microsoft.ML.Transforms.TensorFlowTransform.Arguments args);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.TensorFlowEstimator TensorFlow(class Microsoft.ML.TransformsCatalog catalog, class Microsoft.ML.Transforms.TensorFlowTransform/Arguments args) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TensorflowCatalog.TensorFlow(Microsoft.ML.TransformsCatalog,Microsoft.ML.Transforms.TensorFlowTransform.Arguments)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TensorFlow (catalog As TransformsCatalog, args As TensorFlowTransform.Arguments) As TensorFlowEstimator" />
        <MemberSignature Language="F#" Value="static member TensorFlow : Microsoft.ML.TransformsCatalog * Microsoft.ML.Transforms.TensorFlowTransform.Arguments -&gt; Microsoft.ML.Transforms.TensorFlowEstimator" Usage="Microsoft.ML.TensorflowCatalog.TensorFlow (catalog, args)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.TensorFlowEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="args" Type="Microsoft.ML.Transforms.TensorFlowTransform+Arguments" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="args">The <see cref="T:Microsoft.ML.Transforms.TensorFlowTransform.Arguments" /> specifying the inputs and the settings of the <see cref="T:Microsoft.ML.Transforms.TensorFlowEstimator" />.</param>
          <summary>
            Score or Retrain a tensorflow model (based on setting of the <see cref="F:Microsoft.ML.Transforms.TensorFlowTransform.Arguments.ReTrain" />) setting.
            The model is specified in the <see cref="F:Microsoft.ML.Transforms.TensorFlowTransform.Arguments.ModelLocation" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TensorflowCatalog" Member="M:Microsoft.ML.TensorflowCatalog.TensorFlow(Microsoft.ML.TransformsCatalog,Microsoft.ML.Transforms.TensorFlowTransform.Arguments)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="TensorFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.TensorFlowEstimator TensorFlow (this Microsoft.ML.TransformsCatalog catalog, Microsoft.ML.Transforms.TensorFlowTransform.Arguments args, Microsoft.ML.Transforms.TensorFlowModelInfo tensorFlowModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.TensorFlowEstimator TensorFlow(class Microsoft.ML.TransformsCatalog catalog, class Microsoft.ML.Transforms.TensorFlowTransform/Arguments args, class Microsoft.ML.Transforms.TensorFlowModelInfo tensorFlowModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TensorflowCatalog.TensorFlow(Microsoft.ML.TransformsCatalog,Microsoft.ML.Transforms.TensorFlowTransform.Arguments,Microsoft.ML.Transforms.TensorFlowModelInfo)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TensorFlow (catalog As TransformsCatalog, args As TensorFlowTransform.Arguments, tensorFlowModel As TensorFlowModelInfo) As TensorFlowEstimator" />
        <MemberSignature Language="F#" Value="static member TensorFlow : Microsoft.ML.TransformsCatalog * Microsoft.ML.Transforms.TensorFlowTransform.Arguments * Microsoft.ML.Transforms.TensorFlowModelInfo -&gt; Microsoft.ML.Transforms.TensorFlowEstimator" Usage="Microsoft.ML.TensorflowCatalog.TensorFlow (catalog, args, tensorFlowModel)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.TensorFlowEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="args" Type="Microsoft.ML.Transforms.TensorFlowTransform+Arguments" />
          <Parameter Name="tensorFlowModel" Type="Microsoft.ML.Transforms.TensorFlowModelInfo" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="args">The <see cref="T:Microsoft.ML.Transforms.TensorFlowTransform.Arguments" /> specifying the inputs and the settings of the <see cref="T:Microsoft.ML.Transforms.TensorFlowEstimator" />.</param>
          <param name="tensorFlowModel">The pre-trained TensorFlow model.</param>
          <summary>
            Scores or retrains (based on setting of the <see cref="F:Microsoft.ML.Transforms.TensorFlowTransform.Arguments.ReTrain" />) a pre-traiend TensorFlow model specified via <paramref name="tensorFlowModel" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TensorflowCatalog" Member="M:Microsoft.ML.TensorflowCatalog.TensorFlow(Microsoft.ML.TransformsCatalog,Microsoft.ML.Transforms.TensorFlowTransform.Arguments,Microsoft.ML.Transforms.TensorFlowModelInfo)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="ExtractWordEmbeddings">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingEstimator ExtractWordEmbeddings (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer.PretrainedModelKind modelKind = Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer+PretrainedModelKind.Sswe, params Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer.ColumnInfo[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingEstimator ExtractWordEmbeddings(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, valuetype Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer/PretrainedModelKind modelKind, class Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer/ColumnInfo[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.ExtractWordEmbeddings(Microsoft.ML.TransformsCatalog.TextTransforms,Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer.PretrainedModelKind,Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer.ColumnInfo[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExtractWordEmbeddings (catalog As TransformsCatalog.TextTransforms, Optional modelKind As WordEmbeddingsExtractingTransformer.PretrainedModelKind = Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer+PretrainedModelKind.Sswe, ParamArray columns As WordEmbeddingsExtractingTransformer.ColumnInfo()) As WordEmbeddingsExtractingEstimator" />
        <MemberSignature Language="F#" Value="static member ExtractWordEmbeddings : Microsoft.ML.TransformsCatalog.TextTransforms * Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer.PretrainedModelKind * Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer.ColumnInfo[] -&gt; Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingEstimator" Usage="Microsoft.ML.TextCatalog.ExtractWordEmbeddings (catalog, modelKind, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="modelKind" Type="Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer+PretrainedModelKind" />
          <Parameter Name="columns" Type="Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer+ColumnInfo[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="modelKind">The embeddings <see cref="T:Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer.PretrainedModelKind" /> to use. </param>
          <param name="columns">The array columns, and per-column configurations to extract embeedings from.</param>
          <summary>
            Extracts word embeddings.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.ExtractWordEmbeddings(Microsoft.ML.TransformsCatalog.TextTransforms,Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer.PretrainedModelKind,Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer.ColumnInfo[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="ExtractWordEmbeddings">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingEstimator ExtractWordEmbeddings (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string inputColumn, string outputColumn = null, Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer.PretrainedModelKind modelKind = Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer+PretrainedModelKind.Sswe);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingEstimator ExtractWordEmbeddings(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string inputColumn, string outputColumn, valuetype Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer/PretrainedModelKind modelKind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.ExtractWordEmbeddings(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer.PretrainedModelKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExtractWordEmbeddings (catalog As TransformsCatalog.TextTransforms, inputColumn As String, Optional outputColumn As String = null, Optional modelKind As WordEmbeddingsExtractingTransformer.PretrainedModelKind = Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer+PretrainedModelKind.Sswe) As WordEmbeddingsExtractingEstimator" />
        <MemberSignature Language="F#" Value="static member ExtractWordEmbeddings : Microsoft.ML.TransformsCatalog.TextTransforms * string * string * Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer.PretrainedModelKind -&gt; Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingEstimator" Usage="Microsoft.ML.TextCatalog.ExtractWordEmbeddings (catalog, inputColumn, outputColumn, modelKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="modelKind" Type="Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer+PretrainedModelKind" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="inputColumn">The input column.</param>
          <param name="outputColumn">The optional output column. If it is <value>null</value> the input column will be substituted with its value.</param>
          <param name="modelKind">The embeddings <see cref="T:Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer.PretrainedModelKind" /> to use. </param>
          <summary>
            Extracts word embeddings.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.ExtractWordEmbeddings(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingTransformer.PretrainedModelKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="ExtractWordEmbeddings">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingEstimator ExtractWordEmbeddings (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string inputColumn, string customModelFile, string outputColumn = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingEstimator ExtractWordEmbeddings(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string inputColumn, string customModelFile, string outputColumn) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.ExtractWordEmbeddings(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExtractWordEmbeddings (catalog As TransformsCatalog.TextTransforms, inputColumn As String, customModelFile As String, Optional outputColumn As String = null) As WordEmbeddingsExtractingEstimator" />
        <MemberSignature Language="F#" Value="static member ExtractWordEmbeddings : Microsoft.ML.TransformsCatalog.TextTransforms * string * string * string -&gt; Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingEstimator" Usage="Microsoft.ML.TextCatalog.ExtractWordEmbeddings (catalog, inputColumn, customModelFile, outputColumn)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.WordEmbeddingsExtractingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="customModelFile" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="inputColumn">The input column.</param>
          <param name="customModelFile">The path of the pre-trained embeedings model to use. </param>
          <param name="outputColumn">The optional output column. If it is <value>null</value> the input column will be substituted with its value.</param>
          <summary>
            Extracts word embeddings.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.ExtractWordEmbeddings(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="FeaturizeText">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.TextFeaturizingEstimator FeaturizeText (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, System.Collections.Generic.IEnumerable&lt;string&gt; inputColumns, string outputColumn, Action&lt;Microsoft.ML.Transforms.Text.TextFeaturizingEstimator.Settings&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.TextFeaturizingEstimator FeaturizeText(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, class System.Collections.Generic.IEnumerable`1&lt;string&gt; inputColumns, string outputColumn, class System.Action`1&lt;class Microsoft.ML.Transforms.Text.TextFeaturizingEstimator/Settings&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.FeaturizeText(Microsoft.ML.TransformsCatalog.TextTransforms,System.Collections.Generic.IEnumerable{System.String},System.String,System.Action{Microsoft.ML.Transforms.Text.TextFeaturizingEstimator.Settings})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FeaturizeText (catalog As TransformsCatalog.TextTransforms, inputColumns As IEnumerable(Of String), outputColumn As String, Optional advancedSettings As Action(Of TextFeaturizingEstimator.Settings) = null) As TextFeaturizingEstimator" />
        <MemberSignature Language="F#" Value="static member FeaturizeText : Microsoft.ML.TransformsCatalog.TextTransforms * seq&lt;string&gt; * string * Action&lt;Microsoft.ML.Transforms.Text.TextFeaturizingEstimator.Settings&gt; -&gt; Microsoft.ML.Transforms.Text.TextFeaturizingEstimator" Usage="Microsoft.ML.TextCatalog.FeaturizeText (catalog, inputColumns, outputColumn, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.TextFeaturizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="inputColumns" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Transforms.Text.TextFeaturizingEstimator+Settings&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="inputColumns">The input columns</param>
          <param name="outputColumn">The output column</param>
          <param name="advancedSettings">Advanced transform settings</param>
          <summary>
            Transform several text columns into featurized float array that represents counts of ngrams and char-grams.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.FeaturizeText(Microsoft.ML.TransformsCatalog.TextTransforms,System.Collections.Generic.IEnumerable{System.String},System.String,System.Action{Microsoft.ML.Transforms.Text.TextFeaturizingEstimator.Settings})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="FeaturizeText">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.TextFeaturizingEstimator FeaturizeText (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string inputColumn, string outputColumn = null, Action&lt;Microsoft.ML.Transforms.Text.TextFeaturizingEstimator.Settings&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.TextFeaturizingEstimator FeaturizeText(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string inputColumn, string outputColumn, class System.Action`1&lt;class Microsoft.ML.Transforms.Text.TextFeaturizingEstimator/Settings&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.FeaturizeText(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Action{Microsoft.ML.Transforms.Text.TextFeaturizingEstimator.Settings})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FeaturizeText (catalog As TransformsCatalog.TextTransforms, inputColumn As String, Optional outputColumn As String = null, Optional advancedSettings As Action(Of TextFeaturizingEstimator.Settings) = null) As TextFeaturizingEstimator" />
        <MemberSignature Language="F#" Value="static member FeaturizeText : Microsoft.ML.TransformsCatalog.TextTransforms * string * string * Action&lt;Microsoft.ML.Transforms.Text.TextFeaturizingEstimator.Settings&gt; -&gt; Microsoft.ML.Transforms.Text.TextFeaturizingEstimator" Usage="Microsoft.ML.TextCatalog.FeaturizeText (catalog, inputColumn, outputColumn, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.TextFeaturizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Transforms.Text.TextFeaturizingEstimator+Settings&gt;" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="inputColumn">The input column</param>
          <param name="outputColumn">The output column</param>
          <param name="advancedSettings">Advanced transform settings</param>
          <summary>
            Transform a text column into featurized float array that represents counts of ngrams and char-grams.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.FeaturizeText(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Action{Microsoft.ML.Transforms.Text.TextFeaturizingEstimator.Settings})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="LatentDirichletAllocation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.LatentDirichletAllocationEstimator LatentDirichletAllocation (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, params Microsoft.ML.Transforms.Text.LatentDirichletAllocationTransformer.ColumnInfo[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.LatentDirichletAllocationEstimator LatentDirichletAllocation(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, class Microsoft.ML.Transforms.Text.LatentDirichletAllocationTransformer/ColumnInfo[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.LatentDirichletAllocation(Microsoft.ML.TransformsCatalog.TextTransforms,Microsoft.ML.Transforms.Text.LatentDirichletAllocationTransformer.ColumnInfo[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LatentDirichletAllocation (catalog As TransformsCatalog.TextTransforms, ParamArray columns As LatentDirichletAllocationTransformer.ColumnInfo()) As LatentDirichletAllocationEstimator" />
        <MemberSignature Language="F#" Value="static member LatentDirichletAllocation : Microsoft.ML.TransformsCatalog.TextTransforms * Microsoft.ML.Transforms.Text.LatentDirichletAllocationTransformer.ColumnInfo[] -&gt; Microsoft.ML.Transforms.Text.LatentDirichletAllocationEstimator" Usage="Microsoft.ML.TextCatalog.LatentDirichletAllocation (catalog, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.LatentDirichletAllocationEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.Transforms.Text.LatentDirichletAllocationTransformer+ColumnInfo[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="columns"> Describes the parameters of LDA for each column pair.</param>
          <summary>
            Uses <a href="https://arxiv.org/abs/1412.1576">LightLDA</a> to transform a document (represented as a vector of floats)
            into a vector of floats over a set of topics.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.LatentDirichletAllocation(Microsoft.ML.TransformsCatalog.TextTransforms,Microsoft.ML.Transforms.Text.LatentDirichletAllocationTransformer.ColumnInfo[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="LatentDirichletAllocation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.LatentDirichletAllocationEstimator LatentDirichletAllocation (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string inputColumn, string outputColumn = null, int numTopic = 100, float alphaSum = 100, float beta = 0.01, int mhstep = 4, int numIterations = 200, int likelihoodInterval = 5, int numThreads = 0, int numMaxDocToken = 512, int numSummaryTermPerTopic = 10, int numBurninIterations = 10, bool resetRandomGenerator = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.LatentDirichletAllocationEstimator LatentDirichletAllocation(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string inputColumn, string outputColumn, int32 numTopic, float32 alphaSum, float32 beta, int32 mhstep, int32 numIterations, int32 likelihoodInterval, int32 numThreads, int32 numMaxDocToken, int32 numSummaryTermPerTopic, int32 numBurninIterations, bool resetRandomGenerator) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.LatentDirichletAllocation(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Int32,System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LatentDirichletAllocation (catalog As TransformsCatalog.TextTransforms, inputColumn As String, Optional outputColumn As String = null, Optional numTopic As Integer = 100, Optional alphaSum As Single = 100, Optional beta As Single = 0.01, Optional mhstep As Integer = 4, Optional numIterations As Integer = 200, Optional likelihoodInterval As Integer = 5, Optional numThreads As Integer = 0, Optional numMaxDocToken As Integer = 512, Optional numSummaryTermPerTopic As Integer = 10, Optional numBurninIterations As Integer = 10, Optional resetRandomGenerator As Boolean = false) As LatentDirichletAllocationEstimator" />
        <MemberSignature Language="F#" Value="static member LatentDirichletAllocation : Microsoft.ML.TransformsCatalog.TextTransforms * string * string * int * single * single * int * int * int * int * int * int * int * bool -&gt; Microsoft.ML.Transforms.Text.LatentDirichletAllocationEstimator" Usage="Microsoft.ML.TextCatalog.LatentDirichletAllocation (catalog, inputColumn, outputColumn, numTopic, alphaSum, beta, mhstep, numIterations, likelihoodInterval, numThreads, numMaxDocToken, numSummaryTermPerTopic, numBurninIterations, resetRandomGenerator)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.LatentDirichletAllocationEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="numTopic" Type="System.Int32" />
          <Parameter Name="alphaSum" Type="System.Single" />
          <Parameter Name="beta" Type="System.Single" />
          <Parameter Name="mhstep" Type="System.Int32" />
          <Parameter Name="numIterations" Type="System.Int32" />
          <Parameter Name="likelihoodInterval" Type="System.Int32" />
          <Parameter Name="numThreads" Type="System.Int32" />
          <Parameter Name="numMaxDocToken" Type="System.Int32" />
          <Parameter Name="numSummaryTermPerTopic" Type="System.Int32" />
          <Parameter Name="numBurninIterations" Type="System.Int32" />
          <Parameter Name="resetRandomGenerator" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="inputColumn">The column representing the document as a vector of floats.</param>
          <param name="outputColumn">The column containing the output scores over a set of topics, represented as a vector of floats. A null value for the column means <paramref name="inputColumn" /> is replaced.</param>
          <param name="numTopic">The number of topics.</param>
          <param name="alphaSum">Dirichlet prior on document-topic vectors.</param>
          <param name="beta">Dirichlet prior on vocab-topic vectors.</param>
          <param name="mhstep">Number of Metropolis Hasting step.</param>
          <param name="numIterations">Number of iterations.</param>
          <param name="likelihoodInterval">Compute log likelihood over local dataset on this iteration interval.</param>
          <param name="numThreads">The number of training threads. Default value depends on number of logical processors.</param>
          <param name="numMaxDocToken">The threshold of maximum count of tokens per doc.</param>
          <param name="numSummaryTermPerTopic">The number of words to summarize the topic.</param>
          <param name="numBurninIterations">The number of burn-in iterations.</param>
          <param name="resetRandomGenerator">Reset the random number generator for each document.</param>
          <summary>
            Uses <a href="https://arxiv.org/abs/1412.1576">LightLDA</a> to transform a document (represented as a vector of floats)
            into a vector of floats over a set of topics.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.LatentDirichletAllocation(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Int32,System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="NormalizeText">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.TextNormalizingEstimator NormalizeText (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string inputColumn, string outputColumn = null, Microsoft.ML.Transforms.Text.TextNormalizingEstimator.CaseNormalizationMode textCase = Microsoft.ML.Transforms.Text.TextNormalizingEstimator+CaseNormalizationMode.Lower, bool keepDiacritics = false, bool keepPunctuations = true, bool keepNumbers = true);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.TextNormalizingEstimator NormalizeText(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string inputColumn, string outputColumn, valuetype Microsoft.ML.Transforms.Text.TextNormalizingEstimator/CaseNormalizationMode textCase, bool keepDiacritics, bool keepPunctuations, bool keepNumbers) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.NormalizeText(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,Microsoft.ML.Transforms.Text.TextNormalizingEstimator.CaseNormalizationMode,System.Boolean,System.Boolean,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeText (catalog As TransformsCatalog.TextTransforms, inputColumn As String, Optional outputColumn As String = null, Optional textCase As TextNormalizingEstimator.CaseNormalizationMode = Microsoft.ML.Transforms.Text.TextNormalizingEstimator+CaseNormalizationMode.Lower, Optional keepDiacritics As Boolean = false, Optional keepPunctuations As Boolean = true, Optional keepNumbers As Boolean = true) As TextNormalizingEstimator" />
        <MemberSignature Language="F#" Value="static member NormalizeText : Microsoft.ML.TransformsCatalog.TextTransforms * string * string * Microsoft.ML.Transforms.Text.TextNormalizingEstimator.CaseNormalizationMode * bool * bool * bool -&gt; Microsoft.ML.Transforms.Text.TextNormalizingEstimator" Usage="Microsoft.ML.TextCatalog.NormalizeText (catalog, inputColumn, outputColumn, textCase, keepDiacritics, keepPunctuations, keepNumbers)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.TextNormalizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="textCase" Type="Microsoft.ML.Transforms.Text.TextNormalizingEstimator+CaseNormalizationMode" />
          <Parameter Name="keepDiacritics" Type="System.Boolean" />
          <Parameter Name="keepPunctuations" Type="System.Boolean" />
          <Parameter Name="keepNumbers" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="inputColumn">The column containing text to normalize.</param>
          <param name="outputColumn">The column containing output tokens. Null means <paramref name="inputColumn" /> is replaced.</param>
          <param name="textCase">Casing text using the rules of the invariant culture.</param>
          <param name="keepDiacritics">Whether to keep diacritical marks or remove them.</param>
          <param name="keepPunctuations">Whether to keep punctuation marks or remove them.</param>
          <param name="keepNumbers">Whether to keep numbers or remove them.</param>
          <summary>
            Normalizes incoming text in <paramref name="inputColumn" /> by changing case, removing diacritical marks, punctuation marks and/or numbers
            and outputs new text as <paramref name="outputColumn" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.NormalizeText(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,Microsoft.ML.Transforms.Text.TextNormalizingEstimator.CaseNormalizationMode,System.Boolean,System.Boolean,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="ProduceHashedNgrams">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.NgramHashingEstimator ProduceHashedNgrams (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string inputColumn, string outputColumn = null, int hashBits = 16, int ngramLength = 2, int skipLength = 0, bool allLengths = true, uint seed = 314489979, bool ordered = true, int invertHash = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.NgramHashingEstimator ProduceHashedNgrams(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string inputColumn, string outputColumn, int32 hashBits, int32 ngramLength, int32 skipLength, bool allLengths, unsigned int32 seed, bool ordered, int32 invertHash) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.ProduceHashedNgrams(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProduceHashedNgrams (catalog As TransformsCatalog.TextTransforms, inputColumn As String, Optional outputColumn As String = null, Optional hashBits As Integer = 16, Optional ngramLength As Integer = 2, Optional skipLength As Integer = 0, Optional allLengths As Boolean = true, Optional seed As UInteger = 314489979, Optional ordered As Boolean = true, Optional invertHash As Integer = 0) As NgramHashingEstimator" />
        <MemberSignature Language="F#" Value="static member ProduceHashedNgrams : Microsoft.ML.TransformsCatalog.TextTransforms * string * string * int * int * int * bool * uint32 * bool * int -&gt; Microsoft.ML.Transforms.Text.NgramHashingEstimator" Usage="Microsoft.ML.TextCatalog.ProduceHashedNgrams (catalog, inputColumn, outputColumn, hashBits, ngramLength, skipLength, allLengths, seed, ordered, invertHash)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.NgramHashingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="hashBits" Type="System.Int32" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="allLengths" Type="System.Boolean" />
          <Parameter Name="seed" Type="System.UInt32" />
          <Parameter Name="ordered" Type="System.Boolean" />
          <Parameter Name="invertHash" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="inputColumn">Name of input column containing tokenized text.</param>
          <param name="outputColumn">Name of output column, will contain the ngram vector. Null means <paramref name="inputColumn" /> is replaced.</param>
          <param name="hashBits">Number of bits to hash into. Must be between 1 and 30, inclusive.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="allLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="seed">Hashing seed.</param>
          <param name="ordered">Whether the position of each source column should be included in the hash (when there are multiple source columns).</param>
          <param name="invertHash">During hashing we constuct mappings between original values and the produced hash values.
             Text representation of original values are stored in the slot names of the  metadata for the new column.Hashing, as such, can map many initial values to one.
             <paramref name="invertHash" /> specifies the upper bound of the number of distinct input values mapping to a hash that should be retained.
             <value>0</value> does not retain any input values. <value>-1</value> retains all input values mapping to each hash.</param>
          <summary>
             Produces a bag of counts of hashed ngrams in <paramref name="inputColumn" />
             and outputs ngram vector as <paramref name="outputColumn" /><see cref="T:Microsoft.ML.Transforms.Text.NgramHashingEstimator" /> is different from <see cref="T:Microsoft.ML.Transforms.Text.WordHashBagEstimator" /> in a way that <see cref="T:Microsoft.ML.Transforms.Text.NgramHashingEstimator" />
             takes tokenized text as input while <see cref="T:Microsoft.ML.Transforms.Text.WordHashBagEstimator" /> tokenizes text internally.
             </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.ProduceHashedNgrams(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="ProduceHashedNgrams">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.NgramHashingEstimator ProduceHashedNgrams (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string[] inputColumns, string outputColumn, int hashBits = 16, int ngramLength = 2, int skipLength = 0, bool allLengths = true, uint seed = 314489979, bool ordered = true, int invertHash = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.NgramHashingEstimator ProduceHashedNgrams(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string[] inputColumns, string outputColumn, int32 hashBits, int32 ngramLength, int32 skipLength, bool allLengths, unsigned int32 seed, bool ordered, int32 invertHash) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.ProduceHashedNgrams(Microsoft.ML.TransformsCatalog.TextTransforms,System.String[],System.String,System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProduceHashedNgrams (catalog As TransformsCatalog.TextTransforms, inputColumns As String(), outputColumn As String, Optional hashBits As Integer = 16, Optional ngramLength As Integer = 2, Optional skipLength As Integer = 0, Optional allLengths As Boolean = true, Optional seed As UInteger = 314489979, Optional ordered As Boolean = true, Optional invertHash As Integer = 0) As NgramHashingEstimator" />
        <MemberSignature Language="F#" Value="static member ProduceHashedNgrams : Microsoft.ML.TransformsCatalog.TextTransforms * string[] * string * int * int * int * bool * uint32 * bool * int -&gt; Microsoft.ML.Transforms.Text.NgramHashingEstimator" Usage="Microsoft.ML.TextCatalog.ProduceHashedNgrams (catalog, inputColumns, outputColumn, hashBits, ngramLength, skipLength, allLengths, seed, ordered, invertHash)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.NgramHashingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="inputColumns" Type="System.String[]" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="hashBits" Type="System.Int32" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="allLengths" Type="System.Boolean" />
          <Parameter Name="seed" Type="System.UInt32" />
          <Parameter Name="ordered" Type="System.Boolean" />
          <Parameter Name="invertHash" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="inputColumns">Name of input columns containing tokenized text.</param>
          <param name="outputColumn">Name of output column, will contain the ngram vector.</param>
          <param name="hashBits">Number of bits to hash into. Must be between 1 and 30, inclusive.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="allLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="seed">Hashing seed.</param>
          <param name="ordered">Whether the position of each source column should be included in the hash (when there are multiple source columns).</param>
          <param name="invertHash">During hashing we constuct mappings between original values and the produced hash values.
             Text representation of original values are stored in the slot names of the  metadata for the new column.Hashing, as such, can map many initial values to one.
             <paramref name="invertHash" /> specifies the upper bound of the number of distinct input values mapping to a hash that should be retained.
             <value>0</value> does not retain any input values. <value>-1</value> retains all input values mapping to each hash.</param>
          <summary>
             Produces a bag of counts of hashed ngrams in <paramref name="inputColumns" />
             and outputs ngram vector as <paramref name="outputColumn" /><see cref="T:Microsoft.ML.Transforms.Text.NgramHashingEstimator" /> is different from <see cref="T:Microsoft.ML.Transforms.Text.WordHashBagEstimator" /> in a way that <see cref="T:Microsoft.ML.Transforms.Text.NgramHashingEstimator" />
             takes tokenized text as input while <see cref="T:Microsoft.ML.Transforms.Text.WordHashBagEstimator" /> tokenizes text internally.
             </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.ProduceHashedNgrams(Microsoft.ML.TransformsCatalog.TextTransforms,System.String[],System.String,System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="ProduceHashedNgrams">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.NgramHashingEstimator ProduceHashedNgrams (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, ValueTuple&lt;string[],string&gt;[] columns, int hashBits = 16, int ngramLength = 2, int skipLength = 0, bool allLengths = true, uint seed = 314489979, bool ordered = true, int invertHash = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.NgramHashingEstimator ProduceHashedNgrams(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, valuetype System.ValueTuple`2&lt;string[], string&gt;[] columns, int32 hashBits, int32 ngramLength, int32 skipLength, bool allLengths, unsigned int32 seed, bool ordered, int32 invertHash) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.ProduceHashedNgrams(Microsoft.ML.TransformsCatalog.TextTransforms,System.ValueTuple{System.String[],System.String}[],System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProduceHashedNgrams (catalog As TransformsCatalog.TextTransforms, columns As ValueTuple(Of String(), String)(), Optional hashBits As Integer = 16, Optional ngramLength As Integer = 2, Optional skipLength As Integer = 0, Optional allLengths As Boolean = true, Optional seed As UInteger = 314489979, Optional ordered As Boolean = true, Optional invertHash As Integer = 0) As NgramHashingEstimator" />
        <MemberSignature Language="F#" Value="static member ProduceHashedNgrams : Microsoft.ML.TransformsCatalog.TextTransforms * ValueTuple&lt;string[], string&gt;[] * int * int * int * bool * uint32 * bool * int -&gt; Microsoft.ML.Transforms.Text.NgramHashingEstimator" Usage="Microsoft.ML.TextCatalog.ProduceHashedNgrams (catalog, columns, hashBits, ngramLength, skipLength, allLengths, seed, ordered, invertHash)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.NgramHashingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="columns" Type="System.ValueTuple&lt;System.String[],System.String&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "inputs", "output" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
          <Parameter Name="hashBits" Type="System.Int32" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="allLengths" Type="System.Boolean" />
          <Parameter Name="seed" Type="System.UInt32" />
          <Parameter Name="ordered" Type="System.Boolean" />
          <Parameter Name="invertHash" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="columns">Pairs of columns to compute bag of word vector.</param>
          <param name="hashBits">Number of bits to hash into. Must be between 1 and 30, inclusive.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="allLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="seed">Hashing seed.</param>
          <param name="ordered">Whether the position of each source column should be included in the hash (when there are multiple source columns).</param>
          <param name="invertHash">During hashing we constuct mappings between original values and the produced hash values.
             Text representation of original values are stored in the slot names of the  metadata for the new column.Hashing, as such, can map many initial values to one.
             <paramref name="invertHash" /> specifies the upper bound of the number of distinct input values mapping to a hash that should be retained.
             <value>0</value> does not retain any input values. <value>-1</value> retains all input values mapping to each hash.</param>
          <summary>
             Produces a bag of counts of hashed ngrams in <paramref name="columns.inputs.inputs" />
             and outputs ngram vector for each output in <paramref name="columns.output.output" /><see cref="T:Microsoft.ML.Transforms.Text.NgramHashingEstimator" /> is different from <see cref="T:Microsoft.ML.Transforms.Text.WordHashBagEstimator" /> in a way that <see cref="T:Microsoft.ML.Transforms.Text.NgramHashingEstimator" />
             takes tokenized text as input while <see cref="T:Microsoft.ML.Transforms.Text.WordHashBagEstimator" /> tokenizes text internally.
             </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.ProduceHashedNgrams(Microsoft.ML.TransformsCatalog.TextTransforms,System.ValueTuple{System.String[],System.String}[],System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="ProduceHashedWordBags">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.WordHashBagEstimator ProduceHashedWordBags (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string inputColumn, string outputColumn = null, int hashBits = 16, int ngramLength = 1, int skipLength = 0, bool allLengths = true, uint seed = 314489979, bool ordered = true, int invertHash = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.WordHashBagEstimator ProduceHashedWordBags(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string inputColumn, string outputColumn, int32 hashBits, int32 ngramLength, int32 skipLength, bool allLengths, unsigned int32 seed, bool ordered, int32 invertHash) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.ProduceHashedWordBags(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProduceHashedWordBags (catalog As TransformsCatalog.TextTransforms, inputColumn As String, Optional outputColumn As String = null, Optional hashBits As Integer = 16, Optional ngramLength As Integer = 1, Optional skipLength As Integer = 0, Optional allLengths As Boolean = true, Optional seed As UInteger = 314489979, Optional ordered As Boolean = true, Optional invertHash As Integer = 0) As WordHashBagEstimator" />
        <MemberSignature Language="F#" Value="static member ProduceHashedWordBags : Microsoft.ML.TransformsCatalog.TextTransforms * string * string * int * int * int * bool * uint32 * bool * int -&gt; Microsoft.ML.Transforms.Text.WordHashBagEstimator" Usage="Microsoft.ML.TextCatalog.ProduceHashedWordBags (catalog, inputColumn, outputColumn, hashBits, ngramLength, skipLength, allLengths, seed, ordered, invertHash)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.WordHashBagEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="hashBits" Type="System.Int32" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="allLengths" Type="System.Boolean" />
          <Parameter Name="seed" Type="System.UInt32" />
          <Parameter Name="ordered" Type="System.Boolean" />
          <Parameter Name="invertHash" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="inputColumn">The column containing text to compute bag of word vector.</param>
          <param name="outputColumn">The column containing bag of word vector. Null means <paramref name="inputColumn" /> is replaced.</param>
          <param name="hashBits">Number of bits to hash into. Must be between 1 and 30, inclusive.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="allLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="seed">Hashing seed.</param>
          <param name="ordered">Whether the position of each source column should be included in the hash (when there are multiple source columns).</param>
          <param name="invertHash">During hashing we constuct mappings between original values and the produced hash values.
            Text representation of original values are stored in the slot names of the  metadata for the new column.Hashing, as such, can map many initial values to one.
            <paramref name="invertHash" /> specifies the upper bound of the number of distinct input values mapping to a hash that should be retained.
            <value>0</value> does not retain any input values. <value>-1</value> retains all input values mapping to each hash.</param>
          <summary>
            Produces a bag of counts of hashed ngrams in <paramref name="inputColumn" />
            and outputs bag of word vector as <paramref name="outputColumn" /></summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.ProduceHashedWordBags(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="ProduceHashedWordBags">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.WordHashBagEstimator ProduceHashedWordBags (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string[] inputColumns, string outputColumn, int hashBits = 16, int ngramLength = 1, int skipLength = 0, bool allLengths = true, uint seed = 314489979, bool ordered = true, int invertHash = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.WordHashBagEstimator ProduceHashedWordBags(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string[] inputColumns, string outputColumn, int32 hashBits, int32 ngramLength, int32 skipLength, bool allLengths, unsigned int32 seed, bool ordered, int32 invertHash) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.ProduceHashedWordBags(Microsoft.ML.TransformsCatalog.TextTransforms,System.String[],System.String,System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProduceHashedWordBags (catalog As TransformsCatalog.TextTransforms, inputColumns As String(), outputColumn As String, Optional hashBits As Integer = 16, Optional ngramLength As Integer = 1, Optional skipLength As Integer = 0, Optional allLengths As Boolean = true, Optional seed As UInteger = 314489979, Optional ordered As Boolean = true, Optional invertHash As Integer = 0) As WordHashBagEstimator" />
        <MemberSignature Language="F#" Value="static member ProduceHashedWordBags : Microsoft.ML.TransformsCatalog.TextTransforms * string[] * string * int * int * int * bool * uint32 * bool * int -&gt; Microsoft.ML.Transforms.Text.WordHashBagEstimator" Usage="Microsoft.ML.TextCatalog.ProduceHashedWordBags (catalog, inputColumns, outputColumn, hashBits, ngramLength, skipLength, allLengths, seed, ordered, invertHash)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.WordHashBagEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="inputColumns" Type="System.String[]" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="hashBits" Type="System.Int32" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="allLengths" Type="System.Boolean" />
          <Parameter Name="seed" Type="System.UInt32" />
          <Parameter Name="ordered" Type="System.Boolean" />
          <Parameter Name="invertHash" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="inputColumns">The columns containing text to compute bag of word vector.</param>
          <param name="outputColumn">The column containing output tokens.</param>
          <param name="hashBits">Number of bits to hash into. Must be between 1 and 30, inclusive.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="allLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="seed">Hashing seed.</param>
          <param name="ordered">Whether the position of each source column should be included in the hash (when there are multiple source columns).</param>
          <param name="invertHash">During hashing we constuct mappings between original values and the produced hash values.
            Text representation of original values are stored in the slot names of the  metadata for the new column.Hashing, as such, can map many initial values to one.
            <paramref name="invertHash" /> specifies the upper bound of the number of distinct input values mapping to a hash that should be retained.
            <value>0</value> does not retain any input values. <value>-1</value> retains all input values mapping to each hash.</param>
          <summary>
            Produces a bag of counts of hashed ngrams in <paramref name="inputColumns" />
            and outputs bag of word vector as <paramref name="outputColumn" /></summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.ProduceHashedWordBags(Microsoft.ML.TransformsCatalog.TextTransforms,System.String[],System.String,System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="ProduceHashedWordBags">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.WordHashBagEstimator ProduceHashedWordBags (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, ValueTuple&lt;string[],string&gt;[] columns, int hashBits = 16, int ngramLength = 1, int skipLength = 0, bool allLengths = true, uint seed = 314489979, bool ordered = true, int invertHash = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.WordHashBagEstimator ProduceHashedWordBags(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, valuetype System.ValueTuple`2&lt;string[], string&gt;[] columns, int32 hashBits, int32 ngramLength, int32 skipLength, bool allLengths, unsigned int32 seed, bool ordered, int32 invertHash) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.ProduceHashedWordBags(Microsoft.ML.TransformsCatalog.TextTransforms,System.ValueTuple{System.String[],System.String}[],System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProduceHashedWordBags (catalog As TransformsCatalog.TextTransforms, columns As ValueTuple(Of String(), String)(), Optional hashBits As Integer = 16, Optional ngramLength As Integer = 1, Optional skipLength As Integer = 0, Optional allLengths As Boolean = true, Optional seed As UInteger = 314489979, Optional ordered As Boolean = true, Optional invertHash As Integer = 0) As WordHashBagEstimator" />
        <MemberSignature Language="F#" Value="static member ProduceHashedWordBags : Microsoft.ML.TransformsCatalog.TextTransforms * ValueTuple&lt;string[], string&gt;[] * int * int * int * bool * uint32 * bool * int -&gt; Microsoft.ML.Transforms.Text.WordHashBagEstimator" Usage="Microsoft.ML.TextCatalog.ProduceHashedWordBags (catalog, columns, hashBits, ngramLength, skipLength, allLengths, seed, ordered, invertHash)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.WordHashBagEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="columns" Type="System.ValueTuple&lt;System.String[],System.String&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "inputs", "output" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
          <Parameter Name="hashBits" Type="System.Int32" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="allLengths" Type="System.Boolean" />
          <Parameter Name="seed" Type="System.UInt32" />
          <Parameter Name="ordered" Type="System.Boolean" />
          <Parameter Name="invertHash" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="columns">Pairs of columns to compute bag of word vector.</param>
          <param name="hashBits">Number of bits to hash into. Must be between 1 and 30, inclusive.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="allLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="seed">Hashing seed.</param>
          <param name="ordered">Whether the position of each source column should be included in the hash (when there are multiple source columns).</param>
          <param name="invertHash">During hashing we constuct mappings between original values and the produced hash values.
            Text representation of original values are stored in the slot names of the  metadata for the new column.Hashing, as such, can map many initial values to one.
            <paramref name="invertHash" /> specifies the upper bound of the number of distinct input values mapping to a hash that should be retained.
            <value>0</value> does not retain any input values. <value>-1</value> retains all input values mapping to each hash.</param>
          <summary>
            Produces a bag of counts of hashed ngrams in <paramref name="columns.inputs.inputs" />
            and outputs bag of word vector for each output in <paramref name="columns.output.output" /></summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.ProduceHashedWordBags(Microsoft.ML.TransformsCatalog.TextTransforms,System.ValueTuple{System.String[],System.String}[],System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="ProduceNgrams">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.NgramExtractingEstimator ProduceNgrams (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, params Microsoft.ML.Transforms.Text.NgramExtractingTransformer.ColumnInfo[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.NgramExtractingEstimator ProduceNgrams(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, class Microsoft.ML.Transforms.Text.NgramExtractingTransformer/ColumnInfo[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.ProduceNgrams(Microsoft.ML.TransformsCatalog.TextTransforms,Microsoft.ML.Transforms.Text.NgramExtractingTransformer.ColumnInfo[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProduceNgrams (catalog As TransformsCatalog.TextTransforms, ParamArray columns As NgramExtractingTransformer.ColumnInfo()) As NgramExtractingEstimator" />
        <MemberSignature Language="F#" Value="static member ProduceNgrams : Microsoft.ML.TransformsCatalog.TextTransforms * Microsoft.ML.Transforms.Text.NgramExtractingTransformer.ColumnInfo[] -&gt; Microsoft.ML.Transforms.Text.NgramExtractingEstimator" Usage="Microsoft.ML.TextCatalog.ProduceNgrams (catalog, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.NgramExtractingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.Transforms.Text.NgramExtractingTransformer+ColumnInfo[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="columns">Pairs of columns to run the ngram process on.</param>
          <summary>
            Produces a bag of counts of ngrams (sequences of consecutive words) in <paramref name="columns.inputs.inputs" />
            and outputs bag of word vector for each output in <paramref name="columns.output.output" /></summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.ProduceNgrams(Microsoft.ML.TransformsCatalog.TextTransforms,Microsoft.ML.Transforms.Text.NgramExtractingTransformer.ColumnInfo[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="ProduceNgrams">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.NgramExtractingEstimator ProduceNgrams (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string inputColumn, string outputColumn = null, int ngramLength = 2, int skipLength = 0, bool allLengths = true, int maxNumTerms = 10000000, Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria weighting = Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria.Tf);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.NgramExtractingEstimator ProduceNgrams(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string inputColumn, string outputColumn, int32 ngramLength, int32 skipLength, bool allLengths, int32 maxNumTerms, valuetype Microsoft.ML.Transforms.Text.NgramExtractingEstimator/WeightingCriteria weighting) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.ProduceNgrams(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProduceNgrams (catalog As TransformsCatalog.TextTransforms, inputColumn As String, Optional outputColumn As String = null, Optional ngramLength As Integer = 2, Optional skipLength As Integer = 0, Optional allLengths As Boolean = true, Optional maxNumTerms As Integer = 10000000, Optional weighting As NgramExtractingEstimator.WeightingCriteria = Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria.Tf) As NgramExtractingEstimator" />
        <MemberSignature Language="F#" Value="static member ProduceNgrams : Microsoft.ML.TransformsCatalog.TextTransforms * string * string * int * int * bool * int * Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria -&gt; Microsoft.ML.Transforms.Text.NgramExtractingEstimator" Usage="Microsoft.ML.TextCatalog.ProduceNgrams (catalog, inputColumn, outputColumn, ngramLength, skipLength, allLengths, maxNumTerms, weighting)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.NgramExtractingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="allLengths" Type="System.Boolean" />
          <Parameter Name="maxNumTerms" Type="System.Int32" />
          <Parameter Name="weighting" Type="Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="inputColumn">Name of input column containing tokenized text.</param>
          <param name="outputColumn">Name of output column, will contain the ngram vector. Null means <paramref name="inputColumn" /> is replaced.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="allLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="maxNumTerms">Maximum number of ngrams to store in the dictionary.</param>
          <param name="weighting">Statistical measure used to evaluate how important a word is to a document in a corpus.</param>
          <summary>
            Produces a bag of counts of ngrams (sequences of consecutive words) in <paramref name="inputColumn" />
            and outputs bag of word vector as <paramref name="outputColumn" /></summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.ProduceNgrams(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="ProduceNgrams">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.NgramExtractingEstimator ProduceNgrams (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, ValueTuple&lt;string,string&gt;[] columns, int ngramLength = 2, int skipLength = 0, bool allLengths = true, int maxNumTerms = 10000000, Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria weighting = Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria.Tf);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.NgramExtractingEstimator ProduceNgrams(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, valuetype System.ValueTuple`2&lt;string, string&gt;[] columns, int32 ngramLength, int32 skipLength, bool allLengths, int32 maxNumTerms, valuetype Microsoft.ML.Transforms.Text.NgramExtractingEstimator/WeightingCriteria weighting) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.ProduceNgrams(Microsoft.ML.TransformsCatalog.TextTransforms,System.ValueTuple{System.String,System.String}[],System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProduceNgrams (catalog As TransformsCatalog.TextTransforms, columns As ValueTuple(Of String, String)(), Optional ngramLength As Integer = 2, Optional skipLength As Integer = 0, Optional allLengths As Boolean = true, Optional maxNumTerms As Integer = 10000000, Optional weighting As NgramExtractingEstimator.WeightingCriteria = Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria.Tf) As NgramExtractingEstimator" />
        <MemberSignature Language="F#" Value="static member ProduceNgrams : Microsoft.ML.TransformsCatalog.TextTransforms * ValueTuple&lt;string, string&gt;[] * int * int * bool * int * Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria -&gt; Microsoft.ML.Transforms.Text.NgramExtractingEstimator" Usage="Microsoft.ML.TextCatalog.ProduceNgrams (catalog, columns, ngramLength, skipLength, allLengths, maxNumTerms, weighting)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.NgramExtractingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="columns" Type="System.ValueTuple&lt;System.String,System.String&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "input", "output" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="allLengths" Type="System.Boolean" />
          <Parameter Name="maxNumTerms" Type="System.Int32" />
          <Parameter Name="weighting" Type="Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="columns">Pairs of columns to compute bag of word vector.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="allLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="maxNumTerms">Maximum number of ngrams to store in the dictionary.</param>
          <param name="weighting">Statistical measure used to evaluate how important a word is to a document in a corpus.</param>
          <summary>
            Produces a bag of counts of ngrams (sequences of consecutive words) in <paramref name="columns.inputs.inputs" />
            and outputs bag of word vector for each output in <paramref name="columns.output.output" /></summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.ProduceNgrams(Microsoft.ML.TransformsCatalog.TextTransforms,System.ValueTuple{System.String,System.String}[],System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="ProduceWordBags">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.WordBagEstimator ProduceWordBags (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string inputColumn, string outputColumn = null, int ngramLength = 2, int skipLength = 0, bool allLengths = true, int maxNumTerms = 10000000, Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria weighting = Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria.Tf);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.WordBagEstimator ProduceWordBags(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string inputColumn, string outputColumn, int32 ngramLength, int32 skipLength, bool allLengths, int32 maxNumTerms, valuetype Microsoft.ML.Transforms.Text.NgramExtractingEstimator/WeightingCriteria weighting) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.ProduceWordBags(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProduceWordBags (catalog As TransformsCatalog.TextTransforms, inputColumn As String, Optional outputColumn As String = null, Optional ngramLength As Integer = 2, Optional skipLength As Integer = 0, Optional allLengths As Boolean = true, Optional maxNumTerms As Integer = 10000000, Optional weighting As NgramExtractingEstimator.WeightingCriteria = Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria.Tf) As WordBagEstimator" />
        <MemberSignature Language="F#" Value="static member ProduceWordBags : Microsoft.ML.TransformsCatalog.TextTransforms * string * string * int * int * bool * int * Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria -&gt; Microsoft.ML.Transforms.Text.WordBagEstimator" Usage="Microsoft.ML.TextCatalog.ProduceWordBags (catalog, inputColumn, outputColumn, ngramLength, skipLength, allLengths, maxNumTerms, weighting)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.WordBagEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="allLengths" Type="System.Boolean" />
          <Parameter Name="maxNumTerms" Type="System.Int32" />
          <Parameter Name="weighting" Type="Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="inputColumn">The column containing text to compute bag of word vector.</param>
          <param name="outputColumn">The column containing bag of word vector. Null means <paramref name="inputColumn" /> is replaced.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="allLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="maxNumTerms">Maximum number of ngrams to store in the dictionary.</param>
          <param name="weighting">Statistical measure used to evaluate how important a word is to a document in a corpus.</param>
          <summary>
            Produces a bag of counts of ngrams (sequences of consecutive words) in <paramref name="inputColumn" />
            and outputs bag of word vector as <paramref name="outputColumn" /></summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.ProduceWordBags(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="ProduceWordBags">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.WordBagEstimator ProduceWordBags (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string[] inputColumns, string outputColumn, int ngramLength = 2, int skipLength = 0, bool allLengths = true, int maxNumTerms = 10000000, Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria weighting = Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria.Tf);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.WordBagEstimator ProduceWordBags(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string[] inputColumns, string outputColumn, int32 ngramLength, int32 skipLength, bool allLengths, int32 maxNumTerms, valuetype Microsoft.ML.Transforms.Text.NgramExtractingEstimator/WeightingCriteria weighting) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.ProduceWordBags(Microsoft.ML.TransformsCatalog.TextTransforms,System.String[],System.String,System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProduceWordBags (catalog As TransformsCatalog.TextTransforms, inputColumns As String(), outputColumn As String, Optional ngramLength As Integer = 2, Optional skipLength As Integer = 0, Optional allLengths As Boolean = true, Optional maxNumTerms As Integer = 10000000, Optional weighting As NgramExtractingEstimator.WeightingCriteria = Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria.Tf) As WordBagEstimator" />
        <MemberSignature Language="F#" Value="static member ProduceWordBags : Microsoft.ML.TransformsCatalog.TextTransforms * string[] * string * int * int * bool * int * Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria -&gt; Microsoft.ML.Transforms.Text.WordBagEstimator" Usage="Microsoft.ML.TextCatalog.ProduceWordBags (catalog, inputColumns, outputColumn, ngramLength, skipLength, allLengths, maxNumTerms, weighting)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.WordBagEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="inputColumns" Type="System.String[]" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="allLengths" Type="System.Boolean" />
          <Parameter Name="maxNumTerms" Type="System.Int32" />
          <Parameter Name="weighting" Type="Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="inputColumns">The columns containing text to compute bag of word vector.</param>
          <param name="outputColumn">The column containing output tokens.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="allLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="maxNumTerms">Maximum number of ngrams to store in the dictionary.</param>
          <param name="weighting">Statistical measure used to evaluate how important a word is to a document in a corpus.</param>
          <summary>
            Produces a bag of counts of ngrams (sequences of consecutive words) in <paramref name="inputColumns" />
            and outputs bag of word vector as <paramref name="outputColumn" /></summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.ProduceWordBags(Microsoft.ML.TransformsCatalog.TextTransforms,System.String[],System.String,System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="ProduceWordBags">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.WordBagEstimator ProduceWordBags (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, ValueTuple&lt;string[],string&gt;[] columns, int ngramLength = 2, int skipLength = 0, bool allLengths = true, int maxNumTerms = 10000000, Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria weighting = Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria.Tf);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.WordBagEstimator ProduceWordBags(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, valuetype System.ValueTuple`2&lt;string[], string&gt;[] columns, int32 ngramLength, int32 skipLength, bool allLengths, int32 maxNumTerms, valuetype Microsoft.ML.Transforms.Text.NgramExtractingEstimator/WeightingCriteria weighting) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.ProduceWordBags(Microsoft.ML.TransformsCatalog.TextTransforms,System.ValueTuple{System.String[],System.String}[],System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ProduceWordBags (catalog As TransformsCatalog.TextTransforms, columns As ValueTuple(Of String(), String)(), Optional ngramLength As Integer = 2, Optional skipLength As Integer = 0, Optional allLengths As Boolean = true, Optional maxNumTerms As Integer = 10000000, Optional weighting As NgramExtractingEstimator.WeightingCriteria = Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria.Tf) As WordBagEstimator" />
        <MemberSignature Language="F#" Value="static member ProduceWordBags : Microsoft.ML.TransformsCatalog.TextTransforms * ValueTuple&lt;string[], string&gt;[] * int * int * bool * int * Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria -&gt; Microsoft.ML.Transforms.Text.WordBagEstimator" Usage="Microsoft.ML.TextCatalog.ProduceWordBags (catalog, columns, ngramLength, skipLength, allLengths, maxNumTerms, weighting)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.WordBagEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="columns" Type="System.ValueTuple&lt;System.String[],System.String&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "inputs", "output" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="allLengths" Type="System.Boolean" />
          <Parameter Name="maxNumTerms" Type="System.Int32" />
          <Parameter Name="weighting" Type="Microsoft.ML.Transforms.Text.NgramExtractingEstimator+WeightingCriteria" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="columns">Pairs of columns to compute bag of word vector.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="allLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="maxNumTerms">Maximum number of ngrams to store in the dictionary.</param>
          <param name="weighting">Statistical measure used to evaluate how important a word is to a document in a corpus.</param>
          <summary>
            Produces a bag of counts of ngrams (sequences of consecutive words) in <paramref name="columns.inputs.inputs" />
            and outputs bag of word vector for each output in <paramref name="columns.output.output" /></summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.ProduceWordBags(Microsoft.ML.TransformsCatalog.TextTransforms,System.ValueTuple{System.String[],System.String}[],System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Transforms.Text.NgramExtractingEstimator.WeightingCriteria)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="RemoveStopWords">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator RemoveStopWords (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string inputColumn, string outputColumn = null, Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator.Language language = Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator+Language.English);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator RemoveStopWords(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string inputColumn, string outputColumn, valuetype Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator/Language language) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.RemoveStopWords(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator.Language)" />
        <MemberSignature Language="F#" Value="static member RemoveStopWords : Microsoft.ML.TransformsCatalog.TextTransforms * string * string * Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator.Language -&gt; Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator" Usage="Microsoft.ML.TextCatalog.RemoveStopWords (catalog, inputColumn, outputColumn, language)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="language" Type="Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator+Language" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="inputColumn">The column containing text to remove stop words on.</param>
          <param name="outputColumn">The column containing output text. Null means <paramref name="inputColumn" /> is replaced.</param>
          <param name="language">Langauge of the input text column <paramref name="inputColumn" />.</param>
          <summary>
            Removes stop words from incoming token streams in <paramref name="inputColumn" />
            and outputs the token streams without stopwords as <paramref name="outputColumn" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.RemoveStopWords(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator.Language)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="RemoveStopWords">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator RemoveStopWords (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, ValueTuple&lt;string,string&gt;[] columns, Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator.Language language = Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator+Language.English);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator RemoveStopWords(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, valuetype System.ValueTuple`2&lt;string, string&gt;[] columns, valuetype Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator/Language language) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.RemoveStopWords(Microsoft.ML.TransformsCatalog.TextTransforms,System.ValueTuple{System.String,System.String}[],Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator.Language)" />
        <MemberSignature Language="F#" Value="static member RemoveStopWords : Microsoft.ML.TransformsCatalog.TextTransforms * ValueTuple&lt;string, string&gt;[] * Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator.Language -&gt; Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator" Usage="Microsoft.ML.TextCatalog.RemoveStopWords (catalog, columns, language)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="columns" Type="System.ValueTuple&lt;System.String,System.String&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "input", "output" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
          <Parameter Name="language" Type="Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator+Language" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="columns">Pairs of columns to remove stop words on.</param>
          <param name="language">Langauge of the input text columns <paramref name="columns" />.</param>
          <summary>
            Removes stop words from incoming token streams in input columns
            and outputs the token streams without stop words as output columns.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.RemoveStopWords(Microsoft.ML.TransformsCatalog.TextTransforms,System.ValueTuple{System.String,System.String}[],Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator.Language)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="TokenizeCharacters">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.TokenizingByCharactersEstimator TokenizeCharacters (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, bool useMarkerCharacters = true, params ValueTuple&lt;string,string&gt;[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.TokenizingByCharactersEstimator TokenizeCharacters(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, bool useMarkerCharacters, valuetype System.ValueTuple`2&lt;string, string&gt;[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.TokenizeCharacters(Microsoft.ML.TransformsCatalog.TextTransforms,System.Boolean,System.ValueTuple{System.String,System.String}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TokenizeCharacters (catalog As TransformsCatalog.TextTransforms, Optional useMarkerCharacters As Boolean = true, ParamArray columns As ValueTuple(Of String, String)()) As TokenizingByCharactersEstimator" />
        <MemberSignature Language="F#" Value="static member TokenizeCharacters : Microsoft.ML.TransformsCatalog.TextTransforms * bool * ValueTuple&lt;string, string&gt;[] -&gt; Microsoft.ML.Transforms.Text.TokenizingByCharactersEstimator" Usage="Microsoft.ML.TextCatalog.TokenizeCharacters (catalog, useMarkerCharacters, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.TokenizingByCharactersEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="useMarkerCharacters" Type="System.Boolean" />
          <Parameter Name="columns" Type="System.ValueTuple&lt;System.String,System.String&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
              <Attribute>
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "inputColumn", "outputColumn" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="useMarkerCharacters">Whether to use marker characters to separate words.</param>
          <param name="columns">Pairs of columns to run the tokenization on.</param>
          <summary>
            Tokenize incoming text in input columns and output the tokens as output columns.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.TokenizeCharacters(Microsoft.ML.TransformsCatalog.TextTransforms,System.Boolean,System.ValueTuple{System.String,System.String}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="TokenizeCharacters">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.TokenizingByCharactersEstimator TokenizeCharacters (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string inputColumn, string outputColumn = null, bool useMarkerCharacters = true);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.TokenizingByCharactersEstimator TokenizeCharacters(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string inputColumn, string outputColumn, bool useMarkerCharacters) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.TokenizeCharacters(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TokenizeCharacters (catalog As TransformsCatalog.TextTransforms, inputColumn As String, Optional outputColumn As String = null, Optional useMarkerCharacters As Boolean = true) As TokenizingByCharactersEstimator" />
        <MemberSignature Language="F#" Value="static member TokenizeCharacters : Microsoft.ML.TransformsCatalog.TextTransforms * string * string * bool -&gt; Microsoft.ML.Transforms.Text.TokenizingByCharactersEstimator" Usage="Microsoft.ML.TextCatalog.TokenizeCharacters (catalog, inputColumn, outputColumn, useMarkerCharacters)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.TokenizingByCharactersEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="useMarkerCharacters" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="inputColumn">The column containing text to tokenize.</param>
          <param name="outputColumn">The column containing output tokens. Null means <paramref name="inputColumn" /> is replaced.</param>
          <param name="useMarkerCharacters">Whether to use marker characters to separate words.</param>
          <summary>
            Tokenize incoming text in <paramref name="inputColumn" /> and output the tokens as <paramref name="outputColumn" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.TokenizeCharacters(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="TokenizeWords">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.WordTokenizingEstimator TokenizeWords (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, params Microsoft.ML.Transforms.Text.WordTokenizingTransformer.ColumnInfo[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.WordTokenizingEstimator TokenizeWords(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, class Microsoft.ML.Transforms.Text.WordTokenizingTransformer/ColumnInfo[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.TokenizeWords(Microsoft.ML.TransformsCatalog.TextTransforms,Microsoft.ML.Transforms.Text.WordTokenizingTransformer.ColumnInfo[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TokenizeWords (catalog As TransformsCatalog.TextTransforms, ParamArray columns As WordTokenizingTransformer.ColumnInfo()) As WordTokenizingEstimator" />
        <MemberSignature Language="F#" Value="static member TokenizeWords : Microsoft.ML.TransformsCatalog.TextTransforms * Microsoft.ML.Transforms.Text.WordTokenizingTransformer.ColumnInfo[] -&gt; Microsoft.ML.Transforms.Text.WordTokenizingEstimator" Usage="Microsoft.ML.TextCatalog.TokenizeWords (catalog, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.WordTokenizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.Transforms.Text.WordTokenizingTransformer+ColumnInfo[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="columns">Pairs of columns to run the tokenization on.</param>
          <summary>
             Tokenizes incoming text in input columns, using per-column configurations, and outputs the tokens.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.TokenizeWords(Microsoft.ML.TransformsCatalog.TextTransforms,Microsoft.ML.Transforms.Text.WordTokenizingTransformer.ColumnInfo[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="TokenizeWords">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.WordTokenizingEstimator TokenizeWords (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, string inputColumn, string outputColumn = null, char[] separators = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.WordTokenizingEstimator TokenizeWords(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, string inputColumn, string outputColumn, char[] separators) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.TokenizeWords(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Char[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TokenizeWords (catalog As TransformsCatalog.TextTransforms, inputColumn As String, Optional outputColumn As String = null, Optional separators As Char() = null) As WordTokenizingEstimator" />
        <MemberSignature Language="F#" Value="static member TokenizeWords : Microsoft.ML.TransformsCatalog.TextTransforms * string * string * char[] -&gt; Microsoft.ML.Transforms.Text.WordTokenizingEstimator" Usage="Microsoft.ML.TextCatalog.TokenizeWords (catalog, inputColumn, outputColumn, separators)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.WordTokenizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="separators" Type="System.Char[]" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="inputColumn">The column containing text to tokenize.</param>
          <param name="outputColumn">The column containing output tokens. Null means <paramref name="inputColumn" /> is replaced.</param>
          <param name="separators">The separators to use (uses space character by default).</param>
          <summary>
            Tokenizes incoming text in <paramref name="inputColumn" />, using <paramref name="separators" /> as separators,
            and outputs the tokens as <paramref name="outputColumn" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.TokenizeWords(Microsoft.ML.TransformsCatalog.TextTransforms,System.String,System.String,System.Char[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog.TextTransforms" />
      </Targets>
      <Member MemberName="TokenizeWords">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.Text.WordTokenizingEstimator TokenizeWords (this Microsoft.ML.TransformsCatalog.TextTransforms catalog, ValueTuple&lt;string,string&gt;[] columns, char[] separators = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.Text.WordTokenizingEstimator TokenizeWords(class Microsoft.ML.TransformsCatalog/TextTransforms catalog, valuetype System.ValueTuple`2&lt;string, string&gt;[] columns, char[] separators) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextCatalog.TokenizeWords(Microsoft.ML.TransformsCatalog.TextTransforms,System.ValueTuple{System.String,System.String}[],System.Char[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TokenizeWords (catalog As TransformsCatalog.TextTransforms, columns As ValueTuple(Of String, String)(), Optional separators As Char() = null) As WordTokenizingEstimator" />
        <MemberSignature Language="F#" Value="static member TokenizeWords : Microsoft.ML.TransformsCatalog.TextTransforms * ValueTuple&lt;string, string&gt;[] * char[] -&gt; Microsoft.ML.Transforms.Text.WordTokenizingEstimator" Usage="Microsoft.ML.TextCatalog.TokenizeWords (catalog, columns, separators)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.Text.WordTokenizingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog+TextTransforms" RefType="this" />
          <Parameter Name="columns" Type="System.ValueTuple&lt;System.String,System.String&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "inputColumn", "outputColumn" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
          <Parameter Name="separators" Type="System.Char[]" />
        </Parameters>
        <Docs>
          <param name="catalog">The text-related transform's catalog.</param>
          <param name="columns">Pairs of columns to run the tokenization on.</param>
          <param name="separators">The separators to use (uses space character by default).</param>
          <summary>
            Tokenizes incoming text in input columns and outputs the tokens using <paramref name="separators" /> as separators.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextCatalog" Member="M:Microsoft.ML.TextCatalog.TokenizeWords(Microsoft.ML.TransformsCatalog.TextTransforms,System.ValueTuple{System.String,System.String}[],System.Char[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataOperations" />
      </Targets>
      <Member MemberName="CreateTextReader">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.TextLoader CreateTextReader (this Microsoft.ML.DataOperations catalog, Microsoft.ML.Data.TextLoader.Arguments args, Microsoft.ML.Data.IMultiStreamSource dataSample = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.TextLoader CreateTextReader(class Microsoft.ML.DataOperations catalog, class Microsoft.ML.Data.TextLoader/Arguments args, class Microsoft.ML.Data.IMultiStreamSource dataSample) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextLoaderSaverCatalog.CreateTextReader(Microsoft.ML.DataOperations,Microsoft.ML.Data.TextLoader.Arguments,Microsoft.ML.Data.IMultiStreamSource)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateTextReader (catalog As DataOperations, args As TextLoader.Arguments, Optional dataSample As IMultiStreamSource = null) As TextLoader" />
        <MemberSignature Language="F#" Value="static member CreateTextReader : Microsoft.ML.DataOperations * Microsoft.ML.Data.TextLoader.Arguments * Microsoft.ML.Data.IMultiStreamSource -&gt; Microsoft.ML.Data.TextLoader" Usage="Microsoft.ML.TextLoaderSaverCatalog.CreateTextReader (catalog, args, dataSample)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.TextLoader</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.DataOperations" RefType="this" />
          <Parameter Name="args" Type="Microsoft.ML.Data.TextLoader+Arguments" />
          <Parameter Name="dataSample" Type="Microsoft.ML.Data.IMultiStreamSource" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.DataOperations" /> catalog.</param>
          <param name="args">Defines the settings of the load operation.</param>
          <param name="dataSample">Allows to expose items that can be used for reading.</param>
          <summary>
            Create a text reader <see cref="T:Microsoft.ML.Data.TextLoader" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextLoaderSaverCatalog" Member="M:Microsoft.ML.TextLoaderSaverCatalog.CreateTextReader(Microsoft.ML.DataOperations,Microsoft.ML.Data.TextLoader.Arguments,Microsoft.ML.Data.IMultiStreamSource)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataOperations" />
      </Targets>
      <Member MemberName="CreateTextReader">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.TextLoader CreateTextReader (this Microsoft.ML.DataOperations catalog, Microsoft.ML.Data.TextLoader.Column[] columns, bool hasHeader = false, char separatorChar = '\t', Microsoft.ML.Data.IMultiStreamSource dataSample = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.TextLoader CreateTextReader(class Microsoft.ML.DataOperations catalog, class Microsoft.ML.Data.TextLoader/Column[] columns, bool hasHeader, char separatorChar, class Microsoft.ML.Data.IMultiStreamSource dataSample) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextLoaderSaverCatalog.CreateTextReader(Microsoft.ML.DataOperations,Microsoft.ML.Data.TextLoader.Column[],System.Boolean,System.Char,Microsoft.ML.Data.IMultiStreamSource)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateTextReader (catalog As DataOperations, columns As TextLoader.Column(), Optional hasHeader As Boolean = false, Optional separatorChar As Char = '\t', Optional dataSample As IMultiStreamSource = null) As TextLoader" />
        <MemberSignature Language="F#" Value="static member CreateTextReader : Microsoft.ML.DataOperations * Microsoft.ML.Data.TextLoader.Column[] * bool * char * Microsoft.ML.Data.IMultiStreamSource -&gt; Microsoft.ML.Data.TextLoader" Usage="Microsoft.ML.TextLoaderSaverCatalog.CreateTextReader (catalog, columns, hasHeader, separatorChar, dataSample)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.TextLoader</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.DataOperations" RefType="this" />
          <Parameter Name="columns" Type="Microsoft.ML.Data.TextLoader+Column[]" />
          <Parameter Name="hasHeader" Type="System.Boolean" />
          <Parameter Name="separatorChar" Type="System.Char" />
          <Parameter Name="dataSample" Type="Microsoft.ML.Data.IMultiStreamSource" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.DataOperations" /> catalog.</param>
          <param name="columns">The columns of the schema.</param>
          <param name="hasHeader">Whether the file has a header.</param>
          <param name="separatorChar">The character used as separator between data points in a row. By default the tab character is used as separator.</param>
          <param name="dataSample">The optional location of a data sample.</param>
          <summary>
            Create a text reader <see cref="T:Microsoft.ML.Data.TextLoader" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextLoaderSaverCatalog" Member="M:Microsoft.ML.TextLoaderSaverCatalog.CreateTextReader(Microsoft.ML.DataOperations,Microsoft.ML.Data.TextLoader.Column[],System.Boolean,System.Char,Microsoft.ML.Data.IMultiStreamSource)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataOperations" />
      </Targets>
      <Member MemberName="CreateTextReader&lt;TInput&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.TextLoader CreateTextReader&lt;TInput&gt; (this Microsoft.ML.DataOperations catalog, bool hasHeader = false, char separatorChar = '\t', bool allowQuotedStrings = true, bool supportSparse = true, bool trimWhitespace = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.TextLoader CreateTextReader&lt;TInput&gt;(class Microsoft.ML.DataOperations catalog, bool hasHeader, char separatorChar, bool allowQuotedStrings, bool supportSparse, bool trimWhitespace) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextLoaderSaverCatalog.CreateTextReader``1(Microsoft.ML.DataOperations,System.Boolean,System.Char,System.Boolean,System.Boolean,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateTextReader(Of TInput) (catalog As DataOperations, Optional hasHeader As Boolean = false, Optional separatorChar As Char = '\t', Optional allowQuotedStrings As Boolean = true, Optional supportSparse As Boolean = true, Optional trimWhitespace As Boolean = false) As TextLoader" />
        <MemberSignature Language="F#" Value="static member CreateTextReader : Microsoft.ML.DataOperations * bool * char * bool * bool * bool -&gt; Microsoft.ML.Data.TextLoader" Usage="Microsoft.ML.TextLoaderSaverCatalog.CreateTextReader (catalog, hasHeader, separatorChar, allowQuotedStrings, supportSparse, trimWhitespace)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.TextLoader</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TInput" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.DataOperations" RefType="this" />
          <Parameter Name="hasHeader" Type="System.Boolean" />
          <Parameter Name="separatorChar" Type="System.Char" />
          <Parameter Name="allowQuotedStrings" Type="System.Boolean" />
          <Parameter Name="supportSparse" Type="System.Boolean" />
          <Parameter Name="trimWhitespace" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <typeparam name="TInput">To be added.</typeparam>
          <param name="catalog">The <see cref="T:Microsoft.ML.DataOperations" /> catalog.</param>
          <param name="hasHeader">Does the file contains header?</param>
          <param name="separatorChar">Column separator character. Default is '\t'</param>
          <param name="allowQuotedStrings">Whether the input may include quoted values,
            which can contain separator characters, colons,
            and distinguish empty values from missing values. When true, consecutive separators
            denote a missing value and an empty value is denoted by \"\".
            When false, consecutive separators denote an empty value.</param>
          <param name="supportSparse">Whether the input may include sparse representations for example,
            if one of the row contains "5 2:6 4:3" that's mean there are 5 columns all zero
            except for 3rd and 5th columns which have values 6 and 3</param>
          <param name="trimWhitespace">Remove trailing whitespace from lines</param>
          <summary>
            Create a text reader <see cref="T:Microsoft.ML.Data.TextLoader" /> by inferencing the dataset schema from a data model type.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextLoaderSaverCatalog" Member="M:Microsoft.ML.TextLoaderSaverCatalog.CreateTextReader``1(Microsoft.ML.DataOperations,System.Boolean,System.Char,System.Boolean,System.Boolean,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataOperations" />
      </Targets>
      <Member MemberName="ReadFromTextFile">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.IDataView ReadFromTextFile (this Microsoft.ML.DataOperations catalog, string path, Microsoft.ML.Data.TextLoader.Arguments args = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.IDataView ReadFromTextFile(class Microsoft.ML.DataOperations catalog, string path, class Microsoft.ML.Data.TextLoader/Arguments args) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextLoaderSaverCatalog.ReadFromTextFile(Microsoft.ML.DataOperations,System.String,Microsoft.ML.Data.TextLoader.Arguments)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadFromTextFile (catalog As DataOperations, path As String, Optional args As TextLoader.Arguments = null) As IDataView" />
        <MemberSignature Language="F#" Value="static member ReadFromTextFile : Microsoft.ML.DataOperations * string * Microsoft.ML.Data.TextLoader.Arguments -&gt; Microsoft.ML.Data.IDataView" Usage="Microsoft.ML.TextLoaderSaverCatalog.ReadFromTextFile (catalog, path, args)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.IDataView</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.DataOperations" RefType="this" />
          <Parameter Name="path" Type="System.String" />
          <Parameter Name="args" Type="Microsoft.ML.Data.TextLoader+Arguments" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.DataOperations" /> catalog.</param>
          <param name="path">Specifies a file from which to read.</param>
          <param name="args">Defines the settings of the load operation.</param>
          <summary>
            Read a data view from a text file using <see cref="T:Microsoft.ML.Data.TextLoader" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextLoaderSaverCatalog" Member="M:Microsoft.ML.TextLoaderSaverCatalog.ReadFromTextFile(Microsoft.ML.DataOperations,System.String,Microsoft.ML.Data.TextLoader.Arguments)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataOperations" />
      </Targets>
      <Member MemberName="ReadFromTextFile">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.IDataView ReadFromTextFile (this Microsoft.ML.DataOperations catalog, string path, Microsoft.ML.Data.TextLoader.Column[] columns, bool hasHeader = false, char separatorChar = '\t');" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.IDataView ReadFromTextFile(class Microsoft.ML.DataOperations catalog, string path, class Microsoft.ML.Data.TextLoader/Column[] columns, bool hasHeader, char separatorChar) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextLoaderSaverCatalog.ReadFromTextFile(Microsoft.ML.DataOperations,System.String,Microsoft.ML.Data.TextLoader.Column[],System.Boolean,System.Char)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadFromTextFile (catalog As DataOperations, path As String, columns As TextLoader.Column(), Optional hasHeader As Boolean = false, Optional separatorChar As Char = '\t') As IDataView" />
        <MemberSignature Language="F#" Value="static member ReadFromTextFile : Microsoft.ML.DataOperations * string * Microsoft.ML.Data.TextLoader.Column[] * bool * char -&gt; Microsoft.ML.Data.IDataView" Usage="Microsoft.ML.TextLoaderSaverCatalog.ReadFromTextFile (catalog, path, columns, hasHeader, separatorChar)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.IDataView</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.DataOperations" RefType="this" />
          <Parameter Name="path" Type="System.String" />
          <Parameter Name="columns" Type="Microsoft.ML.Data.TextLoader+Column[]" />
          <Parameter Name="hasHeader" Type="System.Boolean" />
          <Parameter Name="separatorChar" Type="System.Char" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.DataOperations" /> catalog.</param>
          <param name="path">The path to the file.</param>
          <param name="columns">The columns of the schema.</param>
          <param name="hasHeader">Whether the file has a header.</param>
          <param name="separatorChar">The character used as separator between data points in a row. By default the tab character is used as separator.</param>
          <summary>
            Read a data view from a text file using <see cref="T:Microsoft.ML.Data.TextLoader" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextLoaderSaverCatalog" Member="M:Microsoft.ML.TextLoaderSaverCatalog.ReadFromTextFile(Microsoft.ML.DataOperations,System.String,Microsoft.ML.Data.TextLoader.Column[],System.Boolean,System.Char)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataOperations" />
      </Targets>
      <Member MemberName="ReadFromTextFile&lt;TInput&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.IDataView ReadFromTextFile&lt;TInput&gt; (this Microsoft.ML.DataOperations catalog, string path, bool hasHeader = false, char separatorChar = '\t', bool allowQuotedStrings = true, bool supportSparse = true, bool trimWhitespace = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.IDataView ReadFromTextFile&lt;TInput&gt;(class Microsoft.ML.DataOperations catalog, string path, bool hasHeader, char separatorChar, bool allowQuotedStrings, bool supportSparse, bool trimWhitespace) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextLoaderSaverCatalog.ReadFromTextFile``1(Microsoft.ML.DataOperations,System.String,System.Boolean,System.Char,System.Boolean,System.Boolean,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadFromTextFile(Of TInput) (catalog As DataOperations, path As String, Optional hasHeader As Boolean = false, Optional separatorChar As Char = '\t', Optional allowQuotedStrings As Boolean = true, Optional supportSparse As Boolean = true, Optional trimWhitespace As Boolean = false) As IDataView" />
        <MemberSignature Language="F#" Value="static member ReadFromTextFile : Microsoft.ML.DataOperations * string * bool * char * bool * bool * bool -&gt; Microsoft.ML.Data.IDataView" Usage="Microsoft.ML.TextLoaderSaverCatalog.ReadFromTextFile (catalog, path, hasHeader, separatorChar, allowQuotedStrings, supportSparse, trimWhitespace)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.IDataView</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TInput" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.DataOperations" RefType="this" />
          <Parameter Name="path" Type="System.String" />
          <Parameter Name="hasHeader" Type="System.Boolean" />
          <Parameter Name="separatorChar" Type="System.Char" />
          <Parameter Name="allowQuotedStrings" Type="System.Boolean" />
          <Parameter Name="supportSparse" Type="System.Boolean" />
          <Parameter Name="trimWhitespace" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <typeparam name="TInput">To be added.</typeparam>
          <param name="catalog">The <see cref="T:Microsoft.ML.DataOperations" /> catalog.</param>
          <param name="path">The path to the file.</param>
          <param name="hasHeader">Does the file contains header?</param>
          <param name="separatorChar">Column separator character. Default is '\t'</param>
          <param name="allowQuotedStrings">Whether the input may include quoted values,
            which can contain separator characters, colons,
            and distinguish empty values from missing values. When true, consecutive separators
            denote a missing value and an empty value is denoted by \"\".
            When false, consecutive separators denote an empty value.</param>
          <param name="supportSparse">Whether the input may include sparse representations for example,
            if one of the row contains "5 2:6 4:3" that's mean there are 5 columns all zero
            except for 3rd and 5th columns which have values 6 and 3</param>
          <param name="trimWhitespace">Remove trailing whitespace from lines</param>
          <summary>
            Read a data view from a text file using <see cref="T:Microsoft.ML.Data.TextLoader" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextLoaderSaverCatalog" Member="M:Microsoft.ML.TextLoaderSaverCatalog.ReadFromTextFile``1(Microsoft.ML.DataOperations,System.String,System.Boolean,System.Char,System.Boolean,System.Boolean,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.DataOperations" />
      </Targets>
      <Member MemberName="SaveAsText">
        <MemberSignature Language="C#" Value="public static void SaveAsText (this Microsoft.ML.DataOperations catalog, Microsoft.ML.Data.IDataView data, System.IO.Stream stream, char separatorChar = '\t', bool headerRow = false, bool schema = true, bool keepHidden = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SaveAsText(class Microsoft.ML.DataOperations catalog, class Microsoft.ML.Data.IDataView data, class System.IO.Stream stream, char separatorChar, bool headerRow, bool schema, bool keepHidden) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TextLoaderSaverCatalog.SaveAsText(Microsoft.ML.DataOperations,Microsoft.ML.Data.IDataView,System.IO.Stream,System.Char,System.Boolean,System.Boolean,System.Boolean)" />
        <MemberSignature Language="F#" Value="static member SaveAsText : Microsoft.ML.DataOperations * Microsoft.ML.Data.IDataView * System.IO.Stream * char * bool * bool * bool -&gt; unit" Usage="Microsoft.ML.TextLoaderSaverCatalog.SaveAsText (catalog, data, stream, separatorChar, headerRow, schema, keepHidden)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.DataOperations" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.Data.IDataView" />
          <Parameter Name="stream" Type="System.IO.Stream" />
          <Parameter Name="separatorChar" Type="System.Char" />
          <Parameter Name="headerRow" Type="System.Boolean" />
          <Parameter Name="schema" Type="System.Boolean" />
          <Parameter Name="keepHidden" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The <see cref="T:Microsoft.ML.DataOperations" /> catalog.</param>
          <param name="data">The data view to save.</param>
          <param name="stream">The stream to write to.</param>
          <param name="separatorChar">The column separator.</param>
          <param name="headerRow">Whether to write the header row.</param>
          <param name="schema">Whether to write the header comment with the schema.</param>
          <param name="keepHidden">Whether to keep hidden columns in the dataset.</param>
          <summary>
            Save the data view as text.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TextLoaderSaverCatalog" Member="M:Microsoft.ML.TextLoaderSaverCatalog.SaveAsText(Microsoft.ML.DataOperations,Microsoft.ML.Data.IDataView,System.IO.Stream,System.Char,System.Boolean,System.Boolean,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.ITransformer" />
      </Targets>
      <Member MemberName="CreateTimeSeriesPredictionFunction&lt;TSrc,TDst&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.TimeSeries.TimeSeriesPredictionFunction&lt;TSrc,TDst&gt; CreateTimeSeriesPredictionFunction&lt;TSrc,TDst&gt; (this Microsoft.ML.Core.Data.ITransformer transformer, Microsoft.ML.IHostEnvironment env, bool ignoreMissingColumns = false, Microsoft.ML.Data.SchemaDefinition inputSchemaDefinition = null, Microsoft.ML.Data.SchemaDefinition outputSchemaDefinition = null) where TSrc : class where TDst : class, new();" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.TimeSeries.TimeSeriesPredictionFunction`2&lt;!!TSrc, !!TDst&gt; CreateTimeSeriesPredictionFunction&lt;class TSrc, class .ctor TDst&gt;(class Microsoft.ML.Core.Data.ITransformer transformer, class Microsoft.ML.IHostEnvironment env, bool ignoreMissingColumns, class Microsoft.ML.Data.SchemaDefinition inputSchemaDefinition, class Microsoft.ML.Data.SchemaDefinition outputSchemaDefinition) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TimeSeries.PredictionFunctionExtensions.CreateTimeSeriesPredictionFunction``2(Microsoft.ML.Core.Data.ITransformer,Microsoft.ML.IHostEnvironment,System.Boolean,Microsoft.ML.Data.SchemaDefinition,Microsoft.ML.Data.SchemaDefinition)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateTimeSeriesPredictionFunction(Of TSrc As Class, TDst As Class) (transformer As ITransformer, env As IHostEnvironment, Optional ignoreMissingColumns As Boolean = false, Optional inputSchemaDefinition As SchemaDefinition = null, Optional outputSchemaDefinition As SchemaDefinition = null) As TimeSeriesPredictionFunction(Of TSrc, TDst)" />
        <MemberSignature Language="F#" Value="static member CreateTimeSeriesPredictionFunction : Microsoft.ML.Core.Data.ITransformer * Microsoft.ML.IHostEnvironment * bool * Microsoft.ML.Data.SchemaDefinition * Microsoft.ML.Data.SchemaDefinition -&gt; Microsoft.ML.TimeSeries.TimeSeriesPredictionFunction&lt;'Src, 'Dst (requires 'Src : null and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))&gt; (requires 'Src : null and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))" Usage="Microsoft.ML.TimeSeries.PredictionFunctionExtensions.CreateTimeSeriesPredictionFunction (transformer, env, ignoreMissingColumns, inputSchemaDefinition, outputSchemaDefinition)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.TimeSeries.TimeSeriesPredictionFunction&lt;TSrc,TDst&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSrc">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
          <TypeParameter Name="TDst">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="transformer" Type="Microsoft.ML.Core.Data.ITransformer" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" />
          <Parameter Name="ignoreMissingColumns" Type="System.Boolean" />
          <Parameter Name="inputSchemaDefinition" Type="Microsoft.ML.Data.SchemaDefinition" />
          <Parameter Name="outputSchemaDefinition" Type="Microsoft.ML.Data.SchemaDefinition" />
        </Parameters>
        <Docs>
          <typeparam name="TSrc">Class describing input schema to the model.</typeparam>
          <typeparam name="TDst">Class describing the output schema of the prediction.</typeparam>
          <param name="transformer">The time series pipeline in the form of a <see cref="T:Microsoft.ML.Core.Data.ITransformer" />.</param>
          <param name="env">Usually <see cref="T:Microsoft.ML.MLContext" /></param>
          <param name="ignoreMissingColumns">To ignore missing columns. Default is false.</param>
          <param name="inputSchemaDefinition">Input schema definition. Default is null.</param>
          <param name="outputSchemaDefinition">Output schema definition. Default is null.</param>
          <summary>
            <see cref="T:Microsoft.ML.TimeSeries.TimeSeriesPredictionFunction`2" /> creates a prediction function/engine for a time series pipeline
            It updates the state of time series model with observations seen at prediction phase and allows checkpointing the model.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TimeSeries.PredictionFunctionExtensions" Member="M:Microsoft.ML.TimeSeries.PredictionFunctionExtensions.CreateTimeSeriesPredictionFunction``2(Microsoft.ML.Core.Data.ITransformer,Microsoft.ML.IHostEnvironment,System.Boolean,Microsoft.ML.Data.SchemaDefinition,Microsoft.ML.Data.SchemaDefinition)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Array" />
      </Targets>
      <Member MemberName="ArgMax&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static int ArgMax&lt;T&gt; (this T[] arr, int prefix) where T : IComparable&lt;T&gt;;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ArgMax&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(!!T[] arr, int32 prefix) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMax``1(``0[],System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ArgMax(Of T As IComparable(Of T)) (arr As T(), prefix As Integer) As Integer" />
        <MemberSignature Language="F#" Value="static member ArgMax : 'T[] * int -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMax (arr, prefix)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="arr" Type="T[]" RefType="this" />
          <Parameter Name="prefix" Type="System.Int32" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="arr">To be added.</param>
          <param name="prefix">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMax``1(``0[],System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IEnumerable`1" />
      </Targets>
      <Member MemberName="ArgMax&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static int ArgMax&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; e) where T : IComparable&lt;T&gt;;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ArgMax&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; e) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMax``1(System.Collections.Generic.IEnumerable{``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ArgMax(Of T As IComparable(Of T)) (e As IEnumerable(Of T)) As Integer" />
        <MemberSignature Language="F#" Value="static member ArgMax : seq&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMax e" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="e" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="e">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMax``1(System.Collections.Generic.IEnumerable{``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IEnumerable`1" />
      </Targets>
      <Member MemberName="ArgMax&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static int ArgMax&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; e, int prefix) where T : IComparable&lt;T&gt;;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ArgMax&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; e, int32 prefix) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMax``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ArgMax(Of T As IComparable(Of T)) (e As IEnumerable(Of T), prefix As Integer) As Integer" />
        <MemberSignature Language="F#" Value="static member ArgMax : seq&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; * int -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMax (e, prefix)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="e" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
          <Parameter Name="prefix" Type="System.Int32" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="e">To be added.</param>
          <param name="prefix">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMax``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.ReadOnlySpan`1" />
      </Targets>
      <Member MemberName="ArgMax&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static int ArgMax&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span) where T : IComparable&lt;T&gt;;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ArgMax&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMax``1(System.ReadOnlySpan{``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ArgMax(Of T As IComparable(Of T)) (span As ReadOnlySpan(Of T)) As Integer" />
        <MemberSignature Language="F#" Value="static member ArgMax : ReadOnlySpan&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMax span" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="span">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMax``1(System.ReadOnlySpan{``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IEnumerable`1" />
      </Targets>
      <Member MemberName="ArgMaxRand&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static int ArgMaxRand&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; e, int prefix, Random rnd, double fraction) where T : IComparable&lt;T&gt;;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ArgMaxRand&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; e, int32 prefix, class System.Random rnd, float64 fraction) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMaxRand``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Random,System.Double)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ArgMaxRand(Of T As IComparable(Of T)) (e As IEnumerable(Of T), prefix As Integer, rnd As Random, fraction As Double) As Integer" />
        <MemberSignature Language="F#" Value="static member ArgMaxRand : seq&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; * int * Random * double -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMaxRand (e, prefix, rnd, fraction)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="e" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
          <Parameter Name="prefix" Type="System.Int32" />
          <Parameter Name="rnd" Type="System.Random" />
          <Parameter Name="fraction" Type="System.Double" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="e">To be added.</param>
          <param name="prefix">To be added.</param>
          <param name="rnd">To be added.</param>
          <param name="fraction">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMaxRand``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Random,System.Double)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IEnumerable`1" />
      </Targets>
      <Member MemberName="ArgMaxRand&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static int ArgMaxRand&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; e, Random rnd, double fraction) where T : IComparable&lt;T&gt;;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ArgMaxRand&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; e, class System.Random rnd, float64 fraction) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMaxRand``1(System.Collections.Generic.IEnumerable{``0},System.Random,System.Double)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ArgMaxRand(Of T As IComparable(Of T)) (e As IEnumerable(Of T), rnd As Random, fraction As Double) As Integer" />
        <MemberSignature Language="F#" Value="static member ArgMaxRand : seq&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; * Random * double -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMaxRand (e, rnd, fraction)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="e" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
          <Parameter Name="rnd" Type="System.Random" />
          <Parameter Name="fraction" Type="System.Double" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="e">To be added.</param>
          <param name="rnd">To be added.</param>
          <param name="fraction">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMaxRand``1(System.Collections.Generic.IEnumerable{``0},System.Random,System.Double)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Array" />
      </Targets>
      <Member MemberName="ArgMin&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static int ArgMin&lt;T&gt; (this T[] arr) where T : IComparable&lt;T&gt;;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ArgMin&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(!!T[] arr) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMin``1(``0[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ArgMin(Of T As IComparable(Of T)) (arr As T()) As Integer" />
        <MemberSignature Language="F#" Value="static member ArgMin : 'T[] -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMin arr" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="arr" Type="T[]" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="arr">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMin``1(``0[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Array" />
      </Targets>
      <Member MemberName="ArgMin&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static int ArgMin&lt;T&gt; (this T[] arr, int prefix) where T : IComparable&lt;T&gt;;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ArgMin&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(!!T[] arr, int32 prefix) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMin``1(``0[],System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ArgMin(Of T As IComparable(Of T)) (arr As T(), prefix As Integer) As Integer" />
        <MemberSignature Language="F#" Value="static member ArgMin : 'T[] * int -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMin (arr, prefix)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="arr" Type="T[]" RefType="this" />
          <Parameter Name="prefix" Type="System.Int32" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="arr">To be added.</param>
          <param name="prefix">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMin``1(``0[],System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IEnumerable`1" />
      </Targets>
      <Member MemberName="ArgMin&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static int ArgMin&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; e) where T : IComparable&lt;T&gt;;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ArgMin&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; e) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMin``1(System.Collections.Generic.IEnumerable{``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ArgMin(Of T As IComparable(Of T)) (e As IEnumerable(Of T)) As Integer" />
        <MemberSignature Language="F#" Value="static member ArgMin : seq&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMin e" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="e" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="e">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMin``1(System.Collections.Generic.IEnumerable{``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IEnumerable`1" />
      </Targets>
      <Member MemberName="ArgMin&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static int ArgMin&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; e, int prefix) where T : IComparable&lt;T&gt;;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ArgMin&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; e, int32 prefix) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMin``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ArgMin(Of T As IComparable(Of T)) (e As IEnumerable(Of T), prefix As Integer) As Integer" />
        <MemberSignature Language="F#" Value="static member ArgMin : seq&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; * int -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMin (e, prefix)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="e" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
          <Parameter Name="prefix" Type="System.Int32" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="e">To be added.</param>
          <param name="prefix">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ArgMin``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IEnumerable`1" />
      </Targets>
      <Member MemberName="CumulativeSum&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;int&gt; CumulativeSum&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;int&gt; s);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;int32&gt; CumulativeSum&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; s) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.CumulativeSum``1(System.Collections.Generic.IEnumerable{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Iterator Function CumulativeSum(Of T) (s As IEnumerable(Of Integer)) As IEnumerable(Of Integer)" />
        <MemberSignature Language="F#" Value="static member CumulativeSum : seq&lt;int&gt; -&gt; seq&lt;int&gt;" Usage="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.CumulativeSum s" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Int32&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="s" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="s">To be added.</param>
          <summary>
            RunningLength. Converts sequence like 1, 2, 3, 4
            to  1, 3, 6, 10
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.CumulativeSum``1(System.Collections.Generic.IEnumerable{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IEnumerable`1" />
      </Targets>
      <Member MemberName="MergeSortedList&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; MergeSortedList&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; s1, System.Collections.Generic.IEnumerable&lt;T&gt; s2) where T : IComparable&lt;T&gt;;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; MergeSortedList&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; s1, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; s2) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.MergeSortedList``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Iterator Function MergeSortedList(Of T As IComparable(Of T)) (s1 As IEnumerable(Of T), s2 As IEnumerable(Of T)) As IEnumerable(Of T)" />
        <MemberSignature Language="F#" Value="static member MergeSortedList : seq&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; * seq&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; -&gt; seq&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.MergeSortedList (s1, s2)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="s1" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
          <Parameter Name="s2" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="s1">To be added.</param>
          <param name="s2">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.MergeSortedList``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IEnumerable`1" />
      </Targets>
      <Member MemberName="SoftArgMax">
        <MemberSignature Language="C#" Value="public static int SoftArgMax (this System.Collections.Generic.IEnumerable&lt;double&gt; values, Random rand);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SoftArgMax(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; values, class System.Random rand) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.SoftArgMax(System.Collections.Generic.IEnumerable{System.Double},System.Random)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SoftArgMax (values As IEnumerable(Of Double), rand As Random) As Integer" />
        <MemberSignature Language="F#" Value="static member SoftArgMax : seq&lt;double&gt; * Random -&gt; int" Usage="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.SoftArgMax (values, rand)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="rand" Type="System.Random" />
        </Parameters>
        <Docs>
          <param name="values">To be added.</param>
          <param name="rand">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.SoftArgMax(System.Collections.Generic.IEnumerable{System.Double},System.Random)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IEnumerable`1" />
      </Targets>
      <Member MemberName="ToArray&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static T[] ToArray&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; me, int length);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] ToArray&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; me, int32 length) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ToArray``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToArray(Of T) (me As IEnumerable(Of T), length As Integer) As T()" />
        <MemberSignature Language="F#" Value="static member ToArray : seq&lt;'T&gt; * int -&gt; 'T[]" Usage="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ToArray (me, length)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>T[]</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="me" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
          <Parameter Name="length" Type="System.Int32" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="me">To be added.</param>
          <param name="length">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.LinqExtensions.ToArray``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.Stream" />
      </Targets>
      <Member MemberName="ReadCompressed">
        <MemberSignature Language="C#" Value="public static byte[] ReadCompressed (this System.IO.Stream stream);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ReadCompressed(class System.IO.Stream stream) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.StreamExtensions.ReadCompressed(System.IO.Stream)" />
        <MemberSignature Language="F#" Value="static member ReadCompressed : System.IO.Stream -&gt; byte[]" Usage="Microsoft.ML.Trainers.FastTree.Internal.StreamExtensions.ReadCompressed stream" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Byte[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="stream" Type="System.IO.Stream" RefType="this" />
        </Parameters>
        <Docs>
          <param name="stream">The stream to read from</param>
          <summary>
            Reads a compressed array of byte from the stream (written by WriteCompressed)
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.StreamExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.StreamExtensions.ReadCompressed(System.IO.Stream)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.Stream" />
      </Targets>
      <Member MemberName="WriteCompressed">
        <MemberSignature Language="C#" Value="public static void WriteCompressed (this System.IO.Stream stream, byte[] array);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteCompressed(class System.IO.Stream stream, unsigned int8[] array) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.StreamExtensions.WriteCompressed(System.IO.Stream,System.Byte[])" />
        <MemberSignature Language="F#" Value="static member WriteCompressed : System.IO.Stream * byte[] -&gt; unit" Usage="Microsoft.ML.Trainers.FastTree.Internal.StreamExtensions.WriteCompressed (stream, array)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="stream" Type="System.IO.Stream" RefType="this" />
          <Parameter Name="array" Type="System.Byte[]" />
        </Parameters>
        <Docs>
          <param name="stream">Stream to write to</param>
          <param name="array">Array to write</param>
          <summary>
            Writes an array of bytes to the stream with compression
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.StreamExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.StreamExtensions.WriteCompressed(System.IO.Stream,System.Byte[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.Stream" />
      </Targets>
      <Member MemberName="WriteCompressed">
        <MemberSignature Language="C#" Value="public static void WriteCompressed (this System.IO.Stream stream, byte[] array, int offset, int count);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteCompressed(class System.IO.Stream stream, unsigned int8[] array, int32 offset, int32 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.StreamExtensions.WriteCompressed(System.IO.Stream,System.Byte[],System.Int32,System.Int32)" />
        <MemberSignature Language="F#" Value="static member WriteCompressed : System.IO.Stream * byte[] * int * int -&gt; unit" Usage="Microsoft.ML.Trainers.FastTree.Internal.StreamExtensions.WriteCompressed (stream, array, offset, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="stream" Type="System.IO.Stream" RefType="this" />
          <Parameter Name="array" Type="System.Byte[]" />
          <Parameter Name="offset" Type="System.Int32" />
          <Parameter Name="count" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="stream">Stream to write to</param>
          <param name="array">Array to write</param>
          <param name="offset">The byte offset into the array to write</param>
          <param name="count">The number of bytes from the array to write</param>
          <summary>
            Writes an array of bytes to the stream with compression
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.StreamExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.StreamExtensions.WriteCompressed(System.IO.Stream,System.Byte[],System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Trainers.FastTree.Internal.MD5Hash" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this Microsoft.ML.Trainers.FastTree.Internal.MD5Hash[] array);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(valuetype Microsoft.ML.Trainers.FastTree.Internal.MD5Hash[] array) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(Microsoft.ML.Trainers.FastTree.Internal.MD5Hash[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (array As MD5Hash()) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : Microsoft.ML.Trainers.FastTree.Internal.MD5Hash[] -&gt; int" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes array" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="array" Type="Microsoft.ML.Trainers.FastTree.Internal.MD5Hash[]" RefType="this" />
        </Parameters>
        <Docs>
          <param name="array">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(Microsoft.ML.Trainers.FastTree.Internal.MD5Hash[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this byte a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(unsigned int8 a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Byte)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As Byte) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : byte -&gt; int" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Byte" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Byte)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this byte[] a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(unsigned int8[] a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Byte[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As Byte()) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : byte[] -&gt; int" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Byte[]" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Byte[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Double" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this double a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(float64 a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Double)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As Double) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : double -&gt; int" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Double" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Double)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Double" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this double[] array);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(float64[] array) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Double[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (array As Double()) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : double[] -&gt; int" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes array" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="array" Type="System.Double[]" RefType="this" />
        </Parameters>
        <Docs>
          <param name="array">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Double[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Double" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this double[][] array);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(float64[][] array) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Double[][])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (array As Double()()) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : double[][] -&gt; int" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes array" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="array" Type="System.Double[][]" RefType="this" />
        </Parameters>
        <Docs>
          <param name="array">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Double[][])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int16" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this short a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(int16 a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Int16)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As Short) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : int16 -&gt; int" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Int16" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Int16)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int16" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this short[] a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(int16[] a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Int16[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As Short()) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : int16[] -&gt; int" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Int16[]" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Int16[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int32" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this int a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(int32 a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As Integer) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : int -&gt; int" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Int32" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int32" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this int[] array);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(int32[] array) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Int32[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (array As Integer()) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : int[] -&gt; int" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes array" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="array" Type="System.Int32[]" RefType="this" />
        </Parameters>
        <Docs>
          <param name="array">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Int32[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int64" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this long a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(int64 a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Int64)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As Long) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : int64 -&gt; int" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Int64" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Int64)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int64" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this long[] array);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(int64[] array) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Int64[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (array As Long()) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : int64[] -&gt; int" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes array" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="array" Type="System.Int64[]" RefType="this" />
        </Parameters>
        <Docs>
          <param name="array">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Int64[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Single" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this float a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(float32 a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Single)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As Single) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : single -&gt; int" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Single" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Single)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Single" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this float[] array);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(float32[] array) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Single[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (array As Single()) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : single[] -&gt; int" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes array" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="array" Type="System.Single[]" RefType="this" />
        </Parameters>
        <Docs>
          <param name="array">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Single[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.String" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this string a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(string a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As String) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : string -&gt; int" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.String" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.String" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static long SizeInBytes (this string[] array);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 SizeInBytes(string[] array) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.String[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (array As String()) As Long" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : string[] -&gt; int64" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes array" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int64</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="array" Type="System.String[]" RefType="this" />
        </Parameters>
        <Docs>
          <param name="array">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.String[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.UInt16" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this ushort a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(unsigned int16 a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.UInt16)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As UShort) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : uint16 -&gt; int" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.UInt16" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.UInt16)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.UInt16" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this ushort[] a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(unsigned int16[] a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.UInt16[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As UShort()) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : uint16[] -&gt; int" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.UInt16[]" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.UInt16[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.UInt32" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this uint a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(unsigned int32 a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.UInt32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As UInteger) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : uint32 -&gt; int" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.UInt32" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.UInt32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.UInt32" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this uint[] array);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(unsigned int32[] array) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.UInt32[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (array As UInteger()) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : uint32[] -&gt; int" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes array" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="array" Type="System.UInt32[]" RefType="this" />
        </Parameters>
        <Docs>
          <param name="array">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.UInt32[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.UInt64" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this ulong a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(unsigned int64 a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.UInt64)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As ULong) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : uint64 -&gt; int" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.UInt64" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.UInt64)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.UInt64" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this ulong[] array);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(unsigned int64[] array) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.UInt64[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (array As ULong()) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : uint64[] -&gt; int" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes array" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="array" Type="System.UInt64[]" RefType="this" />
        </Parameters>
        <Docs>
          <param name="array">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.UInt64[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToByte">
        <MemberSignature Language="C#" Value="public static byte ToByte (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ToByte(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByte(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToByte (buffer As Byte(), ByRef position As Integer) As Byte" />
        <MemberSignature Language="F#" Value="static member ToByte : byte[] *  -&gt; byte" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByte (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Byte</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByte(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Trainers.FastTree.Internal.MD5Hash" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this Microsoft.ML.Trainers.FastTree.Internal.MD5Hash[] a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(valuetype Microsoft.ML.Trainers.FastTree.Internal.MD5Hash[] a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(Microsoft.ML.Trainers.FastTree.Internal.MD5Hash[],System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As MD5Hash(), buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : Microsoft.ML.Trainers.FastTree.Internal.MD5Hash[] * byte[] *  -&gt; unit" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="Microsoft.ML.Trainers.FastTree.Internal.MD5Hash[]" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(Microsoft.ML.Trainers.FastTree.Internal.MD5Hash[],System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this byte a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(unsigned int8 a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Byte,System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Byte, buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : byte * byte[] *  -&gt; unit" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Byte" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Byte,System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this byte[] a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(unsigned int8[] a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Byte[],System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Byte(), buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : byte[] * byte[] *  -&gt; unit" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Byte[]" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Byte[],System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static byte[] ToByteArray (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ToByteArray(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToByteArray (buffer As Byte(), ByRef position As Integer) As Byte()" />
        <MemberSignature Language="F#" Value="static member ToByteArray : byte[] *  -&gt; byte[]" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Byte[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Double" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this double a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(float64 a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Double,System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Double, buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : double * byte[] *  -&gt; unit" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Double" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Double,System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Double" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this double[] a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(float64[] a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Double[],System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Double(), buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : double[] * byte[] *  -&gt; unit" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Double[]" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Double[],System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Double" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this double[][] a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(float64[][] a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Double[][],System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Double()(), buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : double[][] * byte[] *  -&gt; unit" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Double[][]" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Double[][],System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int16" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this short a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(int16 a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Int16,System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Short, buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : int16 * byte[] *  -&gt; unit" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Int16" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Int16,System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int16" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this short[] a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(int16[] a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Int16[],System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Short(), buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : int16[] * byte[] *  -&gt; unit" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Int16[]" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Int16[],System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int32" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this int a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(int32 a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Int32,System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Integer, buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : int * byte[] *  -&gt; unit" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Int32" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Int32,System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int32" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this int[] a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(int32[] a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Int32[],System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Integer(), buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : int[] * byte[] *  -&gt; unit" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Int32[]" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Int32[],System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int64" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this long a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(int64 a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Int64,System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Long, buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : int64 * byte[] *  -&gt; unit" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Int64" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Int64,System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int64" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this long[] a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(int64[] a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Int64[],System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Long(), buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : int64[] * byte[] *  -&gt; unit" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Int64[]" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Int64[],System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Single" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this float a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(float32 a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Single,System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Single, buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : single * byte[] *  -&gt; unit" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Single" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Single,System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Single" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this float[] a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(float32[] a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Single[],System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Single(), buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : single[] * byte[] *  -&gt; unit" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Single[]" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Single[],System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.String" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static byte[] ToByteArray (this string a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ToByteArray(string a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToByteArray (a As String) As Byte()" />
        <MemberSignature Language="F#" Value="static member ToByteArray : string -&gt; byte[]" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Byte[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.String" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.String" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this string a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(string a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.String,System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As String, buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : string * byte[] *  -&gt; unit" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.String" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.String,System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.String" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this string[] a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(string[] a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.String[],System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As String(), buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : string[] * byte[] *  -&gt; unit" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.String[]" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.String[],System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.UInt16" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this ushort a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(unsigned int16 a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.UInt16,System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As UShort, buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : uint16 * byte[] *  -&gt; unit" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.UInt16" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.UInt16,System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.UInt16" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this ushort[] a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(unsigned int16[] a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.UInt16[],System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As UShort(), buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : uint16[] * byte[] *  -&gt; unit" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.UInt16[]" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.UInt16[],System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.UInt32" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this uint a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(unsigned int32 a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.UInt32,System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As UInteger, buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : uint32 * byte[] *  -&gt; unit" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.UInt32" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.UInt32,System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.UInt32" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this uint[] a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(unsigned int32[] a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.UInt32[],System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As UInteger(), buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : uint32[] * byte[] *  -&gt; unit" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.UInt32[]" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.UInt32[],System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.UInt64" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this ulong a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(unsigned int64 a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.UInt64,System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As ULong, buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : uint64 * byte[] *  -&gt; unit" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.UInt64" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.UInt64,System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.UInt64" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this ulong[] a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(unsigned int64[] a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.UInt64[],System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As ULong(), buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : uint64[] * byte[] *  -&gt; unit" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.UInt64[]" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.UInt64[],System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToDouble">
        <MemberSignature Language="C#" Value="public static double ToDouble (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ToDouble(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToDouble(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDouble (buffer As Byte(), ByRef position As Integer) As Double" />
        <MemberSignature Language="F#" Value="static member ToDouble : byte[] *  -&gt; double" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToDouble (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Double</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToDouble(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToDoubleArray">
        <MemberSignature Language="C#" Value="public static double[] ToDoubleArray (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64[] ToDoubleArray(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToDoubleArray(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDoubleArray (buffer As Byte(), ByRef position As Integer) As Double()" />
        <MemberSignature Language="F#" Value="static member ToDoubleArray : byte[] *  -&gt; double[]" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToDoubleArray (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Double[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToDoubleArray(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToDoubleJaggedArray">
        <MemberSignature Language="C#" Value="public static double[][] ToDoubleJaggedArray (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64[][] ToDoubleJaggedArray(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToDoubleJaggedArray(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDoubleJaggedArray (buffer As Byte(), ByRef position As Integer) As Double()()" />
        <MemberSignature Language="F#" Value="static member ToDoubleJaggedArray : byte[] *  -&gt; double[][]" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToDoubleJaggedArray (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Double[][]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToDoubleJaggedArray(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static float ToFloat (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ToFloat(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToFloat(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (buffer As Byte(), ByRef position As Integer) As Single" />
        <MemberSignature Language="F#" Value="static member ToFloat : byte[] *  -&gt; single" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToFloat (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Single</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToFloat(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToFloatArray">
        <MemberSignature Language="C#" Value="public static float[] ToFloatArray (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32[] ToFloatArray(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToFloatArray(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloatArray (buffer As Byte(), ByRef position As Integer) As Single()" />
        <MemberSignature Language="F#" Value="static member ToFloatArray : byte[] *  -&gt; single[]" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToFloatArray (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Single[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToFloatArray(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToInt">
        <MemberSignature Language="C#" Value="public static int ToInt (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToInt(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToInt(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToInt (buffer As Byte(), ByRef position As Integer) As Integer" />
        <MemberSignature Language="F#" Value="static member ToInt : byte[] *  -&gt; int" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToInt (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToInt(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToIntArray">
        <MemberSignature Language="C#" Value="public static int[] ToIntArray (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32[] ToIntArray(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToIntArray(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToIntArray (buffer As Byte(), ByRef position As Integer) As Integer()" />
        <MemberSignature Language="F#" Value="static member ToIntArray : byte[] *  -&gt; int[]" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToIntArray (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToIntArray(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToIntArray">
        <MemberSignature Language="C#" Value="public static int[] ToIntArray (this byte[] buffer, ref int position, int length);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32[] ToIntArray(unsigned int8[] buffer, int32&amp; position, int32 length) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToIntArray(System.Byte[],System.Int32@,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToIntArray (buffer As Byte(), ByRef position As Integer, length As Integer) As Integer()" />
        <MemberSignature Language="F#" Value="static member ToIntArray : byte[] *  * int -&gt; int[]" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToIntArray (buffer, position, length)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
          <Parameter Name="length" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <param name="length">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToIntArray(System.Byte[],System.Int32@,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToLong">
        <MemberSignature Language="C#" Value="public static long ToLong (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToLong(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToLong(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLong (buffer As Byte(), ByRef position As Integer) As Long" />
        <MemberSignature Language="F#" Value="static member ToLong : byte[] *  -&gt; int64" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToLong (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int64</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToLong(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToLongArray">
        <MemberSignature Language="C#" Value="public static long[] ToLongArray (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64[] ToLongArray(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToLongArray(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLongArray (buffer As Byte(), ByRef position As Integer) As Long()" />
        <MemberSignature Language="F#" Value="static member ToLongArray : byte[] *  -&gt; int64[]" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToLongArray (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int64[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToLongArray(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToRowId">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.Internal.MD5Hash ToRowId (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.ML.Trainers.FastTree.Internal.MD5Hash ToRowId(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToRowId(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToRowId (buffer As Byte(), ByRef position As Integer) As MD5Hash" />
        <MemberSignature Language="F#" Value="static member ToRowId : byte[] *  -&gt; Microsoft.ML.Trainers.FastTree.Internal.MD5Hash" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToRowId (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.Internal.MD5Hash</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToRowId(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToRowIdArray">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.Internal.MD5Hash[] ToRowIdArray (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.ML.Trainers.FastTree.Internal.MD5Hash[] ToRowIdArray(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToRowIdArray(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToRowIdArray (buffer As Byte(), ByRef position As Integer) As MD5Hash()" />
        <MemberSignature Language="F#" Value="static member ToRowIdArray : byte[] *  -&gt; Microsoft.ML.Trainers.FastTree.Internal.MD5Hash[]" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToRowIdArray (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.Internal.MD5Hash[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToRowIdArray(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToShort">
        <MemberSignature Language="C#" Value="public static short ToShort (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ToShort(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToShort(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToShort (buffer As Byte(), ByRef position As Integer) As Short" />
        <MemberSignature Language="F#" Value="static member ToShort : byte[] *  -&gt; int16" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToShort (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int16</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToShort(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToShortArray">
        <MemberSignature Language="C#" Value="public static short[] ToShortArray (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16[] ToShortArray(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToShortArray(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToShortArray (buffer As Byte(), ByRef position As Integer) As Short()" />
        <MemberSignature Language="F#" Value="static member ToShortArray : byte[] *  -&gt; int16[]" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToShortArray (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int16[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToShortArray(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToString">
        <MemberSignature Language="C#" Value="public static string ToString (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToString(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToString (buffer As Byte(), ByRef position As Integer) As String" />
        <MemberSignature Language="F#" Value="static member ToString : byte[] *  -&gt; string" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToString (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToString(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToStringArray">
        <MemberSignature Language="C#" Value="public static string[] ToStringArray (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] ToStringArray(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToStringArray(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToStringArray (buffer As Byte(), ByRef position As Integer) As String()" />
        <MemberSignature Language="F#" Value="static member ToStringArray : byte[] *  -&gt; string[]" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToStringArray (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToStringArray(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToUInt">
        <MemberSignature Language="C#" Value="public static uint ToUInt (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ToUInt(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToUInt(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToUInt (buffer As Byte(), ByRef position As Integer) As UInteger" />
        <MemberSignature Language="F#" Value="static member ToUInt : byte[] *  -&gt; uint32" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToUInt (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.UInt32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToUInt(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToUIntArray">
        <MemberSignature Language="C#" Value="public static uint[] ToUIntArray (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32[] ToUIntArray(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToUIntArray(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToUIntArray (buffer As Byte(), ByRef position As Integer) As UInteger()" />
        <MemberSignature Language="F#" Value="static member ToUIntArray : byte[] *  -&gt; uint32[]" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToUIntArray (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.UInt32[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToUIntArray(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToULong">
        <MemberSignature Language="C#" Value="public static ulong ToULong (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ToULong(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToULong(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToULong (buffer As Byte(), ByRef position As Integer) As ULong" />
        <MemberSignature Language="F#" Value="static member ToULong : byte[] *  -&gt; uint64" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToULong (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.UInt64</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToULong(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToULongArray">
        <MemberSignature Language="C#" Value="public static ulong[] ToULongArray (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64[] ToULongArray(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToULongArray(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToULongArray (buffer As Byte(), ByRef position As Integer) As ULong()" />
        <MemberSignature Language="F#" Value="static member ToULongArray : byte[] *  -&gt; uint64[]" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToULongArray (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.UInt64[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToULongArray(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToUShort">
        <MemberSignature Language="C#" Value="public static ushort ToUShort (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ToUShort(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToUShort(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToUShort (buffer As Byte(), ByRef position As Integer) As UShort" />
        <MemberSignature Language="F#" Value="static member ToUShort : byte[] *  -&gt; uint16" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToUShort (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.UInt16</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToUShort(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToUShortArray">
        <MemberSignature Language="C#" Value="public static ushort[] ToUShortArray (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16[] ToUShortArray(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToUShortArray(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToUShortArray (buffer As Byte(), ByRef position As Integer) As UShort()" />
        <MemberSignature Language="F#" Value="static member ToUShortArray : byte[] *  -&gt; uint16[]" Usage="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToUShortArray (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.UInt16[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Trainers.FastTree.Internal.ToByteArrayExtensions.ToUShortArray(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="Concatenate">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.ColumnConcatenatingEstimator Concatenate (this Microsoft.ML.TransformsCatalog catalog, string outputColumn, params string[] inputColumns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.ColumnConcatenatingEstimator Concatenate(class Microsoft.ML.TransformsCatalog catalog, string outputColumn, string[] inputColumns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TransformExtensionsCatalog.Concatenate(Microsoft.ML.TransformsCatalog,System.String,System.String[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Concatenate (catalog As TransformsCatalog, outputColumn As String, ParamArray inputColumns As String()) As ColumnConcatenatingEstimator" />
        <MemberSignature Language="F#" Value="static member Concatenate : Microsoft.ML.TransformsCatalog * string * string[] -&gt; Microsoft.ML.Transforms.ColumnConcatenatingEstimator" Usage="Microsoft.ML.TransformExtensionsCatalog.Concatenate (catalog, outputColumn, inputColumns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.ColumnConcatenatingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="inputColumns" Type="System.String[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="outputColumn">The name of the output column.</param>
          <param name="inputColumns">The names of the columns to concatenate together.</param>
          <summary>
            Concatenates two columns together.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TransformExtensionsCatalog" Member="M:Microsoft.ML.TransformExtensionsCatalog.Concatenate(Microsoft.ML.TransformsCatalog,System.String,System.String[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="CopyColumns">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.ColumnCopyingEstimator CopyColumns (this Microsoft.ML.TransformsCatalog catalog, string inputColumn, string outputColumn);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.ColumnCopyingEstimator CopyColumns(class Microsoft.ML.TransformsCatalog catalog, string inputColumn, string outputColumn) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TransformExtensionsCatalog.CopyColumns(Microsoft.ML.TransformsCatalog,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CopyColumns (catalog As TransformsCatalog, inputColumn As String, outputColumn As String) As ColumnCopyingEstimator" />
        <MemberSignature Language="F#" Value="static member CopyColumns : Microsoft.ML.TransformsCatalog * string * string -&gt; Microsoft.ML.Transforms.ColumnCopyingEstimator" Usage="Microsoft.ML.TransformExtensionsCatalog.CopyColumns (catalog, inputColumn, outputColumn)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.ColumnCopyingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="inputColumn">Name of the input column.</param>
          <param name="outputColumn">Name of the new column, resulting from copying.</param>
          <summary>
            Copies the input column to another column named as specified in <paramref name="outputColumn" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TransformExtensionsCatalog" Member="M:Microsoft.ML.TransformExtensionsCatalog.CopyColumns(Microsoft.ML.TransformsCatalog,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="CopyColumns">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.ColumnCopyingEstimator CopyColumns (this Microsoft.ML.TransformsCatalog catalog, params ValueTuple&lt;string,string&gt;[] columns);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.ColumnCopyingEstimator CopyColumns(class Microsoft.ML.TransformsCatalog catalog, valuetype System.ValueTuple`2&lt;string, string&gt;[] columns) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TransformExtensionsCatalog.CopyColumns(Microsoft.ML.TransformsCatalog,System.ValueTuple{System.String,System.String}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CopyColumns (catalog As TransformsCatalog, ParamArray columns As ValueTuple(Of String, String)()) As ColumnCopyingEstimator" />
        <MemberSignature Language="F#" Value="static member CopyColumns : Microsoft.ML.TransformsCatalog * ValueTuple&lt;string, string&gt;[] -&gt; Microsoft.ML.Transforms.ColumnCopyingEstimator" Usage="Microsoft.ML.TransformExtensionsCatalog.CopyColumns (catalog, columns)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.ColumnCopyingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="columns" Type="System.ValueTuple&lt;System.String,System.String&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
              <Attribute>
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "source", "name" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog</param>
          <param name="columns">The pairs of input and output columns.</param>
          <summary>
            Copies the input column, name specified in the first item of the tuple,
            to another column, named as specified in the second item of the tuple.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TransformExtensionsCatalog" Member="M:Microsoft.ML.TransformExtensionsCatalog.CopyColumns(Microsoft.ML.TransformsCatalog,System.ValueTuple{System.String,System.String}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="DropColumns">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.ColumnSelectingEstimator DropColumns (this Microsoft.ML.TransformsCatalog catalog, params string[] columnsToDrop);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.ColumnSelectingEstimator DropColumns(class Microsoft.ML.TransformsCatalog catalog, string[] columnsToDrop) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TransformExtensionsCatalog.DropColumns(Microsoft.ML.TransformsCatalog,System.String[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DropColumns (catalog As TransformsCatalog, ParamArray columnsToDrop As String()) As ColumnSelectingEstimator" />
        <MemberSignature Language="F#" Value="static member DropColumns : Microsoft.ML.TransformsCatalog * string[] -&gt; Microsoft.ML.Transforms.ColumnSelectingEstimator" Usage="Microsoft.ML.TransformExtensionsCatalog.DropColumns (catalog, columnsToDrop)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.ColumnSelectingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="columnsToDrop" Type="System.String[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="columnsToDrop">The array of column names to drop.</param>
          <summary>
            DropColumns is used to select a list of columns that user wants to drop from a given input. Any column not specified will
            be maintained in the output schema.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TransformExtensionsCatalog" Member="M:Microsoft.ML.TransformExtensionsCatalog.DropColumns(Microsoft.ML.TransformsCatalog,System.String[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TransformsCatalog" />
      </Targets>
      <Member MemberName="SelectColumns">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Transforms.ColumnSelectingEstimator SelectColumns (this Microsoft.ML.TransformsCatalog catalog, string[] keepColumns, bool keepHidden = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Transforms.ColumnSelectingEstimator SelectColumns(class Microsoft.ML.TransformsCatalog catalog, string[] keepColumns, bool keepHidden) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TransformExtensionsCatalog.SelectColumns(Microsoft.ML.TransformsCatalog,System.String[],System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectColumns (catalog As TransformsCatalog, keepColumns As String(), Optional keepHidden As Boolean = false) As ColumnSelectingEstimator" />
        <MemberSignature Language="F#" Value="static member SelectColumns : Microsoft.ML.TransformsCatalog * string[] * bool -&gt; Microsoft.ML.Transforms.ColumnSelectingEstimator" Usage="Microsoft.ML.TransformExtensionsCatalog.SelectColumns (catalog, keepColumns, keepHidden)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Transforms.ColumnSelectingEstimator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="catalog" Type="Microsoft.ML.TransformsCatalog" RefType="this" />
          <Parameter Name="keepColumns" Type="System.String[]" />
          <Parameter Name="keepHidden" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="catalog">The transform's catalog.</param>
          <param name="keepColumns">The array of column names to keep.</param>
          <param name="keepHidden">If true will keep hidden columns and false will remove hidden columns.</param>
          <summary>
            ColumnSelectingEstimator is used to select a list of columns that user wants to drop from a given input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TransformExtensionsCatalog" Member="M:Microsoft.ML.TransformExtensionsCatalog.SelectColumns(Microsoft.ML.TransformsCatalog,System.String[],System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Transforms.DnnImageModelSelector" />
      </Targets>
      <Member MemberName="AlexNet">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; AlexNet (this Microsoft.ML.Transforms.DnnImageModelSelector dnnModelContext, Microsoft.ML.IHostEnvironment env, string inputColumn, string outputColumn);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.EstimatorChain`1&lt;class Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; AlexNet(class Microsoft.ML.Transforms.DnnImageModelSelector dnnModelContext, class Microsoft.ML.IHostEnvironment env, string inputColumn, string outputColumn) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.AlexNetExtension.AlexNet(Microsoft.ML.Transforms.DnnImageModelSelector,Microsoft.ML.IHostEnvironment,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AlexNet (dnnModelContext As DnnImageModelSelector, env As IHostEnvironment, inputColumn As String, outputColumn As String) As EstimatorChain(Of ColumnCopyingTransformer)" />
        <MemberSignature Language="F#" Value="static member AlexNet : Microsoft.ML.Transforms.DnnImageModelSelector * Microsoft.ML.IHostEnvironment * string * string -&gt; Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;" Usage="Microsoft.ML.Transforms.AlexNetExtension.AlexNet (dnnModelContext, env, inputColumn, outputColumn)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="dnnModelContext" Type="Microsoft.ML.Transforms.DnnImageModelSelector" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="dnnModelContext">To be added.</param>
          <param name="env">To be added.</param>
          <param name="inputColumn">To be added.</param>
          <param name="outputColumn">To be added.</param>
          <summary>
            Returns an estimator chain with the two corresponding models (a preprocessing one and a main one) required for the AlexNet pipeline.
            Also includes the renaming ColumnsCopyingTransforms required to be able to use arbitrary input and output column names.
            This assumes both of the models are in the same location as the file containing this method, which they will be if used through the NuGet.
            This should be the default way to use AlexNet if importing the model from a NuGet.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.AlexNetExtension" Member="M:Microsoft.ML.Transforms.AlexNetExtension.AlexNet(Microsoft.ML.Transforms.DnnImageModelSelector,Microsoft.ML.IHostEnvironment,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Transforms.DnnImageModelSelector" />
      </Targets>
      <Member MemberName="AlexNet">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; AlexNet (this Microsoft.ML.Transforms.DnnImageModelSelector dnnModelContext, Microsoft.ML.IHostEnvironment env, string inputColumn, string outputColumn, string modelDir);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.EstimatorChain`1&lt;class Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; AlexNet(class Microsoft.ML.Transforms.DnnImageModelSelector dnnModelContext, class Microsoft.ML.IHostEnvironment env, string inputColumn, string outputColumn, string modelDir) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.AlexNetExtension.AlexNet(Microsoft.ML.Transforms.DnnImageModelSelector,Microsoft.ML.IHostEnvironment,System.String,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AlexNet (dnnModelContext As DnnImageModelSelector, env As IHostEnvironment, inputColumn As String, outputColumn As String, modelDir As String) As EstimatorChain(Of ColumnCopyingTransformer)" />
        <MemberSignature Language="F#" Value="static member AlexNet : Microsoft.ML.Transforms.DnnImageModelSelector * Microsoft.ML.IHostEnvironment * string * string * string -&gt; Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;" Usage="Microsoft.ML.Transforms.AlexNetExtension.AlexNet (dnnModelContext, env, inputColumn, outputColumn, modelDir)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="dnnModelContext" Type="Microsoft.ML.Transforms.DnnImageModelSelector" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="modelDir" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="dnnModelContext">To be added.</param>
          <param name="env">To be added.</param>
          <param name="inputColumn">To be added.</param>
          <param name="outputColumn">To be added.</param>
          <param name="modelDir">To be added.</param>
          <summary>
            This allows a custom model location to be specified. This is useful is a custom model is specified,
            or if the model is desired to be placed or shipped separately in a different folder from the main application. Note that because Onnx models
            must be in a directory all by themsleves for the OnnxTransform to work, this method appends a AlexNetOnnx/AlexNetPrepOnnx subdirectory
            to the passed in directory to prevent having to make that directory manually each time.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.AlexNetExtension" Member="M:Microsoft.ML.Transforms.AlexNetExtension.AlexNet(Microsoft.ML.Transforms.DnnImageModelSelector,Microsoft.ML.IHostEnvironment,System.String,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Transforms.DnnImageModelSelector" />
      </Targets>
      <Member MemberName="ResNet101">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; ResNet101 (this Microsoft.ML.Transforms.DnnImageModelSelector dnnModelContext, Microsoft.ML.IHostEnvironment env, string inputColumn, string outputColumn);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.EstimatorChain`1&lt;class Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; ResNet101(class Microsoft.ML.Transforms.DnnImageModelSelector dnnModelContext, class Microsoft.ML.IHostEnvironment env, string inputColumn, string outputColumn) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.ResNet101Extension.ResNet101(Microsoft.ML.Transforms.DnnImageModelSelector,Microsoft.ML.IHostEnvironment,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ResNet101 (dnnModelContext As DnnImageModelSelector, env As IHostEnvironment, inputColumn As String, outputColumn As String) As EstimatorChain(Of ColumnCopyingTransformer)" />
        <MemberSignature Language="F#" Value="static member ResNet101 : Microsoft.ML.Transforms.DnnImageModelSelector * Microsoft.ML.IHostEnvironment * string * string -&gt; Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;" Usage="Microsoft.ML.Transforms.ResNet101Extension.ResNet101 (dnnModelContext, env, inputColumn, outputColumn)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="dnnModelContext" Type="Microsoft.ML.Transforms.DnnImageModelSelector" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="dnnModelContext">To be added.</param>
          <param name="env">To be added.</param>
          <param name="inputColumn">To be added.</param>
          <param name="outputColumn">To be added.</param>
          <summary>
            Returns an estimator chain with the two corresponding models (a preprocessing one and a main one) required for the ResNet pipeline.
            Also includes the renaming ColumnsCopyingTransforms required to be able to use arbitrary input and output column names.
            This assumes both of the models are in the same location as the file containing this method, which they will be if used through the NuGet.
            This should be the default way to use ResNet101 if importing the model from a NuGet.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.ResNet101Extension" Member="M:Microsoft.ML.Transforms.ResNet101Extension.ResNet101(Microsoft.ML.Transforms.DnnImageModelSelector,Microsoft.ML.IHostEnvironment,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Transforms.DnnImageModelSelector" />
      </Targets>
      <Member MemberName="ResNet101">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; ResNet101 (this Microsoft.ML.Transforms.DnnImageModelSelector dnnModelContext, Microsoft.ML.IHostEnvironment env, string inputColumn, string outputColumn, string modelDir);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.EstimatorChain`1&lt;class Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; ResNet101(class Microsoft.ML.Transforms.DnnImageModelSelector dnnModelContext, class Microsoft.ML.IHostEnvironment env, string inputColumn, string outputColumn, string modelDir) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.ResNet101Extension.ResNet101(Microsoft.ML.Transforms.DnnImageModelSelector,Microsoft.ML.IHostEnvironment,System.String,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ResNet101 (dnnModelContext As DnnImageModelSelector, env As IHostEnvironment, inputColumn As String, outputColumn As String, modelDir As String) As EstimatorChain(Of ColumnCopyingTransformer)" />
        <MemberSignature Language="F#" Value="static member ResNet101 : Microsoft.ML.Transforms.DnnImageModelSelector * Microsoft.ML.IHostEnvironment * string * string * string -&gt; Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;" Usage="Microsoft.ML.Transforms.ResNet101Extension.ResNet101 (dnnModelContext, env, inputColumn, outputColumn, modelDir)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="dnnModelContext" Type="Microsoft.ML.Transforms.DnnImageModelSelector" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="modelDir" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="dnnModelContext">To be added.</param>
          <param name="env">To be added.</param>
          <param name="inputColumn">To be added.</param>
          <param name="outputColumn">To be added.</param>
          <param name="modelDir">To be added.</param>
          <summary>
            This allows a custom model location to be specified. This is useful is a custom model is specified,
            or if the model is desired to be placed or shipped separately in a different folder from the main application. Note that because Onnx models
            must be in a directory all by themsleves for the OnnxTransform to work, this method appends a ResNet101Onnx/ResNetPrepOnnx subdirectory
            to the passed in directory to prevent having to make that directory manually each time.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.ResNet101Extension" Member="M:Microsoft.ML.Transforms.ResNet101Extension.ResNet101(Microsoft.ML.Transforms.DnnImageModelSelector,Microsoft.ML.IHostEnvironment,System.String,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Transforms.DnnImageModelSelector" />
      </Targets>
      <Member MemberName="ResNet18">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; ResNet18 (this Microsoft.ML.Transforms.DnnImageModelSelector dnnModelContext, Microsoft.ML.IHostEnvironment env, string inputColumn, string outputColumn);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.EstimatorChain`1&lt;class Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; ResNet18(class Microsoft.ML.Transforms.DnnImageModelSelector dnnModelContext, class Microsoft.ML.IHostEnvironment env, string inputColumn, string outputColumn) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.ResNet18Extension.ResNet18(Microsoft.ML.Transforms.DnnImageModelSelector,Microsoft.ML.IHostEnvironment,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ResNet18 (dnnModelContext As DnnImageModelSelector, env As IHostEnvironment, inputColumn As String, outputColumn As String) As EstimatorChain(Of ColumnCopyingTransformer)" />
        <MemberSignature Language="F#" Value="static member ResNet18 : Microsoft.ML.Transforms.DnnImageModelSelector * Microsoft.ML.IHostEnvironment * string * string -&gt; Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;" Usage="Microsoft.ML.Transforms.ResNet18Extension.ResNet18 (dnnModelContext, env, inputColumn, outputColumn)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="dnnModelContext" Type="Microsoft.ML.Transforms.DnnImageModelSelector" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="dnnModelContext">To be added.</param>
          <param name="env">To be added.</param>
          <param name="inputColumn">To be added.</param>
          <param name="outputColumn">To be added.</param>
          <summary>
            Returns an estimator chain with the two corresponding models (a preprocessing one and a main one) required for the ResNet pipeline.
            Also includes the renaming ColumnsCopyingTransforms required to be able to use arbitrary input and output column names.
            This assumes both of the models are in the same location as the file containing this method, which they will be if used through the NuGet.
            This should be the default way to use ResNet18 if importing the model from a NuGet.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.ResNet18Extension" Member="M:Microsoft.ML.Transforms.ResNet18Extension.ResNet18(Microsoft.ML.Transforms.DnnImageModelSelector,Microsoft.ML.IHostEnvironment,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Transforms.DnnImageModelSelector" />
      </Targets>
      <Member MemberName="ResNet18">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; ResNet18 (this Microsoft.ML.Transforms.DnnImageModelSelector dnnModelContext, Microsoft.ML.IHostEnvironment env, string inputColumn, string outputColumn, string modelDir);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.EstimatorChain`1&lt;class Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; ResNet18(class Microsoft.ML.Transforms.DnnImageModelSelector dnnModelContext, class Microsoft.ML.IHostEnvironment env, string inputColumn, string outputColumn, string modelDir) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.ResNet18Extension.ResNet18(Microsoft.ML.Transforms.DnnImageModelSelector,Microsoft.ML.IHostEnvironment,System.String,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ResNet18 (dnnModelContext As DnnImageModelSelector, env As IHostEnvironment, inputColumn As String, outputColumn As String, modelDir As String) As EstimatorChain(Of ColumnCopyingTransformer)" />
        <MemberSignature Language="F#" Value="static member ResNet18 : Microsoft.ML.Transforms.DnnImageModelSelector * Microsoft.ML.IHostEnvironment * string * string * string -&gt; Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;" Usage="Microsoft.ML.Transforms.ResNet18Extension.ResNet18 (dnnModelContext, env, inputColumn, outputColumn, modelDir)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="dnnModelContext" Type="Microsoft.ML.Transforms.DnnImageModelSelector" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="modelDir" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="dnnModelContext">To be added.</param>
          <param name="env">To be added.</param>
          <param name="inputColumn">To be added.</param>
          <param name="outputColumn">To be added.</param>
          <param name="modelDir">To be added.</param>
          <summary>
            This allows a custom model location to be specified. This is useful is a custom model is specified,
            or if the model is desired to be placed or shipped separately in a different folder from the main application. Note that because Onnx models
            must be in a directory all by themsleves for the OnnxTransform to work, this method appends a ResNet18Onnx/ResNetPrepOnnx subdirectory
            to the passed in directory to prevent having to make that directory manually each time.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.ResNet18Extension" Member="M:Microsoft.ML.Transforms.ResNet18Extension.ResNet18(Microsoft.ML.Transforms.DnnImageModelSelector,Microsoft.ML.IHostEnvironment,System.String,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Transforms.DnnImageModelSelector" />
      </Targets>
      <Member MemberName="ResNet50">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; ResNet50 (this Microsoft.ML.Transforms.DnnImageModelSelector dnnModelContext, Microsoft.ML.IHostEnvironment env, string inputColumn, string outputColumn);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.EstimatorChain`1&lt;class Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; ResNet50(class Microsoft.ML.Transforms.DnnImageModelSelector dnnModelContext, class Microsoft.ML.IHostEnvironment env, string inputColumn, string outputColumn) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.ResNet50Extension.ResNet50(Microsoft.ML.Transforms.DnnImageModelSelector,Microsoft.ML.IHostEnvironment,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ResNet50 (dnnModelContext As DnnImageModelSelector, env As IHostEnvironment, inputColumn As String, outputColumn As String) As EstimatorChain(Of ColumnCopyingTransformer)" />
        <MemberSignature Language="F#" Value="static member ResNet50 : Microsoft.ML.Transforms.DnnImageModelSelector * Microsoft.ML.IHostEnvironment * string * string -&gt; Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;" Usage="Microsoft.ML.Transforms.ResNet50Extension.ResNet50 (dnnModelContext, env, inputColumn, outputColumn)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="dnnModelContext" Type="Microsoft.ML.Transforms.DnnImageModelSelector" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="dnnModelContext">To be added.</param>
          <param name="env">To be added.</param>
          <param name="inputColumn">To be added.</param>
          <param name="outputColumn">To be added.</param>
          <summary>
            Returns an estimator chain with the two corresponding models (a preprocessing one and a main one) required for the ResNet pipeline.
            Also includes the renaming ColumnsCopyingTransforms required to be able to use arbitrary input and output column names.
            This assumes both of the models are in the same location as the file containing this method, which they will be if used through the NuGet.
            This should be the default way to use ResNet50 if importing the model from a NuGet.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.ResNet50Extension" Member="M:Microsoft.ML.Transforms.ResNet50Extension.ResNet50(Microsoft.ML.Transforms.DnnImageModelSelector,Microsoft.ML.IHostEnvironment,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Transforms.DnnImageModelSelector" />
      </Targets>
      <Member MemberName="ResNet50">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; ResNet50 (this Microsoft.ML.Transforms.DnnImageModelSelector dnnModelContext, Microsoft.ML.IHostEnvironment env, string inputColumn, string outputColumn, string modelDir);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Data.EstimatorChain`1&lt;class Microsoft.ML.Transforms.ColumnCopyingTransformer&gt; ResNet50(class Microsoft.ML.Transforms.DnnImageModelSelector dnnModelContext, class Microsoft.ML.IHostEnvironment env, string inputColumn, string outputColumn, string modelDir) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.ResNet50Extension.ResNet50(Microsoft.ML.Transforms.DnnImageModelSelector,Microsoft.ML.IHostEnvironment,System.String,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ResNet50 (dnnModelContext As DnnImageModelSelector, env As IHostEnvironment, inputColumn As String, outputColumn As String, modelDir As String) As EstimatorChain(Of ColumnCopyingTransformer)" />
        <MemberSignature Language="F#" Value="static member ResNet50 : Microsoft.ML.Transforms.DnnImageModelSelector * Microsoft.ML.IHostEnvironment * string * string * string -&gt; Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;" Usage="Microsoft.ML.Transforms.ResNet50Extension.ResNet50 (dnnModelContext, env, inputColumn, outputColumn, modelDir)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Data.EstimatorChain&lt;Microsoft.ML.Transforms.ColumnCopyingTransformer&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="dnnModelContext" Type="Microsoft.ML.Transforms.DnnImageModelSelector" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.IHostEnvironment" />
          <Parameter Name="inputColumn" Type="System.String" />
          <Parameter Name="outputColumn" Type="System.String" />
          <Parameter Name="modelDir" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="dnnModelContext">To be added.</param>
          <param name="env">To be added.</param>
          <param name="inputColumn">To be added.</param>
          <param name="outputColumn">To be added.</param>
          <param name="modelDir">To be added.</param>
          <summary>
            This allows a custom model location to be specified. This is useful is a custom model is specified,
            or if the model is desired to be placed or shipped separately in a different folder from the main application. Note that because Onnx models
            must be in a directory all by themsleves for the OnnxTransform to work, this method appends a ResNet50Onnx/ResNetPrepOnnx subdirectory
            to the passed in directory to prevent having to make that directory manually each time.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.ResNet50Extension" Member="M:Microsoft.ML.Transforms.ResNet50Extension.ResNet50(Microsoft.ML.Transforms.DnnImageModelSelector,Microsoft.ML.IHostEnvironment,System.String,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="FastForest">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.FastForestClassification FastForest (this Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers ctx, string labelColumn = &quot;Label&quot;, string featureColumn = &quot;Features&quot;, string weights = null, int numLeaves = 20, int numTrees = 100, int minDatapointsInLeaves = 10, double learningRate = 0.2, Action&lt;Microsoft.ML.Trainers.FastTree.FastForestClassification.Arguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FastTree.FastForestClassification FastForest(class Microsoft.ML.BinaryClassificationContext/BinaryClassificationTrainers ctx, string labelColumn, string featureColumn, string weights, int32 numLeaves, int32 numTrees, int32 minDatapointsInLeaves, float64 learningRate, class System.Action`1&lt;class Microsoft.ML.Trainers.FastTree.FastForestClassification/Arguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TreeExtensions.FastForest(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Trainers.FastTree.FastForestClassification.Arguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FastForest (ctx As BinaryClassificationContext.BinaryClassificationTrainers, Optional labelColumn As String = &quot;Label&quot;, Optional featureColumn As String = &quot;Features&quot;, Optional weights As String = null, Optional numLeaves As Integer = 20, Optional numTrees As Integer = 100, Optional minDatapointsInLeaves As Integer = 10, Optional learningRate As Double = 0.2, Optional advancedSettings As Action(Of FastForestClassification.Arguments) = null) As FastForestClassification" />
        <MemberSignature Language="F#" Value="static member FastForest : Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers * string * string * string * int * int * int * double * Action&lt;Microsoft.ML.Trainers.FastTree.FastForestClassification.Arguments&gt; -&gt; Microsoft.ML.Trainers.FastTree.FastForestClassification" Usage="Microsoft.ML.TreeExtensions.FastForest (ctx, labelColumn, featureColumn, weights, numLeaves, numTrees, minDatapointsInLeaves, learningRate, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.FastForestClassification</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumn" Type="System.String" />
          <Parameter Name="featureColumn" Type="System.String" />
          <Parameter Name="weights" Type="System.String" />
          <Parameter Name="numLeaves" Type="System.Int32" />
          <Parameter Name="numTrees" Type="System.Int32" />
          <Parameter Name="minDatapointsInLeaves" Type="System.Int32" />
          <Parameter Name="learningRate" Type="System.Double" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.FastTree.FastForestClassification+Arguments&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The <see cref="T:Microsoft.ML.BinaryClassificationContext" />.</param>
          <param name="labelColumn">The labelColumn column.</param>
          <param name="featureColumn">The featureColumn column.</param>
          <param name="weights">The optional weights column.</param>
          <param name="numLeaves">The maximum number of leaves per decision tree.</param>
          <param name="numTrees">Total number of decision trees to create in the ensemble.</param>
          <param name="minDatapointsInLeaves">The minimal number of datapoints allowed in a leaf of the tree, out of the subsampled data.</param>
          <param name="learningRate">The learning rate.</param>
          <param name="advancedSettings">Algorithm advanced settings.</param>
          <summary>
            Predict a target using a decision tree regression model trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.FastForestClassification" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TreeExtensions" Member="M:Microsoft.ML.TreeExtensions.FastForest(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Trainers.FastTree.FastForestClassification.Arguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionContext.RegressionTrainers" />
      </Targets>
      <Member MemberName="FastForest">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.FastForestRegression FastForest (this Microsoft.ML.RegressionContext.RegressionTrainers ctx, string labelColumn = &quot;Label&quot;, string featureColumn = &quot;Features&quot;, string weights = null, int numLeaves = 20, int numTrees = 100, int minDatapointsInLeaves = 10, double learningRate = 0.2, Action&lt;Microsoft.ML.Trainers.FastTree.FastForestRegression.Arguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FastTree.FastForestRegression FastForest(class Microsoft.ML.RegressionContext/RegressionTrainers ctx, string labelColumn, string featureColumn, string weights, int32 numLeaves, int32 numTrees, int32 minDatapointsInLeaves, float64 learningRate, class System.Action`1&lt;class Microsoft.ML.Trainers.FastTree.FastForestRegression/Arguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TreeExtensions.FastForest(Microsoft.ML.RegressionContext.RegressionTrainers,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Trainers.FastTree.FastForestRegression.Arguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FastForest (ctx As RegressionContext.RegressionTrainers, Optional labelColumn As String = &quot;Label&quot;, Optional featureColumn As String = &quot;Features&quot;, Optional weights As String = null, Optional numLeaves As Integer = 20, Optional numTrees As Integer = 100, Optional minDatapointsInLeaves As Integer = 10, Optional learningRate As Double = 0.2, Optional advancedSettings As Action(Of FastForestRegression.Arguments) = null) As FastForestRegression" />
        <MemberSignature Language="F#" Value="static member FastForest : Microsoft.ML.RegressionContext.RegressionTrainers * string * string * string * int * int * int * double * Action&lt;Microsoft.ML.Trainers.FastTree.FastForestRegression.Arguments&gt; -&gt; Microsoft.ML.Trainers.FastTree.FastForestRegression" Usage="Microsoft.ML.TreeExtensions.FastForest (ctx, labelColumn, featureColumn, weights, numLeaves, numTrees, minDatapointsInLeaves, learningRate, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.FastForestRegression</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RegressionContext+RegressionTrainers" RefType="this" />
          <Parameter Name="labelColumn" Type="System.String" />
          <Parameter Name="featureColumn" Type="System.String" />
          <Parameter Name="weights" Type="System.String" />
          <Parameter Name="numLeaves" Type="System.Int32" />
          <Parameter Name="numTrees" Type="System.Int32" />
          <Parameter Name="minDatapointsInLeaves" Type="System.Int32" />
          <Parameter Name="learningRate" Type="System.Double" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.FastTree.FastForestRegression+Arguments&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The <see cref="T:Microsoft.ML.RegressionContext" />.</param>
          <param name="labelColumn">The labelColumn column.</param>
          <param name="featureColumn">The featureColumn column.</param>
          <param name="weights">The optional weights column.</param>
          <param name="numLeaves">The maximum number of leaves per decision tree.</param>
          <param name="numTrees">Total number of decision trees to create in the ensemble.</param>
          <param name="minDatapointsInLeaves">The minimal number of datapoints allowed in a leaf of the tree, out of the subsampled data.</param>
          <param name="learningRate">The learning rate.</param>
          <param name="advancedSettings">Algorithm advanced settings.</param>
          <summary>
            Predict a target using a decision tree regression model trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.FastForestRegression" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TreeExtensions" Member="M:Microsoft.ML.TreeExtensions.FastForest(Microsoft.ML.RegressionContext.RegressionTrainers,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Trainers.FastTree.FastForestRegression.Arguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="FastTree">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.FastTreeBinaryClassificationTrainer FastTree (this Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers ctx, string labelColumn = &quot;Label&quot;, string featureColumn = &quot;Features&quot;, string weights = null, int numLeaves = 20, int numTrees = 100, int minDatapointsInLeaves = 10, double learningRate = 0.2, Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeBinaryClassificationTrainer.Arguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FastTree.FastTreeBinaryClassificationTrainer FastTree(class Microsoft.ML.BinaryClassificationContext/BinaryClassificationTrainers ctx, string labelColumn, string featureColumn, string weights, int32 numLeaves, int32 numTrees, int32 minDatapointsInLeaves, float64 learningRate, class System.Action`1&lt;class Microsoft.ML.Trainers.FastTree.FastTreeBinaryClassificationTrainer/Arguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TreeExtensions.FastTree(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Trainers.FastTree.FastTreeBinaryClassificationTrainer.Arguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FastTree (ctx As BinaryClassificationContext.BinaryClassificationTrainers, Optional labelColumn As String = &quot;Label&quot;, Optional featureColumn As String = &quot;Features&quot;, Optional weights As String = null, Optional numLeaves As Integer = 20, Optional numTrees As Integer = 100, Optional minDatapointsInLeaves As Integer = 10, Optional learningRate As Double = 0.2, Optional advancedSettings As Action(Of FastTreeBinaryClassificationTrainer.Arguments) = null) As FastTreeBinaryClassificationTrainer" />
        <MemberSignature Language="F#" Value="static member FastTree : Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers * string * string * string * int * int * int * double * Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeBinaryClassificationTrainer.Arguments&gt; -&gt; Microsoft.ML.Trainers.FastTree.FastTreeBinaryClassificationTrainer" Usage="Microsoft.ML.TreeExtensions.FastTree (ctx, labelColumn, featureColumn, weights, numLeaves, numTrees, minDatapointsInLeaves, learningRate, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.FastTreeBinaryClassificationTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext+BinaryClassificationTrainers" RefType="this" Index="0" />
          <Parameter Name="labelColumn" Type="System.String" Index="1" FrameworkAlternate="ml-dotnet" />
          <Parameter Name="featureColumn" Type="System.String" Index="2" FrameworkAlternate="ml-dotnet" />
          <Parameter Name="weights" Type="System.String" Index="3" />
          <Parameter Name="numLeaves" Type="System.Int32" Index="4" />
          <Parameter Name="numTrees" Type="System.Int32" Index="5" />
          <Parameter Name="minDatapointsInLeaves" Type="System.Int32" Index="6" FrameworkAlternate="ml-dotnet" />
          <Parameter Name="learningRate" Type="System.Double" Index="7" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeBinaryClassificationTrainer+Arguments&gt;" Index="8" />
        </Parameters>
        <Docs>
          <param name="ctx">The <see cref="T:Microsoft.ML.BinaryClassificationContext" />.</param>
          <param name="labelColumn">The labelColumn column.</param>
          <param name="featureColumn">The featureColumn column.</param>
          <param name="weights">The optional weights column.</param>
          <param name="numLeaves">The maximum number of leaves per decision tree.</param>
          <param name="numTrees">Total number of decision trees to create in the ensemble.</param>
          <param name="minDatapointsInLeaves">The minimal number of datapoints allowed in a leaf of the tree, out of the subsampled data.</param>
          <param name="learningRate">The learning rate.</param>
          <param name="advancedSettings">Algorithm advanced settings.</param>
          <summary>
            Predict a target using a decision tree binary classification model trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.FastTreeBinaryClassificationTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TreeExtensions" Member="M:Microsoft.ML.TreeExtensions.FastTree(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Trainers.FastTree.FastTreeBinaryClassificationTrainer.Arguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RankingContext.RankingTrainers" />
      </Targets>
      <Member MemberName="FastTree">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer FastTree (this Microsoft.ML.RankingContext.RankingTrainers ctx, string labelColumn = &quot;Label&quot;, string featureColumn = &quot;Features&quot;, string groupId = &quot;GroupId&quot;, string weights = null, int numLeaves = 20, int numTrees = 100, int minDatapointsInLeaves = 10, double learningRate = 0.2, Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer.Arguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer FastTree(class Microsoft.ML.RankingContext/RankingTrainers ctx, string labelColumn, string featureColumn, string groupId, string weights, int32 numLeaves, int32 numTrees, int32 minDatapointsInLeaves, float64 learningRate, class System.Action`1&lt;class Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer/Arguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TreeExtensions.FastTree(Microsoft.ML.RankingContext.RankingTrainers,System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer.Arguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FastTree (ctx As RankingContext.RankingTrainers, Optional labelColumn As String = &quot;Label&quot;, Optional featureColumn As String = &quot;Features&quot;, Optional groupId As String = &quot;GroupId&quot;, Optional weights As String = null, Optional numLeaves As Integer = 20, Optional numTrees As Integer = 100, Optional minDatapointsInLeaves As Integer = 10, Optional learningRate As Double = 0.2, Optional advancedSettings As Action(Of FastTreeRankingTrainer.Arguments) = null) As FastTreeRankingTrainer" />
        <MemberSignature Language="F#" Value="static member FastTree : Microsoft.ML.RankingContext.RankingTrainers * string * string * string * string * int * int * int * double * Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer.Arguments&gt; -&gt; Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer" Usage="Microsoft.ML.TreeExtensions.FastTree (ctx, labelColumn, featureColumn, groupId, weights, numLeaves, numTrees, minDatapointsInLeaves, learningRate, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RankingContext+RankingTrainers" RefType="this" Index="0" />
          <Parameter Name="labelColumn" Type="System.String" Index="1" FrameworkAlternate="ml-dotnet" />
          <Parameter Name="groupId" Type="System.String" Index="3" FrameworkAlternate="ml-dotnet" />
          <Parameter Name="featureColumn" Type="System.String" Index="2" FrameworkAlternate="ml-dotnet" />
          <Parameter Name="features" Type="System.String" Index="3" />
          <Parameter Name="weights" Type="System.String" Index="4" />
          <Parameter Name="numLeaves" Type="System.Int32" Index="5" />
          <Parameter Name="numTrees" Type="System.Int32" Index="6" />
          <Parameter Name="minDatapointsInLeaves" Type="System.Int32" Index="7" FrameworkAlternate="ml-dotnet" />
          <Parameter Name="learningRate" Type="System.Double" Index="8" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer+Arguments&gt;" Index="9" />
        </Parameters>
        <Docs>
          <param name="ctx">The <see cref="T:Microsoft.ML.RankingContext" />.</param>
          <param name="labelColumn">The labelColumn column.</param>
          <param name="groupId">The groupId column.</param>
          <param name="featureColumn">The featureColumn column.</param>
          <param name="features">The features column.</param>
          <param name="weights">The optional weights column.</param>
          <param name="numLeaves">The maximum number of leaves per decision tree.</param>
          <param name="numTrees">Total number of decision trees to create in the ensemble.</param>
          <param name="minDatapointsInLeaves">The minimal number of datapoints allowed in a leaf of the tree, out of the subsampled data.</param>
          <param name="learningRate">The learning rate.</param>
          <param name="advancedSettings">Algorithm advanced settings.</param>
          <summary>
            Ranks a series of inputs based on their relevance, training a decision tree ranking model through the <see cref="T:Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TreeExtensions" Member="M:Microsoft.ML.TreeExtensions.FastTree(Microsoft.ML.RankingContext.RankingTrainers,System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Trainers.FastTree.FastTreeRankingTrainer.Arguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionContext.RegressionTrainers" />
      </Targets>
      <Member MemberName="FastTree">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer FastTree (this Microsoft.ML.RegressionContext.RegressionTrainers ctx, string labelColumn = &quot;Label&quot;, string featureColumn = &quot;Features&quot;, string weights = null, int numLeaves = 20, int numTrees = 100, int minDatapointsInLeaves = 10, double learningRate = 0.2, Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer.Arguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer FastTree(class Microsoft.ML.RegressionContext/RegressionTrainers ctx, string labelColumn, string featureColumn, string weights, int32 numLeaves, int32 numTrees, int32 minDatapointsInLeaves, float64 learningRate, class System.Action`1&lt;class Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer/Arguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TreeExtensions.FastTree(Microsoft.ML.RegressionContext.RegressionTrainers,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer.Arguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FastTree (ctx As RegressionContext.RegressionTrainers, Optional labelColumn As String = &quot;Label&quot;, Optional featureColumn As String = &quot;Features&quot;, Optional weights As String = null, Optional numLeaves As Integer = 20, Optional numTrees As Integer = 100, Optional minDatapointsInLeaves As Integer = 10, Optional learningRate As Double = 0.2, Optional advancedSettings As Action(Of FastTreeRegressionTrainer.Arguments) = null) As FastTreeRegressionTrainer" />
        <MemberSignature Language="F#" Value="static member FastTree : Microsoft.ML.RegressionContext.RegressionTrainers * string * string * string * int * int * int * double * Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer.Arguments&gt; -&gt; Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer" Usage="Microsoft.ML.TreeExtensions.FastTree (ctx, labelColumn, featureColumn, weights, numLeaves, numTrees, minDatapointsInLeaves, learningRate, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RegressionContext+RegressionTrainers" RefType="this" Index="0" />
          <Parameter Name="labelColumn" Type="System.String" Index="1" FrameworkAlternate="ml-dotnet" />
          <Parameter Name="featureColumn" Type="System.String" Index="2" FrameworkAlternate="ml-dotnet" />
          <Parameter Name="weights" Type="System.String" Index="3" />
          <Parameter Name="numLeaves" Type="System.Int32" Index="4" />
          <Parameter Name="numTrees" Type="System.Int32" Index="5" />
          <Parameter Name="minDatapointsInLeaves" Type="System.Int32" Index="6" FrameworkAlternate="ml-dotnet" />
          <Parameter Name="learningRate" Type="System.Double" Index="7" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer+Arguments&gt;" Index="8" />
        </Parameters>
        <Docs>
          <param name="ctx">The <see cref="T:Microsoft.ML.RegressionContext" />.</param>
          <param name="labelColumn">The label column.</param>
          <param name="featureColumn">The feature column.</param>
          <param name="weights">The optional weights column.</param>
          <param name="numLeaves">The maximum number of leaves per decision tree.</param>
          <param name="numTrees">Total number of decision trees to create in the ensemble.</param>
          <param name="minDatapointsInLeaves">The minimal number of datapoints allowed in a leaf of a regression tree, out of the subsampled data.</param>
          <param name="learningRate">The learning rate.</param>
          <param name="advancedSettings">Algorithm advanced settings.</param>
          <summary>
            Predict a target using a decision tree regression model trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TreeExtensions" Member="M:Microsoft.ML.TreeExtensions.FastTree(Microsoft.ML.RegressionContext.RegressionTrainers,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Trainers.FastTree.FastTreeRegressionTrainer.Arguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionContext.RegressionTrainers" />
      </Targets>
      <Member MemberName="FastTreeTweedie">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer FastTreeTweedie (this Microsoft.ML.RegressionContext.RegressionTrainers ctx, string labelColumn = &quot;Label&quot;, string featureColumn = &quot;Features&quot;, string weights = null, int numLeaves = 20, int numTrees = 100, int minDatapointsInLeaves = 10, double learningRate = 0.2, Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer.Arguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer FastTreeTweedie(class Microsoft.ML.RegressionContext/RegressionTrainers ctx, string labelColumn, string featureColumn, string weights, int32 numLeaves, int32 numTrees, int32 minDatapointsInLeaves, float64 learningRate, class System.Action`1&lt;class Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer/Arguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TreeExtensions.FastTreeTweedie(Microsoft.ML.RegressionContext.RegressionTrainers,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer.Arguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FastTreeTweedie (ctx As RegressionContext.RegressionTrainers, Optional labelColumn As String = &quot;Label&quot;, Optional featureColumn As String = &quot;Features&quot;, Optional weights As String = null, Optional numLeaves As Integer = 20, Optional numTrees As Integer = 100, Optional minDatapointsInLeaves As Integer = 10, Optional learningRate As Double = 0.2, Optional advancedSettings As Action(Of FastTreeTweedieTrainer.Arguments) = null) As FastTreeTweedieTrainer" />
        <MemberSignature Language="F#" Value="static member FastTreeTweedie : Microsoft.ML.RegressionContext.RegressionTrainers * string * string * string * int * int * int * double * Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer.Arguments&gt; -&gt; Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer" Usage="Microsoft.ML.TreeExtensions.FastTreeTweedie (ctx, labelColumn, featureColumn, weights, numLeaves, numTrees, minDatapointsInLeaves, learningRate, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RegressionContext+RegressionTrainers" RefType="this" Index="0" />
          <Parameter Name="labelColumn" Type="System.String" Index="1" FrameworkAlternate="ml-dotnet" />
          <Parameter Name="featureColumn" Type="System.String" Index="2" FrameworkAlternate="ml-dotnet" />
          <Parameter Name="weights" Type="System.String" Index="3" />
          <Parameter Name="numLeaves" Type="System.Int32" Index="4" />
          <Parameter Name="numTrees" Type="System.Int32" Index="5" />
          <Parameter Name="minDatapointsInLeaves" Type="System.Int32" Index="6" FrameworkAlternate="ml-dotnet" />
          <Parameter Name="learningRate" Type="System.Double" Index="7" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer+Arguments&gt;" Index="8" />
        </Parameters>
        <Docs>
          <param name="ctx">The <see cref="T:Microsoft.ML.RegressionContext" />.</param>
          <param name="labelColumn">The labelColumn column.</param>
          <param name="featureColumn">The featureColumn column.</param>
          <param name="weights">The optional weights column.</param>
          <param name="numLeaves">The maximum number of leaves per decision tree.</param>
          <param name="numTrees">Total number of decision trees to create in the ensemble.</param>
          <param name="minDatapointsInLeaves">The minimal number of datapoints allowed in a leaf of the tree, out of the subsampled data.</param>
          <param name="learningRate">The learning rate.</param>
          <param name="advancedSettings">Algorithm advanced settings.</param>
          <summary>
            Predict a target using a decision tree regression model trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TreeExtensions" Member="M:Microsoft.ML.TreeExtensions.FastTreeTweedie(Microsoft.ML.RegressionContext.RegressionTrainers,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Trainers.FastTree.FastTreeTweedieTrainer.Arguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="GeneralizedAdditiveModels">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.BinaryClassificationGamTrainer GeneralizedAdditiveModels (this Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers ctx, string labelColumn = &quot;Label&quot;, string featureColumn = &quot;Features&quot;, string weights = null, int numIterations = 9500, double learningRate = 0.002, int maxBins = 255, Action&lt;Microsoft.ML.Trainers.FastTree.BinaryClassificationGamTrainer.Arguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FastTree.BinaryClassificationGamTrainer GeneralizedAdditiveModels(class Microsoft.ML.BinaryClassificationContext/BinaryClassificationTrainers ctx, string labelColumn, string featureColumn, string weights, int32 numIterations, float64 learningRate, int32 maxBins, class System.Action`1&lt;class Microsoft.ML.Trainers.FastTree.BinaryClassificationGamTrainer/Arguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TreeExtensions.GeneralizedAdditiveModels(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,System.String,System.String,System.String,System.Int32,System.Double,System.Int32,System.Action{Microsoft.ML.Trainers.FastTree.BinaryClassificationGamTrainer.Arguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GeneralizedAdditiveModels (ctx As BinaryClassificationContext.BinaryClassificationTrainers, Optional labelColumn As String = &quot;Label&quot;, Optional featureColumn As String = &quot;Features&quot;, Optional weights As String = null, Optional numIterations As Integer = 9500, Optional learningRate As Double = 0.002, Optional maxBins As Integer = 255, Optional advancedSettings As Action(Of BinaryClassificationGamTrainer.Arguments) = null) As BinaryClassificationGamTrainer" />
        <MemberSignature Language="F#" Value="static member GeneralizedAdditiveModels : Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers * string * string * string * int * double * int * Action&lt;Microsoft.ML.Trainers.FastTree.BinaryClassificationGamTrainer.Arguments&gt; -&gt; Microsoft.ML.Trainers.FastTree.BinaryClassificationGamTrainer" Usage="Microsoft.ML.TreeExtensions.GeneralizedAdditiveModels (ctx, labelColumn, featureColumn, weights, numIterations, learningRate, maxBins, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.BinaryClassificationGamTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="labelColumn" Type="System.String" />
          <Parameter Name="featureColumn" Type="System.String" />
          <Parameter Name="weights" Type="System.String" />
          <Parameter Name="numIterations" Type="System.Int32" />
          <Parameter Name="learningRate" Type="System.Double" />
          <Parameter Name="maxBins" Type="System.Int32" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.FastTree.BinaryClassificationGamTrainer+Arguments&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The <see cref="T:Microsoft.ML.BinaryClassificationContext" />.</param>
          <param name="labelColumn">The labelColumn column.</param>
          <param name="featureColumn">The featureColumn column.</param>
          <param name="weights">The optional weights column.</param>
          <param name="numIterations">The number of iterations to use in learning the features.</param>
          <param name="learningRate">The learning rate. GAMs work best with a small learning rate.</param>
          <param name="maxBins">The maximum number of bins to use to approximate features.</param>
          <param name="advancedSettings">Algorithm advanced settings.</param>
          <summary>
            Predict a target using generalized additive models trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.BinaryClassificationGamTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TreeExtensions" Member="M:Microsoft.ML.TreeExtensions.GeneralizedAdditiveModels(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,System.String,System.String,System.String,System.Int32,System.Double,System.Int32,System.Action{Microsoft.ML.Trainers.FastTree.BinaryClassificationGamTrainer.Arguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionContext.RegressionTrainers" />
      </Targets>
      <Member MemberName="GeneralizedAdditiveModels">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Trainers.FastTree.RegressionGamTrainer GeneralizedAdditiveModels (this Microsoft.ML.RegressionContext.RegressionTrainers ctx, string labelColumn = &quot;Label&quot;, string featureColumn = &quot;Features&quot;, string weights = null, int numIterations = 9500, double learningRate = 0.002, int maxBins = 255, Action&lt;Microsoft.ML.Trainers.FastTree.RegressionGamTrainer.Arguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Trainers.FastTree.RegressionGamTrainer GeneralizedAdditiveModels(class Microsoft.ML.RegressionContext/RegressionTrainers ctx, string labelColumn, string featureColumn, string weights, int32 numIterations, float64 learningRate, int32 maxBins, class System.Action`1&lt;class Microsoft.ML.Trainers.FastTree.RegressionGamTrainer/Arguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TreeExtensions.GeneralizedAdditiveModels(Microsoft.ML.RegressionContext.RegressionTrainers,System.String,System.String,System.String,System.Int32,System.Double,System.Int32,System.Action{Microsoft.ML.Trainers.FastTree.RegressionGamTrainer.Arguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GeneralizedAdditiveModels (ctx As RegressionContext.RegressionTrainers, Optional labelColumn As String = &quot;Label&quot;, Optional featureColumn As String = &quot;Features&quot;, Optional weights As String = null, Optional numIterations As Integer = 9500, Optional learningRate As Double = 0.002, Optional maxBins As Integer = 255, Optional advancedSettings As Action(Of RegressionGamTrainer.Arguments) = null) As RegressionGamTrainer" />
        <MemberSignature Language="F#" Value="static member GeneralizedAdditiveModels : Microsoft.ML.RegressionContext.RegressionTrainers * string * string * string * int * double * int * Action&lt;Microsoft.ML.Trainers.FastTree.RegressionGamTrainer.Arguments&gt; -&gt; Microsoft.ML.Trainers.FastTree.RegressionGamTrainer" Usage="Microsoft.ML.TreeExtensions.GeneralizedAdditiveModels (ctx, labelColumn, featureColumn, weights, numIterations, learningRate, maxBins, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Trainers.FastTree.RegressionGamTrainer</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RegressionContext+RegressionTrainers" RefType="this" />
          <Parameter Name="labelColumn" Type="System.String" />
          <Parameter Name="featureColumn" Type="System.String" />
          <Parameter Name="weights" Type="System.String" />
          <Parameter Name="numIterations" Type="System.Int32" />
          <Parameter Name="learningRate" Type="System.Double" />
          <Parameter Name="maxBins" Type="System.Int32" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Trainers.FastTree.RegressionGamTrainer+Arguments&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The <see cref="T:Microsoft.ML.RegressionContext" />.</param>
          <param name="labelColumn">The labelColumn column.</param>
          <param name="featureColumn">The featureColumn column.</param>
          <param name="weights">The optional weights column.</param>
          <param name="numIterations">The number of iterations to use in learning the features.</param>
          <param name="learningRate">The learning rate. GAMs work best with a small learning rate.</param>
          <param name="maxBins">The maximum number of bins to use to approximate features.</param>
          <param name="advancedSettings">Algorithm advanced settings.</param>
          <summary>
            Predict a target using generalized additive models trained with the <see cref="T:Microsoft.ML.Trainers.FastTree.RegressionGamTrainer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TreeExtensions" Member="M:Microsoft.ML.TreeExtensions.GeneralizedAdditiveModels(Microsoft.ML.RegressionContext.RegressionTrainers,System.String,System.String,System.String,System.Int32,System.Double,System.Int32,System.Action{Microsoft.ML.Trainers.FastTree.RegressionGamTrainer.Arguments})" />
      </Member>
    </ExtensionMethod>
  </ExtensionMethods>
</Overview>
