<Overview>
  <Assemblies>
    <Assembly Name="Microsoft.ML.CpuMath" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyConfiguration("Release")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation.  All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.CpuMath")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.3.26703.12")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.3.26703.12 @BuiltBy: dlab14-DDVSOWINAGE101 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/41d59a194914674369f6a49684b768985cb4bd0f")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.StandardLearners, PublicKey=00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.InternalStreams" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyConfiguration("Release")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation.  All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.InternalStreams")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.3.26703.12")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.3.26703.12 @BuiltBy: dlab14-DDVSOWINAGE101 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/41d59a194914674369f6a49684b768985cb4bd0f")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.UniversalModelFormat" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyConfiguration("Release")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation.  All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.UniversalModelFormat")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.3.26703.12")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.3.26703.12 @BuiltBy: dlab14-DDVSOWINAGE101 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/41d59a194914674369f6a49684b768985cb4bd0f")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.EntryPoints.CodeGen.ModuleGenerator), typeof(Microsoft.ML.Runtime.EntryPoints.CodeGen.ModuleGenerator/Arguments), typeof(Microsoft.ML.Runtime.Tools.SignatureModuleGenerator), "Module generator", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.CrossValidationBinaryMacro), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "CrossValidationBinaryMacro", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.CrossValidationMacro), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "CrossValidationMacro", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.CVSplit), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "CVSplit", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.DataViewReference), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "DataViewReference", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.FeatureCombiner), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "FeatureCombiner", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.ImportTextData), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "ImportTextData", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.EntryPoints.JsonUtils.ExecuteGraphCommand), typeof(Microsoft.ML.Runtime.EntryPoints.JsonUtils.ExecuteGraphCommand/Arguments), typeof(Microsoft.ML.Runtime.Command.SignatureCommand), "", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.ModelOperations), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "ModelOperations", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.OneVersusAllMacro), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "OneVersusAllMacro", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.TrainTestBinaryMacro), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "TrainTestBinaryMacro", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.TrainTestMacro), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "TrainTestMacro", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.TrainTestSplit), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "TrainTestSplit", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Internal.Tools.CSharpApiGenerator), typeof(Microsoft.ML.Runtime.Internal.Tools.CSharpApiGenerator/Arguments), typeof(Microsoft.ML.Runtime.Tools.SignatureModuleGenerator), "CSharp API generator", Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.5.26905.7")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.5.26905.7 @BuiltBy: dlab14-DDVSOWINAGE101 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/769a9c958f8267c904f9e85eabea535d7848051f+769a9c958f8267c904f9e85eabea535d7848051f")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.Api" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.Api")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.Api")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Api.GenerateCodeCommand), typeof(Microsoft.ML.Runtime.Api.GenerateCodeCommand/Arguments), typeof(Microsoft.ML.Runtime.Command.SignatureCommand), "Generate Sample Prediction Code", new System.String[] { "GenerateSamplePredictionCode", "codegen" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Allows the definition of convenient user defined transforms", typeof(Microsoft.ML.Runtime.Data.ITransformTemplate), typeof(Microsoft.ML.Runtime.Api.SerializableLambdaTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "", new System.String[] { "UserLambdaMapTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.6.27002.6")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.6.27002.6 @BuiltBy: dlab14-DDVSOWINAGE057 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/fbcac800001673d9d2b000a400e84f7a55c0c913+fbcac800001673d9d2b000a400e84f7a55c0c913")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.Core" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.Core")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TestFramework, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.Core")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.6.27002.6")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.6.27002.6 @BuiltBy: dlab14-DDVSOWINAGE057 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/fbcac800001673d9d2b000a400e84f7a55c0c913+fbcac800001673d9d2b000a400e84f7a55c0c913")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.Data" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.EntryPoints.SelectRows))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.EntryPoints.SummarizePredictor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.Internal.Calibration.FixedPlattCalibratorTrainer/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.Internal.Calibration.NaiveCalibratorTrainerFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.Internal.Calibration.PavCalibratorTrainerFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.Internal.Calibration.PlattCalibratorTrainerFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.Internal.Internallearn.TolerantEarlyStoppingCriterion))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.Internal.Internallearn.GLEarlyStoppingCriterion))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.Internal.Internallearn.LPEarlyStoppingCriterion))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.Internal.Internallearn.PQEarlyStoppingCriterion))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.Internal.Internallearn.UPEarlyStoppingCriterion))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.Data.TypeConversion))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.Data.RandomNumberGenerator))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.ExpLoss/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.LogLossFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.HingeLoss/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.PoissonLossFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.SmoothedHingeLoss/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.SquaredLossFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.TweedieLoss/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TestFramework, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.Data.SimplePartitionedPathParser/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.Data.ParquetPartitionedPathParserFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.CrossValidationCommand), typeof(Microsoft.ML.Runtime.Data.CrossValidationCommand/Arguments), typeof(Microsoft.ML.Runtime.Command.SignatureCommand), "Cross Validation", new System.String[] { "CV" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Runs a previously trained predictor on the data.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.EvaluateTransform), typeof(Microsoft.ML.Runtime.Data.EvaluateTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Evaluate Predictor", new System.String[] { "Evaluate" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Evaluates the metrics for a scored data file.", typeof(Microsoft.ML.Runtime.Data.EvaluateCommand), typeof(Microsoft.ML.Runtime.Data.EvaluateCommand/Arguments), typeof(Microsoft.ML.Runtime.Command.SignatureCommand), "Evaluate Predictor", new System.String[] { "Evaluate" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Given input data, a loader, and possibly transforms, save the data to a new file as parameterized by a saver.", typeof(Microsoft.ML.Runtime.Data.SaveDataCommand), typeof(Microsoft.ML.Runtime.Data.SaveDataCommand/Arguments), typeof(Microsoft.ML.Runtime.Command.SignatureCommand), "Save Data", new System.String[] { "SaveData", "save" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Given input data, a loader, and possibly transforms, display a sample of the data file.", typeof(Microsoft.ML.Runtime.Data.ShowDataCommand), typeof(Microsoft.ML.Runtime.Data.ShowDataCommand/Arguments), typeof(Microsoft.ML.Runtime.Command.SignatureCommand), "Show Data", new System.String[] { "ShowData", "show" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Given a TLC model file with a predictor, we can output this same predictor in multiple export formats.", typeof(Microsoft.ML.Runtime.Tools.SavePredictorCommand), typeof(Microsoft.ML.Runtime.Tools.SavePredictorCommand/Arguments), typeof(Microsoft.ML.Runtime.Command.SignatureCommand), "Save Predictor As", new System.String[] { "SavePredictorAs", "SavePredictor", "SaveAs", "SaveModel" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Scores a data file.", typeof(Microsoft.ML.Runtime.Data.ScoreCommand), typeof(Microsoft.ML.Runtime.Data.ScoreCommand/Arguments), typeof(Microsoft.ML.Runtime.Command.SignatureCommand), "Score Predictor", new System.String[] { "Score" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Given input data, a loader, and possibly transforms, display the schema.", typeof(Microsoft.ML.Runtime.Data.ShowSchemaCommand), typeof(Microsoft.ML.Runtime.Data.ShowSchemaCommand/Arguments), typeof(Microsoft.ML.Runtime.Command.SignatureCommand), "Show Schema", new System.String[] { "ShowSchema", "schema" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Scores and evaluates a data file.", typeof(Microsoft.ML.Runtime.Data.TestCommand), typeof(Microsoft.ML.Runtime.Data.TestCommand/Arguments), typeof(Microsoft.ML.Runtime.Command.SignatureCommand), "Test Predictor", new System.String[] { "Test" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Trains a predictor.", typeof(Microsoft.ML.Runtime.Data.TrainCommand), typeof(Microsoft.ML.Runtime.Data.TrainCommand/Arguments), typeof(Microsoft.ML.Runtime.Command.SignatureCommand), "Train Predictor", new System.String[] { "Train" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Trains a predictor using the train file and then scores and evaluates the predictor using the test file.", typeof(Microsoft.ML.Runtime.Data.TrainTestCommand), typeof(Microsoft.ML.Runtime.Data.TrainTestCommand/Arguments), typeof(Microsoft.ML.Runtime.Command.SignatureCommand), "Train Test", new System.String[] { "TrainTest" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Loads native Binary IDV data file.", typeof(Microsoft.ML.Runtime.Data.IO.BinaryLoader), typeof(Microsoft.ML.Runtime.Data.IO.BinaryLoader/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataLoader), "Binary Loader", new System.String[] { "BinaryLoader", "Binary", "Bin" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Loads native Binary IDV data file.", typeof(Microsoft.ML.Runtime.Data.IO.BinaryLoader), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataLoader), "Binary Data View Loader", new System.String[] { "BinaryLoader" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.IO.BinaryLoader/InfoCommand), typeof(Microsoft.ML.Runtime.Data.IO.BinaryLoader/InfoCommand/Arguments), typeof(Microsoft.ML.Runtime.Command.SignatureCommand), "", new System.String[] { "IdvInfo", "idv" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Writes data into a native binary IDV file.", typeof(Microsoft.ML.Runtime.Data.IO.BinarySaver), typeof(Microsoft.ML.Runtime.Data.IO.BinarySaver/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataSaver), "Binary Saver", new System.String[] { "BinarySaver", "Binary" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.IDataLoader), typeof(Microsoft.ML.Runtime.Data.CompositeDataLoader), typeof(Microsoft.ML.Runtime.Data.CompositeDataLoader/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataLoader), "Composite Data Loader", new System.String[] { "CompositeDataLoader", "Composite", "PipeData", "Pipe", "PipeDataLoader" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.IDataLoader), typeof(Microsoft.ML.Runtime.Data.CompositeDataLoader), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataLoader), "Pipe DataL Loader", new System.String[] { "PipeDataLoader" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Loads a horizontally partitioned file set.", typeof(Microsoft.ML.Runtime.Data.PartitionedFileLoader), typeof(Microsoft.ML.Runtime.Data.PartitionedFileLoader/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataLoader), "Partitioned Loader", new System.String[] { "PartitionedLoader", "Part" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Loads a horizontally partitioned file set.", typeof(Microsoft.ML.Runtime.Data.PartitionedFileLoader), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataLoader), "Partitioned Loader", new System.String[] { "PartitionedLoader", "Part" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("A simple parser that extracts directory names as column values. Column names are defined as arguments.", typeof(Microsoft.ML.Runtime.Data.SimplePartitionedPathParser), typeof(Microsoft.ML.Runtime.Data.SimplePartitionedPathParser/Arguments), typeof(Microsoft.ML.Runtime.Data.PartitionedPathParser), "Simple Partitioned Path Parser", new System.String[] { "SimplePathParser", "SmplPP" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Extract name/value pairs from Parquet formatted directory names. Example path: Year=2018/Month=12/data1.parquet", typeof(Microsoft.ML.Runtime.Data.ParquetPartitionedPathParser), null, typeof(Microsoft.ML.Runtime.Data.PartitionedPathParser), "Parquet Partitioned Path Parser", new System.String[] { "ParquetPathParser", "ParqPP" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("A simple parser that extracts directory names as column values. Column names are defined as arguments.", typeof(Microsoft.ML.Runtime.Data.SimplePartitionedPathParser), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Simple Partitioned Path Parser", new System.String[] { "SimplePathParser", "SmplPP" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Extract name/value pairs from Parquet formatted directory names. Example path: Year=2018/Month=12/data1.parquet", typeof(Microsoft.ML.Runtime.Data.ParquetPartitionedPathParser), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Parquet Partitioned Path Parser", new System.String[] { "ParquetPathParser", "ParqPP" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Loads text data file.", typeof(Microsoft.ML.Runtime.Data.IDataLoader), typeof(Microsoft.ML.Runtime.Data.TextLoader), typeof(Microsoft.ML.Runtime.Data.TextLoader/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataLoader), "Text Loader", new System.String[] { "TextLoader", "Text" }, DocName="loader/TextLoader.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Loads text data file.", typeof(Microsoft.ML.Runtime.Data.IDataLoader), typeof(Microsoft.ML.Runtime.Data.TextLoader), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataLoader), "Text Loader", new System.String[] { "TextLoader" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Writes data into a text file.", typeof(Microsoft.ML.Runtime.Data.IO.TextSaver), typeof(Microsoft.ML.Runtime.Data.IO.TextSaver/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataSaver), "Text Saver", new System.String[] { "TextSaver", "Text" }, DocName="saver/TextSaver.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.TransformerChain`1&lt;Microsoft.ML.Core.Data.ITransformer&gt;), typeof(Microsoft.ML.Runtime.Data.TransformerChain), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Transformer chain", new System.String[] { "TransformerChain" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.TransformWrapper), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Transform wrapper", new System.String[] { "TransformWrapper" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Loads a binary transposed data file.", typeof(Microsoft.ML.Runtime.Data.IO.TransposeLoader), typeof(Microsoft.ML.Runtime.Data.IO.TransposeLoader/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataLoader), "Transpose Loader", new System.String[] { "TransposeLoader", "Transpose", "trans" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Loads a binary transposed data file.", typeof(Microsoft.ML.Runtime.Data.IO.TransposeLoader), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataLoader), "Transpose Data View Loader", new System.String[] { "TransposeLoader" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Writes data into a transposed binary TDV file.", typeof(Microsoft.ML.Runtime.Data.IO.TransposeSaver), typeof(Microsoft.ML.Runtime.Data.IO.TransposeSaver/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataSaver), "Transpose Saver", new System.String[] { "TransposeSaver", "TransposedSaver", "Transpose", "Transposed", "trans" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.RowToRowMapperTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "", new System.String[] { "RowToRowMapper" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.ChooseColumnsByIndexTransform), typeof(Microsoft.ML.Runtime.Data.ChooseColumnsByIndexTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "", new System.String[] { "ChooseColumnsByIndexTransform", "ChooseColumnsByIndex" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.ChooseColumnsByIndexTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "", new System.String[] { "ChooseColumnsIdxTrans", "ChooseColumnsIdxFunc" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.Cache), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "Cache", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.SchemaManipulation), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "SchemaManipulation", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.ScoreModel), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "ScoreModel", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.AnomalyDetectionEvaluator), typeof(Microsoft.ML.Runtime.Data.AnomalyDetectionEvaluator), typeof(Microsoft.ML.Runtime.Data.AnomalyDetectionEvaluator/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureEvaluator), "Anomaly Detection Evaluator", new System.String[] { "AnomalyDetectionEvaluator", "AnomalyDetection", "Anomaly" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.AnomalyDetectionMamlEvaluator), typeof(Microsoft.ML.Runtime.Data.AnomalyDetectionMamlEvaluator), typeof(Microsoft.ML.Runtime.Data.AnomalyDetectionMamlEvaluator/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureMamlEvaluator), "Anomaly Detection Evaluator", new System.String[] { "AnomalyDetectionEvaluator", "AnomalyDetection", "Anomaly" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator), typeof(Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator), typeof(Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureEvaluator), "Binary Classifier Evaluator", new System.String[] { "BinaryClassifierEvaluator", "BinaryClassifier", "Binary", "bin" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.BinaryClassifierMamlEvaluator), typeof(Microsoft.ML.Runtime.Data.BinaryClassifierMamlEvaluator), typeof(Microsoft.ML.Runtime.Data.BinaryClassifierMamlEvaluator/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureMamlEvaluator), "Binary Classifier Evaluator", new System.String[] { "BinaryClassifierEvaluator", "BinaryClassifier", "Binary", "bin" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.BinaryPerInstanceEvaluator), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadRowMapper), "", new System.String[] { "BinaryPerInstance" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.Data.Evaluate), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "Evaluators", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.ClusteringEvaluator), typeof(Microsoft.ML.Runtime.Data.ClusteringEvaluator), typeof(Microsoft.ML.Runtime.Data.ClusteringEvaluator/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureEvaluator), "Clustering Evaluator", new System.String[] { "ClusteringEvaluator", "Clustering" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.ClusteringMamlEvaluator), typeof(Microsoft.ML.Runtime.Data.ClusteringMamlEvaluator), typeof(Microsoft.ML.Runtime.Data.ClusteringMamlEvaluator/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureMamlEvaluator), "Clustering Evaluator", new System.String[] { "ClusteringEvaluator", "Clustering" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.ClusteringPerInstanceEvaluator), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadRowMapper), "", new System.String[] { "ClusteringPerInstance" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.MultiClassClassifierEvaluator), typeof(Microsoft.ML.Runtime.Data.MultiClassClassifierEvaluator), typeof(Microsoft.ML.Runtime.Data.MultiClassClassifierEvaluator/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureEvaluator), "Multi-Class Classifier Evaluator", new System.String[] { "MultiClassClassifierEvaluator", "MultiClassClassifier", "MultiClass" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.MultiClassMamlEvaluator), typeof(Microsoft.ML.Runtime.Data.MultiClassMamlEvaluator), typeof(Microsoft.ML.Runtime.Data.MultiClassMamlEvaluator/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureMamlEvaluator), "Multi-Class Classifier Evaluator", new System.String[] { "MultiClassClassifierEvaluator", "MultiClassClassifier", "MultiClass" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.MultiClassPerInstanceEvaluator), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadRowMapper), "", new System.String[] { "MulticlassPerInstance" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.MultiOutputRegressionEvaluator), typeof(Microsoft.ML.Runtime.Data.MultiOutputRegressionEvaluator), typeof(Microsoft.ML.Runtime.Data.MultiOutputRegressionEvaluator/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureEvaluator), "Multi Output Regression Evaluator", new System.String[] { "MultiRegressionEvaluator", "MultiOutputRegression", "MRE" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.MultiOutputRegressionMamlEvaluator), typeof(Microsoft.ML.Runtime.Data.MultiOutputRegressionMamlEvaluator), typeof(Microsoft.ML.Runtime.Data.MultiOutputRegressionMamlEvaluator/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureMamlEvaluator), "Multi Output Regression Evaluator", new System.String[] { "MultiRegressionEvaluator", "MultiOutputRegression", "MRE" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.MultiOutputRegressionPerInstanceEvaluator), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadRowMapper), "", new System.String[] { "MultiRegPerInstance" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.QuantileRegressionEvaluator), typeof(Microsoft.ML.Runtime.Data.QuantileRegressionEvaluator), typeof(Microsoft.ML.Runtime.Data.QuantileRegressionEvaluator/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureEvaluator), "Quantile Regression Evaluator", new System.String[] { "QuantileRegressionEvaluator", "QuantileRegression" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.QuantileRegressionMamlEvaluator), typeof(Microsoft.ML.Runtime.Data.QuantileRegressionMamlEvaluator), typeof(Microsoft.ML.Runtime.Data.QuantileRegressionMamlEvaluator/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureMamlEvaluator), "Quantile Regression Evaluator", new System.String[] { "QuantileRegressionEvaluator", "QuantileRegression" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.QuantileRegressionPerInstanceEvaluator), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadRowMapper), "", new System.String[] { "QuantileRegPerInstance" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.RankerEvaluator), typeof(Microsoft.ML.Runtime.Data.RankerEvaluator), typeof(Microsoft.ML.Runtime.Data.RankerEvaluator/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureEvaluator), "Ranking Evaluator", new System.String[] { "RankingEvaluator", "Ranking", "rank" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.RankerMamlEvaluator), typeof(Microsoft.ML.Runtime.Data.RankerMamlEvaluator), typeof(Microsoft.ML.Runtime.Data.RankerMamlEvaluator/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureMamlEvaluator), "Ranking Evaluator", new System.String[] { "RankingEvaluator", "Ranking", "rank" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.RankerPerInstanceTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "", new System.String[] { "RankerPerInstTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.RegressionEvaluator), typeof(Microsoft.ML.Runtime.Data.RegressionEvaluator), typeof(Microsoft.ML.Runtime.Data.RegressionEvaluator/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureEvaluator), "Regression Evaluator", new System.String[] { "RegressionEvaluator", "Regression" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.RegressionMamlEvaluator), typeof(Microsoft.ML.Runtime.Data.RegressionMamlEvaluator), typeof(Microsoft.ML.Runtime.Data.RegressionMamlEvaluator/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureMamlEvaluator), "Regression Evaluator", new System.String[] { "RegressionEvaluator", "Regression" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.RegressionPerInstanceEvaluator), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadRowMapper), "", new System.String[] { "RegressionPerInstance" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Given a data model, write out the corresponding PFA.", typeof(Microsoft.ML.Runtime.Model.Pfa.SavePfaCommand), typeof(Microsoft.ML.Runtime.Model.Pfa.SavePfaCommand/Arguments), typeof(Microsoft.ML.Runtime.Command.SignatureCommand), "Save PFA", new System.String[] { "SavePfa" }, DocName="command/SavePfa.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("This model was introduced by Platt in the paper Probabilistic Outputs for Support Vector Machines and Comparisons to Regularized Likelihood Methods", typeof(Microsoft.ML.Runtime.Internal.Calibration.PlattCalibratorTrainer), null, typeof(Microsoft.ML.Runtime.Internal.Calibration.SignatureCalibrator), "Sigmoid Calibration", new System.String[] { "PlattCalibration", "SigmoidCalibration" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Sigmoid calibrator with configurable slope and offset.", typeof(Microsoft.ML.Runtime.Internal.Calibration.FixedPlattCalibratorTrainer), typeof(Microsoft.ML.Runtime.Internal.Calibration.FixedPlattCalibratorTrainer/Arguments), typeof(Microsoft.ML.Runtime.Internal.Calibration.SignatureCalibrator), "Fixed Sigmoid Calibration", new System.String[] { "FixedPlattCalibration", "FixedSigmoidCalibration" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Piecewise linear calibrator.", typeof(Microsoft.ML.Runtime.Internal.Calibration.PavCalibratorTrainer), null, typeof(Microsoft.ML.Runtime.Internal.Calibration.SignatureCalibrator), "PAV Calibration", new System.String[] { "PAVCalibration", "PAV" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Naive calibrator divides the range of the outputs into equally sized bins. In each bin, the probability of belonging to class 1 is the number of class 1 instances in the bin, divided by the total number of instances in the bin.", typeof(Microsoft.ML.Runtime.Internal.Calibration.NaiveCalibratorTrainer), null, typeof(Microsoft.ML.Runtime.Internal.Calibration.SignatureCalibrator), "Naive Calibrator", new System.String[] { "NaiveCalibrator", "Naive", "NaiveCalibration" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Internal.Calibration.PlattCalibrator), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Platt Calibration Executor", new System.String[] { "PlattCaliExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Internal.Calibration.PavCalibrator), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "PAV Calibration Executor", new System.String[] { "PAVCaliExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Internal.Calibration.NaiveCalibrator), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Naive Calibration Executor", new System.String[] { "NaiveCaliExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Internal.Calibration.CalibratedPredictor), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Calibrated Predictor Executor", new System.String[] { "CaliPredExec", "BulkCaliPredExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Internal.Calibration.FeatureWeightsCalibratedPredictor), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Feature Weights Calibrated Predictor Executor", new System.String[] { "FeatWCaliPredExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Internal.Calibration.ParameterMixingCalibratedPredictor), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Parameter Mixing Calibrated Predictor Executor", new System.String[] { "PMixCaliPredExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Internal.Calibration.SchemaBindableCalibratedPredictor), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Schema Bindable Calibrated Predictor", new System.String[] { "SchemaBindableCalibrated" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.Internal.Calibration.Calibrate), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "Calibrate", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.BinaryClassifierScorer), typeof(Microsoft.ML.Runtime.Data.BinaryClassifierScorer/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataScorer), "Binary Classifier Scorer", new System.String[] { "BinaryClassifierScorer", "BinaryClassifier", "Binary", "bin", "BinaryClassification" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.BinaryClassifierScorer), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Binary Classifier Scorer", new System.String[] { "BinClassScoreTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.ClusteringScorer), typeof(Microsoft.ML.Runtime.Data.ClusteringScorer/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataScorer), "Clustering Scorer", new System.String[] { "ClusteringScorer", "Clustering" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.ClusteringScorer), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Clustering Scorer", new System.String[] { "ClusteringScoreTrans" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.GenericScorer), typeof(Microsoft.ML.Runtime.Data.GenericScorer/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataScorer), "Generic Scorer", new System.String[] { "GenericScorer", "Generic" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.GenericScorer), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Generic Scorer", new System.String[] { "GenericScoreTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.MultiClassClassifierScorer), typeof(Microsoft.ML.Runtime.Data.MultiClassClassifierScorer/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataScorer), "Multi-Class Classifier Scorer", new System.String[] { "MultiClassClassifierScorer", "MultiClassClassifier", "MultiClass", "MultiClassClassification" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.MultiClassClassifierScorer), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Multi-Class Classifier Scorer", new System.String[] { "MultiClassScoreTrans" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.ISchemaBindableMapper), typeof(Microsoft.ML.Runtime.Data.MultiClassClassifierScorer/LabelNameBindableMapper), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Multi-Class Label-Name Mapper", new System.String[] { "LabelSlotNameMapper" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.BinaryPredictionTransformer`1&lt;Microsoft.ML.Runtime.IPredictorProducing`1&lt;System.Single&gt;&gt;), typeof(Microsoft.ML.Runtime.Data.BinaryPredictionTransformer), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "", new System.String[] { "BinaryPredXfer" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.MulticlassPredictionTransformer`1&lt;Microsoft.ML.Runtime.IPredictorProducing`1&lt;Microsoft.ML.Runtime.Data.VBuffer`1&lt;System.Single&gt;&gt;&gt;), typeof(Microsoft.ML.Runtime.Data.MulticlassPredictionTransformer), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "", new System.String[] { "MulticlassPredXfer" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.RegressionPredictionTransformer`1&lt;Microsoft.ML.Runtime.IPredictorProducing`1&lt;System.Single&gt;&gt;), typeof(Microsoft.ML.Runtime.Data.RegressionPredictionTransformer), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "", new System.String[] { "RegressionPredXfer" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.RankingPredictionTransformer`1&lt;Microsoft.ML.Runtime.IPredictorProducing`1&lt;System.Single&gt;&gt;), typeof(Microsoft.ML.Runtime.Data.RankingPredictionTransformer), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "", new System.String[] { "RankingPredXfer" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.AnomalyPredictionTransformer`1&lt;Microsoft.ML.Runtime.IPredictorProducing`1&lt;System.Single&gt;&gt;), typeof(Microsoft.ML.Runtime.Data.AnomalyPredictionTransformer), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "", new System.String[] { "AnomalyPredXfer" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.ClusteringPredictionTransformer`1&lt;Microsoft.ML.Runtime.IPredictorProducing`1&lt;Microsoft.ML.Runtime.Data.VBuffer`1&lt;System.Single&gt;&gt;&gt;), typeof(Microsoft.ML.Runtime.Data.ClusteringPredictionTransformer), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "", new System.String[] { "ClusteringPredXfer" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.IDataScorerTransform), typeof(Microsoft.ML.Runtime.Data.QuantileRegressionScorerTransform), typeof(Microsoft.ML.Runtime.Data.QuantileRegressionScorerTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataScorer), "Quantile Regression Scorer", new System.String[] { "QuantileRegressionScorer", "QuantileRegression" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.ISchemaBindableMapper), typeof(Microsoft.ML.Runtime.Data.QuantileRegressionScorerTransform), typeof(Microsoft.ML.Runtime.Data.QuantileRegressionScorerTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureBindableMapper), "Quantile Regression Mapper", new System.String[] { "QuantileRegressionScorer", "QuantileRegression" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.SchemaBindablePredictorWrapper), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Bindable Mapper", new System.String[] { "SchemaBindableWrapper" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.SchemaBindableQuantileRegressionPredictor), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Regression Bindable Mapper", new System.String[] { "QuantileSchemaBindable" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.SchemaBindableBinaryPredictorWrapper), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Binary Classification Bindable Mapper", new System.String[] { "BinarySchemaBindable" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Internal.Internallearn.TolerantEarlyStoppingCriterion), typeof(Microsoft.ML.Runtime.Internal.Internallearn.TolerantEarlyStoppingCriterion/Arguments), typeof(Microsoft.ML.Runtime.Internal.Internallearn.SignatureEarlyStoppingCriterion), "Tolerant (TR)", new System.String[] { "tr" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Internal.Internallearn.GLEarlyStoppingCriterion), typeof(Microsoft.ML.Runtime.Internal.Internallearn.GLEarlyStoppingCriterion/Arguments), typeof(Microsoft.ML.Runtime.Internal.Internallearn.SignatureEarlyStoppingCriterion), "Loss of Generality (GL)", new System.String[] { "gl" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Internal.Internallearn.LPEarlyStoppingCriterion), typeof(Microsoft.ML.Runtime.Internal.Internallearn.LPEarlyStoppingCriterion/Arguments), typeof(Microsoft.ML.Runtime.Internal.Internallearn.SignatureEarlyStoppingCriterion), "Low Progress (LP)", new System.String[] { "lp" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Internal.Internallearn.PQEarlyStoppingCriterion), typeof(Microsoft.ML.Runtime.Internal.Internallearn.PQEarlyStoppingCriterion/Arguments), typeof(Microsoft.ML.Runtime.Internal.Internallearn.SignatureEarlyStoppingCriterion), "Generality to Progress Ratio (PQ)", new System.String[] { "pq" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Internal.Internallearn.UPEarlyStoppingCriterion), typeof(Microsoft.ML.Runtime.Internal.Internallearn.UPEarlyStoppingCriterion/Arguments), typeof(Microsoft.ML.Runtime.Internal.Internallearn.SignatureEarlyStoppingCriterion), "Consecutive Loss in Generality (UP)", new System.String[] { "up" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.ChooseColumnsTransform), typeof(Microsoft.ML.Runtime.Data.ChooseColumnsTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Choose Columns Transform", new System.String[] { "ChooseColumnsTransform", "ChooseColumns", "Choose" }, DocName="transform/DropKeepChooseTransforms.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.ChooseColumnsTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Choose Columns Transform", new System.String[] { "ChooseColumnsTransform", "ChooseColumnsFunction" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Concatenates one or more columns of the same item type.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.ConcatTransform), typeof(Microsoft.ML.Runtime.Data.ConcatTransform/TaggedArguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Concat Transform", new System.String[] { "Concat", "ConcatTransform" }, DocName="transform/ConcatTransform.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Concatenates one or more columns of the same item type.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.ConcatTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Concat Transform", new System.String[] { "ConcatTransform", "ConcatFunction" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.ConcatTransform), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Concat Transform", new System.String[] { "ConcatTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.IRowMapper), typeof(Microsoft.ML.Runtime.Data.ConcatTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadRowMapper), "Concat Transform", new System.String[] { "ConcatTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Converts a column to a different type, using standard conversions.", typeof(Microsoft.ML.Runtime.Data.ConvertTransform), typeof(Microsoft.ML.Runtime.Data.ConvertTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Convert Transform", new System.String[] { "Convert", "ConvertTransform" }, DocName="transform/ConvertTransform.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Converts a column to a different type, using standard conversions.", typeof(Microsoft.ML.Runtime.Data.ConvertTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Convert Transform", new System.String[] { "ConvertTransform", "ConvertFunction" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.ConvertTransform/TypeInfoCommand), typeof(Microsoft.ML.Runtime.Data.ConvertTransform/TypeInfoCommand/Arguments), typeof(Microsoft.ML.Runtime.Command.SignatureCommand), "", new System.String[] { "TypeInfo" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Copy a source column to a new column.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.CopyColumnsTransform), typeof(Microsoft.ML.Runtime.Data.CopyColumnsTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Copy Columns Transform", new System.String[] { "CopyColumns", "CopyColumnsTransform", "Copy" }, DocName="transform/CopyColumnsTransformer.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Copy a source column to a new column.", typeof(Microsoft.ML.Runtime.Data.IDataView), typeof(Microsoft.ML.Runtime.Data.CopyColumnsTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Copy Columns Transform", new System.String[] { "CopyTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Copy a source column to a new column.", typeof(Microsoft.ML.Runtime.Data.CopyColumnsTransform), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Copy Columns Transform", new System.String[] { "CopyTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Copy a source column to a new column.", typeof(Microsoft.ML.Runtime.Data.CopyColumnsRowMapper), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadRowMapper), "Copy Columns Transform", new System.String[] { "CopyColumnsRowMapper" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Removes a column or columns from the dataset.", typeof(Microsoft.ML.Runtime.Data.DropColumnsTransform), typeof(Microsoft.ML.Runtime.Data.DropColumnsTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Drop Columns Transform", new System.String[] { "DropColumns", "DropColumnsTransform", "Drop" }, DocName="transform/DropKeepChooseTransforms.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Selects which columns from the dataset to keep.", typeof(Microsoft.ML.Runtime.Data.DropColumnsTransform), typeof(Microsoft.ML.Runtime.Data.DropColumnsTransform/KeepArguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Keep Columns Transform", new System.String[] { "KeepColumns", "KeepColumnsTransform", "Keep" }, DocName="transform/DropKeepChooseTransforms.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Removes a column or columns from the dataset.", typeof(Microsoft.ML.Runtime.Data.DropColumnsTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Drop Columns Transform", new System.String[] { "DropColumnsTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Removes the selected slots from the column.", typeof(Microsoft.ML.Runtime.Data.DropSlotsTransform), typeof(Microsoft.ML.Runtime.Data.DropSlotsTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Drop Slots Transform", new System.String[] { "DropSlots", "DropSlotsTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Removes the selected slots from the column.", typeof(Microsoft.ML.Runtime.Data.DropSlotsTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Drop Slots Transform", new System.String[] { "DropSlotsTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Adds a column with a generated number sequence.", typeof(Microsoft.ML.Runtime.Data.GenerateNumberTransform), typeof(Microsoft.ML.Runtime.Data.GenerateNumberTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Generate Number Transform", new System.String[] { "GenerateNumberTransform", "GenerateNumber", "Generate" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Adds a column with a generated number sequence.", typeof(Microsoft.ML.Runtime.Data.GenerateNumberTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Generate Number Transform", new System.String[] { "GenNumTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Converts column values into hashes. This transform accepts text and keys as inputs. It works on single- and vector-valued columns, and hashes each slot in a vector separately.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Transforms.HashTransformer), typeof(Microsoft.ML.Transforms.HashTransformer/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Hash Transform", new System.String[] { "HashTransform", "Hash" }, DocName="transform/HashTransform.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Converts column values into hashes. This transform accepts text and keys as inputs. It works on single- and vector-valued columns, and hashes each slot in a vector separately.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Transforms.HashTransformer), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Hash Transform", new System.String[] { "HashTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Converts column values into hashes. This transform accepts text and keys as inputs. It works on single- and vector-valued columns, and hashes each slot in a vector separately.", typeof(Microsoft.ML.Transforms.HashTransformer), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Hash Transform", new System.String[] { "HashTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.IRowMapper), typeof(Microsoft.ML.Transforms.HashTransformer), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadRowMapper), "Hash Transform", new System.String[] { "HashTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.KeyToValueTransform), typeof(Microsoft.ML.Runtime.Data.KeyToValueTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Key To Value Transform", new System.String[] { "KeyToValueTransform", "KeyToValue", "KeyToVal", "Unterm" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.KeyToValueTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Key To Value Transform", new System.String[] { "KeyToValueTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.KeyToValueTransform), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Key To Value Transform", new System.String[] { "KeyToValueTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.IRowMapper), typeof(Microsoft.ML.Runtime.Data.KeyToValueTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadRowMapper), "Key To Value Transform", new System.String[] { "KeyToValueTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Converts a key column to an indicator vector.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.KeyToVectorTransform), typeof(Microsoft.ML.Runtime.Data.KeyToVectorTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Key To Vector Transform", new System.String[] { "KeyToVectorTransform", "KeyToVector", "ToVector" }, DocName="transform/KeyToVectorTransform.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Converts a key column to an indicator vector.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.KeyToVectorTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Key To Vector Transform", new System.String[] { "KeyToVectorTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Converts a key column to an indicator vector.", typeof(Microsoft.ML.Runtime.Data.KeyToVectorTransform), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "KeyToVectorTransform", new System.String[] { "KeyToVectorTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.IRowMapper), typeof(Microsoft.ML.Runtime.Data.KeyToVectorTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadRowMapper), "KeyToVectorTransform", new System.String[] { "KeyToVectorTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Convert a label column into a standard floating point representation.", typeof(Microsoft.ML.Runtime.Data.LabelConvertTransform), typeof(Microsoft.ML.Runtime.Data.LabelConvertTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "", new System.String[] { "LabelConvert", "LabelConvertTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Convert a label column into a standard floating point representation.", typeof(Microsoft.ML.Runtime.Data.LabelConvertTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Label Convert Transform", new System.String[] { "LabelConvertTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.LabelIndicatorTransform), typeof(Microsoft.ML.Runtime.Data.LabelIndicatorTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Label Indicator Transform", new System.String[] { "LabelIndicatorTransform", "LabelIndicator" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.LabelIndicatorTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Label Indicator Transform", new System.String[] { "LabelIndicatorTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.Data.LabelIndicatorTransform), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "LabelIndicatorTransform", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Filters out rows that contain missing values.", typeof(Microsoft.ML.Runtime.Data.NAFilter), typeof(Microsoft.ML.Runtime.Data.NAFilter/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "NA Filter", new System.String[] { "NAFilter", "MissingValueFilter", "MissingFilter" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Filters out rows that contain missing values.", typeof(Microsoft.ML.Runtime.Data.NAFilter), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "NA Filter", new System.String[] { "MissingValueFilter", "MissingFeatureFilter" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Does nothing.", typeof(Microsoft.ML.Runtime.Data.NopTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "", new System.String[] { "NopTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.Data.NopTransform), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "NopTransform", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Normalizes the data based on the observed minimum and maximum values of the data.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.NormalizeTransform), typeof(Microsoft.ML.Runtime.Data.NormalizeTransform/MinMaxArguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Min-Max Normalizer", new System.String[] { "MinMaxNormalizer", "MinMax" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Normalizes the data based on the computed mean and variance of the data.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.NormalizeTransform), typeof(Microsoft.ML.Runtime.Data.NormalizeTransform/MeanVarArguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "MeanVar Normalizer", new System.String[] { "MeanVarNormalizer", "MeanVar", "ZScoreNormalizer", "ZScore", "GaussianNormalizer", "Gaussian" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Normalizes the data based on the computed mean and variance of the logarithm of the data.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.NormalizeTransform), typeof(Microsoft.ML.Runtime.Data.NormalizeTransform/LogMeanVarArguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "LogMeanVar Normalizer", new System.String[] { "LogMeanVarNormalizer", "LogMeanVar", "LogNormalNormalizer", "LogNormal" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("The values are assigned into equidensity bins and a value is mapped to its bin_number/number_of_bins.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.NormalizeTransform), typeof(Microsoft.ML.Runtime.Data.NormalizeTransform/BinArguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Binning Normalizer", new System.String[] { "BinNormalizer", "Bin" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.NormalizeTransform/AffineColumnFunction), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadColumnFunction), "Affine Normalizer", new System.String[] { "AffineNormExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.NormalizeTransform/CdfColumnFunction), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadColumnFunction), "CDF Normalizer", new System.String[] { "CdfNormalizeFunction" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("The values are assigned into equidensity bins and a value is mapped to its bin_number/number_of_bins.", typeof(Microsoft.ML.Runtime.Data.NormalizeTransform/BinColumnFunction), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadColumnFunction), "Bin Normalizer", new System.String[] { "BinNormalizeFunction" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.NormalizerTransformer), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "", new System.String[] { "Normalizer" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.IRowMapper), typeof(Microsoft.ML.Runtime.Data.NormalizerTransformer), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadRowMapper), "", new System.String[] { "Normalizer" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.Data.Normalize), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "Normalize", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Filters a dataview on a column of type Single, Double or Key (contiguous). Keeps the values that are in the specified min/max range. NaNs are always filtered out. If the input is a Key type, the min/max are considered percentages of the number of values.", typeof(Microsoft.ML.Runtime.Data.RangeFilter), typeof(Microsoft.ML.Runtime.Data.RangeFilter/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Range Filter", new System.String[] { "RangeFilter" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Filters a dataview on a column of type Single, Double or Key (contiguous). Keeps the values that are in the specified min/max range. NaNs are always filtered out. If the input is a Key type, the min/max are considered percentages of the number of values.", typeof(Microsoft.ML.Runtime.Data.RangeFilter), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Range Filter", new System.String[] { "RangeFilter" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Reorders rows in the dataset by pseudo-random shuffling.", typeof(Microsoft.ML.Runtime.Data.ShuffleTransform), typeof(Microsoft.ML.Runtime.Data.ShuffleTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Shuffle Transform", new System.String[] { "ShuffleTransform", "Shuffle", "shuf" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Reorders rows in the dataset by pseudo-random shuffling.", typeof(Microsoft.ML.Runtime.Data.ShuffleTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Shuffle Transform", new System.String[] { "ShuffleTrans" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Allows limiting input to a subset of rows at an optional offset.  Can be used to implement data paging.", typeof(Microsoft.ML.Runtime.Data.SkipTakeFilter), typeof(Microsoft.ML.Runtime.Data.SkipTakeFilter/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Skip and Take Filter", new System.String[] { "SkipTakeFilter", "SkipTake" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Allows limiting input to a subset of rows by skipping a number of rows.", typeof(Microsoft.ML.Runtime.Data.SkipTakeFilter), typeof(Microsoft.ML.Runtime.Data.SkipTakeFilter/SkipArguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Skip Filter", new System.String[] { "SkipFilter", "Skip" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Allows limiting input to a subset of rows by taking N first rows.", typeof(Microsoft.ML.Runtime.Data.SkipTakeFilter), typeof(Microsoft.ML.Runtime.Data.SkipTakeFilter/TakeArguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Take Filter", new System.String[] { "TakeFilter", "Take" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Allows limiting input to a subset of rows at an optional offset.  Can be used to implement data paging.", typeof(Microsoft.ML.Runtime.Data.SkipTakeFilter), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Skip and Take Filter", new System.String[] { "SkipTakeFilter" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Converts input values (words, numbers, etc.) to index in a dictionary.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.TermTransform), typeof(Microsoft.ML.Runtime.Data.TermTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Term Transform", new System.String[] { "Term", "AutoLabel", "TermTransform", "AutoLabelTransform" }, DocName="transform/TermTransform.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Converts input values (words, numbers, etc.) to index in a dictionary.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.TermTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Term Transform", new System.String[] { "TermTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Converts input values (words, numbers, etc.) to index in a dictionary.", typeof(Microsoft.ML.Runtime.Data.TermTransform), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Term Transform", new System.String[] { "TermTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.IRowMapper), typeof(Microsoft.ML.Runtime.Data.TermTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadRowMapper), "Term Transform", new System.String[] { "TermTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Runs a previously trained predictor on the data.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.ScoreTransform), typeof(Microsoft.ML.Runtime.Data.ScoreTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Score Predictor", new System.String[] { "Score" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Trains a predictor, or loads it from a file, and runs it on the data.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.TrainAndScoreTransform), typeof(Microsoft.ML.Runtime.Data.TrainAndScoreTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Train and Score Predictor", new System.String[] { "TrainScore" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("The log loss function for classification. Supported by SDCA.", typeof(Microsoft.ML.Runtime.LogLoss), null, typeof(Microsoft.ML.Runtime.SignatureClassificationLoss), "Log Loss", new System.String[] { "LogLoss", "Logistic", "CrossEntropy" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("The Hinge loss function for classification. Supported by SDCA.", typeof(Microsoft.ML.Runtime.HingeLoss), typeof(Microsoft.ML.Runtime.HingeLoss/Arguments), typeof(Microsoft.ML.Runtime.SignatureClassificationLoss), "Hinge Loss", new System.String[] { "HingeLoss", "Hinge" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("The smooth Hinge loss function for classification. Supported by SDCA.", typeof(Microsoft.ML.Runtime.SmoothedHingeLoss), typeof(Microsoft.ML.Runtime.SmoothedHingeLoss/Arguments), typeof(Microsoft.ML.Runtime.SignatureClassificationLoss), "Smoothed Hinge Loss", new System.String[] { "SmoothedHingeLoss", "SmoothedHinge" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("The exponential loss function for classification.", typeof(Microsoft.ML.Runtime.ExpLoss), typeof(Microsoft.ML.Runtime.ExpLoss/Arguments), typeof(Microsoft.ML.Runtime.SignatureClassificationLoss), "Exponential Loss", new System.String[] { "ExpLoss", "Exp" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("The squared loss function for regression.", typeof(Microsoft.ML.Runtime.SquaredLoss), null, typeof(Microsoft.ML.Runtime.SignatureRegressionLoss), "Squared Loss", new System.String[] { "SquaredLoss", "L2" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("The Poisson loss function for regression.", typeof(Microsoft.ML.Runtime.PoissonLoss), null, typeof(Microsoft.ML.Runtime.SignatureRegressionLoss), "Poisson Loss", new System.String[] { "PoissonLoss", "Poisson" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("The Tweedie loss function for regression.", typeof(Microsoft.ML.Runtime.TweedieLoss), typeof(Microsoft.ML.Runtime.TweedieLoss/Arguments), typeof(Microsoft.ML.Runtime.SignatureRegressionLoss), "Tweedie Loss", new System.String[] { "TweedieLoss", "Tweedie", "Tw" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.6.27002.6")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.6.27002.6 @BuiltBy: dlab14-DDVSOWINAGE057 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/fbcac800001673d9d2b000a400e84f7a55c0c913+fbcac800001673d9d2b000a400e84f7a55c0c913")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.FastTree" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.FastTree.FastTreeBinaryClassificationTrainer/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.FastTree.FastTreeRegressionTrainer/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.FastTree.FastTreeTweedieTrainer/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.FastTree.FastTreeRankingTrainer/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.FastTree.SingleTrainerFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.FastTree")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.FastTree")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Uses a logit-boost boosted tree learner to perform binary classification.", typeof(Microsoft.ML.Runtime.FastTree.FastTreeBinaryClassificationTrainer), typeof(Microsoft.ML.Runtime.FastTree.FastTreeBinaryClassificationTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer), typeof(Microsoft.ML.Runtime.FastTree.SignatureTreeEnsembleTrainer), typeof(Microsoft.ML.Runtime.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "FastTree (Boosted Trees) Classification", new System.String[] { "FastTreeBinaryClassification", "FastTreeClassification", "FastTree", "ft", "ftc", "FastRankBinaryClassification", "FastRankBinaryClassificationWrapper", "FastRankClassification", "fr", "btc", "frc", "fastrank", "fastrankwrapper" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.IPredictorProducing`1&lt;System.Single&gt;), typeof(Microsoft.ML.Runtime.FastTree.FastTreeBinaryPredictor), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "FastTree Binary Executor", new System.String[] { "FastTreeBinaryExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Trains gradient boosted decision trees to the LambdaRank quasi-gradient.", typeof(Microsoft.ML.Runtime.FastTree.FastTreeRankingTrainer), typeof(Microsoft.ML.Runtime.FastTree.FastTreeRankingTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureRankerTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer), typeof(Microsoft.ML.Runtime.FastTree.SignatureTreeEnsembleTrainer), typeof(Microsoft.ML.Runtime.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "FastTree (Boosted Trees) Ranking", new System.String[] { "FastTreeRanking", "ftrank", "FastRankRanking", "FastRankRankingWrapper", "rank", "frrank", "btrank" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.FastTree.FastTreeRankingPredictor), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "FastTree Ranking Executor", new System.String[] { "FastTreeRankerExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.FastTree.FastTree), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "FastTree", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Trains gradient boosted decision trees to fit target values using least-squares.", typeof(Microsoft.ML.Runtime.FastTree.FastTreeRegressionTrainer), typeof(Microsoft.ML.Runtime.FastTree.FastTreeRegressionTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureRegressorTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer), typeof(Microsoft.ML.Runtime.FastTree.SignatureTreeEnsembleTrainer), typeof(Microsoft.ML.Runtime.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "FastTree (Boosted Trees) Regression", new System.String[] { "FastTreeRegression", "ftr", "FastRankRegression", "FastRankRegressionWrapper", "frr", "btr" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.FastTree.FastTreeRegressionPredictor), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "FastTree Regression Executor", new System.String[] { "FastTreeRegressionExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Trains gradient boosted decision trees to fit target values using a Tweedie loss function. This learner is a generalization of Poisson, compound Poisson, and gamma regression.", typeof(Microsoft.ML.Runtime.FastTree.FastTreeTweedieTrainer), typeof(Microsoft.ML.Runtime.FastTree.FastTreeTweedieTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureRegressorTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer), typeof(Microsoft.ML.Runtime.FastTree.SignatureTreeEnsembleTrainer), typeof(Microsoft.ML.Runtime.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "FastTree (Boosted Trees) Tweedie Regression", new System.String[] { "FastTreeTweedieRegression", "fttweedie" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.FastTree.FastTreeTweediePredictor), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "FastTree Tweedie Regression Executor", new System.String[] { "FastTreeTweedieExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Trains a gradient boosted stump per feature, on all features simultaneously, to fit target values using least-squares. It mantains no interactions between features.", typeof(Microsoft.ML.Runtime.FastTree.BinaryClassificationGamTrainer), typeof(Microsoft.ML.Runtime.FastTree.BinaryClassificationGamTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer), typeof(Microsoft.ML.Runtime.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Generalized Additive Model for Binary Classification", new System.String[] { "BinaryClassificationGamTrainer", "gam" }, DocName="trainer/GAM.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.IPredictorProducing`1&lt;System.Single&gt;), typeof(Microsoft.ML.Runtime.FastTree.BinaryClassGamPredictor), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "GAM Binary Class Predictor", new System.String[] { "BinaryClassGamPredictor" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Trains a gradient boosted stump per feature, on all features simultaneously, to fit target values using least-squares. It mantains no interactions between features.", typeof(Microsoft.ML.Runtime.FastTree.RegressionGamTrainer), typeof(Microsoft.ML.Runtime.FastTree.RegressionGamTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureRegressorTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer), typeof(Microsoft.ML.Runtime.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Generalized Additive Model for Regression", new System.String[] { "RegressionGamTrainer", "gamr" }, DocName="trainer/GAM.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.FastTree.RegressionGamPredictor), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "GAM Regression Predictor", new System.String[] { "RegressionGamPredictor" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.FastTree.GamPredictorBase/VisualizationCommand), typeof(Microsoft.ML.Runtime.FastTree.GamPredictorBase/VisualizationCommand/Arguments), typeof(Microsoft.ML.Runtime.Command.SignatureCommand), "GAM Vizualization Command", new System.String[] { "GamVisualization", "gamviz" }, DocName="command/GamViz.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.FastTree.Gam), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "GAM", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Trains a random forest to fit target values using least-squares.", typeof(Microsoft.ML.Runtime.FastTree.FastForestRegression), typeof(Microsoft.ML.Runtime.FastTree.FastForestRegression/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureRegressorTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer), typeof(Microsoft.ML.Runtime.FastTree.SignatureTreeEnsembleTrainer), typeof(Microsoft.ML.Runtime.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Fast Forest Regression", new System.String[] { "FastForestRegression", "ffr" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.FastTree.FastForestRegressionPredictor), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "FastForest Regression Executor", new System.String[] { "FastForestRegressionExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Uses a random forest learner to perform binary classification.", typeof(Microsoft.ML.Runtime.FastTree.FastForestClassification), typeof(Microsoft.ML.Runtime.FastTree.FastForestClassification/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer), typeof(Microsoft.ML.Runtime.FastTree.SignatureTreeEnsembleTrainer), typeof(Microsoft.ML.Runtime.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Fast Forest Classification", new System.String[] { "FastForestClassification", "FastForest", "ff", "ffc" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.IPredictorProducing`1&lt;System.Single&gt;), typeof(Microsoft.ML.Runtime.FastTree.FastForestClassificationPredictor), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "FastForest Binary Executor", new System.String[] { "FastForestBinaryExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.FastTree.FastForest), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "FastForest", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.FastTree.SumupPerformanceCommand), typeof(Microsoft.ML.Runtime.FastTree.SumupPerformanceCommand/Arguments), typeof(Microsoft.ML.Runtime.Command.SignatureCommand), "", new System.String[] { "FastTreeSumupPerformance", "ftsumup" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.FastTree.SingleTrainer), null, typeof(Microsoft.ML.Runtime.FastTree.SignatureParallelTrainer), "single", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.ISchemaBindableMapper), typeof(Microsoft.ML.Runtime.Data.TreeEnsembleFeaturizerTransform), typeof(Microsoft.ML.Runtime.Data.TreeEnsembleFeaturizerBindableMapper/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureBindableMapper), "Tree Ensemble Featurizer Mapper", new System.String[] { "TreeFeat" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.IDataScorerTransform), typeof(Microsoft.ML.Runtime.Data.TreeEnsembleFeaturizerTransform), typeof(Microsoft.ML.Runtime.Data.TreeEnsembleFeaturizerBindableMapper/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataScorer), "Tree Ensemble Featurizer Scorer", new System.String[] { "TreeFeat" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.ISchemaBindableMapper), typeof(Microsoft.ML.Runtime.Data.TreeEnsembleFeaturizerTransform), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Tree Ensemble Featurizer Mapper", new System.String[] { "TreeEnsembleMapper" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Trains a tree ensemble, or loads it from a file, then maps a numeric feature vector to three outputs: 1. A vector containing the individual tree outputs of the tree ensemble. 2. A vector indicating the leaves that the feature vector falls on in the tree ensemble. 3. A vector indicating the paths that the feature vector falls on in the tree ensemble. If a both a model file and a trainer are specified - will use the model file. If neither are specified, will train a default FastTree model. This can handle key labels by training a regression model towards their optionally permuted indices.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.TreeEnsembleFeaturizerTransform), typeof(Microsoft.ML.Runtime.Data.TreeEnsembleFeaturizerTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Tree Ensemble Featurization Transform", new System.String[] { "TreeFeat", "TreeFeaturizationTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.Data.TreeFeaturize), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "TreeFeaturize", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.FastTree.Internal.TreeEnsembleCombiner), null, typeof(Microsoft.ML.Runtime.SignatureModelCombiner), "Fast Tree Model Combiner", new System.String[] { "FastTreeCombiner" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.6.27002.6")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.6.27002.6 @BuiltBy: dlab14-DDVSOWINAGE057 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/fbcac800001673d9d2b000a400e84f7a55c0c913+fbcac800001673d9d2b000a400e84f7a55c0c913")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.KMeansClustering" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.KMeansClustering")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.KMeansClustering")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("K-means is a popular clustering algorithm. With K-means, the data is clustered into a specified number of clusters in order to minimize the within-cluster sum of squares. K-means++ improves upon K-means by using a better method for choosing the initial cluster centers.", typeof(Microsoft.ML.Runtime.KMeans.KMeansPlusPlusTrainer), typeof(Microsoft.ML.Runtime.KMeans.KMeansPlusPlusTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureClusteringTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer) }, "KMeans++ Clustering", new System.String[] { "KMeansPlusPlus", "KM", "KMeans" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.KMeans.KMeansPlusPlusTrainer), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "KMeans", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.KMeans.KMeansPredictor), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "KMeans predictor", new System.String[] { "KMeansPredictor" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.6.27002.6")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.6.27002.6 @BuiltBy: dlab14-DDVSOWINAGE057 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/fbcac800001673d9d2b000a400e84f7a55c0c913+fbcac800001673d9d2b000a400e84f7a55c0c913")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.Legacy" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.EntryPoints.CodeGen.ModuleGenerator), typeof(Microsoft.ML.Runtime.EntryPoints.CodeGen.ModuleGenerator/Arguments), typeof(Microsoft.ML.Runtime.Tools.SignatureModuleGenerator), "Module generator", new System.String[] { "ModuleGenerator", "Module" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.CrossValidationBinaryMacro), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "CrossValidationBinaryMacro", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.CrossValidationMacro), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "CrossValidationMacro", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.CVSplit), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "CVSplit", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.DataViewReference), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "DataViewReference", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.FeatureCombiner), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "FeatureCombiner", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.ImportTextData), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "ImportTextData", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.EntryPoints.JsonUtils.ExecuteGraphCommand), typeof(Microsoft.ML.Runtime.EntryPoints.JsonUtils.ExecuteGraphCommand/Arguments), typeof(Microsoft.ML.Runtime.Command.SignatureCommand), "", new System.String[] { "ExecGraph" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.ModelOperations), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "ModelOperations", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.OneVersusAllMacro), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "OneVersusAllMacro", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.TrainTestBinaryMacro), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "TrainTestBinaryMacro", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.TrainTestMacro), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "TrainTestMacro", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.TrainTestSplit), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "TrainTestSplit", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Internal.Tools.CSharpApiGenerator), typeof(Microsoft.ML.Runtime.Internal.Tools.CSharpApiGenerator/Arguments), typeof(Microsoft.ML.Runtime.Tools.SignatureModuleGenerator), "CSharp API generator", new System.String[] { "CSGenerator", "CS" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.Legacy")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.6.27002.6")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.6.27002.6 @BuiltBy: dlab14-DDVSOWINAGE057 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/fbcac800001673d9d2b000a400e84f7a55c0c913+fbcac800001673d9d2b000a400e84f7a55c0c913")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.Legacy")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Tests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.ML.Maml" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.Maml")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.TestFramework, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.Maml")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("A command that chains multiple other commands.", typeof(Microsoft.ML.Runtime.Tools.ChainCommand), typeof(Microsoft.ML.Runtime.Tools.ChainCommand/Arguments), typeof(Microsoft.ML.Runtime.Command.SignatureCommand), "Chain Command", new System.String[] { "Chain" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Prints command line help.", typeof(Microsoft.ML.Runtime.Tools.HelpCommand), typeof(Microsoft.ML.Runtime.Tools.HelpCommand/Arguments), typeof(Microsoft.ML.Runtime.Command.SignatureCommand), "MAML Help Command", new System.String[] { "Help", "?" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Tools.XmlGenerator), typeof(Microsoft.ML.Runtime.Tools.XmlGenerator/Arguments), typeof(Microsoft.ML.Runtime.Tools.SignatureModuleGenerator), "Xml generator", new System.String[] { "XmlGenerator", "Xml" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Prints the TLC version.", typeof(Microsoft.ML.Runtime.Tools.VersionCommand), null, typeof(Microsoft.ML.Runtime.Command.SignatureCommand), "Version Command", new System.String[] { "Version" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.6.27002.6")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.6.27002.6 @BuiltBy: dlab14-DDVSOWINAGE057 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/fbcac800001673d9d2b000a400e84f7a55c0c913+fbcac800001673d9d2b000a400e84f7a55c0c913")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.ML.Benchmarks, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.PCA" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.PCA")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.PCA")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("This algorithm trains an approximate PCA using Randomized SVD algorithm. This PCA can be made into Kernel PCA by using Random Fourier Features transform.", typeof(Microsoft.ML.Runtime.PCA.RandomizedPcaTrainer), typeof(Microsoft.ML.Runtime.PCA.RandomizedPcaTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureAnomalyDetectorTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer) }, "PCA Anomaly Detector", new System.String[] { "pcaAnomaly", "pcaAnom" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.PCA.PcaPredictor), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "PCA Anomaly Executor", new System.String[] { "pcaAnomExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.PCA.RandomizedPcaTrainer), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "pcaAnomaly", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("PCA is a dimensionality-reduction transform which computes the projection of a numeric vector onto a low-rank subspace.", typeof(Microsoft.ML.Runtime.Data.PcaTransform), typeof(Microsoft.ML.Runtime.Data.PcaTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Principal Component Analysis Transform", new System.String[] { "PcaTransform", "Pca" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("PCA is a dimensionality-reduction transform which computes the projection of a numeric vector onto a low-rank subspace.", typeof(Microsoft.ML.Runtime.Data.PcaTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Principal Component Analysis Transform", new System.String[] { "PcaTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.Data.PcaTransform), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "PcaTransform", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.6.27002.6")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.6.27002.6 @BuiltBy: dlab14-DDVSOWINAGE057 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/fbcac800001673d9d2b000a400e84f7a55c0c913+fbcac800001673d9d2b000a400e84f7a55c0c913")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.PipelineInference" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.PipelineInference.AutoInference/AutoMlMlState/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.PipelineInference.AutoInference/ISupportAutoMlStateFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.PipelineInference.DefaultsEngine/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.PipelineInference.RocketEngine/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.PipelineInference.UniformRandomEngine/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.PipelineInference.ISupportIPipelineOptimizerFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.PipelineInference.IterationTerminator/Arguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.PipelineInference.ISupportITerminatorFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.PipelineInference")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.PipelineInference")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.PipelineSweeperMacro), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "PipelineSweeperMacro", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.6.27002.6")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.6.27002.6 @BuiltBy: dlab14-DDVSOWINAGE057 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/fbcac800001673d9d2b000a400e84f7a55c0c913+fbcac800001673d9d2b000a400e84f7a55c0c913")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.ResultProcessor" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.ResultProcessor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.ResultProcessor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.6.27002.6")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.6.27002.6 @BuiltBy: dlab14-DDVSOWINAGE057 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/fbcac800001673d9d2b000a400e84f7a55c0c913+fbcac800001673d9d2b000a400e84f7a55c0c913")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.StandardLearners" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.Learners.OvaPredictor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.StandardLearners")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.StandardLearners")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Train a field-aware factorization machine for binary classification", typeof(Microsoft.ML.Runtime.FactorizationMachine.FieldAwareFactorizationMachineTrainer), typeof(Microsoft.ML.Runtime.FactorizationMachine.FieldAwareFactorizationMachineTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer) }, "Field-aware Factorization Machine", new System.String[] { "FieldAwareFactorizationMachine", "ffm" }, DocName="trainer/FactorizationMachine.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.FactorizationMachine.FieldAwareFactorizationMachineTrainer), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "FieldAwareFactorizationMachine", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.FactorizationMachine.FieldAwareFactorizationMachinePredictor), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Field Aware Factorization Machine", new System.String[] { "FieldAwareFactMacPredict" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.FactorizationMachine.FieldAwareFactorizationMachinePredictionTransformer), typeof(Microsoft.ML.Runtime.FactorizationMachine.FieldAwareFactorizationMachinePredictionTransformer), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "", new System.String[] { "FAFMPredXfer" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Learners.LinearClassificationTrainer), typeof(Microsoft.ML.Runtime.Learners.LinearClassificationTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer), typeof(Microsoft.ML.Runtime.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Fast Linear (SA-SDCA)", new System.String[] { "SDCA", "LinearClassifier", "lc", "sasdca" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Learners.StochasticGradientDescentClassificationTrainer), typeof(Microsoft.ML.Runtime.Learners.StochasticGradientDescentClassificationTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer), typeof(Microsoft.ML.Runtime.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Hogwild SGD (binary)", new System.String[] { "BinarySGD", "sgd" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.Learners.Sdca), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "SDCA", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.Learners.StochasticGradientDescentClassificationTrainer), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "HogwildSGD", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.IPredictorProducing`1&lt;System.Single&gt;), typeof(Microsoft.ML.Runtime.Learners.LinearBinaryPredictor), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Linear Binary Executor", new System.String[] { "Linear2CExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Learners.LinearRegressionPredictor), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Linear Regression Executor", new System.String[] { "LinearRegressionExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Learners.PoissonRegressionPredictor), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Poisson Regression Executor", new System.String[] { "PoissonRegressionExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Logistic Regression is a method in statistics used to predict the probability of occurrence of an event and can be used as a classification algorithm. The algorithm predicts the probability of occurrence of an event by fitting data to a logistical function.", typeof(Microsoft.ML.Runtime.Learners.LogisticRegression), typeof(Microsoft.ML.Runtime.Learners.LogisticRegression/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer), typeof(Microsoft.ML.Runtime.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Logistic Regression", new System.String[] { "LogisticRegression", "lr", "logisticregressionwrapper" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.Learners.LogisticRegression), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "LogisticRegression", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Learners.MulticlassLogisticRegression), typeof(Microsoft.ML.Runtime.Learners.MulticlassLogisticRegression/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureMultiClassClassifierTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer) }, "Multi-class Logistic Regression", new System.String[] { "MultiClassLogisticRegression", "MulticlassLogisticRegressionPredictorNew", "mlr", "multilr" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Learners.MulticlassLogisticRegressionPredictor), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Multiclass LR Executor", new System.String[] { "MultiClassLRExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Learners.LinearModelStatistics), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Linear Model Statistics", new System.String[] { "LinearModelStats" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Trains a multiclass Naive Bayes predictor that supports binary feature values.", typeof(Microsoft.ML.Runtime.Learners.MultiClassNaiveBayesTrainer), typeof(Microsoft.ML.Runtime.Learners.MultiClassNaiveBayesTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureMultiClassClassifierTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer) }, "Multiclass Naive Bayes", new System.String[] { "MultiClassNaiveBayes", "MNB" }, DocName="trainer/NaiveBayes.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Learners.MultiClassNaiveBayesPredictor), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Multi Class Naive Bayes predictor", new System.String[] { "MultiClassNaiveBayesPred" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.Learners.MultiClassNaiveBayesTrainer), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "MultiClassNaiveBayes", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("In this strategy, a binary classification algorithm is used to train one classifier for each class, which distinguishes that class from all other classes. Prediction is then performed by running these binary classifiers, and choosing the prediction with the highest confidence score.", typeof(Microsoft.ML.Runtime.Learners.Ova), typeof(Microsoft.ML.Runtime.Learners.Ova/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureMultiClassClassifierTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer) }, "One-vs-All", new System.String[] { "OVA" }, DocName="trainer/OvaPkpd.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Learners.OvaPredictor), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "OVA Executor", new System.String[] { "OVAExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("In this strategy, a binary classification algorithm is used to train one classifier for each pair of classes. Prediction is then performed by running these binary classifiers, and computing a score for each class by counting how many of the binary classifiers predicted it. The prediction is the class with the highest score.", typeof(Microsoft.ML.Runtime.Learners.Pkpd), typeof(Microsoft.ML.Runtime.Learners.Pkpd/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureMultiClassClassifierTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer) }, "Pairwise coupling (PKPD)", new System.String[] { "PKPD" }, DocName="trainer/OvaPkpd.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Learners.PkpdPredictor), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "PKPD Executor", new System.String[] { "PKPDExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Averaged Perceptron Binary Classifier.", typeof(Microsoft.ML.Runtime.Learners.AveragedPerceptronTrainer), typeof(Microsoft.ML.Runtime.Learners.AveragedPerceptronTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer), typeof(Microsoft.ML.Runtime.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Averaged Perceptron", new System.String[] { "AveragedPerceptron", "avgper", "ap" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.Learners.AveragedPerceptronTrainer), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "AP", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("The idea behind support vector machines, is to map the instances into a high dimensional space in which instances of the two classes are linearly separable, i.e., there exists a hyperplane such that all the positive examples are on one side of it, and all the negative examples are on the other. After this mapping, quadratic programming is used to find the separating hyperplane that maximizes the margin, i.e., the minimal distance between it and the instances.", typeof(Microsoft.ML.Runtime.Learners.LinearSvm), typeof(Microsoft.ML.Runtime.Learners.LinearSvm/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer), typeof(Microsoft.ML.Runtime.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "SVM (Pegasos-Linear)", new System.String[] { "LinearSVM", "svm" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.Learners.LinearSvm), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "LinearSvm", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Stochastic gradient descent is an optimization method used to train a wide range of models in machine learning. In the TLC implementation of OGD, it is for linear regression.", typeof(Microsoft.ML.Runtime.Learners.OnlineGradientDescentTrainer), typeof(Microsoft.ML.Runtime.Learners.OnlineGradientDescentTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureRegressorTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer), typeof(Microsoft.ML.Runtime.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Stochastic Gradient Descent (Regression)", new System.String[] { "OnlineGradientDescent", "ogd", "sgdr", "stochasticgradientdescentregression" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.Learners.OnlineGradientDescentTrainer), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "OGD", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Poisson Regression assumes the unknown function, denoted Y has a Poisson distribution.", typeof(Microsoft.ML.Runtime.Learners.PoissonRegression), typeof(Microsoft.ML.Runtime.Learners.PoissonRegression/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureRegressorTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer), typeof(Microsoft.ML.Runtime.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Poisson Regression", new System.String[] { "PoissonRegression", "PoissonRegressionNew", "Poisson", "PR" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.Learners.PoissonRegression), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "PoissonRegression", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("The SDCA linear multi-class classification trainer.", typeof(Microsoft.ML.Runtime.Learners.SdcaMultiClassTrainer), typeof(Microsoft.ML.Runtime.Learners.SdcaMultiClassTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureMultiClassClassifierTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer), typeof(Microsoft.ML.Runtime.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Fast Linear Multi-class Classification (SA-SDCA)", new System.String[] { "SDCAMC", "sasdcamc" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("The SDCA linear regression trainer.", typeof(Microsoft.ML.Runtime.Learners.SdcaRegressionTrainer), typeof(Microsoft.ML.Runtime.Learners.SdcaRegressionTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureRegressorTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer), typeof(Microsoft.ML.Runtime.Internal.Internallearn.SignatureFeatureScorerTrainer) }, "Fast Linear Regression (SA-SDCA)", new System.String[] { "SDCAR", "sasdcar" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("A toy predictor that returns a random value.", typeof(Microsoft.ML.Runtime.Learners.RandomTrainer), typeof(Microsoft.ML.Runtime.Learners.RandomTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer) }, "Random Predictor", new System.String[] { "RandomPredictor", "random" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("A toy predictor that returns a random value.", typeof(Microsoft.ML.Runtime.Learners.PriorTrainer), typeof(Microsoft.ML.Runtime.Learners.PriorTrainer/Arguments), new System.Type[] { typeof(Microsoft.ML.Runtime.SignatureBinaryClassifierTrainer), typeof(Microsoft.ML.Runtime.SignatureTrainer) }, "Prior Predictor", new System.String[] { "PriorPredictor", "prior", "constant" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Learners.RandomPredictor), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Random predictor", new System.String[] { "RandomPredictor" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Learners.PriorPredictor), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Prior predictor", new System.String[] { "PriorPredictor" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.6.27002.6")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.6.27002.6 @BuiltBy: dlab14-DDVSOWINAGE057 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/fbcac800001673d9d2b000a400e84f7a55c0c913+fbcac800001673d9d2b000a400e84f7a55c0c913")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.Sweeper" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.Sweeper")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.Sweeper")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Sweeper.RandomGridSweeper), typeof(Microsoft.ML.Runtime.Sweeper.RandomGridSweeper/Arguments), typeof(Microsoft.ML.Runtime.SignatureSweeper), "Random Grid Sweeper", new System.String[] { "RandomGridSweeper", "RandomGrid" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Sweeper.RandomGridSweeper), typeof(Microsoft.ML.Runtime.Sweeper.RandomGridSweeper/Arguments), typeof(Microsoft.ML.Runtime.Sweeper.SignatureSweeperFromParameterList), "Random Grid Sweeper", new System.String[] { "RandomGridSweeperParamList", "RandomGridpl" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Sweeper.Algorithms.KdoSweeper), typeof(Microsoft.ML.Runtime.Sweeper.Algorithms.KdoSweeper/Arguments), typeof(Microsoft.ML.Runtime.SignatureSweeper), "KDO Sweeper", new System.String[] { "KDOSweeper", "KDO" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Sweeper.NelderMeadSweeper), typeof(Microsoft.ML.Runtime.Sweeper.NelderMeadSweeper/Arguments), typeof(Microsoft.ML.Runtime.SignatureSweeper), "Nelder Mead Sweeper", new System.String[] { "NelderMeadSweeper", "NelderMead", "NM" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Sweeper.UniformRandomSweeper), typeof(Microsoft.ML.Runtime.Sweeper.SweeperBase/ArgumentsBase), typeof(Microsoft.ML.Runtime.SignatureSweeper), "Uniform Random Sweeper", new System.String[] { "UniformRandomSweeper", "UniformRandom" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Sweeper.UniformRandomSweeper), typeof(Microsoft.ML.Runtime.Sweeper.SweeperBase/ArgumentsBase), typeof(Microsoft.ML.Runtime.Sweeper.SignatureSweeperFromParameterList), "Uniform Random Sweeper", new System.String[] { "UniformRandomSweeperParamList", "UniformRandompl" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Sweeper.SmacSweeper), typeof(Microsoft.ML.Runtime.Sweeper.SmacSweeper/Arguments), typeof(Microsoft.ML.Runtime.SignatureSweeper), "SMAC Sweeper", new System.String[] { "SMACSweeper", "SMAC" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Sweeper.SimpleAsyncSweeper), typeof(Microsoft.ML.Runtime.Sweeper.SweeperBase/ArgumentsBase), typeof(Microsoft.ML.Runtime.Sweeper.SignatureAsyncSweeper), "Asynchronous Uniform Random Sweeper", new System.String[] { "UniformRandomSweeper", "UniformRandom" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Sweeper.SimpleAsyncSweeper), typeof(Microsoft.ML.Runtime.Sweeper.RandomGridSweeper/Arguments), typeof(Microsoft.ML.Runtime.Sweeper.SignatureAsyncSweeper), "Asynchronous Random Grid Sweeper", new System.String[] { "RandomGridSweeper", "RandomGrid" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Sweeper.DeterministicSweeperAsync), typeof(Microsoft.ML.Runtime.Sweeper.DeterministicSweeperAsync/Arguments), typeof(Microsoft.ML.Runtime.Sweeper.SignatureAsyncSweeper), "Asynchronous and Deterministic Sweeper", new System.String[] { "DeterministicSweeper", "Deterministic" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Sweeper.LocalExeConfigRunner), typeof(Microsoft.ML.Runtime.Sweeper.LocalExeConfigRunner/Arguments), typeof(Microsoft.ML.Runtime.Sweeper.SignatureConfigRunner), "Local Sweep Config Runner", new System.String[] { "Local" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Sweeper.LongValueGenerator), typeof(Microsoft.ML.Runtime.Sweeper.LongParamArguments), typeof(Microsoft.ML.Runtime.Sweeper.SignatureSweeperParameter), "Long parameter", new System.String[] { "lp" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Sweeper.FloatValueGenerator), typeof(Microsoft.ML.Runtime.Sweeper.FloatParamArguments), typeof(Microsoft.ML.Runtime.Sweeper.SignatureSweeperParameter), "Float parameter", new System.String[] { "fp" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Sweeper.DiscreteValueGenerator), typeof(Microsoft.ML.Runtime.Sweeper.DiscreteParamArguments), typeof(Microsoft.ML.Runtime.Sweeper.SignatureSweeperParameter), "Discrete parameter", new System.String[] { "dp" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Given a command line template and sweep ranges, creates and runs a sweep.", typeof(Microsoft.ML.Runtime.Sweeper.SweepCommand), typeof(Microsoft.ML.Runtime.Sweeper.SweepCommand/Arguments), typeof(Microsoft.ML.Runtime.Command.SignatureCommand), "Sweep", new System.String[] { "Sweep" }, DocName="command/Sweep.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Sweeper.InternalSweepResultEvaluator), typeof(Microsoft.ML.Runtime.Sweeper.InternalSweepResultEvaluator/Arguments), typeof(Microsoft.ML.Runtime.SignatureSweepResultEvaluator), "TLC Sweep Result Evaluator", new System.String[] { "TlcEvaluator", "Tlc" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Sweeper.SynthConfigRunner), typeof(Microsoft.ML.Runtime.Sweeper.SynthConfigRunner/Arguments), typeof(Microsoft.ML.Runtime.Sweeper.SignatureConfigRunner), "", new System.String[] { "Synth" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.6.27002.6")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.6.27002.6 @BuiltBy: dlab14-DDVSOWINAGE057 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/fbcac800001673d9d2b000a400e84f7a55c0c913+fbcac800001673d9d2b000a400e84f7a55c0c913")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.TensorFlow" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Transforms.TensorFlowTransform))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.TensorFlow")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.TensorFlow")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Transforms the data using the TensorFlow model.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Transforms.TensorFlowTransform), typeof(Microsoft.ML.Transforms.TensorFlowTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "TensorFlowTransform", new System.String[] { "TFTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Transforms the data using the TensorFlow model.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Transforms.TensorFlowTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "TensorFlowTransform", new System.String[] { "TensorFlowTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Transforms.TensorFlowTransform), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "TensorFlowTransform", new System.String[] { "TensorFlowTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.IRowMapper), typeof(Microsoft.ML.Transforms.TensorFlowTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadRowMapper), "TensorFlowTransform", new System.String[] { "TensorFlowTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.6.27002.6")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.6.27002.6 @BuiltBy: dlab14-DDVSOWINAGE057 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/fbcac800001673d9d2b000a400e84f7a55c0c913+fbcac800001673d9d2b000a400e84f7a55c0c913")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
    <Assembly Name="Microsoft.ML.Transforms" Version="1.0.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.Data.BootstrapSample))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.Data.LpNormalization))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.Data.GroupingOperations))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.Data.HashJoin))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.Data.NAHandling))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.DataPipe.OptionalColumnTransform))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.TextAnalytics.PredefinedStopWordsRemoverFactory))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.TextAnalytics.CustomStopWordsRemoverTransform/LoaderArguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.Data.NgramExtractorTransform/NgramExtractorArguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.EntryPoints.EntryPointModule(typeof(Microsoft.ML.Runtime.Data.NgramHashExtractorTransform/NgramHashExtractorArguments))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyProduct("Microsoft® .NET Framework")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyTitle("Microsoft.ML.Transforms")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName="")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyDefaultAlias("Microsoft.ML.Transforms")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Approximate bootstrap sampling.", typeof(Microsoft.ML.Runtime.Data.BootstrapSampleTransform), typeof(Microsoft.ML.Runtime.Data.BootstrapSampleTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Bootstrap Sample Transform", new System.String[] { "BootstrapSampleTransform", "BootstrapSample" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Approximate bootstrap sampling.", typeof(Microsoft.ML.Runtime.Data.BootstrapSampleTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Bootstrap Sample Transform", new System.String[] { "BootstrapSampleTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Converts the categorical value into an indicator array by hashing the value and using the hash as an index in the bag. If the input column is a vector, a single indicator bag is returned for it.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.CategoricalHashTransform), typeof(Microsoft.ML.Runtime.Data.CategoricalHashTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Categorical Hash Transform", new System.String[] { "CategoricalHashTransform", "CatHashTransform", "CategoricalHash", "CatHash" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Converts the categorical value into an indicator array by building a dictionary of categories based on the data and using the id in the dictionary as the index in the array.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.CategoricalTransform), typeof(Microsoft.ML.Runtime.Data.CategoricalTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Categorical Transform", new System.String[] { "CategoricalTransform", "CatTransform", "Categorical", "Cat" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.Data.Categorical), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "Categorical", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.CompositeTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Composite Transform", new System.String[] { "CompositeRowFunction" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Selects the slots for which the count of non-default values is greater than or equal to a threshold.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.CountFeatureSelectionTransform), typeof(Microsoft.ML.Runtime.Data.CountFeatureSelectionTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Count Feature Selection Transform", new System.String[] { "CountFeatureSelectionTransform", "CountFeatureSelection" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.EntryPoints.SelectFeatures), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "SelectFeatures", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(System.Void), typeof(Microsoft.ML.Runtime.Transforms.TextAnalytics), null, typeof(Microsoft.ML.Runtime.EntryPoints.SignatureEntryPointModule), "TextAnalytics", new System.String[] {  })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.GaussianFourierSampler), typeof(Microsoft.ML.Runtime.Data.GaussianFourierSampler/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureFourierDistributionSampler), "Gaussian Kernel", new System.String[] { "GaussianRandom", "Gaussian" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.LaplacianFourierSampler), typeof(Microsoft.ML.Runtime.Data.LaplacianFourierSampler/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureFourierDistributionSampler), "Laplacian Kernel", new System.String[] { "LaplacianRandom", "Laplacian" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.GaussianFourierSampler), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Gaussian Fourier Sampler Executor", new System.String[] { "GaussianSamplerExecutor", "RandGaussFourierExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.LaplacianFourierSampler), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Laplacian Fourier Sampler Executor", new System.String[] { "LaplacianSamplerExecutor", "RandLaplacianFourierExec" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Performs a global contrast normalization on input values: Y = (s * X - M) / D, where s is a scale, M is mean and D is either L2 norm or standard deviation.", typeof(Microsoft.ML.Runtime.Data.LpNormNormalizerTransform), typeof(Microsoft.ML.Runtime.Data.LpNormNormalizerTransform/GcnArguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Global Contrast Normalization Transform", new System.String[] { "GcnTransform", "Gcn" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Performs a global contrast normalization on input values: Y = (s * X - M) / D, where s is a scale, M is mean and D is either L2 norm or standard deviation.", typeof(Microsoft.ML.Runtime.Data.LpNormNormalizerTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Global Contrast Normalization Transform", new System.String[] { "GcnTransform", "GcnFunction" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Normalize vectors (rows) individually by rescaling them to unit norm (L2, L1 or LInf). Performs the following operation on a vector X: Y = (X - M) / D, where M is mean and D is either L2 norm, L1 norm or LInf norm.", typeof(Microsoft.ML.Runtime.Data.LpNormNormalizerTransform), typeof(Microsoft.ML.Runtime.Data.LpNormNormalizerTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Lp-Norm Normalizer", new System.String[] { "LpNormNormalizer", "lpnorm" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Groups values of a scalar column into a vector, by a contiguous group ID", typeof(Microsoft.ML.Runtime.Data.GroupTransform), typeof(Microsoft.ML.Runtime.Data.GroupTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Group Transform", new System.String[] { "Group" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Groups values of a scalar column into a vector, by a contiguous group ID", typeof(Microsoft.ML.Runtime.Data.GroupTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Group Transform", new System.String[] { "GroupTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Converts column values into hashes. This transform accepts both numeric and text inputs, both single and vector-valued columns. ", typeof(Microsoft.ML.Runtime.Data.HashJoinTransform), typeof(Microsoft.ML.Runtime.Data.HashJoinTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Hash Join Transform", new System.String[] { "HashJoinTransform", "HashJoin" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Converts column values into hashes. This transform accepts both numeric and text inputs, both single and vector-valued columns. ", typeof(Microsoft.ML.Runtime.Data.HashJoinTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Hash Join Transform", new System.String[] { "HashJoinTransform", "HashJoinFunction" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Converts a key column to a binary encoded vector.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.KeyToBinaryVectorTransform), typeof(Microsoft.ML.Runtime.Data.KeyToBinaryVectorTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Key To Binary Vector Transform", new System.String[] { "KeyToBinaryVectorTransform", "KeyToBinary", "ToBinaryVector" }, DocName="transform/KeyToBinaryVectorTransform.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Converts a key column to a binary encoded vector.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.KeyToBinaryVectorTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Key To Binary Vector Transform", new System.String[] { "KeyToBinaryTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Converts a key column to a binary encoded vector.", typeof(Microsoft.ML.Runtime.Data.KeyToBinaryVectorTransform), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "KeyToBinaryVectorTransform", new System.String[] { "KeyToBinaryTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.IRowMapper), typeof(Microsoft.ML.Runtime.Data.KeyToBinaryVectorTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadRowMapper), "KeyToBinaryVectorTransform", new System.String[] { "KeyToBinaryTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Selects the slots for which the absolute value of the corresponding weight in a linear learner is greater than a threshold.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.LearnerFeatureSelectionTransform), typeof(Microsoft.ML.Runtime.Data.LearnerFeatureSelectionTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Learner Feature Selection Transform", new System.String[] { "LearnerFeatureSelectionTransform", "LearnerFeatureSelection" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Loads specified transforms from the model file and applies them to current data.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.LoadTransform), typeof(Microsoft.ML.Runtime.Data.LoadTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Load Transform", new System.String[] { "LoadTransform", "Load" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.MissingValueIndicatorTransform), typeof(Microsoft.ML.Runtime.Data.MissingValueIndicatorTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "", new System.String[] { "MissingValueIndicatorTransform", "MissingValueTransform", "MissingTransform", "Missing" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.MissingValueIndicatorTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Missing Value Indicator Transform", new System.String[] { "MissingIndicatorFunction", "MissingFeatureFunction" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Selects the top k slots across all specified columns ordered by their mutual information with the label column.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.MutualInformationFeatureSelectionTransform), typeof(Microsoft.ML.Runtime.Data.MutualInformationFeatureSelectionTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Mutual Information Feature Selection Transform", new System.String[] { "MutualInformationFeatureSelection", "MutualInformationFeatureSelectionTransform", "MIFeatureSelection" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Removes NAs from vector columns.", typeof(Microsoft.ML.Runtime.Data.NADropTransform), typeof(Microsoft.ML.Runtime.Data.NADropTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "NA Drop Transform", new System.String[] { "NADrop", "NADropTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Removes NAs from vector columns.", typeof(Microsoft.ML.Runtime.Data.NADropTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "NA Drop Transform", new System.String[] { "NADropTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Handle missing values by replacing them with either the default value or the mean/min/max value (for non-text columns only). An indicator column can optionally be concatenated, if theinput column type is numeric.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.NAHandleTransform), typeof(Microsoft.ML.Runtime.Data.NAHandleTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "NA Handle Transform", new System.String[] { "NAHandleTransform", "NAHandle", "NA" }, DocName="transform/NAHandle.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.NAIndicatorTransform), typeof(Microsoft.ML.Runtime.Data.NAIndicatorTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "NA Indicator Transform", new System.String[] { "NAIndicatorTransform", "NAIndicator", "NAInd" }, DocName="transform/NAHandle.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.NAIndicatorTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "NA Indicator Transform", new System.String[] { "NaIndicatorTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Create an output column of the same type and size of the input column, where missing values are replaced with either the default value or the mean/min/max value (for non-text columns only).", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.NAReplaceTransform), typeof(Microsoft.ML.Runtime.Data.NAReplaceTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "NA Replace Transform", new System.String[] { "NAReplaceTransform", "NAReplace", "NARep" }, DocName="transform/NAHandle.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Create an output column of the same type and size of the input column, where missing values are replaced with either the default value or the mean/min/max value (for non-text columns only).", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.NAReplaceTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "NA Replace Transform", new System.String[] { "NAReplaceTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Create an output column of the same type and size of the input column, where missing values are replaced with either the default value or the mean/min/max value (for non-text columns only).", typeof(Microsoft.ML.Runtime.Data.NAReplaceTransform), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "NA Replace Transform", new System.String[] { "NAReplaceTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.IRowMapper), typeof(Microsoft.ML.Runtime.Data.NAReplaceTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadRowMapper), "NA Replace Transform", new System.String[] { "NAReplaceTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("If the source column does not exist after deserialization, create a column with the right type and default values.", typeof(Microsoft.ML.Runtime.DataPipe.OptionalColumnTransform), typeof(Microsoft.ML.Runtime.DataPipe.OptionalColumnTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Optional Column Transform", new System.String[] { "OptColTransform", "optional" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.DataPipe.OptionalColumnTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Optional Column Transform", new System.String[] { "OptColTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Produces a new column with the row ID.", typeof(Microsoft.ML.Runtime.Data.ProduceIdTransform), typeof(Microsoft.ML.Runtime.Data.ProduceIdTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "", new System.String[] { "ProduceIdTransform", "ProduceId" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Produces a new column with the row ID.", typeof(Microsoft.ML.Runtime.Data.ProduceIdTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Produce ID Transform", new System.String[] { "ProduceIdTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("This transform maps numeric vectors to a random low-dimensional feature space. It is useful when data has non-linear features, since the transform is designed so that the inner products of the transformed data are approximately equal to those in the feature space of a user specified shift-invariant kernel.", typeof(Microsoft.ML.Runtime.Data.RffTransform), typeof(Microsoft.ML.Runtime.Data.RffTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Random Fourier Features Transform", new System.String[] { "RffTransform", "Rff" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("This transform maps numeric vectors to a random low-dimensional feature space. It is useful when data has non-linear features, since the transform is designed so that the inner products of the transformed data are approximately equal to those in the feature space of a user specified shift-invariant kernel.", typeof(Microsoft.ML.Runtime.Data.RffTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Random Fourier Features Transform", new System.String[] { "RffTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Maps text values columns to new columns using a map dataset.", typeof(Microsoft.ML.Runtime.Data.TermLookupTransform), typeof(Microsoft.ML.Runtime.Data.TermLookupTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Term Lookup Transform", new System.String[] { "TermLookup", "Lookup", "LookupTransform", "TermLookupTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Maps text values columns to new columns using a map dataset.", typeof(Microsoft.ML.Runtime.Data.TermLookupTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Term Lookup Transform", new System.String[] { "TermLookupTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Character-oriented tokenizer where text is considered a sequence of characters.", typeof(Microsoft.ML.Runtime.TextAnalytics.CharTokenizeTransform), typeof(Microsoft.ML.Runtime.TextAnalytics.CharTokenizeTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Character Tokenizer Transform", new System.String[] { "CharTokenize", "CharToken" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.TextAnalytics.CharTokenizeTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Character Tokenizer Transform", new System.String[] { "CharToken" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.TextAnalytics.LdaTransform), typeof(Microsoft.ML.Runtime.TextAnalytics.LdaTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Latent Dirichlet Allocation Transform", new System.String[] { "LdaTransform", "LightLda" }, DocName="transform/LdaTransform.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.TextAnalytics.LdaTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Latent Dirichlet Allocation Transform", new System.String[] { "LdaTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.NgramHashTransform), typeof(Microsoft.ML.Runtime.Data.NgramHashTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Ngram Hash Transform", new System.String[] { "NgramHashTransform", "NgramHash" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.NgramHashTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Ngram Hash Transform", new System.String[] { "NgramHashTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Produces a bag of counts of ngrams (sequences of consecutive values of length 1-n) in a given vector of keys. It does so by building a dictionary of ngrams and using the id in the dictionary as the index in the bag.", typeof(Microsoft.ML.Runtime.Data.NgramTransform), typeof(Microsoft.ML.Runtime.Data.NgramTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Ngram Transform", new System.String[] { "NgramTransform", "Ngram" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Produces a bag of counts of ngrams (sequences of consecutive values of length 1-n) in a given vector of keys. It does so by building a dictionary of ngrams and using the id in the dictionary as the index in the bag.", typeof(Microsoft.ML.Runtime.Data.NgramTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Ngram Transform", new System.String[] { "NgramTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("A transform that turns a collection of text documents into numerical feature vectors. The feature vectors are normalized counts of (word and/or character) ngrams in a given tokenized text.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.TextAnalytics.SentimentAnalyzingTransform), typeof(Microsoft.ML.Runtime.TextAnalytics.SentimentAnalyzingTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Sentiment Analyzing Transform", new System.String[] { "SentimentAnalyzingTransform", "SentimentAnalyzer", "Senti" }, DocName="transform/SentimentAnalyzingTransform.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("A Stopword remover transform based on language-specific lists of stop words (most common words) from Office Named Entity Recognition project. The transform is usually applied after tokenizing text, so it compares individual tokens (case-insensitive comparison) to the stopwords.", typeof(Microsoft.ML.Runtime.TextAnalytics.StopWordsRemoverTransform), typeof(Microsoft.ML.Runtime.TextAnalytics.StopWordsRemoverTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Stopwords Remover Transform", new System.String[] { "StopWordsRemoverTransform", "StopWordsRemover", "StopWords" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("A Stopword remover transform based on language-specific lists of stop words (most common words) from Office Named Entity Recognition project. The transform is usually applied after tokenizing text, so it compares individual tokens (case-insensitive comparison) to the stopwords.", typeof(Microsoft.ML.Runtime.TextAnalytics.StopWordsRemoverTransform), null, typeof(Microsoft.ML.Runtime.TextAnalytics.SignatureStopWordsRemoverTransform), "Predefined Stopwords List Remover", new System.String[] { "PredefinedStopWordsRemoverTransform", "PredefinedStopWordsRemover", "PredefinedStopWords", "Predefined" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("A Stopword remover transform based on language-specific lists of stop words (most common words) from Office Named Entity Recognition project. The transform is usually applied after tokenizing text, so it compares individual tokens (case-insensitive comparison) to the stopwords.", typeof(Microsoft.ML.Runtime.TextAnalytics.StopWordsRemoverTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Stopwords Remover Transform", new System.String[] { "StopWordsTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("A Stopword remover transform based on a user-defined list of stopwords. The transform is usually applied after tokenizing text, so it compares individual tokens (case-insensitive comparison) to the stopwords.", typeof(Microsoft.ML.Runtime.TextAnalytics.CustomStopWordsRemoverTransform), typeof(Microsoft.ML.Runtime.TextAnalytics.CustomStopWordsRemoverTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Custom Stopwords Remover Transform", new System.String[] { "CustomStopWordsRemoverTransform", "CustomStopWords" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("A Stopword remover transform based on a user-defined list of stopwords. The transform is usually applied after tokenizing text, so it compares individual tokens (case-insensitive comparison) to the stopwords.", typeof(Microsoft.ML.Runtime.TextAnalytics.CustomStopWordsRemoverTransform), typeof(Microsoft.ML.Runtime.TextAnalytics.CustomStopWordsRemoverTransform/LoaderArguments), typeof(Microsoft.ML.Runtime.TextAnalytics.SignatureStopWordsRemoverTransform), "Custom Stopwords Remover Transform", new System.String[] { "CustomStopWordsRemoverTransform", "CustomStopWords", "Custom" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("A Stopword remover transform based on a user-defined list of stopwords. The transform is usually applied after tokenizing text, so it compares individual tokens (case-insensitive comparison) to the stopwords.", typeof(Microsoft.ML.Runtime.TextAnalytics.CustomStopWordsRemoverTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Custom Stopwords Remover Transform", new System.String[] { "CustomStopWords" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("A text normalization transform that allows normalizing text case, removing diacritical marks, punctuation marks and/or numbers. The transform operates on text input as well as vector of tokens/text (vector of ReadOnlyMemory).", typeof(Microsoft.ML.Runtime.TextAnalytics.TextNormalizerTransform), typeof(Microsoft.ML.Runtime.TextAnalytics.TextNormalizerTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Text Normalizer Transform", new System.String[] { "TextNormalizerTransform", "TextNormalizer", "TextNorm" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("A text normalization transform that allows normalizing text case, removing diacritical marks, punctuation marks and/or numbers. The transform operates on text input as well as vector of tokens/text (vector of ReadOnlyMemory).", typeof(Microsoft.ML.Runtime.TextAnalytics.TextNormalizerTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Text Normalizer Transform", new System.String[] { "TextNormalizerTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("A transform that turns a collection of text documents into numerical feature vectors. The feature vectors are normalized counts of (word and/or character) ngrams in a given tokenized text.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.TextTransform), typeof(Microsoft.ML.Runtime.Data.TextTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Text Transform", new System.String[] { "TextTransform", "Text" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("A transform that turns a collection of text documents into numerical feature vectors. The feature vectors are normalized counts of (word and/or character) ngrams in a given tokenized text.", typeof(Microsoft.ML.Core.Data.ITransformer), typeof(Microsoft.ML.Runtime.Data.TextTransform), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Text Transform", new System.String[] { "TextTransform", "Text" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Produces a bag of counts of ngrams (sequences of consecutive words of length 1-n) in a given text. It does so by building a dictionary of ngrams and using the id in the dictionary as the index in the bag.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.WordBagTransform), typeof(Microsoft.ML.Runtime.Data.WordBagTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Word Bag Transform", new System.String[] { "WordBagTransform", "WordBag" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("A transform that turns a collection of tokenized text ReadOnlyMemory, or vectors of keys into numerical feature vectors. The feature vectors are counts of ngrams (sequences of consecutive *tokens* -words or keys- of length 1-n).", typeof(Microsoft.ML.Runtime.Data.INgramExtractorFactory), typeof(Microsoft.ML.Runtime.Data.NgramExtractorTransform), typeof(Microsoft.ML.Runtime.Data.NgramExtractorTransform/NgramExtractorArguments), typeof(Microsoft.ML.Runtime.Data.SignatureNgramExtractorFactory), "Ngram Extractor Transform", new System.String[] { "NgramExtractorTransform", "Ngram", "NgramExtractor" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Word Embeddings transform is a text featurizer which converts vectors of text tokens into sentence vectors using a pre-trained model", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.WordEmbeddingsTransform), typeof(Microsoft.ML.Runtime.Data.WordEmbeddingsTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Word Embeddings Transform", new System.String[] { "WordEmbeddingsTransform", "WordEmbeddings" }, DocName="transform/WordEmbeddingsTransform.md")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Word Embeddings transform is a text featurizer which converts vectors of text tokens into sentence vectors using a pre-trained model", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.WordEmbeddingsTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Word Embeddings Transform", new System.String[] { "WordEmbeddingsTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.WordEmbeddingsTransform), null, typeof(Microsoft.ML.Runtime.Model.SignatureLoadModel), "Word Embeddings Transform", new System.String[] { "WordEmbeddingsTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass(typeof(Microsoft.ML.Runtime.Data.IRowMapper), typeof(Microsoft.ML.Runtime.Data.WordEmbeddingsTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadRowMapper), "Word Embeddings Transform", new System.String[] { "WordEmbeddingsTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Produces a bag of counts of ngrams (sequences of consecutive words of length 1-n) in a given text. It does so by hashing each ngram and using the hash value as the index in the bag.", typeof(Microsoft.ML.Runtime.Data.IDataTransform), typeof(Microsoft.ML.Runtime.Data.WordHashBagTransform), typeof(Microsoft.ML.Runtime.Data.WordHashBagTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Word Hash Bag Transform", new System.String[] { "WordHashBagTransform", "WordHashBag" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("A transform that turns a collection of tokenized text (vector of ReadOnlyMemory) into numerical feature vectors using the hashing trick.", typeof(Microsoft.ML.Runtime.Data.INgramExtractorFactory), typeof(Microsoft.ML.Runtime.Data.NgramHashExtractorTransform), typeof(Microsoft.ML.Runtime.Data.NgramHashExtractorTransform/NgramHashExtractorArguments), typeof(Microsoft.ML.Runtime.Data.SignatureNgramExtractorFactory), "Ngram Hash Extractor Transform", new System.String[] { "NgramHashExtractorTransform", "NgramHash", "NgramHashExtractor" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("The input to this transform is text, and the output is a vector of text containing the words (tokens) in the original text. The separator is space, but can be specified as any other character (or multiple characters) if needed.", typeof(Microsoft.ML.Runtime.Data.DelimitedTokenizeTransform), typeof(Microsoft.ML.Runtime.Data.DelimitedTokenizeTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Word Tokenizer Transform", new System.String[] { "WordTokenizeTransform", "DelimitedTokenizeTransform", "WordToken", "DelimitedTokenize", "Token" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("The input to this transform is text, and the output is a vector of text containing the words (tokens) in the original text. The separator is space, but can be specified as any other character (or multiple characters) if needed.", typeof(Microsoft.ML.Runtime.Data.DelimitedTokenizeTransform), typeof(Microsoft.ML.Runtime.Data.DelimitedTokenizeTransform/TokenizeArguments), typeof(Microsoft.ML.Runtime.Data.SignatureTokenizeTransform), "Word Tokenizer Transform", new System.String[] { "WordTokenizeTransform", "DelimitedTokenizeTransform", "WordToken", "DelimitedTokenize", "Token" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("The input to this transform is text, and the output is a vector of text containing the words (tokens) in the original text. The separator is space, but can be specified as any other character (or multiple characters) if needed.", typeof(Microsoft.ML.Runtime.Data.DelimitedTokenizeTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Word Tokenizer Transform", new System.String[] { "TokenizeTextTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Un-groups vector columns into sequences of rows, inverse of Group transform", typeof(Microsoft.ML.Runtime.Data.UngroupTransform), typeof(Microsoft.ML.Runtime.Data.UngroupTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Un-group Transform", new System.String[] { "Ungroup" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Un-groups vector columns into sequences of rows, inverse of Group transform", typeof(Microsoft.ML.Runtime.Data.UngroupTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Un-group Transform", new System.String[] { "UngroupTransform" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Apply PCA or ZCA whitening algorithm to the input.", typeof(Microsoft.ML.Runtime.Data.WhiteningTransform), typeof(Microsoft.ML.Runtime.Data.WhiteningTransform/Arguments), typeof(Microsoft.ML.Runtime.Data.SignatureDataTransform), "Whitening Transform", new System.String[] { "WhiteningTransform", "Whitening" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.ML.Runtime.LoadableClass("Apply PCA or ZCA whitening algorithm to the input.", typeof(Microsoft.ML.Runtime.Data.WhiteningTransform), null, typeof(Microsoft.ML.Runtime.Data.SignatureLoadDataTransform), "Whitening Transform", new System.String[] { "WhiteningTransform", "WhiteningFunction" })</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("0.6.27002.6")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("0.6.27002.6 @BuiltBy: dlab14-DDVSOWINAGE057 @Branch: release/preview @SrcCode: https://github.com/dotnet/machinelearning/tree/fbcac800001673d9d2b000a400e84f7a55c0c913+fbcac800001673d9d2b000a400e84f7a55c0c913")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 4b 86 c4 cb 78 54 9b 34 ba b6 1a 3b 18 00 e2 3b fe b5 b3 ec 39 00 74 04 15 36 a7 e3 cb d9 7f 5f 04 cf 0f 85 71 55 a8 92 8e aa 29 eb fd 11 cf bb ad 3b a7 0e fe a7 bd a3 22 6c 6a 8d 37 0a 4c d3 03 f7 14 48 6b 6e bc 22 59 85 a6 38 47 1e 6e f5 71 cc 92 a4 61 3c 00 b8 fa 65 d6 1c ce e0 cb e5 f3 63 30 c9 a0 1f 41 83 55 9f 1b ef 24 cc 29 17 c6 d9 13 e3 a5 41 33 3a 1d 05 d9 be d2 2b 38 cb ]</AssemblyPublicKey>
    </Assembly>
  </Assemblies>
  <Remarks>To be added.</Remarks>
  <Copyright>To be added.</Copyright>
  <Types>
    <Namespace Name="LotusIR">
    </Namespace>
    <Namespace Name="Microsoft.ML">
      <Type Name="BinaryClassificationContext" Kind="Class" />
      <Type Name="BinaryClassificationContext+BinaryClassificationTrainers" Kind="Class" />
      <Type Name="ClusteringContext" Kind="Class" />
      <Type Name="ClusteringContext+ClusteringTrainers" Kind="Class" />
      <Type Name="MulticlassClassificationContext" Kind="Class" />
      <Type Name="MulticlassClassificationContext+MulticlassClassificationTrainers" Kind="Class" />
      <Type Name="RegressionContext" Kind="Class" />
      <Type Name="RegressionContext+RegressionTrainers" Kind="Class" />
      <Type Name="TrainContextBase" Kind="Class" />
      <Type Name="TrainContextBase+ContextInstantiatorBase" Kind="Class" />
      <Type Name="TrainContextComponentUtils" Kind="Class" />
      <Type Name="TrainingStaticExtensions" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Core.Data">
      <Type Name="IDataReader`1" DisplayName="IDataReader&lt;TSource&gt;" Kind="Interface" />
      <Type Name="IDataReaderEstimator`2" DisplayName="IDataReaderEstimator&lt;TSource,TReader&gt;" Kind="Interface" />
      <Type Name="IEstimator`1" DisplayName="IEstimator&lt;TTransformer&gt;" Kind="Interface" />
      <Type Name="ITransformer" Kind="Interface" />
      <Type Name="SchemaException" Kind="Class" />
      <Type Name="SchemaShape" Kind="Class" />
      <Type Name="SchemaShape+Column" Kind="Class" />
      <Type Name="SchemaShape+Column+VectorKind" Kind="Enumeration" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Core.Prediction">
      <Type Name="TrainerEstimatorContext" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Data">
      <Type Name="ColumnCursorExtensions" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Legacy">
      <Type Name="ILearningPipelineDataStep" Kind="Interface" />
      <Type Name="ILearningPipelineItem" Kind="Interface" />
      <Type Name="ILearningPipelineLoader" Kind="Interface" />
      <Type Name="ILearningPipelinePredictorStep" Kind="Interface" />
      <Type Name="ILearningPipelineStep" Kind="Interface" />
      <Type Name="LearningPipeline" Kind="Class" />
      <Type Name="PredictionModel" Kind="Class" />
      <Type Name="PredictionModel`2" DisplayName="PredictionModel&lt;TInput,TOutput&gt;" Kind="Class" />
      <Type Name="ScorerPipelineStep" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Legacy.Data">
      <Type Name="CollectionDataSource" Kind="Class" />
      <Type Name="CustomTextLoader" Kind="Class" />
      <Type Name="CustomTextLoader+Output" Kind="Class" />
      <Type Name="DataKind" Kind="Enumeration" />
      <Type Name="DataViewReference" Kind="Class" />
      <Type Name="DataViewReference+Output" Kind="Class" />
      <Type Name="IDataViewArrayConverter" Kind="Class" />
      <Type Name="IDataViewArrayConverter+Output" Kind="Class" />
      <Type Name="KeyRange" Kind="Class" />
      <Type Name="PredictorModelArrayConverter" Kind="Class" />
      <Type Name="PredictorModelArrayConverter+Output" Kind="Class" />
      <Type Name="TextLoader" Kind="Class" />
      <Type Name="TextLoader+Output" Kind="Class" />
      <Type Name="TextLoaderArguments" Kind="Class" />
      <Type Name="TextLoaderColumn" Kind="Class" />
      <Type Name="TextLoaderRange" Kind="Class" />
      <Type Name="TransformModelArrayConverter" Kind="Class" />
      <Type Name="TransformModelArrayConverter+Output" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Legacy.Models">
      <Type Name="AnomalyDetectionEvaluator" Kind="Class" />
      <Type Name="AnomalyDetectionEvaluator+Output" Kind="Class" />
      <Type Name="AnomalyPipelineEnsemble" Kind="Class" />
      <Type Name="AnomalyPipelineEnsemble+Output" Kind="Class" />
      <Type Name="BinaryClassificationEvaluator" Kind="Class" />
      <Type Name="BinaryClassificationEvaluator+Output" Kind="Class" />
      <Type Name="BinaryClassificationMetrics" Kind="Class" />
      <Type Name="BinaryCrossValidator" Kind="Class" />
      <Type Name="BinaryCrossValidator+Output" Kind="Class" />
      <Type Name="BinaryEnsemble" Kind="Class" />
      <Type Name="BinaryEnsemble+Output" Kind="Class" />
      <Type Name="BinaryPipelineEnsemble" Kind="Class" />
      <Type Name="BinaryPipelineEnsemble+Output" Kind="Class" />
      <Type Name="CachingOptions" Kind="Enumeration" />
      <Type Name="ClassificationEvaluator" Kind="Class" />
      <Type Name="ClassificationEvaluator+Output" Kind="Class" />
      <Type Name="ClassificationMetrics" Kind="Class" />
      <Type Name="ClusterEvaluator" Kind="Class" />
      <Type Name="ClusterEvaluator+Output" Kind="Class" />
      <Type Name="ClusterMetrics" Kind="Class" />
      <Type Name="ConfusionMatrix" Kind="Class" />
      <Type Name="CrossValidationBinaryMacroSubGraphInput" Kind="Class" />
      <Type Name="CrossValidationBinaryMacroSubGraphOutput" Kind="Class" />
      <Type Name="CrossValidationMacroSubGraphInput" Kind="Class" />
      <Type Name="CrossValidationMacroSubGraphOutput" Kind="Class" />
      <Type Name="CrossValidationOutput`2" DisplayName="CrossValidationOutput&lt;TInput,TOutput&gt;" Kind="Class" />
      <Type Name="CrossValidationResultsCombiner" Kind="Class" />
      <Type Name="CrossValidationResultsCombiner+Output" Kind="Class" />
      <Type Name="CrossValidator" Kind="Class" />
      <Type Name="CrossValidator+Output" Kind="Class" />
      <Type Name="CrossValidatorDatasetSplitter" Kind="Class" />
      <Type Name="CrossValidatorDatasetSplitter+Output" Kind="Class" />
      <Type Name="DatasetTransformer" Kind="Class" />
      <Type Name="DatasetTransformer+Output" Kind="Class" />
      <Type Name="EnsembleCreatorClassifierCombiner" Kind="Enumeration" />
      <Type Name="EnsembleCreatorScoreCombiner" Kind="Enumeration" />
      <Type Name="EnsembleSummary" Kind="Class" />
      <Type Name="EnsembleSummary+Output" Kind="Class" />
      <Type Name="FixedPlattCalibrator" Kind="Class" />
      <Type Name="FixedPlattCalibrator+Output" Kind="Class" />
      <Type Name="MacroUtilsTrainerKinds" Kind="Enumeration" />
      <Type Name="MultiClassPipelineEnsemble" Kind="Class" />
      <Type Name="MultiClassPipelineEnsemble+Output" Kind="Class" />
      <Type Name="MultiOutputRegressionEvaluator" Kind="Class" />
      <Type Name="MultiOutputRegressionEvaluator+Output" Kind="Class" />
      <Type Name="NaiveCalibrator" Kind="Class" />
      <Type Name="NaiveCalibrator+Output" Kind="Class" />
      <Type Name="NormalizeOption" Kind="Enumeration" />
      <Type Name="OneVersusAll" Kind="Class" />
      <Type Name="OneVersusAll+Output" Kind="Class" />
      <Type Name="OneVersusAllMacroSubGraphOutput" Kind="Class" />
      <Type Name="OnnxConverter" Kind="Class" />
      <Type Name="OnnxConverter+Output" Kind="Class" />
      <Type Name="OvaModelCombiner" Kind="Class" />
      <Type Name="OvaModelCombiner+Output" Kind="Class" />
      <Type Name="PAVCalibrator" Kind="Class" />
      <Type Name="PAVCalibrator+Output" Kind="Class" />
      <Type Name="PipelineSweeper" Kind="Class" />
      <Type Name="PipelineSweeper+Output" Kind="Class" />
      <Type Name="PlattCalibrator" Kind="Class" />
      <Type Name="PlattCalibrator+Output" Kind="Class" />
      <Type Name="QuantileRegressionEvaluator" Kind="Class" />
      <Type Name="QuantileRegressionEvaluator+Output" Kind="Class" />
      <Type Name="RankerEvaluator" Kind="Class" />
      <Type Name="RankerEvaluator+Output" Kind="Class" />
      <Type Name="RegressionEnsemble" Kind="Class" />
      <Type Name="RegressionEnsemble+Output" Kind="Class" />
      <Type Name="RegressionEvaluator" Kind="Class" />
      <Type Name="RegressionEvaluator+Output" Kind="Class" />
      <Type Name="RegressionMetrics" Kind="Class" />
      <Type Name="RegressionPipelineEnsemble" Kind="Class" />
      <Type Name="RegressionPipelineEnsemble+Output" Kind="Class" />
      <Type Name="Summarizer" Kind="Class" />
      <Type Name="Summarizer+Output" Kind="Class" />
      <Type Name="SweepResultExtractor" Kind="Class" />
      <Type Name="SweepResultExtractor+Output" Kind="Class" />
      <Type Name="TrainTestBinaryEvaluator" Kind="Class" />
      <Type Name="TrainTestBinaryEvaluator+Output" Kind="Class" />
      <Type Name="TrainTestBinaryMacroSubGraphInput" Kind="Class" />
      <Type Name="TrainTestBinaryMacroSubGraphOutput" Kind="Class" />
      <Type Name="TrainTestEvaluator" Kind="Class" />
      <Type Name="TrainTestEvaluator+Output" Kind="Class" />
      <Type Name="TrainTestEvaluatorOutput`2" DisplayName="TrainTestEvaluatorOutput&lt;TInput,TOutput&gt;" Kind="Class" />
      <Type Name="TrainTestMacroSubGraphInput" Kind="Class" />
      <Type Name="TrainTestMacroSubGraphOutput" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Legacy.Trainers">
      <Type Name="AveragedPerceptronBinaryClassifier" Kind="Class" />
      <Type Name="AveragedPerceptronBinaryClassifier+Output" Kind="Class" />
      <Type Name="BoostedTreeArgsOptimizationAlgorithmType" Kind="Enumeration" />
      <Type Name="Bundle" Kind="Enumeration" />
      <Type Name="EnsembleBinaryClassifier" Kind="Class" />
      <Type Name="EnsembleBinaryClassifier+Output" Kind="Class" />
      <Type Name="EnsembleClassification" Kind="Class" />
      <Type Name="EnsembleClassification+Output" Kind="Class" />
      <Type Name="EnsembleRegression" Kind="Class" />
      <Type Name="EnsembleRegression+Output" Kind="Class" />
      <Type Name="FastForestBinaryClassifier" Kind="Class" />
      <Type Name="FastForestBinaryClassifier+Output" Kind="Class" />
      <Type Name="FastForestRegressor" Kind="Class" />
      <Type Name="FastForestRegressor+Output" Kind="Class" />
      <Type Name="FastTreeBinaryClassifier" Kind="Class" />
      <Type Name="FastTreeBinaryClassifier+Output" Kind="Class" />
      <Type Name="FastTreeRanker" Kind="Class" />
      <Type Name="FastTreeRanker+Output" Kind="Class" />
      <Type Name="FastTreeRegressor" Kind="Class" />
      <Type Name="FastTreeRegressor+Output" Kind="Class" />
      <Type Name="FastTreeTweedieRegressor" Kind="Class" />
      <Type Name="FastTreeTweedieRegressor+Output" Kind="Class" />
      <Type Name="FieldAwareFactorizationMachineBinaryClassifier" Kind="Class" />
      <Type Name="FieldAwareFactorizationMachineBinaryClassifier+Output" Kind="Class" />
      <Type Name="GeneralizedAdditiveModelBinaryClassifier" Kind="Class" />
      <Type Name="GeneralizedAdditiveModelBinaryClassifier+Output" Kind="Class" />
      <Type Name="GeneralizedAdditiveModelRegressor" Kind="Class" />
      <Type Name="GeneralizedAdditiveModelRegressor+Output" Kind="Class" />
      <Type Name="KMeansPlusPlusClusterer" Kind="Class" />
      <Type Name="KMeansPlusPlusClusterer+Output" Kind="Class" />
      <Type Name="KMeansPlusPlusTrainerInitAlgorithm" Kind="Enumeration" />
      <Type Name="LightGbmArgumentsEvalMetricType" Kind="Enumeration" />
      <Type Name="LightGbmBinaryClassifier" Kind="Class" />
      <Type Name="LightGbmBinaryClassifier+Output" Kind="Class" />
      <Type Name="LightGbmClassifier" Kind="Class" />
      <Type Name="LightGbmClassifier+Output" Kind="Class" />
      <Type Name="LightGbmRanker" Kind="Class" />
      <Type Name="LightGbmRanker+Output" Kind="Class" />
      <Type Name="LightGbmRegressor" Kind="Class" />
      <Type Name="LightGbmRegressor+Output" Kind="Class" />
      <Type Name="LinearSvmBinaryClassifier" Kind="Class" />
      <Type Name="LinearSvmBinaryClassifier+Output" Kind="Class" />
      <Type Name="LogisticRegressionBinaryClassifier" Kind="Class" />
      <Type Name="LogisticRegressionBinaryClassifier+Output" Kind="Class" />
      <Type Name="LogisticRegressionClassifier" Kind="Class" />
      <Type Name="LogisticRegressionClassifier+Output" Kind="Class" />
      <Type Name="NaiveBayesClassifier" Kind="Class" />
      <Type Name="NaiveBayesClassifier+Output" Kind="Class" />
      <Type Name="OnlineGradientDescentRegressor" Kind="Class" />
      <Type Name="OnlineGradientDescentRegressor+Output" Kind="Class" />
      <Type Name="OrdinaryLeastSquaresRegressor" Kind="Class" />
      <Type Name="OrdinaryLeastSquaresRegressor+Output" Kind="Class" />
      <Type Name="PcaAnomalyDetector" Kind="Class" />
      <Type Name="PcaAnomalyDetector+Output" Kind="Class" />
      <Type Name="PoissonRegressor" Kind="Class" />
      <Type Name="PoissonRegressor+Output" Kind="Class" />
      <Type Name="StochasticDualCoordinateAscentBinaryClassifier" Kind="Class" />
      <Type Name="StochasticDualCoordinateAscentBinaryClassifier+Output" Kind="Class" />
      <Type Name="StochasticDualCoordinateAscentClassifier" Kind="Class" />
      <Type Name="StochasticDualCoordinateAscentClassifier+Output" Kind="Class" />
      <Type Name="StochasticDualCoordinateAscentRegressor" Kind="Class" />
      <Type Name="StochasticDualCoordinateAscentRegressor+Output" Kind="Class" />
      <Type Name="StochasticGradientDescentBinaryClassifier" Kind="Class" />
      <Type Name="StochasticGradientDescentBinaryClassifier+Output" Kind="Class" />
      <Type Name="SymSgdBinaryClassifier" Kind="Class" />
      <Type Name="SymSgdBinaryClassifier+Output" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Legacy.Transforms">
      <Type Name="ApproximateBootstrapSampler" Kind="Class" />
      <Type Name="ApproximateBootstrapSampler+Output" Kind="Class" />
      <Type Name="BinaryPredictionScoreColumnsRenamer" Kind="Class" />
      <Type Name="BinaryPredictionScoreColumnsRenamer+Output" Kind="Class" />
      <Type Name="BinNormalizer" Kind="Class" />
      <Type Name="BinNormalizer+Output" Kind="Class" />
      <Type Name="CacheCachingType" Kind="Enumeration" />
      <Type Name="CategoricalHashOneHotVectorizer" Kind="Class" />
      <Type Name="CategoricalHashOneHotVectorizer+Output" Kind="Class" />
      <Type Name="CategoricalHashTransformColumn" Kind="Class" />
      <Type Name="CategoricalOneHotVectorizer" Kind="Class" />
      <Type Name="CategoricalOneHotVectorizer+Output" Kind="Class" />
      <Type Name="CategoricalTransformColumn" Kind="Class" />
      <Type Name="CategoricalTransformOutputKind" Kind="Enumeration" />
      <Type Name="CharacterTokenizer" Kind="Class" />
      <Type Name="CharacterTokenizer+Output" Kind="Class" />
      <Type Name="CharTokenizeTransformColumn" Kind="Class" />
      <Type Name="ColumnConcatenator" Kind="Class" />
      <Type Name="ColumnConcatenator+Output" Kind="Class" />
      <Type Name="ColumnCopier" Kind="Class" />
      <Type Name="ColumnCopier+Output" Kind="Class" />
      <Type Name="ColumnDropper" Kind="Class" />
      <Type Name="ColumnDropper+Output" Kind="Class" />
      <Type Name="ColumnSelector" Kind="Class" />
      <Type Name="ColumnSelector+Output" Kind="Class" />
      <Type Name="ColumnTypeConverter" Kind="Class" />
      <Type Name="ColumnTypeConverter+Output" Kind="Class" />
      <Type Name="CombinerByContiguousGroupId" Kind="Class" />
      <Type Name="CombinerByContiguousGroupId+Output" Kind="Class" />
      <Type Name="ConcatTransformColumn" Kind="Class" />
      <Type Name="ConditionalNormalizer" Kind="Class" />
      <Type Name="ConditionalNormalizer+Output" Kind="Class" />
      <Type Name="ConvertTransformColumn" Kind="Class" />
      <Type Name="CopyColumnsTransformColumn" Kind="Class" />
      <Type Name="DataCache" Kind="Class" />
      <Type Name="DataCache+Output" Kind="Class" />
      <Type Name="DatasetScorer" Kind="Class" />
      <Type Name="DatasetScorer+Output" Kind="Class" />
      <Type Name="DatasetTransformScorer" Kind="Class" />
      <Type Name="DatasetTransformScorer+Output" Kind="Class" />
      <Type Name="DelimitedTokenizeTransformColumn" Kind="Class" />
      <Type Name="Dictionarizer" Kind="Class" />
      <Type Name="Dictionarizer+Output" Kind="Class" />
      <Type Name="FeatureCombiner" Kind="Class" />
      <Type Name="FeatureCombiner+Output" Kind="Class" />
      <Type Name="FeatureSelectorByCount" Kind="Class" />
      <Type Name="FeatureSelectorByCount+Output" Kind="Class" />
      <Type Name="FeatureSelectorByMutualInformation" Kind="Class" />
      <Type Name="FeatureSelectorByMutualInformation+Output" Kind="Class" />
      <Type Name="GenerateNumberTransformColumn" Kind="Class" />
      <Type Name="GlobalContrastNormalizer" Kind="Class" />
      <Type Name="GlobalContrastNormalizer+Output" Kind="Class" />
      <Type Name="HashConverter" Kind="Class" />
      <Type Name="HashConverter+Output" Kind="Class" />
      <Type Name="HashJoinTransformColumn" Kind="Class" />
      <Type Name="ImageGrayscale" Kind="Class" />
      <Type Name="ImageGrayscale+Output" Kind="Class" />
      <Type Name="ImageGrayscaleTransformColumn" Kind="Class" />
      <Type Name="ImageLoader" Kind="Class" />
      <Type Name="ImageLoader+Output" Kind="Class" />
      <Type Name="ImageLoaderTransformColumn" Kind="Class" />
      <Type Name="ImagePixelExtractor" Kind="Class" />
      <Type Name="ImagePixelExtractor+Output" Kind="Class" />
      <Type Name="ImagePixelExtractorTransformColumn" Kind="Class" />
      <Type Name="ImageResizer" Kind="Class" />
      <Type Name="ImageResizer+Output" Kind="Class" />
      <Type Name="ImageResizerTransformAnchor" Kind="Enumeration" />
      <Type Name="ImageResizerTransformColumn" Kind="Class" />
      <Type Name="ImageResizerTransformResizingKind" Kind="Enumeration" />
      <Type Name="KeyToTextConverter" Kind="Class" />
      <Type Name="KeyToTextConverter+Output" Kind="Class" />
      <Type Name="KeyToValueTransformColumn" Kind="Class" />
      <Type Name="LabelColumnKeyBooleanConverter" Kind="Class" />
      <Type Name="LabelColumnKeyBooleanConverter+Output" Kind="Class" />
      <Type Name="LabelIndicator" Kind="Class" />
      <Type Name="LabelIndicator+Output" Kind="Class" />
      <Type Name="LabelIndicatorTransformColumn" Kind="Class" />
      <Type Name="LabelToFloatConverter" Kind="Class" />
      <Type Name="LabelToFloatConverter+Output" Kind="Class" />
      <Type Name="LdaTransformColumn" Kind="Class" />
      <Type Name="LightLda" Kind="Class" />
      <Type Name="LightLda+Output" Kind="Class" />
      <Type Name="LogMeanVarianceNormalizer" Kind="Class" />
      <Type Name="LogMeanVarianceNormalizer+Output" Kind="Class" />
      <Type Name="LpNormalizer" Kind="Class" />
      <Type Name="LpNormalizer+Output" Kind="Class" />
      <Type Name="LpNormNormalizerTransformColumn" Kind="Class" />
      <Type Name="LpNormNormalizerTransformGcnColumn" Kind="Class" />
      <Type Name="LpNormNormalizerTransformNormalizerKind" Kind="Enumeration" />
      <Type Name="ManyHeterogeneousModelCombiner" Kind="Class" />
      <Type Name="ManyHeterogeneousModelCombiner+Output" Kind="Class" />
      <Type Name="MeanVarianceNormalizer" Kind="Class" />
      <Type Name="MeanVarianceNormalizer+Output" Kind="Class" />
      <Type Name="MinMaxNormalizer" Kind="Class" />
      <Type Name="MinMaxNormalizer+Output" Kind="Class" />
      <Type Name="MissingValueHandler" Kind="Class" />
      <Type Name="MissingValueHandler+Output" Kind="Class" />
      <Type Name="MissingValueIndicator" Kind="Class" />
      <Type Name="MissingValueIndicator+Output" Kind="Class" />
      <Type Name="MissingValuesDropper" Kind="Class" />
      <Type Name="MissingValuesDropper+Output" Kind="Class" />
      <Type Name="MissingValuesRowDropper" Kind="Class" />
      <Type Name="MissingValuesRowDropper+Output" Kind="Class" />
      <Type Name="MissingValueSubstitutor" Kind="Class" />
      <Type Name="MissingValueSubstitutor+Output" Kind="Class" />
      <Type Name="ModelCombiner" Kind="Class" />
      <Type Name="ModelCombiner+Output" Kind="Class" />
      <Type Name="NADropTransformColumn" Kind="Class" />
      <Type Name="NAHandleTransformColumn" Kind="Class" />
      <Type Name="NAHandleTransformReplacementKind" Kind="Enumeration" />
      <Type Name="NAIndicatorTransformColumn" Kind="Class" />
      <Type Name="NAReplaceTransformColumn" Kind="Class" />
      <Type Name="NAReplaceTransformReplacementKind" Kind="Enumeration" />
      <Type Name="NgramTransformColumn" Kind="Class" />
      <Type Name="NgramTransformWeightingCriteria" Kind="Enumeration" />
      <Type Name="NGramTranslator" Kind="Class" />
      <Type Name="NGramTranslator+Output" Kind="Class" />
      <Type Name="NoOperation" Kind="Class" />
      <Type Name="NoOperation+Output" Kind="Class" />
      <Type Name="NormalizeTransformAffineColumn" Kind="Class" />
      <Type Name="NormalizeTransformBinColumn" Kind="Class" />
      <Type Name="NormalizeTransformLogNormalColumn" Kind="Class" />
      <Type Name="OptionalColumnCreator" Kind="Class" />
      <Type Name="OptionalColumnCreator+Output" Kind="Class" />
      <Type Name="PcaCalculator" Kind="Class" />
      <Type Name="PcaCalculator+Output" Kind="Class" />
      <Type Name="PcaTransformColumn" Kind="Class" />
      <Type Name="PredictedLabelColumnOriginalValueConverter" Kind="Class" />
      <Type Name="PredictedLabelColumnOriginalValueConverter+Output" Kind="Class" />
      <Type Name="RandomNumberGenerator" Kind="Class" />
      <Type Name="RandomNumberGenerator+Output" Kind="Class" />
      <Type Name="RowRangeFilter" Kind="Class" />
      <Type Name="RowRangeFilter+Output" Kind="Class" />
      <Type Name="RowSkipAndTakeFilter" Kind="Class" />
      <Type Name="RowSkipAndTakeFilter+Output" Kind="Class" />
      <Type Name="RowSkipFilter" Kind="Class" />
      <Type Name="RowSkipFilter+Output" Kind="Class" />
      <Type Name="RowTakeFilter" Kind="Class" />
      <Type Name="RowTakeFilter+Output" Kind="Class" />
      <Type Name="ScoreColumnSelector" Kind="Class" />
      <Type Name="ScoreColumnSelector+Output" Kind="Class" />
      <Type Name="Scorer" Kind="Class" />
      <Type Name="Scorer+Output" Kind="Class" />
      <Type Name="Segregator" Kind="Class" />
      <Type Name="Segregator+Output" Kind="Class" />
      <Type Name="SentimentAnalyzer" Kind="Class" />
      <Type Name="SentimentAnalyzer+Output" Kind="Class" />
      <Type Name="TensorFlowScorer" Kind="Class" />
      <Type Name="TensorFlowScorer+Output" Kind="Class" />
      <Type Name="TermLoaderArguments" Kind="Class" />
      <Type Name="TermTransformColumn" Kind="Class" />
      <Type Name="TermTransformSortOrder" Kind="Enumeration" />
      <Type Name="TextFeaturizer" Kind="Class" />
      <Type Name="TextFeaturizer+Output" Kind="Class" />
      <Type Name="TextNormalizerTransformCaseNormalizationMode" Kind="Enumeration" />
      <Type Name="TextToKeyConverter" Kind="Class" />
      <Type Name="TextToKeyConverter+Output" Kind="Class" />
      <Type Name="TextTransformColumn" Kind="Class" />
      <Type Name="TextTransformLanguage" Kind="Enumeration" />
      <Type Name="TextTransformTextNormKind" Kind="Enumeration" />
      <Type Name="TrainTestDatasetSplitter" Kind="Class" />
      <Type Name="TrainTestDatasetSplitter+Output" Kind="Class" />
      <Type Name="TreeLeafFeaturizer" Kind="Class" />
      <Type Name="TreeLeafFeaturizer+Output" Kind="Class" />
      <Type Name="TwoHeterogeneousModelCombiner" Kind="Class" />
      <Type Name="TwoHeterogeneousModelCombiner+Output" Kind="Class" />
      <Type Name="UngroupTransformUngroupMode" Kind="Enumeration" />
      <Type Name="VectorToImage" Kind="Class" />
      <Type Name="VectorToImage+Output" Kind="Class" />
      <Type Name="VectorToImageTransformColumn" Kind="Class" />
      <Type Name="WordEmbeddings" Kind="Class" />
      <Type Name="WordEmbeddings+Output" Kind="Class" />
      <Type Name="WordEmbeddingsTransformColumn" Kind="Class" />
      <Type Name="WordEmbeddingsTransformPretrainedModelKind" Kind="Enumeration" />
      <Type Name="WordTokenizer" Kind="Class" />
      <Type Name="WordTokenizer+Output" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Models">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime">
      <Type Name="AllFeatureSelectorEnsembleFeatureSelector" Kind="Class" />
      <Type Name="AllInstanceSelectorEnsembleSubsetSelector" Kind="Class" />
      <Type Name="AllSelectorEnsembleBinarySubModelSelector" Kind="Class" />
      <Type Name="AllSelectorEnsembleRegressionSubModelSelector" Kind="Class" />
      <Type Name="AllSelectorMultiClassEnsembleMulticlassSubModelSelector" Kind="Class" />
      <Type Name="AutoMlEngine" Kind="Class" />
      <Type Name="AutoMlStateAutoMlStateBase" Kind="Class" />
      <Type Name="AutoMlStateBase" Kind="Class" />
      <Type Name="AverageEnsembleBinaryOutputCombiner" Kind="Class" />
      <Type Name="AverageEnsembleRegressionOutputCombiner" Kind="Class" />
      <Type Name="BestDiverseSelectorEnsembleBinarySubModelSelector" Kind="Class" />
      <Type Name="BestDiverseSelectorMultiClassEnsembleMulticlassSubModelSelector" Kind="Class" />
      <Type Name="BestDiverseSelectorRegressionEnsembleRegressionSubModelSelector" Kind="Class" />
      <Type Name="BestPerformanceRegressionSelectorEnsembleRegressionSubModelSelector" Kind="Class" />
      <Type Name="BestPerformanceSelectorEnsembleBinarySubModelSelector" Kind="Class" />
      <Type Name="BestPerformanceSelectorMultiClassEnsembleMulticlassSubModelSelector" Kind="Class" />
      <Type Name="BinaryClassifierEvaluatorMetrics" Kind="Enumeration" />
      <Type Name="BoosterParameterFunction" Kind="Class" />
      <Type Name="BootstrapSelectorEnsembleSubsetSelector" Kind="Class" />
      <Type Name="CalibratorTrainer" Kind="Class" />
      <Type Name="ChannelMessage" Kind="Structure" />
      <Type Name="ChannelMessageKind" Kind="Enumeration" />
      <Type Name="ClassificationLossFunction" Kind="Class" />
      <Type Name="ComponentCatalog" Kind="Class" />
      <Type Name="ComponentCatalog+ComponentInfo" Kind="Class" />
      <Type Name="ComponentCatalog+EntryPointInfo" Kind="Class" />
      <Type Name="ComponentCatalog+LoadableClassInfo" Kind="Class" />
      <Type Name="ComponentFactoryUtils" Kind="Class" />
      <Type Name="ComponentKind" Kind="Class" />
      <Type Name="ComponentSerializer" Kind="Class" />
      <Type Name="Contracts" Kind="Class" />
      <Type Name="CustomStopWordsRemover" Kind="Class" />
      <Type Name="DartBoosterParameterFunction" Kind="Class" />
      <Type Name="DefaultsAutoMlEngine" Kind="Class" />
      <Type Name="DisagreementDiversityMeasureEnsembleBinaryDiversityMeasure" Kind="Class" />
      <Type Name="EarlyStoppingCriterion" Kind="Class" />
      <Type Name="EnsembleBinaryDiversityMeasure" Kind="Class" />
      <Type Name="EnsembleBinaryOutputCombiner" Kind="Class" />
      <Type Name="EnsembleBinarySubModelSelector" Kind="Class" />
      <Type Name="EnsembleFeatureSelector" Kind="Class" />
      <Type Name="EnsembleMulticlassDiversityMeasure" Kind="Class" />
      <Type Name="EnsembleMulticlassOutputCombiner" Kind="Class" />
      <Type Name="EnsembleMulticlassSubModelSelector" Kind="Class" />
      <Type Name="EnsembleRegressionDiversityMeasure" Kind="Class" />
      <Type Name="EnsembleRegressionOutputCombiner" Kind="Class" />
      <Type Name="EnsembleRegressionSubModelSelector" Kind="Class" />
      <Type Name="EnsembleSubsetSelector" Kind="Class" />
      <Type Name="EntryPointTrainerOutput" Kind="Class" />
      <Type Name="EntryPointTransformOutput" Kind="Class" />
      <Type Name="Experiment" Kind="Class" />
      <Type Name="ExperimentSerializer" Kind="Class" />
      <Type Name="ExperimentUtils" Kind="Class" />
      <Type Name="ExpLoss" Kind="Class" />
      <Type Name="ExpLoss+Arguments" Kind="Class" />
      <Type Name="ExpLossClassificationLossFunction" Kind="Class" />
      <Type Name="FastTreeBinaryClassificationFastTreeTrainer" Kind="Class" />
      <Type Name="FastTreeRankingFastTreeTrainer" Kind="Class" />
      <Type Name="FastTreeRegressionFastTreeTrainer" Kind="Class" />
      <Type Name="FastTreeTrainer" Kind="Class" />
      <Type Name="FastTreeTweedieRegressionFastTreeTrainer" Kind="Class" />
      <Type Name="FixedPlattCalibratorCalibratorTrainer" Kind="Class" />
      <Type Name="GbdtBoosterParameterFunction" Kind="Class" />
      <Type Name="GLEarlyStoppingCriterion" Kind="Class" />
      <Type Name="GossBoosterParameterFunction" Kind="Class" />
      <Type Name="HingeLoss" Kind="Class" />
      <Type Name="HingeLoss+Arguments" Kind="Class" />
      <Type Name="HingeLossClassificationLossFunction" Kind="Class" />
      <Type Name="HingeLossSDCAClassificationLossFunction" Kind="Class" />
      <Type Name="HostExtensions" Kind="Class" />
      <Type Name="IBulkDistributionPredictor`6" DisplayName="IBulkDistributionPredictor&lt;TFeatures,TFeaturesCollection,TResult,TResultCollection,TResultDistribution,TResultDistributionCollection&gt;" Kind="Interface" />
      <Type Name="IBulkPredictor`4" DisplayName="IBulkPredictor&lt;TFeatures,TFeaturesCollection,TResult,TResultCollection&gt;" Kind="Interface" />
      <Type Name="IChannel" Kind="Interface" />
      <Type Name="IChannelProvider" Kind="Interface" />
      <Type Name="IClassificationLoss" Kind="Interface" />
      <Type Name="IComponentFactory" Kind="Interface" />
      <Type Name="IComponentFactory`1" DisplayName="IComponentFactory&lt;TComponent&gt;" Kind="Interface" />
      <Type Name="IComponentFactory`2" DisplayName="IComponentFactory&lt;TArg1,TComponent&gt;" Kind="Interface" />
      <Type Name="IComponentFactory`3" DisplayName="IComponentFactory&lt;TArg1,TArg2,TComponent&gt;" Kind="Interface" />
      <Type Name="IComponentFactory`4" DisplayName="IComponentFactory&lt;TArg1,TArg2,TArg3,TComponent&gt;" Kind="Interface" />
      <Type Name="IDistPredictorProducing`2" DisplayName="IDistPredictorProducing&lt;TResult,TResultDistribution&gt;" Kind="Interface" />
      <Type Name="IDistributionPredictor`3" DisplayName="IDistributionPredictor&lt;TFeatures,TResult,TResultDistribution&gt;" Kind="Interface" />
      <Type Name="IExceptionContext" Kind="Interface" />
      <Type Name="IFileHandle" Kind="Interface" />
      <Type Name="IHost" Kind="Interface" />
      <Type Name="IHostEnvironment" Kind="Interface" />
      <Type Name="ILossFunction`2" DisplayName="ILossFunction&lt;TOutput,TLabel&gt;" Kind="Interface" />
      <Type Name="IModelCombiner`2" DisplayName="IModelCombiner&lt;TModel,TPredictor&gt;" Kind="Interface" />
      <Type Name="IParameterValue" Kind="Interface" />
      <Type Name="IParameterValue`1" DisplayName="IParameterValue&lt;TValue&gt;" Kind="Interface" />
      <Type Name="IPipe`1" DisplayName="IPipe&lt;TMessage&gt;" Kind="Interface" />
      <Type Name="IPredictionTransformer`1" DisplayName="IPredictionTransformer&lt;TModel&gt;" Kind="Interface" />
      <Type Name="IPredictor" Kind="Interface" />
      <Type Name="IPredictor`2" DisplayName="IPredictor&lt;TFeatures,TResult&gt;" Kind="Interface" />
      <Type Name="IPredictorProducing`1" DisplayName="IPredictorProducing&lt;TResult&gt;" Kind="Interface" />
      <Type Name="IProgressChannel" Kind="Interface" />
      <Type Name="IProgressChannelProvider" Kind="Interface" />
      <Type Name="IProgressEntry" Kind="Interface" />
      <Type Name="IRandom" Kind="Interface" />
      <Type Name="IRegressionLoss" Kind="Interface" />
      <Type Name="IRunResult" Kind="Interface" />
      <Type Name="IRunResult`1" DisplayName="IRunResult&lt;T&gt;" Kind="Interface" />
      <Type Name="IScalarOutputLoss" Kind="Interface" />
      <Type Name="ISingleFeaturePredictionTransformer`1" DisplayName="ISingleFeaturePredictionTransformer&lt;TModel&gt;" Kind="Interface" />
      <Type Name="ISupportClassificationLossFactory" Kind="Interface" />
      <Type Name="ISupportRegressionLossFactory" Kind="Interface" />
      <Type Name="ISupportSdcaClassificationLoss" Kind="Interface" />
      <Type Name="ISupportSdcaClassificationLossFactory" Kind="Interface" />
      <Type Name="ISupportSdcaLoss" Kind="Interface" />
      <Type Name="ISupportSdcaRegressionLoss" Kind="Interface" />
      <Type Name="ISupportSdcaRegressionLossFactory" Kind="Interface" />
      <Type Name="ISweeper" Kind="Interface" />
      <Type Name="ISweepResultEvaluator`1" DisplayName="ISweepResultEvaluator&lt;TResults&gt;" Kind="Interface" />
      <Type Name="IterationLimitedSearchTerminator" Kind="Class" />
      <Type Name="ITrainer" Kind="Interface" />
      <Type Name="ITrainer`1" DisplayName="ITrainer&lt;TPredictor&gt;" Kind="Interface" />
      <Type Name="ITrainerArguments" Kind="Interface" />
      <Type Name="IValueGenerator" Kind="Interface" />
      <Type Name="LoadableClassAttribute" Kind="Class" />
      <Type Name="LoadableClassAttributeBase" Kind="Class" />
      <Type Name="LogLoss" Kind="Class" />
      <Type Name="LogLossClassificationLossFunction" Kind="Class" />
      <Type Name="LogLossFactory" Kind="Class" />
      <Type Name="LogLossSDCAClassificationLossFunction" Kind="Class" />
      <Type Name="LPEarlyStoppingCriterion" Kind="Class" />
      <Type Name="MedianEnsembleBinaryOutputCombiner" Kind="Class" />
      <Type Name="MedianEnsembleRegressionOutputCombiner" Kind="Class" />
      <Type Name="MessageSensitivity" Kind="Enumeration" />
      <Type Name="MultiAverageEnsembleMulticlassOutputCombiner" Kind="Class" />
      <Type Name="MultiClassClassifierEvaluatorMetrics" Kind="Enumeration" />
      <Type Name="MultiDisagreementDiversityMeasureEnsembleMulticlassDiversityMeasure" Kind="Class" />
      <Type Name="MultiMedianEnsembleMulticlassOutputCombiner" Kind="Class" />
      <Type Name="MultiStackingEnsembleMulticlassOutputCombiner" Kind="Class" />
      <Type Name="MultiVotingEnsembleMulticlassOutputCombiner" Kind="Class" />
      <Type Name="MultiWeightageKind" Kind="Enumeration" />
      <Type Name="MultiWeightedAverageEnsembleMulticlassOutputCombiner" Kind="Class" />
      <Type Name="NaiveCalibratorCalibratorTrainer" Kind="Class" />
      <Type Name="NgramExtractor" Kind="Class" />
      <Type Name="NGramHashNgramExtractor" Kind="Class" />
      <Type Name="NGramNgramExtractor" Kind="Class" />
      <Type Name="ParallelLightGBM" Kind="Class" />
      <Type Name="ParallelTraining" Kind="Class" />
      <Type Name="ParameterSet" Kind="Class" />
      <Type Name="ParquetPathParserPartitionedPathParser" Kind="Class" />
      <Type Name="PartitionedFileLoaderColumn" Kind="Class" />
      <Type Name="PartitionedPathParser" Kind="Class" />
      <Type Name="PavCalibratorCalibratorTrainer" Kind="Class" />
      <Type Name="PipelineSweeperSupportedMetricsMetrics" Kind="Enumeration" />
      <Type Name="PlattCalibratorCalibratorTrainer" Kind="Class" />
      <Type Name="PoissonLoss" Kind="Class" />
      <Type Name="PoissonLossFactory" Kind="Class" />
      <Type Name="PoissonLossRegressionLossFunction" Kind="Class" />
      <Type Name="PQEarlyStoppingCriterion" Kind="Class" />
      <Type Name="PredefinedStopWordsRemover" Kind="Class" />
      <Type Name="PredictionKind" Kind="Enumeration" />
      <Type Name="ProgressHeader" Kind="Class" />
      <Type Name="QuantileStatistics" Kind="Class" />
      <Type Name="RandomFeatureSelectorEnsembleFeatureSelector" Kind="Class" />
      <Type Name="RandomPartitionSelectorEnsembleSubsetSelector" Kind="Class" />
      <Type Name="RandomUtils" Kind="Class" />
      <Type Name="RegressionDisagreementDiversityMeasureEnsembleRegressionDiversityMeasure" Kind="Class" />
      <Type Name="RegressionEvaluatorMetrics" Kind="Enumeration" />
      <Type Name="RegressionLossFunction" Kind="Class" />
      <Type Name="RegressionStackingEnsembleRegressionOutputCombiner" Kind="Class" />
      <Type Name="RocketAutoMlEngine" Kind="Class" />
      <Type Name="RunMetric" Kind="Class" />
      <Type Name="RunResult" Kind="Class" />
      <Type Name="SDCAClassificationLossFunction" Kind="Class" />
      <Type Name="SDCARegressionLossFunction" Kind="Class" />
      <Type Name="SearchTerminator" Kind="Class" />
      <Type Name="ServerChannel" Kind="Class" />
      <Type Name="ServerChannel+Bundle" Kind="Class" />
      <Type Name="ServerChannel+IPendingBundleNotification" Kind="Interface" />
      <Type Name="ServerChannel+IServer" Kind="Interface" />
      <Type Name="ServerChannel+IServerFactory" Kind="Interface" />
      <Type Name="ServerChannelUtilities" Kind="Class" />
      <Type Name="SignatureAnomalyDetectorTrainer" Kind="Delegate" />
      <Type Name="SignatureBinaryClassifierTrainer" Kind="Delegate" />
      <Type Name="SignatureClassificationLoss" Kind="Delegate" />
      <Type Name="SignatureClusteringTrainer" Kind="Delegate" />
      <Type Name="SignatureDefault" Kind="Delegate" />
      <Type Name="SignatureMatrixRecommendingTrainer" Kind="Delegate" />
      <Type Name="SignatureModelCombiner" Kind="Delegate" />
      <Type Name="SignatureMultiClassClassifierTrainer" Kind="Delegate" />
      <Type Name="SignatureMultiOutputRegressorTrainer" Kind="Delegate" />
      <Type Name="SignatureRankerTrainer" Kind="Delegate" />
      <Type Name="SignatureRegressionLoss" Kind="Delegate" />
      <Type Name="SignatureRegressorTrainer" Kind="Delegate" />
      <Type Name="SignatureSequenceTrainer" Kind="Delegate" />
      <Type Name="SignatureSuggestedSweepsParser" Kind="Delegate" />
      <Type Name="SignatureSweeper" Kind="Delegate" />
      <Type Name="SignatureSweepResultEvaluator" Kind="Delegate" />
      <Type Name="SignatureTrainer" Kind="Delegate" />
      <Type Name="SimpleFileHandle" Kind="Class" />
      <Type Name="SimplePathParserPartitionedPathParser" Kind="Class" />
      <Type Name="SingleParallelLightGBM" Kind="Class" />
      <Type Name="SingleParallelTraining" Kind="Class" />
      <Type Name="SmoothedHingeLoss" Kind="Class" />
      <Type Name="SmoothedHingeLoss+Arguments" Kind="Class" />
      <Type Name="SmoothedHingeLossClassificationLossFunction" Kind="Class" />
      <Type Name="SmoothedHingeLossSDCAClassificationLossFunction" Kind="Class" />
      <Type Name="SquaredLoss" Kind="Class" />
      <Type Name="SquaredLossFactory" Kind="Class" />
      <Type Name="SquaredLossRegressionLossFunction" Kind="Class" />
      <Type Name="SquaredLossSDCARegressionLossFunction" Kind="Class" />
      <Type Name="StackingEnsembleBinaryOutputCombiner" Kind="Class" />
      <Type Name="StopWordsRemover" Kind="Class" />
      <Type Name="SysRandom" Kind="Class" />
      <Type Name="TauswortheHybrid" Kind="Class" />
      <Type Name="TauswortheHybrid+State" Kind="Structure" />
      <Type Name="TelemetryException" Kind="Class" />
      <Type Name="TelemetryMessage" Kind="Class" />
      <Type Name="TelemetryMetric" Kind="Class" />
      <Type Name="TelemetryTrace" Kind="Class" />
      <Type Name="TrainContext" Kind="Class" />
      <Type Name="TrainerExtensions" Kind="Class" />
      <Type Name="TrainerInfo" Kind="Class" />
      <Type Name="TREarlyStoppingCriterion" Kind="Class" />
      <Type Name="TweedieLoss" Kind="Class" />
      <Type Name="TweedieLoss+Arguments" Kind="Class" />
      <Type Name="TweedieLossRegressionLossFunction" Kind="Class" />
      <Type Name="UniformRandomAutoMlEngine" Kind="Class" />
      <Type Name="UPEarlyStoppingCriterion" Kind="Class" />
      <Type Name="VotingEnsembleBinaryOutputCombiner" Kind="Class" />
      <Type Name="WeightageKind" Kind="Enumeration" />
      <Type Name="WeightedAverageEnsembleBinaryOutputCombiner" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Api">
      <Type Name="BatchPredictionEngine`2" DisplayName="BatchPredictionEngine&lt;TSrc,TDst&gt;" Kind="Class" />
      <Type Name="ColumnAttribute" Kind="Class" />
      <Type Name="ColumnNameAttribute" Kind="Class" />
      <Type Name="ComponentCreation" Kind="Class" />
      <Type Name="CursorChannelAttribute" Kind="Class" />
      <Type Name="CursoringUtils" Kind="Class" />
      <Type Name="GenerateCodeCommand" Kind="Class" />
      <Type Name="GenerateCodeCommand+Arguments" Kind="Class" />
      <Type Name="ICursorable`1" DisplayName="ICursorable&lt;TRow&gt;" Kind="Interface" />
      <Type Name="IRowBackedBy`1" DisplayName="IRowBackedBy&lt;TRow&gt;" Kind="Interface" />
      <Type Name="IRowCursor`1" DisplayName="IRowCursor&lt;TRow&gt;" Kind="Interface" />
      <Type Name="IRowReadableAs`1" DisplayName="IRowReadableAs&lt;TRow&gt;" Kind="Interface" />
      <Type Name="KeyTypeAttribute" Kind="Class" />
      <Type Name="LambdaTransform" Kind="Class" />
      <Type Name="LambdaTransform+LoadDelegate" Kind="Delegate" />
      <Type Name="MetadataInfo" Kind="Class" />
      <Type Name="MetadataInfo`1" DisplayName="MetadataInfo&lt;T&gt;" Kind="Class" />
      <Type Name="MetadataInfo`1+TElement" DisplayName="MetadataInfo&lt;T&gt;+TElement" Kind="Class" />
      <Type Name="NoColumnAttribute" Kind="Class" />
      <Type Name="PredictionEngine`2" DisplayName="PredictionEngine&lt;TSrc,TDst&gt;" Kind="Class" />
      <Type Name="Predictor" Kind="Class" />
      <Type Name="SchemaDefinition" Kind="Class" />
      <Type Name="SchemaDefinition+Column" Kind="Class" />
      <Type Name="SchemaDefinition+Direction" Kind="Enumeration" />
      <Type Name="SimplePredictionEngine" Kind="Class" />
      <Type Name="SimplePredictionEngine+Prediction" Kind="Class" />
      <Type Name="VectorTypeAttribute" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Command">
      <Type Name="ICommand" Kind="Interface" />
      <Type Name="SignatureCommand" Kind="Delegate" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.CommandLine">
      <Type Name="ArgumentAttribute" Kind="Class" />
      <Type Name="ArgumentAttribute+VisibilityType" Kind="Enumeration" />
      <Type Name="ArgumentType" Kind="Enumeration" />
      <Type Name="CharCursor" Kind="Class" />
      <Type Name="CmdLexer" Kind="Class" />
      <Type Name="CmdParser" Kind="Class" />
      <Type Name="CmdParser+ArgInfo" Kind="Class" />
      <Type Name="CmdParser+ArgInfo+Arg" Kind="Class" />
      <Type Name="CmdQuoter" Kind="Class" />
      <Type Name="DefaultArgumentAttribute" Kind="Class" />
      <Type Name="EnumValueDisplayAttribute" Kind="Class" />
      <Type Name="ErrorReporter" Kind="Delegate" />
      <Type Name="HideEnumValueAttribute" Kind="Class" />
      <Type Name="ICommandLineComponentFactory" Kind="Interface" />
      <Type Name="SettingsFlags" Kind="Enumeration" />
      <Type Name="SpecialPurpose" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Data">
      <Type Name="AffineNormSerializationUtils" Kind="Class" />
      <Type Name="AnomalyDetectionEvaluator" Kind="Class" />
      <Type Name="AnomalyDetectionEvaluator+Aggregator" Kind="Class" />
      <Type Name="AnomalyDetectionEvaluator+Aggregator+CountersBase" Kind="Class" />
      <Type Name="AnomalyDetectionEvaluator+Aggregator+CountersBase+Info" Kind="Structure" />
      <Type Name="AnomalyDetectionEvaluator+Arguments" Kind="Class" />
      <Type Name="AnomalyDetectionEvaluator+OverallMetrics" Kind="Class" />
      <Type Name="AnomalyDetectionEvaluator+TopKResultsColumns" Kind="Class" />
      <Type Name="AnomalyDetectionMamlEvaluator" Kind="Class" />
      <Type Name="AnomalyDetectionMamlEvaluator+Arguments" Kind="Class" />
      <Type Name="AnomalyPredictionTransformer`1" DisplayName="AnomalyPredictionTransformer&lt;TModel&gt;" Kind="Class" />
      <Type Name="AppendRowsDataView" Kind="Class" />
      <Type Name="ApplyTransformUtils" Kind="Class" />
      <Type Name="ArrayDataViewBuilder" Kind="Class" />
      <Type Name="BinaryClassifierEvaluator" Kind="Class" />
      <Type Name="BinaryClassifierEvaluator+Aggregator" Kind="Class" />
      <Type Name="BinaryClassifierEvaluator+Aggregator+Counters" Kind="Class" />
      <Type Name="BinaryClassifierEvaluator+Arguments" Kind="Class" />
      <Type Name="BinaryClassifierEvaluator+CalibratedResult" Kind="Class" />
      <Type Name="BinaryClassifierEvaluator+Metrics" Kind="Enumeration" />
      <Type Name="BinaryClassifierEvaluator+Result" Kind="Class" />
      <Type Name="BinaryClassifierMamlEvaluator" Kind="Class" />
      <Type Name="BinaryClassifierMamlEvaluator+Arguments" Kind="Class" />
      <Type Name="BinaryClassifierSchema" Kind="Class" />
      <Type Name="BinaryClassifierScorer" Kind="Class" />
      <Type Name="BinaryClassifierScorer+Arguments" Kind="Class" />
      <Type Name="BinaryPerInstanceEvaluator" Kind="Class" />
      <Type Name="BinaryPredictionTransformer`1" DisplayName="BinaryPredictionTransformer&lt;TModel&gt;" Kind="Class" />
      <Type Name="BindingsWrappedRowCursor" Kind="Class" />
      <Type Name="BinNormSerializationUtils" Kind="Class" />
      <Type Name="BoolType" Kind="Class" />
      <Type Name="BootstrapSample" Kind="Class" />
      <Type Name="BootstrapSampleTransform" Kind="Class" />
      <Type Name="BootstrapSampleTransform+Arguments" Kind="Class" />
      <Type Name="BufferBuilder`1" DisplayName="BufferBuilder&lt;T&gt;" Kind="Class" />
      <Type Name="CacheDataView" Kind="Class" />
      <Type Name="Categorical" Kind="Class" />
      <Type Name="CategoricalEstimator" Kind="Class" />
      <Type Name="CategoricalEstimator+ColumnInfo" Kind="Class" />
      <Type Name="CategoricalEstimator+Defaults" Kind="Class" />
      <Type Name="CategoricalHashTransform" Kind="Class" />
      <Type Name="CategoricalHashTransform+Arguments" Kind="Class" />
      <Type Name="CategoricalHashTransform+Column" Kind="Class" />
      <Type Name="CategoricalStaticExtensions" Kind="Class" />
      <Type Name="CategoricalStaticExtensions+OneHotScalarOutputKind" Kind="Enumeration" />
      <Type Name="CategoricalStaticExtensions+OneHotVectorOutputKind" Kind="Enumeration" />
      <Type Name="CategoricalTransform" Kind="Class" />
      <Type Name="CategoricalTransform+Arguments" Kind="Class" />
      <Type Name="CategoricalTransform+Column" Kind="Class" />
      <Type Name="CategoricalTransform+OutputKind" Kind="Enumeration" />
      <Type Name="CdfNormSerializationUtils" Kind="Class" />
      <Type Name="ChannelProviderBase" Kind="Class" />
      <Type Name="ChannelProviderBase+ExceptionContextKeys" Kind="Class" />
      <Type Name="ChooseColumnsByIndexTransform" Kind="Class" />
      <Type Name="ChooseColumnsByIndexTransform+Arguments" Kind="Class" />
      <Type Name="ChooseColumnsTransform" Kind="Class" />
      <Type Name="ChooseColumnsTransform+Arguments" Kind="Class" />
      <Type Name="ChooseColumnsTransform+Column" Kind="Class" />
      <Type Name="ChooseColumnsTransform+HiddenColumnOption" Kind="Enumeration" />
      <Type Name="ClusteringEvaluator" Kind="Class" />
      <Type Name="ClusteringEvaluator+Aggregator" Kind="Class" />
      <Type Name="ClusteringEvaluator+Aggregator+Counters" Kind="Class" />
      <Type Name="ClusteringEvaluator+Arguments" Kind="Class" />
      <Type Name="ClusteringEvaluator+Result" Kind="Class" />
      <Type Name="ClusteringMamlEvaluator" Kind="Class" />
      <Type Name="ClusteringMamlEvaluator+Arguments" Kind="Class" />
      <Type Name="ClusteringPerInstanceEvaluator" Kind="Class" />
      <Type Name="ClusteringPredictionTransformer`1" DisplayName="ClusteringPredictionTransformer&lt;TModel&gt;" Kind="Class" />
      <Type Name="ClusteringScorer" Kind="Class" />
      <Type Name="ClusteringScorer+Arguments" Kind="Class" />
      <Type Name="ColumnBindingsBase" Kind="Class" />
      <Type Name="ColumnInfo" Kind="Class" />
      <Type Name="ColumnMetadataInfo" Kind="Class" />
      <Type Name="ColumnParsingUtils" Kind="Class" />
      <Type Name="ColumnType" Kind="Class" />
      <Type Name="Combiner`1" DisplayName="Combiner&lt;T&gt;" Kind="Class" />
      <Type Name="CompositeDataLoader" Kind="Class" />
      <Type Name="CompositeDataLoader+Arguments" Kind="Class" />
      <Type Name="CompositeDataReader" Kind="Class" />
      <Type Name="CompositeDataReader`2" DisplayName="CompositeDataReader&lt;TSource,TLastTransformer&gt;" Kind="Class" />
      <Type Name="CompositeReaderEstimator`2" DisplayName="CompositeReaderEstimator&lt;TSource,TLastTransformer&gt;" Kind="Class" />
      <Type Name="CompositeRowToRowMapper" Kind="Class" />
      <Type Name="CompositeTransform" Kind="Class" />
      <Type Name="ConcatEstimator" Kind="Class" />
      <Type Name="ConcatStaticExtensions" Kind="Class" />
      <Type Name="ConcatStaticExtensions+ScalarOrVector`1" DisplayName="ConcatStaticExtensions+ScalarOrVector&lt;T&gt;" Kind="Class" />
      <Type Name="ConcatStaticExtensions+ScalarOrVectorOrVarVector`1" DisplayName="ConcatStaticExtensions+ScalarOrVectorOrVarVector&lt;T&gt;" Kind="Class" />
      <Type Name="ConcatTransform" Kind="Class" />
      <Type Name="ConcatTransform+Arguments" Kind="Class" />
      <Type Name="ConcatTransform+Column" Kind="Class" />
      <Type Name="ConcatTransform+ColumnInfo" Kind="Class" />
      <Type Name="ConcatTransform+TaggedArguments" Kind="Class" />
      <Type Name="ConcatTransform+TaggedColumn" Kind="Class" />
      <Type Name="ConsoleEnvironment" Kind="Class" />
      <Type Name="ConvertTransform" Kind="Class" />
      <Type Name="ConvertTransform+Arguments" Kind="Class" />
      <Type Name="ConvertTransform+Column" Kind="Class" />
      <Type Name="ConvertTransform+TypeInfoCommand" Kind="Class" />
      <Type Name="ConvertTransform+TypeInfoCommand+Arguments" Kind="Class" />
      <Type Name="CopyColumnsEstimator" Kind="Class" />
      <Type Name="CopyColumnsTransform" Kind="Class" />
      <Type Name="CopyColumnsTransform+Arguments" Kind="Class" />
      <Type Name="CopyColumnsTransform+Column" Kind="Class" />
      <Type Name="CountFeatureSelectionTransform" Kind="Class" />
      <Type Name="CountFeatureSelectionTransform+Arguments" Kind="Class" />
      <Type Name="CountFeatureSelectionUtils" Kind="Class" />
      <Type Name="CrossValidationCommand" Kind="Class" />
      <Type Name="CrossValidationCommand+Arguments" Kind="Class" />
      <Type Name="CursorState" Kind="Enumeration" />
      <Type Name="DataCommand" Kind="Class" />
      <Type Name="DataCommand+ArgumentsBase" Kind="Class" />
      <Type Name="DataCommand+ImplBase`1" DisplayName="DataCommand+ImplBase&lt;TArgs&gt;" Kind="Class" />
      <Type Name="DataKind" Kind="Enumeration" />
      <Type Name="DataKindExtensions" Kind="Class" />
      <Type Name="DataSaverUtils" Kind="Class" />
      <Type Name="DataViewUtils" Kind="Class" />
      <Type Name="DateTimeOffsetType" Kind="Class" />
      <Type Name="DateTimeType" Kind="Class" />
      <Type Name="DefaultColumnNames" Kind="Class" />
      <Type Name="DelimitedTokenizeTransform" Kind="Class" />
      <Type Name="DelimitedTokenizeTransform+Arguments" Kind="Class" />
      <Type Name="DelimitedTokenizeTransform+ArgumentsBase" Kind="Class" />
      <Type Name="DelimitedTokenizeTransform+Column" Kind="Class" />
      <Type Name="DelimitedTokenizeTransform+TokenizeArguments" Kind="Class" />
      <Type Name="DropColumnsTransform" Kind="Class" />
      <Type Name="DropColumnsTransform+Arguments" Kind="Class" />
      <Type Name="DropColumnsTransform+ArgumentsBase" Kind="Class" />
      <Type Name="DropColumnsTransform+KeepArguments" Kind="Class" />
      <Type Name="DropSlotsTransform" Kind="Class" />
      <Type Name="DropSlotsTransform+Arguments" Kind="Class" />
      <Type Name="DropSlotsTransform+Column" Kind="Class" />
      <Type Name="DropSlotsTransform+Range" Kind="Class" />
      <Type Name="EmptyDataView" Kind="Class" />
      <Type Name="EstimatorChain`1" DisplayName="EstimatorChain&lt;TLastTransformer&gt;" Kind="Class" />
      <Type Name="Evaluate" Kind="Class" />
      <Type Name="EvaluateCommand" Kind="Class" />
      <Type Name="EvaluateCommand+Arguments" Kind="Class" />
      <Type Name="EvaluateTransform" Kind="Class" />
      <Type Name="EvaluateTransform+Arguments" Kind="Class" />
      <Type Name="EvaluateUtils" Kind="Class" />
      <Type Name="EvaluateUtils+AggregatedMetric" Kind="Structure" />
      <Type Name="EvaluatorBase`1" DisplayName="EvaluatorBase&lt;TAgg&gt;" Kind="Class" />
      <Type Name="EvaluatorBase`1+AggregatorBase" DisplayName="EvaluatorBase&lt;TAgg&gt;+AggregatorBase" Kind="Class" />
      <Type Name="EvaluatorBase`1+AggregatorDictionaryBase" DisplayName="EvaluatorBase&lt;TAgg&gt;+AggregatorDictionaryBase" Kind="Class" />
      <Type Name="EvaluatorBase`1+AucAggregatorBase" DisplayName="EvaluatorBase&lt;TAgg&gt;+AucAggregatorBase" Kind="Class" />
      <Type Name="EvaluatorBase`1+AucAggregatorBase`1" DisplayName="EvaluatorBase&lt;TAgg&gt;+AucAggregatorBase&lt;T&gt;" Kind="Class" />
      <Type Name="EvaluatorBase`1+AuPrcAggregatorBase" DisplayName="EvaluatorBase&lt;TAgg&gt;+AuPrcAggregatorBase" Kind="Class" />
      <Type Name="EvaluatorBase`1+AuPrcAggregatorBase`1" DisplayName="EvaluatorBase&lt;TAgg&gt;+AuPrcAggregatorBase&lt;T&gt;" Kind="Class" />
      <Type Name="EvaluatorBase`1+UnweightedAucAggregator" DisplayName="EvaluatorBase&lt;TAgg&gt;+UnweightedAucAggregator" Kind="Class" />
      <Type Name="EvaluatorBase`1+UnweightedAuPrcAggregator" DisplayName="EvaluatorBase&lt;TAgg&gt;+UnweightedAuPrcAggregator" Kind="Class" />
      <Type Name="EvaluatorBase`1+UnweightedAuPrcAggregator+Info" DisplayName="EvaluatorBase&lt;TAgg&gt;+UnweightedAuPrcAggregator+Info" Kind="Structure" />
      <Type Name="EvaluatorBase`1+WeightedAucAggregator" DisplayName="EvaluatorBase&lt;TAgg&gt;+WeightedAucAggregator" Kind="Class" />
      <Type Name="EvaluatorBase`1+WeightedAucAggregator+AucInfo" DisplayName="EvaluatorBase&lt;TAgg&gt;+WeightedAucAggregator+AucInfo" Kind="Structure" />
      <Type Name="EvaluatorBase`1+WeightedAuPrcAggregator" DisplayName="EvaluatorBase&lt;TAgg&gt;+WeightedAuPrcAggregator" Kind="Class" />
      <Type Name="EvaluatorBase`1+WeightedAuPrcAggregator+Info" DisplayName="EvaluatorBase&lt;TAgg&gt;+WeightedAuPrcAggregator+Info" Kind="Structure" />
      <Type Name="EvaluatorStaticExtensions" Kind="Class" />
      <Type Name="ExtractorColumn" Kind="Class" />
      <Type Name="FileHandleSource" Kind="Class" />
      <Type Name="FilterBase" Kind="Class" />
      <Type Name="FloatAdder" Kind="Class" />
      <Type Name="GaussianFourierSampler" Kind="Class" />
      <Type Name="GaussianFourierSampler+Arguments" Kind="Class" />
      <Type Name="GenerateNumberTransform" Kind="Class" />
      <Type Name="GenerateNumberTransform+Arguments" Kind="Class" />
      <Type Name="GenerateNumberTransform+Column" Kind="Class" />
      <Type Name="GenericScorer" Kind="Class" />
      <Type Name="GenericScorer+Arguments" Kind="Class" />
      <Type Name="GroupingOperations" Kind="Class" />
      <Type Name="GroupTransform" Kind="Class" />
      <Type Name="GroupTransform+Arguments" Kind="Class" />
      <Type Name="GroupTransform+Cursor" Kind="Class" />
      <Type Name="HashJoin" Kind="Class" />
      <Type Name="HashJoinTransform" Kind="Class" />
      <Type Name="HashJoinTransform+Arguments" Kind="Class" />
      <Type Name="HashJoinTransform+Column" Kind="Class" />
      <Type Name="HashJoinTransform+ColumnInfoEx" Kind="Class" />
      <Type Name="HostEnvironmentBase`1" DisplayName="HostEnvironmentBase&lt;TEnv&gt;" Kind="Class" />
      <Type Name="HostEnvironmentBase`1+ChannelBase" DisplayName="HostEnvironmentBase&lt;TEnv&gt;+ChannelBase" Kind="Class" />
      <Type Name="HostEnvironmentBase`1+Dispatcher" DisplayName="HostEnvironmentBase&lt;TEnv&gt;+Dispatcher" Kind="Class" />
      <Type Name="HostEnvironmentBase`1+Dispatcher`1" DisplayName="HostEnvironmentBase&lt;TEnv&gt;+Dispatcher&lt;TMessage&gt;" Kind="Class" />
      <Type Name="HostEnvironmentBase`1+HostBase" DisplayName="HostEnvironmentBase&lt;TEnv&gt;+HostBase" Kind="Class" />
      <Type Name="HostEnvironmentBase`1+Pipe`1" DisplayName="HostEnvironmentBase&lt;TEnv&gt;+Pipe&lt;TMessage&gt;" Kind="Class" />
      <Type Name="HostEnvironmentBase`1+PipeBase`1" DisplayName="HostEnvironmentBase&lt;TEnv&gt;+PipeBase&lt;TMessage&gt;" Kind="Class" />
      <Type Name="IColumn" Kind="Interface" />
      <Type Name="IColumn`1" DisplayName="IColumn&lt;T&gt;" Kind="Interface" />
      <Type Name="IColumnAggregator`1" DisplayName="IColumnAggregator&lt;T&gt;" Kind="Interface" />
      <Type Name="ICounted" Kind="Interface" />
      <Type Name="ICursor" Kind="Interface" />
      <Type Name="IDataLoader" Kind="Interface" />
      <Type Name="IDataSaver" Kind="Interface" />
      <Type Name="IDataScorerTransform" Kind="Interface" />
      <Type Name="IDataTransform" Kind="Interface" />
      <Type Name="IDataView" Kind="Interface" />
      <Type Name="IEvaluator" Kind="Interface" />
      <Type Name="IFourierDistributionSampler" Kind="Interface" />
      <Type Name="IMamlEvaluator" Kind="Interface" />
      <Type Name="IManyToOneColumn" Kind="Interface" />
      <Type Name="IMessageDispatcher" Kind="Interface" />
      <Type Name="IMessageSource" Kind="Interface" />
      <Type Name="IMultiStreamSource" Kind="Interface" />
      <Type Name="INgramExtractorFactory" Kind="Interface" />
      <Type Name="INgramExtractorFactoryFactory" Kind="Interface" />
      <Type Name="InvertHashCollector`1" DisplayName="InvertHashCollector&lt;T&gt;" Kind="Class" />
      <Type Name="InvertHashUtils" Kind="Class" />
      <Type Name="IOneToOneColumn" Kind="Interface" />
      <Type Name="IPartitionedPathParser" Kind="Interface" />
      <Type Name="IPartitionedPathParserFactory" Kind="Interface" />
      <Type Name="IRow" Kind="Interface" />
      <Type Name="IRowCursor" Kind="Interface" />
      <Type Name="IRowCursorConsolidator" Kind="Interface" />
      <Type Name="IRowMapper" Kind="Interface" />
      <Type Name="IRowSeekable" Kind="Interface" />
      <Type Name="IRowSeeker" Kind="Interface" />
      <Type Name="IRowToRowMapper" Kind="Interface" />
      <Type Name="ISchema" Kind="Interface" />
      <Type Name="ISchemaBindableMapper" Kind="Interface" />
      <Type Name="ISchemaBoundMapper" Kind="Interface" />
      <Type Name="ISchemaBoundRowMapper" Kind="Interface" />
      <Type Name="ISchematized" Kind="Interface" />
      <Type Name="ISlotCursor" Kind="Interface" />
      <Type Name="ITokenizeTransform" Kind="Interface" />
      <Type Name="ITransformTemplate" Kind="Interface" />
      <Type Name="ITransposeDataView" Kind="Interface" />
      <Type Name="ITransposeSchema" Kind="Interface" />
      <Type Name="IValueMapper" Kind="Interface" />
      <Type Name="IValueMapperDist" Kind="Interface" />
      <Type Name="KeepColumnsTransform" Kind="Class" />
      <Type Name="KeyRange" Kind="Class" />
      <Type Name="KeyToBinaryVectorEstimator" Kind="Class" />
      <Type Name="KeyToBinaryVectorExtensions" Kind="Class" />
      <Type Name="KeyToBinaryVectorTransform" Kind="Class" />
      <Type Name="KeyToBinaryVectorTransform+Arguments" Kind="Class" />
      <Type Name="KeyToBinaryVectorTransform+ColumnInfo" Kind="Class" />
      <Type Name="KeyToValueEstimator" Kind="Class" />
      <Type Name="KeyToValueStaticExtensions" Kind="Class" />
      <Type Name="KeyToValueTransform" Kind="Class" />
      <Type Name="KeyToValueTransform+Arguments" Kind="Class" />
      <Type Name="KeyToValueTransform+Column" Kind="Class" />
      <Type Name="KeyToVectorEstimator" Kind="Class" />
      <Type Name="KeyToVectorEstimator+Defaults" Kind="Class" />
      <Type Name="KeyToVectorExtensions" Kind="Class" />
      <Type Name="KeyToVectorTransform" Kind="Class" />
      <Type Name="KeyToVectorTransform+Arguments" Kind="Class" />
      <Type Name="KeyToVectorTransform+Column" Kind="Class" />
      <Type Name="KeyToVectorTransform+ColumnBase" Kind="Class" />
      <Type Name="KeyToVectorTransform+ColumnInfo" Kind="Class" />
      <Type Name="KeyType" Kind="Class" />
      <Type Name="KeyValueOrder" Kind="Enumeration" />
      <Type Name="LabelConvertTransform" Kind="Class" />
      <Type Name="LabelConvertTransform+Arguments" Kind="Class" />
      <Type Name="LabelConvertTransform+Column" Kind="Class" />
      <Type Name="LabelIndicatorTransform" Kind="Class" />
      <Type Name="LabelIndicatorTransform+Arguments" Kind="Class" />
      <Type Name="LabelIndicatorTransform+Column" Kind="Class" />
      <Type Name="LambdaColumnMapper" Kind="Class" />
      <Type Name="LambdaFilter" Kind="Class" />
      <Type Name="LaplacianFourierSampler" Kind="Class" />
      <Type Name="LaplacianFourierSampler+Arguments" Kind="Class" />
      <Type Name="LearnerFeatureSelectionTransform" Kind="Class" />
      <Type Name="LearnerFeatureSelectionTransform+Arguments" Kind="Class" />
      <Type Name="LearningPipelineExtensions" Kind="Class" />
      <Type Name="LinkedRootCursorBase`1" DisplayName="LinkedRootCursorBase&lt;TInput&gt;" Kind="Class" />
      <Type Name="LinkedRowFilterCursorBase" Kind="Class" />
      <Type Name="LinkedRowRootCursorBase" Kind="Class" />
      <Type Name="LoaderUtils" Kind="Class" />
      <Type Name="LoadTransform" Kind="Class" />
      <Type Name="LoadTransform+Arguments" Kind="Class" />
      <Type Name="LocalEnvironment" Kind="Class" />
      <Type Name="LpNormalization" Kind="Class" />
      <Type Name="LpNormNormalizerTransform" Kind="Class" />
      <Type Name="LpNormNormalizerTransform+Arguments" Kind="Class" />
      <Type Name="LpNormNormalizerTransform+Column" Kind="Class" />
      <Type Name="LpNormNormalizerTransform+ColumnBase" Kind="Class" />
      <Type Name="LpNormNormalizerTransform+GcnArguments" Kind="Class" />
      <Type Name="LpNormNormalizerTransform+GcnColumn" Kind="Class" />
      <Type Name="LpNormNormalizerTransform+NormalizerKind" Kind="Enumeration" />
      <Type Name="MamlEvaluatorBase" Kind="Class" />
      <Type Name="MamlEvaluatorBase+ArgumentsBase" Kind="Class" />
      <Type Name="ManyToOneColumn" Kind="Class" />
      <Type Name="ManyToOneColumn`1" DisplayName="ManyToOneColumn&lt;T&gt;" Kind="Class" />
      <Type Name="ManyToOneColumnBindingsBase" Kind="Class" />
      <Type Name="ManyToOneColumnBindingsBase+ColInfo" Kind="Class" />
      <Type Name="MeanVarDblAggregator" Kind="Class" />
      <Type Name="MeanVarSngAggregator" Kind="Class" />
      <Type Name="MetadataDispatcher" Kind="Class" />
      <Type Name="MetadataDispatcher+Builder" Kind="Class" />
      <Type Name="MetadataDispatcherBase" Kind="Class" />
      <Type Name="MetadataDispatcherBase+ColInfo" Kind="Class" />
      <Type Name="MetadataDispatcherBase+GetterInfo" Kind="Class" />
      <Type Name="MetadataDispatcherBase+GetterInfo`1" DisplayName="MetadataDispatcherBase+GetterInfo&lt;TValue&gt;" Kind="Class" />
      <Type Name="MetadataDispatcherBase+GetterInfoDelegate`1" DisplayName="MetadataDispatcherBase+GetterInfoDelegate&lt;TValue&gt;" Kind="Class" />
      <Type Name="MetadataDispatcherBase+GetterInfoPrimitive`1" DisplayName="MetadataDispatcherBase+GetterInfoPrimitive&lt;TValue&gt;" Kind="Class" />
      <Type Name="MetadataInfo" Kind="Class" />
      <Type Name="MetadataInfo`1" DisplayName="MetadataInfo&lt;T&gt;" Kind="Class" />
      <Type Name="MetadataUtils" Kind="Class" />
      <Type Name="MetadataUtils+Const" Kind="Class" />
      <Type Name="MetadataUtils+Const+ScoreColumnKind" Kind="Class" />
      <Type Name="MetadataUtils+Const+ScoreValueKind" Kind="Class" />
      <Type Name="MetadataUtils+Kinds" Kind="Class" />
      <Type Name="MetadataUtils+MetadataGetter`1" DisplayName="MetadataUtils+MetadataGetter&lt;TValue&gt;" Kind="Delegate" />
      <Type Name="MetricColumn" Kind="Class" />
      <Type Name="MetricColumn+Objective" Kind="Enumeration" />
      <Type Name="MetricKinds" Kind="Class" />
      <Type Name="MetricKinds+ColumnNames" Kind="Class" />
      <Type Name="MetricWriter" Kind="Class" />
      <Type Name="MinMaxDblAggregator" Kind="Class" />
      <Type Name="MinMaxSngAggregator" Kind="Class" />
      <Type Name="MissingValueIndicatorTransform" Kind="Class" />
      <Type Name="MissingValueIndicatorTransform+Arguments" Kind="Class" />
      <Type Name="MissingValueIndicatorTransform+Column" Kind="Class" />
      <Type Name="MultiClassClassifierEvaluator" Kind="Class" />
      <Type Name="MultiClassClassifierEvaluator+Aggregator" Kind="Class" />
      <Type Name="MultiClassClassifierEvaluator+Aggregator+Counters" Kind="Class" />
      <Type Name="MultiClassClassifierEvaluator+Arguments" Kind="Class" />
      <Type Name="MultiClassClassifierEvaluator+Metrics" Kind="Enumeration" />
      <Type Name="MultiClassClassifierEvaluator+Result" Kind="Class" />
      <Type Name="MultiClassClassifierScorer" Kind="Class" />
      <Type Name="MultiClassClassifierScorer+Arguments" Kind="Class" />
      <Type Name="MultiClassClassifierScorer+LabelNameBindableMapper" Kind="Class" />
      <Type Name="MultiClassMamlEvaluator" Kind="Class" />
      <Type Name="MultiClassMamlEvaluator+Arguments" Kind="Class" />
      <Type Name="MultiClassPerInstanceEvaluator" Kind="Class" />
      <Type Name="MulticlassPredictionTransformer`1" DisplayName="MulticlassPredictionTransformer&lt;TModel&gt;" Kind="Class" />
      <Type Name="MultiFileSource" Kind="Class" />
      <Type Name="MultiOutputRegressionEvaluator" Kind="Class" />
      <Type Name="MultiOutputRegressionEvaluator+Aggregator" Kind="Class" />
      <Type Name="MultiOutputRegressionEvaluator+Aggregator+Counters" Kind="Class" />
      <Type Name="MultiOutputRegressionEvaluator+Arguments" Kind="Class" />
      <Type Name="MultiOutputRegressionMamlEvaluator" Kind="Class" />
      <Type Name="MultiOutputRegressionMamlEvaluator+Arguments" Kind="Class" />
      <Type Name="MultiOutputRegressionPerInstanceEvaluator" Kind="Class" />
      <Type Name="MutualInformationFeatureSelectionTransform" Kind="Class" />
      <Type Name="MutualInformationFeatureSelectionTransform+Arguments" Kind="Class" />
      <Type Name="MutualInformationFeatureSelectionTransform+Defaults" Kind="Class" />
      <Type Name="MutualInformationFeatureSelectionUtils" Kind="Class" />
      <Type Name="NADropTransform" Kind="Class" />
      <Type Name="NADropTransform+Arguments" Kind="Class" />
      <Type Name="NADropTransform+Column" Kind="Class" />
      <Type Name="NAFilter" Kind="Class" />
      <Type Name="NAFilter+Arguments" Kind="Class" />
      <Type Name="NAHandleTransform" Kind="Class" />
      <Type Name="NAHandleTransform+Arguments" Kind="Class" />
      <Type Name="NAHandleTransform+Column" Kind="Class" />
      <Type Name="NAHandleTransform+ReplacementKind" Kind="Enumeration" />
      <Type Name="NAHandling" Kind="Class" />
      <Type Name="NAIndicatorTransform" Kind="Class" />
      <Type Name="NAIndicatorTransform+Arguments" Kind="Class" />
      <Type Name="NAIndicatorTransform+Column" Kind="Class" />
      <Type Name="NAReplaceEstimator" Kind="Class" />
      <Type Name="NAReplaceEstimator+Defaults" Kind="Class" />
      <Type Name="NAReplaceExtensions" Kind="Class" />
      <Type Name="NAReplaceTransform" Kind="Class" />
      <Type Name="NAReplaceTransform+Arguments" Kind="Class" />
      <Type Name="NAReplaceTransform+Column" Kind="Class" />
      <Type Name="NAReplaceTransform+ColumnInfo" Kind="Class" />
      <Type Name="NAReplaceTransform+ColumnInfo+ReplacementMode" Kind="Enumeration" />
      <Type Name="NAReplaceTransform+ReplacementKind" Kind="Enumeration" />
      <Type Name="NgramExtractionUtils" Kind="Class" />
      <Type Name="NgramExtractorTransform" Kind="Class" />
      <Type Name="NgramExtractorTransform+Arguments" Kind="Class" />
      <Type Name="NgramExtractorTransform+ArgumentsBase" Kind="Class" />
      <Type Name="NgramExtractorTransform+Column" Kind="Class" />
      <Type Name="NgramExtractorTransform+NgramExtractorArguments" Kind="Class" />
      <Type Name="NgramHashExtractorTransform" Kind="Class" />
      <Type Name="NgramHashExtractorTransform+Arguments" Kind="Class" />
      <Type Name="NgramHashExtractorTransform+ArgumentsBase" Kind="Class" />
      <Type Name="NgramHashExtractorTransform+Column" Kind="Class" />
      <Type Name="NgramHashExtractorTransform+ColumnBase" Kind="Class" />
      <Type Name="NgramHashExtractorTransform+NgramHashExtractorArguments" Kind="Class" />
      <Type Name="NgramHashTransform" Kind="Class" />
      <Type Name="NgramHashTransform+Arguments" Kind="Class" />
      <Type Name="NgramHashTransform+Column" Kind="Class" />
      <Type Name="NgramTransform" Kind="Class" />
      <Type Name="NgramTransform+Arguments" Kind="Class" />
      <Type Name="NgramTransform+Column" Kind="Class" />
      <Type Name="NgramTransform+WeightingCriteria" Kind="Enumeration" />
      <Type Name="NopTransform" Kind="Class" />
      <Type Name="NopTransform+NopInput" Kind="Class" />
      <Type Name="Normalize" Kind="Class" />
      <Type Name="NormalizeOption" Kind="Enumeration" />
      <Type Name="Normalizer" Kind="Class" />
      <Type Name="Normalizer+BinningColumn" Kind="Class" />
      <Type Name="Normalizer+ColumnBase" Kind="Class" />
      <Type Name="Normalizer+FixZeroColumnBase" Kind="Class" />
      <Type Name="Normalizer+LogMeanVarColumn" Kind="Class" />
      <Type Name="Normalizer+MeanVarColumn" Kind="Class" />
      <Type Name="Normalizer+MinMaxColumn" Kind="Class" />
      <Type Name="Normalizer+NormalizerMode" Kind="Enumeration" />
      <Type Name="NormalizerStaticExtensions" Kind="Class" />
      <Type Name="NormalizerStaticExtensions+OnFitAffine`1" DisplayName="NormalizerStaticExtensions+OnFitAffine&lt;TData&gt;" Kind="Delegate" />
      <Type Name="NormalizerStaticExtensions+OnFitBinned`1" DisplayName="NormalizerStaticExtensions+OnFitBinned&lt;TData&gt;" Kind="Delegate" />
      <Type Name="NormalizerStaticExtensions+OnFitCumulativeDistribution`1" DisplayName="NormalizerStaticExtensions+OnFitCumulativeDistribution&lt;TData&gt;" Kind="Delegate" />
      <Type Name="NormalizerTransformer" Kind="Class" />
      <Type Name="NormalizeTransform" Kind="Class" />
      <Type Name="NormalizeTransform+AffineArgumentsBase" Kind="Class" />
      <Type Name="NormalizeTransform+AffineColumn" Kind="Class" />
      <Type Name="NormalizeTransform+ArgumentsBase" Kind="Class" />
      <Type Name="NormalizeTransform+BinArguments" Kind="Class" />
      <Type Name="NormalizeTransform+BinArgumentsBase" Kind="Class" />
      <Type Name="NormalizeTransform+BinColumn" Kind="Class" />
      <Type Name="NormalizeTransform+ColumnBase" Kind="Class" />
      <Type Name="NormalizeTransform+FixZeroArgumentsBase" Kind="Class" />
      <Type Name="NormalizeTransform+FixZeroColumnBase" Kind="Class" />
      <Type Name="NormalizeTransform+LogMeanVarArguments" Kind="Class" />
      <Type Name="NormalizeTransform+LogNormalColumn" Kind="Class" />
      <Type Name="NormalizeTransform+MeanVarArguments" Kind="Class" />
      <Type Name="NormalizeTransform+MinMaxArguments" Kind="Class" />
      <Type Name="NormalizeTransform+SupervisedBinArguments" Kind="Class" />
      <Type Name="NormalizeUtils" Kind="Class" />
      <Type Name="NumberType" Kind="Class" />
      <Type Name="OneToOneColumn" Kind="Class" />
      <Type Name="OneToOneColumn`1" DisplayName="OneToOneColumn&lt;T&gt;" Kind="Class" />
      <Type Name="OneToOneTransformBase" Kind="Class" />
      <Type Name="OneToOneTransformBase+ColInfo" Kind="Class" />
      <Type Name="OneToOneTransformerBase" Kind="Class" />
      <Type Name="OneToOneTransformerBase+MapperBase" Kind="Class" />
      <Type Name="OpaqueDataView" Kind="Class" />
      <Type Name="ParquetPartitionedPathParser" Kind="Class" />
      <Type Name="ParquetPartitionedPathParserFactory" Kind="Class" />
      <Type Name="PartitionedFileLoader" Kind="Class" />
      <Type Name="PartitionedFileLoader+Arguments" Kind="Class" />
      <Type Name="PartitionedFileLoader+Column" Kind="Class" />
      <Type Name="PartitionedPathParser" Kind="Delegate" />
      <Type Name="PcaEstimator" Kind="Class" />
      <Type Name="PcaEstimatorExtensions" Kind="Class" />
      <Type Name="PcaTransform" Kind="Class" />
      <Type Name="PcaTransform+Arguments" Kind="Class" />
      <Type Name="PcaTransform+Column" Kind="Class" />
      <Type Name="PerGroupTransformBase`3" DisplayName="PerGroupTransformBase&lt;TLabel,TScore,TState&gt;" Kind="Class" />
      <Type Name="PerGroupTransformBase`3+BindingsBase" DisplayName="PerGroupTransformBase&lt;TLabel,TScore,TState&gt;+BindingsBase" Kind="Class" />
      <Type Name="PerInstanceEvaluatorBase" Kind="Class" />
      <Type Name="PredictedLabelScorerBase" Kind="Class" />
      <Type Name="PredictedLabelScorerBase+BindingsImpl" Kind="Class" />
      <Type Name="PredictedLabelScorerBase+ThresholdArgumentsBase" Kind="Class" />
      <Type Name="PredictionFunction`2" DisplayName="PredictionFunction&lt;TSrc,TDst&gt;" Kind="Class" />
      <Type Name="PredictionFunctionExtensions" Kind="Class" />
      <Type Name="PredictionTransformerBase`2" DisplayName="PredictionTransformerBase&lt;TModel,TScorer&gt;" Kind="Class" />
      <Type Name="PrimitiveType" Kind="Class" />
      <Type Name="ProduceIdTransform" Kind="Class" />
      <Type Name="ProduceIdTransform+Arguments" Kind="Class" />
      <Type Name="ProgressReporting" Kind="Class" />
      <Type Name="ProgressReporting+ProgressChannel" Kind="Class" />
      <Type Name="ProgressReporting+ProgressEntry" Kind="Class" />
      <Type Name="ProgressReporting+ProgressEvent" Kind="Class" />
      <Type Name="ProgressReporting+ProgressEvent+EventKind" Kind="Enumeration" />
      <Type Name="ProgressReporting+ProgressTracker" Kind="Class" />
      <Type Name="QuantileRegressionEvaluator" Kind="Class" />
      <Type Name="QuantileRegressionEvaluator+Aggregator" Kind="Class" />
      <Type Name="QuantileRegressionEvaluator+Arguments" Kind="Class" />
      <Type Name="QuantileRegressionMamlEvaluator" Kind="Class" />
      <Type Name="QuantileRegressionMamlEvaluator+Arguments" Kind="Class" />
      <Type Name="QuantileRegressionPerInstanceEvaluator" Kind="Class" />
      <Type Name="QuantileRegressionScorerTransform" Kind="Class" />
      <Type Name="QuantileRegressionScorerTransform+Arguments" Kind="Class" />
      <Type Name="R4Adder" Kind="Class" />
      <Type Name="R8Adder" Kind="Class" />
      <Type Name="RandomNumberGenerator" Kind="Class" />
      <Type Name="RangeFilter" Kind="Class" />
      <Type Name="RangeFilter+Arguments" Kind="Class" />
      <Type Name="RankerEvaluator" Kind="Class" />
      <Type Name="RankerEvaluator+Aggregator" Kind="Class" />
      <Type Name="RankerEvaluator+Aggregator+Counters" Kind="Class" />
      <Type Name="RankerEvaluator+Arguments" Kind="Class" />
      <Type Name="RankerMamlEvaluator" Kind="Class" />
      <Type Name="RankerMamlEvaluator+Arguments" Kind="Class" />
      <Type Name="RankerPerInstanceTransform" Kind="Class" />
      <Type Name="RankingPredictionTransformer`1" DisplayName="RankingPredictionTransformer&lt;TModel&gt;" Kind="Class" />
      <Type Name="ReadOnlyMemoryUtils" Kind="Class" />
      <Type Name="RefPredicate`1" DisplayName="RefPredicate&lt;T&gt;" Kind="Delegate" />
      <Type Name="RegressionEvaluator" Kind="Class" />
      <Type Name="RegressionEvaluator+Aggregator" Kind="Class" />
      <Type Name="RegressionEvaluator+Arguments" Kind="Class" />
      <Type Name="RegressionEvaluator+Metrics" Kind="Enumeration" />
      <Type Name="RegressionEvaluator+Result" Kind="Class" />
      <Type Name="RegressionEvaluatorBase`3" DisplayName="RegressionEvaluatorBase&lt;TAgg,TScore,TMetrics&gt;" Kind="Class" />
      <Type Name="RegressionEvaluatorBase`3+RegressionAggregatorBase" DisplayName="RegressionEvaluatorBase&lt;TAgg,TScore,TMetrics&gt;+RegressionAggregatorBase" Kind="Class" />
      <Type Name="RegressionEvaluatorBase`3+RegressionAggregatorBase+CountersBase" DisplayName="RegressionEvaluatorBase&lt;TAgg,TScore,TMetrics&gt;+RegressionAggregatorBase+CountersBase" Kind="Class" />
      <Type Name="RegressionLossEvaluatorBase`1" DisplayName="RegressionLossEvaluatorBase&lt;TAgg&gt;" Kind="Class" />
      <Type Name="RegressionLossEvaluatorBase`1+ArgumentsBase" DisplayName="RegressionLossEvaluatorBase&lt;TAgg&gt;+ArgumentsBase" Kind="Class" />
      <Type Name="RegressionMamlEvaluator" Kind="Class" />
      <Type Name="RegressionMamlEvaluator+Arguments" Kind="Class" />
      <Type Name="RegressionPerInstanceEvaluator" Kind="Class" />
      <Type Name="RegressionPredictionTransformer`1" DisplayName="RegressionPredictionTransformer&lt;TModel&gt;" Kind="Class" />
      <Type Name="RffTransform" Kind="Class" />
      <Type Name="RffTransform+Arguments" Kind="Class" />
      <Type Name="RffTransform+Column" Kind="Class" />
      <Type Name="RoleMappedData" Kind="Class" />
      <Type Name="RoleMappedSchema" Kind="Class" />
      <Type Name="RoleMappedSchema+ColumnRole" Kind="Structure" />
      <Type Name="RootCursorBase" Kind="Class" />
      <Type Name="RowColumnUtils" Kind="Class" />
      <Type Name="RowColumnUtils+DefaultCounted" Kind="Class" />
      <Type Name="RowColumnUtils+MetadataRow" Kind="Class" />
      <Type Name="RowCursorUtils" Kind="Class" />
      <Type Name="RowMapperColumnInfo" Kind="Class" />
      <Type Name="RowToRowEvaluatorBase`1" DisplayName="RowToRowEvaluatorBase&lt;TAgg&gt;" Kind="Class" />
      <Type Name="RowToRowMapperTransform" Kind="Class" />
      <Type Name="RowToRowMapperTransformBase" Kind="Class" />
      <Type Name="RowToRowScorerBase" Kind="Class" />
      <Type Name="RowToRowScorerBase+BindingsBase" Kind="Class" />
      <Type Name="RowToRowScorerBase+RowCursor" Kind="Class" />
      <Type Name="RowToRowTransformBase" Kind="Class" />
      <Type Name="SaveDataCommand" Kind="Class" />
      <Type Name="SaveDataCommand+Arguments" Kind="Class" />
      <Type Name="SchemaBindableBinaryPredictorWrapper" Kind="Class" />
      <Type Name="SchemaBindablePredictorWrapper" Kind="Class" />
      <Type Name="SchemaBindablePredictorWrapperBase" Kind="Class" />
      <Type Name="SchemaBindablePredictorWrapperBase+SingleValueRowMapper" Kind="Class" />
      <Type Name="SchemaBindableQuantileRegressionPredictor" Kind="Class" />
      <Type Name="ScoreCommand" Kind="Class" />
      <Type Name="ScoreCommand+Arguments" Kind="Class" />
      <Type Name="ScoreMapperSchema" Kind="Class" />
      <Type Name="ScoreMapperSchemaBase" Kind="Class" />
      <Type Name="ScorerArgumentsBase" Kind="Class" />
      <Type Name="ScorerBindingsBase" Kind="Class" />
      <Type Name="ScoreTransform" Kind="Class" />
      <Type Name="ScoreTransform+Arguments" Kind="Class" />
      <Type Name="ScoreUtils" Kind="Class" />
      <Type Name="SequencePredictorSchema" Kind="Class" />
      <Type Name="ShowDataCommand" Kind="Class" />
      <Type Name="ShowDataCommand+Arguments" Kind="Class" />
      <Type Name="ShowSchemaCommand" Kind="Class" />
      <Type Name="ShowSchemaCommand+Arguments" Kind="Class" />
      <Type Name="ShuffleTransform" Kind="Class" />
      <Type Name="ShuffleTransform+Arguments" Kind="Class" />
      <Type Name="SignatureBindableMapper" Kind="Delegate" />
      <Type Name="SignatureDataLoader" Kind="Delegate" />
      <Type Name="SignatureDataSaver" Kind="Delegate" />
      <Type Name="SignatureDataScorer" Kind="Delegate" />
      <Type Name="SignatureDataTransform" Kind="Delegate" />
      <Type Name="SignatureEvaluator" Kind="Delegate" />
      <Type Name="SignatureFourierDistributionSampler" Kind="Delegate" />
      <Type Name="SignatureLoadColumnFunction" Kind="Delegate" />
      <Type Name="SignatureLoadDataLoader" Kind="Delegate" />
      <Type Name="SignatureLoadDataTransform" Kind="Delegate" />
      <Type Name="SignatureLoadRowMapper" Kind="Delegate" />
      <Type Name="SignatureMamlEvaluator" Kind="Delegate" />
      <Type Name="SignatureNgramExtractorFactory" Kind="Delegate" />
      <Type Name="SignatureTokenizeTransform" Kind="Delegate" />
      <Type Name="SimplePartitionedPathParser" Kind="Class" />
      <Type Name="SimplePartitionedPathParser+Arguments" Kind="Class" />
      <Type Name="SimpleRow" Kind="Class" />
      <Type Name="SimpleSchema" Kind="Class" />
      <Type Name="SimpleSchemaBase" Kind="Class" />
      <Type Name="SingleFeaturePredictionTransformerBase`2" DisplayName="SingleFeaturePredictionTransformerBase&lt;TModel,TScorer&gt;" Kind="Class" />
      <Type Name="SkipFilter" Kind="Class" />
      <Type Name="SkipTakeFilter" Kind="Class" />
      <Type Name="SkipTakeFilter+Arguments" Kind="Class" />
      <Type Name="SkipTakeFilter+SkipArguments" Kind="Class" />
      <Type Name="SkipTakeFilter+TakeArguments" Kind="Class" />
      <Type Name="SourceNameColumnBase" Kind="Class" />
      <Type Name="StructuredType" Kind="Class" />
      <Type Name="SynchronizedCursorBase`1" DisplayName="SynchronizedCursorBase&lt;TBase&gt;" Kind="Class" />
      <Type Name="TakeFilter" Kind="Class" />
      <Type Name="TermEstimator" Kind="Class" />
      <Type Name="TermEstimator+Defaults" Kind="Class" />
      <Type Name="TermLoaderArguments" Kind="Class" />
      <Type Name="TermLookupTransform" Kind="Class" />
      <Type Name="TermLookupTransform+Arguments" Kind="Class" />
      <Type Name="TermLookupTransform+Column" Kind="Class" />
      <Type Name="TermStaticExtensions" Kind="Class" />
      <Type Name="TermTransform" Kind="Class" />
      <Type Name="TermTransform+Arguments" Kind="Class" />
      <Type Name="TermTransform+ArgumentsBase" Kind="Class" />
      <Type Name="TermTransform+Column" Kind="Class" />
      <Type Name="TermTransform+ColumnBase" Kind="Class" />
      <Type Name="TermTransform+ColumnInfo" Kind="Class" />
      <Type Name="TermTransform+SortOrder" Kind="Enumeration" />
      <Type Name="TermTransform+TermMap" Kind="Class" />
      <Type Name="TermTransform+TermMap`1" DisplayName="TermTransform+TermMap&lt;T&gt;" Kind="Class" />
      <Type Name="TermTransform+TermMap+HashArrayImpl`1" DisplayName="TermTransform+TermMap+HashArrayImpl&lt;T&gt;" Kind="Class" />
      <Type Name="TermTransform+TermMap+TextImpl" Kind="Class" />
      <Type Name="TestCommand" Kind="Class" />
      <Type Name="TestCommand+Arguments" Kind="Class" />
      <Type Name="TextCombiner" Kind="Class" />
      <Type Name="TextFeaturizerStaticPipe" Kind="Class" />
      <Type Name="TextLoader" Kind="Class" />
      <Type Name="TextLoader+Arguments" Kind="Class" />
      <Type Name="TextLoader+ArgumentsCore" Kind="Class" />
      <Type Name="TextLoader+Column" Kind="Class" />
      <Type Name="TextLoader+Context" Kind="Class" />
      <Type Name="TextLoader+Range" Kind="Class" />
      <Type Name="TextModelHelper" Kind="Class" />
      <Type Name="TextTransform" Kind="Class" />
      <Type Name="TextTransform+Arguments" Kind="Class" />
      <Type Name="TextTransform+Column" Kind="Class" />
      <Type Name="TextTransform+Language" Kind="Enumeration" />
      <Type Name="TextTransform+Settings" Kind="Class" />
      <Type Name="TextTransform+TextNormKind" Kind="Enumeration" />
      <Type Name="TextType" Kind="Class" />
      <Type Name="TimeSpanType" Kind="Class" />
      <Type Name="ToKeyFitResult`1" DisplayName="ToKeyFitResult&lt;T&gt;" Kind="Class" />
      <Type Name="ToKeyFitResult`1+OnFit" DisplayName="ToKeyFitResult&lt;T&gt;+OnFit" Kind="Delegate" />
      <Type Name="TrainAndScoreTransform" Kind="Class" />
      <Type Name="TrainAndScoreTransform+Arguments" Kind="Class" />
      <Type Name="TrainAndScoreTransform+ArgumentsBase" Kind="Class" />
      <Type Name="TrainCommand" Kind="Class" />
      <Type Name="TrainCommand+Arguments" Kind="Class" />
      <Type Name="TrainedWrapperEstimatorBase" Kind="Class" />
      <Type Name="TrainTestCommand" Kind="Class" />
      <Type Name="TrainTestCommand+Arguments" Kind="Class" />
      <Type Name="TrainUtils" Kind="Class" />
      <Type Name="TransformBase" Kind="Class" />
      <Type Name="TransformerChain" Kind="Class" />
      <Type Name="TransformerChain`1" DisplayName="TransformerChain&lt;TLastTransformer&gt;" Kind="Class" />
      <Type Name="TransformerScope" Kind="Enumeration" />
      <Type Name="TransformWrapper" Kind="Class" />
      <Type Name="Transposer" Kind="Class" />
      <Type Name="TransposerUtils" Kind="Class" />
      <Type Name="TransposerUtils+SlotDataView" Kind="Class" />
      <Type Name="TreeEnsembleFeaturizerBindableMapper" Kind="Class" />
      <Type Name="TreeEnsembleFeaturizerBindableMapper+Arguments" Kind="Class" />
      <Type Name="TreeEnsembleFeaturizerBindableMapper+OutputColumnNames" Kind="Class" />
      <Type Name="TreeEnsembleFeaturizerTransform" Kind="Class" />
      <Type Name="TreeEnsembleFeaturizerTransform+Arguments" Kind="Class" />
      <Type Name="TreeEnsembleFeaturizerTransform+ArgumentsForEntryPoint" Kind="Class" />
      <Type Name="TreeFeaturize" Kind="Class" />
      <Type Name="TrivialEstimator`1" DisplayName="TrivialEstimator&lt;TTransformer&gt;" Kind="Class" />
      <Type Name="TrivialReaderEstimator`2" DisplayName="TrivialReaderEstimator&lt;TSource,TReader&gt;" Kind="Class" />
      <Type Name="TrivialWrapperEstimator" Kind="Class" />
      <Type Name="TypeConversion" Kind="Class" />
      <Type Name="TypeParsingUtils" Kind="Class" />
      <Type Name="U4Adder" Kind="Class" />
      <Type Name="UInt128" Kind="Structure" />
      <Type Name="UngroupTransform" Kind="Class" />
      <Type Name="UngroupTransform+Arguments" Kind="Class" />
      <Type Name="UngroupTransform+UngroupMode" Kind="Enumeration" />
      <Type Name="ValueGetter`1" DisplayName="ValueGetter&lt;TValue&gt;" Kind="Delegate" />
      <Type Name="ValueMapper`2" DisplayName="ValueMapper&lt;TSrc,TDst&gt;" Kind="Delegate" />
      <Type Name="ValueMapper`3" DisplayName="ValueMapper&lt;TVal1,TVal2,TVal3&gt;" Kind="Delegate" />
      <Type Name="VBuffer`1" DisplayName="VBuffer&lt;T&gt;" Kind="Structure" />
      <Type Name="VectorType" Kind="Class" />
      <Type Name="WhiteningKind" Kind="Enumeration" />
      <Type Name="WhiteningTransform" Kind="Class" />
      <Type Name="WhiteningTransform+Arguments" Kind="Class" />
      <Type Name="WhiteningTransform+ColInfoEx" Kind="Class" />
      <Type Name="WhiteningTransform+Column" Kind="Class" />
      <Type Name="WordBagTransform" Kind="Class" />
      <Type Name="WordBagTransform+Arguments" Kind="Class" />
      <Type Name="WordBagTransform+Column" Kind="Class" />
      <Type Name="WordBagTransform+TokenizeColumn" Kind="Class" />
      <Type Name="WordEmbeddingsEstimator" Kind="Class" />
      <Type Name="WordEmbeddingsStaticExtensions" Kind="Class" />
      <Type Name="WordEmbeddingsTransform" Kind="Class" />
      <Type Name="WordEmbeddingsTransform+Arguments" Kind="Class" />
      <Type Name="WordEmbeddingsTransform+Column" Kind="Class" />
      <Type Name="WordEmbeddingsTransform+ColumnInfo" Kind="Class" />
      <Type Name="WordEmbeddingsTransform+PretrainedModelKind" Kind="Enumeration" />
      <Type Name="WordHashBagTransform" Kind="Class" />
      <Type Name="WordHashBagTransform+Arguments" Kind="Class" />
      <Type Name="WordHashBagTransform+Column" Kind="Class" />
      <Type Name="ZipDataView" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Data.Conversion">
      <Type Name="Conversions" Kind="Class" />
      <Type Name="TryParseMapper`1" DisplayName="TryParseMapper&lt;T&gt;" Kind="Delegate" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Data.IO">
      <Type Name="BinaryLoader" Kind="Class" />
      <Type Name="BinaryLoader+Arguments" Kind="Class" />
      <Type Name="BinaryLoader+InfoCommand" Kind="Class" />
      <Type Name="BinaryLoader+InfoCommand+Arguments" Kind="Class" />
      <Type Name="BinarySaver" Kind="Class" />
      <Type Name="BinarySaver+Arguments" Kind="Class" />
      <Type Name="Compression" Kind="Class" />
      <Type Name="Compression+NoneImpl" Kind="Class" />
      <Type Name="Compression+ZlibImpl" Kind="Class" />
      <Type Name="Compression+ZlibImpl+ArgumentsBase" Kind="Class" />
      <Type Name="Compression+ZlibImpl+DeflateArguments" Kind="Class" />
      <Type Name="Compression+ZlibImpl+ZlibArguments" Kind="Class" />
      <Type Name="CompressionCodecExtension" Kind="Class" />
      <Type Name="CompressionKind" Kind="Enumeration" />
      <Type Name="Header" Kind="Structure" />
      <Type Name="TextSaver" Kind="Class" />
      <Type Name="TextSaver+Arguments" Kind="Class" />
      <Type Name="TransposeLoader" Kind="Class" />
      <Type Name="TransposeLoader+Arguments" Kind="Class" />
      <Type Name="TransposeLoader+Header" Kind="Structure" />
      <Type Name="TransposeSaver" Kind="Class" />
      <Type Name="TransposeSaver+Arguments" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Data.IO.Zlib">
      <Type Name="Constants" Kind="Class" />
      <Type Name="Constants+Flush" Kind="Enumeration" />
      <Type Name="Constants+Level" Kind="Enumeration" />
      <Type Name="Constants+RetCode" Kind="Enumeration" />
      <Type Name="Constants+Strategy" Kind="Enumeration" />
      <Type Name="Constants+Type" Kind="Enumeration" />
      <Type Name="ZDeflateStream" Kind="Class" />
      <Type Name="ZInflateStream" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.DataPipe">
      <Type Name="OptionalColumnTransform" Kind="Class" />
      <Type Name="OptionalColumnTransform+Arguments" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.EntryPoints">
      <Type Name="ArrayIndexParameterBinding" Kind="Class" />
      <Type Name="ArrayIndexVariableBinding" Kind="Class" />
      <Type Name="ArrayVar`1" DisplayName="ArrayVar&lt;T&gt;" Kind="Class" />
      <Type Name="Cache" Kind="Class" />
      <Type Name="Cache+CacheInput" Kind="Class" />
      <Type Name="Cache+CacheOutput" Kind="Class" />
      <Type Name="Cache+CachingType" Kind="Enumeration" />
      <Type Name="CachingOptions" Kind="Enumeration" />
      <Type Name="CommonInputs" Kind="Class" />
      <Type Name="CommonInputs+ICalibratorInput" Kind="Interface" />
      <Type Name="CommonInputs+IEvaluatorInput" Kind="Interface" />
      <Type Name="CommonInputs+IFeaturizerInput" Kind="Interface" />
      <Type Name="CommonInputs+ITrainerInput" Kind="Interface" />
      <Type Name="CommonInputs+ITrainerInputWithGroupId" Kind="Interface" />
      <Type Name="CommonInputs+ITrainerInputWithLabel" Kind="Interface" />
      <Type Name="CommonInputs+ITrainerInputWithWeight" Kind="Interface" />
      <Type Name="CommonInputs+ITransformInput" Kind="Interface" />
      <Type Name="CommonInputs+IUnsupervisedTrainerWithWeight" Kind="Interface" />
      <Type Name="CommonOutputs" Kind="Class" />
      <Type Name="CommonOutputs+AnomalyDetectionOutput" Kind="Class" />
      <Type Name="CommonOutputs+BinaryClassificationOutput" Kind="Class" />
      <Type Name="CommonOutputs+CalibratorOutput" Kind="Class" />
      <Type Name="CommonOutputs+ClassificationEvaluateOutput" Kind="Class" />
      <Type Name="CommonOutputs+ClusteringOutput" Kind="Class" />
      <Type Name="CommonOutputs+CommonEvaluateOutput" Kind="Class" />
      <Type Name="CommonOutputs+EvaluateOutputBase" Kind="Class" />
      <Type Name="CommonOutputs+IAnomalyDetectionOutput" Kind="Interface" />
      <Type Name="CommonOutputs+IBinaryClassificationOutput" Kind="Interface" />
      <Type Name="CommonOutputs+ICalibratorOutput" Kind="Interface" />
      <Type Name="CommonOutputs+IClassificationEvaluatorOutput" Kind="Interface" />
      <Type Name="CommonOutputs+IClusteringOutput" Kind="Interface" />
      <Type Name="CommonOutputs+IEvaluatorOutput" Kind="Interface" />
      <Type Name="CommonOutputs+IMulticlassClassificationOutput" Kind="Interface" />
      <Type Name="CommonOutputs+IMultiRegressionOutput" Kind="Interface" />
      <Type Name="CommonOutputs+IRankingOutput" Kind="Interface" />
      <Type Name="CommonOutputs+IRegressionOutput" Kind="Interface" />
      <Type Name="CommonOutputs+ISequencePredictionOutput" Kind="Interface" />
      <Type Name="CommonOutputs+ITrainerOutput" Kind="Interface" />
      <Type Name="CommonOutputs+ITransformOutput" Kind="Interface" />
      <Type Name="CommonOutputs+MacroOutput" Kind="Class" />
      <Type Name="CommonOutputs+MacroOutput`1" DisplayName="CommonOutputs+MacroOutput&lt;TOut&gt;" Kind="Class" />
      <Type Name="CommonOutputs+MulticlassClassificationOutput" Kind="Class" />
      <Type Name="CommonOutputs+MultiRegressionOutput" Kind="Class" />
      <Type Name="CommonOutputs+RankingOutput" Kind="Class" />
      <Type Name="CommonOutputs+RegressionOutput" Kind="Class" />
      <Type Name="CommonOutputs+SequencePredictionOutput" Kind="Class" />
      <Type Name="CommonOutputs+SummaryOutput" Kind="Class" />
      <Type Name="CommonOutputs+TrainerOutput" Kind="Class" />
      <Type Name="CommonOutputs+TransformOutput" Kind="Class" />
      <Type Name="CrossValidationBinaryMacro" Kind="Class" />
      <Type Name="CrossValidationBinaryMacro+Arguments" Kind="Class" />
      <Type Name="CrossValidationBinaryMacro+ArrayIDataViewInput" Kind="Class" />
      <Type Name="CrossValidationBinaryMacro+ArrayIDataViewOutput" Kind="Class" />
      <Type Name="CrossValidationBinaryMacro+ArrayIPredictorModelInput" Kind="Class" />
      <Type Name="CrossValidationBinaryMacro+ArrayIPredictorModelOutput" Kind="Class" />
      <Type Name="CrossValidationBinaryMacro+ArrayITransformModelInput" Kind="Class" />
      <Type Name="CrossValidationBinaryMacro+ArrayITransformModelOutput" Kind="Class" />
      <Type Name="CrossValidationBinaryMacro+Output" Kind="Class" />
      <Type Name="CrossValidationBinaryMacro+SubGraphInput" Kind="Class" />
      <Type Name="CrossValidationBinaryMacro+SubGraphOutput" Kind="Class" />
      <Type Name="CrossValidationMacro" Kind="Class" />
      <Type Name="CrossValidationMacro+Arguments" Kind="Class" />
      <Type Name="CrossValidationMacro+CombinedOutput" Kind="Class" />
      <Type Name="CrossValidationMacro+CombineMetricsInput" Kind="Class" />
      <Type Name="CrossValidationMacro+Output" Kind="Class" />
      <Type Name="CrossValidationMacro+SubGraphInput" Kind="Class" />
      <Type Name="CrossValidationMacro+SubGraphOutput" Kind="Class" />
      <Type Name="CVSplit" Kind="Class" />
      <Type Name="CVSplit+Input" Kind="Class" />
      <Type Name="CVSplit+Output" Kind="Class" />
      <Type Name="DataViewReference" Kind="Class" />
      <Type Name="DataViewReference+Input" Kind="Class" />
      <Type Name="DataViewReference+Output" Kind="Class" />
      <Type Name="DictionaryKeyParameterBinding" Kind="Class" />
      <Type Name="DictionaryKeyVariableBinding" Kind="Class" />
      <Type Name="DictionaryVar`1" DisplayName="DictionaryVar&lt;T&gt;" Kind="Class" />
      <Type Name="EntryPointGraph" Kind="Class" />
      <Type Name="EntryPointModuleAttribute" Kind="Class" />
      <Type Name="EntryPointNode" Kind="Class" />
      <Type Name="EntryPointUtils" Kind="Class" />
      <Type Name="EntryPointVariable" Kind="Class" />
      <Type Name="EvaluateInputBase" Kind="Class" />
      <Type Name="FeatureCombiner" Kind="Class" />
      <Type Name="FeatureCombiner+ClassificationLabelInput" Kind="Class" />
      <Type Name="FeatureCombiner+FeatureCombinerInput" Kind="Class" />
      <Type Name="FeatureCombiner+LabelInputBase" Kind="Class" />
      <Type Name="FeatureCombiner+PredictedLabelInput" Kind="Class" />
      <Type Name="FeatureCombiner+RegressionLabelInput" Kind="Class" />
      <Type Name="IMlState" Kind="Interface" />
      <Type Name="ImportTextData" Kind="Class" />
      <Type Name="ImportTextData+Input" Kind="Class" />
      <Type Name="ImportTextData+LoaderInput" Kind="Class" />
      <Type Name="ImportTextData+Output" Kind="Class" />
      <Type Name="IPredictorModel" Kind="Interface" />
      <Type Name="ITransformModel" Kind="Interface" />
      <Type Name="LearnerEntryPointsUtils" Kind="Class" />
      <Type Name="LearnerInputBase" Kind="Class" />
      <Type Name="LearnerInputBaseWithGroupId" Kind="Class" />
      <Type Name="LearnerInputBaseWithLabel" Kind="Class" />
      <Type Name="LearnerInputBaseWithWeight" Kind="Class" />
      <Type Name="MacroUtils" Kind="Class" />
      <Type Name="MacroUtils+EvaluatorSettings" Kind="Class" />
      <Type Name="MacroUtils+TrainerKinds" Kind="Enumeration" />
      <Type Name="ModelOperations" Kind="Class" />
      <Type Name="ModelOperations+ApplyTransformModelInput" Kind="Class" />
      <Type Name="ModelOperations+ApplyTransformModelOutput" Kind="Class" />
      <Type Name="ModelOperations+CombineOvaPredictorModelsInput" Kind="Class" />
      <Type Name="ModelOperations+CombinePredictorModelsInput" Kind="Class" />
      <Type Name="ModelOperations+CombineTransformModelsInput" Kind="Class" />
      <Type Name="ModelOperations+CombineTransformModelsOutput" Kind="Class" />
      <Type Name="ModelOperations+PredictorModelInput" Kind="Class" />
      <Type Name="ModelOperations+PredictorModelOutput" Kind="Class" />
      <Type Name="ModelOperations+SimplePredictorModelInput" Kind="Class" />
      <Type Name="OneVersusAllMacro" Kind="Class" />
      <Type Name="OneVersusAllMacro+Arguments" Kind="Class" />
      <Type Name="OneVersusAllMacro+Output" Kind="Class" />
      <Type Name="OneVersusAllMacro+SubGraphOutput" Kind="Class" />
      <Type Name="Optional" Kind="Class" />
      <Type Name="Optional`1" DisplayName="Optional&lt;T&gt;" Kind="Class" />
      <Type Name="ParameterBinding" Kind="Class" />
      <Type Name="PipelineSweeperMacro" Kind="Class" />
      <Type Name="PipelineSweeperMacro+Arguments" Kind="Class" />
      <Type Name="PipelineSweeperMacro+Output" Kind="Class" />
      <Type Name="PipelineSweeperMacro+ResultInput" Kind="Class" />
      <Type Name="PredictorModel" Kind="Class" />
      <Type Name="RunContext" Kind="Class" />
      <Type Name="SchemaManipulation" Kind="Class" />
      <Type Name="ScoreModel" Kind="Class" />
      <Type Name="ScoreModel+Input" Kind="Class" />
      <Type Name="ScoreModel+InputTransformScorer" Kind="Class" />
      <Type Name="ScoreModel+ModelInput" Kind="Class" />
      <Type Name="ScoreModel+ModelOutput" Kind="Class" />
      <Type Name="ScoreModel+Output" Kind="Class" />
      <Type Name="ScoreModel+RenameBinaryPredictionScoreColumnsInput" Kind="Class" />
      <Type Name="ScoreModel+ScoreColumnSelectorInput" Kind="Class" />
      <Type Name="SelectFeatures" Kind="Class" />
      <Type Name="SelectRows" Kind="Class" />
      <Type Name="SignatureEntryPointModule" Kind="Delegate" />
      <Type Name="SimpleParameterBinding" Kind="Class" />
      <Type Name="SimpleVariableBinding" Kind="Class" />
      <Type Name="SplitUtils" Kind="Class" />
      <Type Name="SummarizePredictor" Kind="Class" />
      <Type Name="SummarizePredictor+Input" Kind="Class" />
      <Type Name="SummarizePredictor+InputBase" Kind="Class" />
      <Type Name="TlcModule" Kind="Class" />
      <Type Name="TlcModule+ComponentAttribute" Kind="Class" />
      <Type Name="TlcModule+ComponentKindAttribute" Kind="Class" />
      <Type Name="TlcModule+DataKind" Kind="Enumeration" />
      <Type Name="TlcModule+EntryPointAttribute" Kind="Class" />
      <Type Name="TlcModule+EntryPointKindAttribute" Kind="Class" />
      <Type Name="TlcModule+OptionalInputAttribute" Kind="Class" />
      <Type Name="TlcModule+OutputAttribute" Kind="Class" />
      <Type Name="TlcModule+RangeAttribute" Kind="Class" />
      <Type Name="TlcModule+SweepableDiscreteParamAttribute" Kind="Class" />
      <Type Name="TlcModule+SweepableFloatParamAttribute" Kind="Class" />
      <Type Name="TlcModule+SweepableLongParamAttribute" Kind="Class" />
      <Type Name="TlcModule+SweepableParamAttribute" Kind="Class" />
      <Type Name="TrainTestBinaryMacro" Kind="Class" />
      <Type Name="TrainTestBinaryMacro+Arguments" Kind="Class" />
      <Type Name="TrainTestBinaryMacro+Output" Kind="Class" />
      <Type Name="TrainTestBinaryMacro+SubGraphInput" Kind="Class" />
      <Type Name="TrainTestBinaryMacro+SubGraphOutput" Kind="Class" />
      <Type Name="TrainTestMacro" Kind="Class" />
      <Type Name="TrainTestMacro+Arguments" Kind="Class" />
      <Type Name="TrainTestMacro+Output" Kind="Class" />
      <Type Name="TrainTestMacro+SubGraphInput" Kind="Class" />
      <Type Name="TrainTestMacro+SubGraphOutput" Kind="Class" />
      <Type Name="TrainTestSplit" Kind="Class" />
      <Type Name="TrainTestSplit+Input" Kind="Class" />
      <Type Name="TrainTestSplit+Output" Kind="Class" />
      <Type Name="TransformInputBase" Kind="Class" />
      <Type Name="TransformModel" Kind="Class" />
      <Type Name="UnsupervisedLearnerInputBaseWithWeight" Kind="Class" />
      <Type Name="Var`1" DisplayName="Var&lt;T&gt;" Kind="Class" />
      <Type Name="VariableBinding" Kind="Class" />
      <Type Name="VarSerializer" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.EntryPoints.CodeGen">
      <Type Name="ModuleGenerator" Kind="Class" />
      <Type Name="ModuleGenerator+Arguments" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.EntryPoints.JsonUtils">
      <Type Name="ExecuteGraphCommand" Kind="Class" />
      <Type Name="ExecuteGraphCommand+Arguments" Kind="Class" />
      <Type Name="FieldNames" Kind="Class" />
      <Type Name="FieldNames+Deprecated" Kind="Class" />
      <Type Name="FieldNames+PipelineSweeperSupportedMetrics" Kind="Class" />
      <Type Name="FieldNames+Range" Kind="Class" />
      <Type Name="FieldNames+SweepableDiscreteParam" Kind="Class" />
      <Type Name="FieldNames+SweepableFloatParam" Kind="Class" />
      <Type Name="FieldNames+SweepableLongParam" Kind="Class" />
      <Type Name="GraphRunner" Kind="Class" />
      <Type Name="InputBuilder" Kind="Class" />
      <Type Name="JsonManifestUtils" Kind="Class" />
      <Type Name="OutputHelper" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.FactorizationMachine">
      <Type Name="FieldAwareFactorizationMachinePredictionTransformer" Kind="Class" />
      <Type Name="FieldAwareFactorizationMachinePredictor" Kind="Class" />
      <Type Name="FieldAwareFactorizationMachineTrainer" Kind="Class" />
      <Type Name="FieldAwareFactorizationMachineTrainer+Arguments" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.FastTree">
      <Type Name="BinaryClassGamPredictor" Kind="Class" />
      <Type Name="BinaryClassificationGamTrainer" Kind="Class" />
      <Type Name="BinaryClassificationGamTrainer+Arguments" Kind="Class" />
      <Type Name="BoostedTreeArgs" Kind="Class" />
      <Type Name="BoostedTreeArgs+OptimizationAlgorithmType" Kind="Enumeration" />
      <Type Name="BoostingFastTreeTrainerBase`3" DisplayName="BoostingFastTreeTrainerBase&lt;TArgs,TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="Bundle" Kind="Enumeration" />
      <Type Name="FastForest" Kind="Class" />
      <Type Name="FastForestArgumentsBase" Kind="Class" />
      <Type Name="FastForestClassification" Kind="Class" />
      <Type Name="FastForestClassification+Arguments" Kind="Class" />
      <Type Name="FastForestClassificationPredictor" Kind="Class" />
      <Type Name="FastForestRegression" Kind="Class" />
      <Type Name="FastForestRegression+Arguments" Kind="Class" />
      <Type Name="FastForestRegressionPredictor" Kind="Class" />
      <Type Name="FastTree" Kind="Class" />
      <Type Name="FastTreeBinaryClassificationTrainer" Kind="Class" />
      <Type Name="FastTreeBinaryClassificationTrainer+Arguments" Kind="Class" />
      <Type Name="FastTreeBinaryPredictor" Kind="Class" />
      <Type Name="FastTreePredictionWrapper" Kind="Class" />
      <Type Name="FastTreeRankingPredictor" Kind="Class" />
      <Type Name="FastTreeRankingTrainer" Kind="Class" />
      <Type Name="FastTreeRankingTrainer+Arguments" Kind="Class" />
      <Type Name="FastTreeRankingTrainer+LambdaRankObjectiveFunction" Kind="Class" />
      <Type Name="FastTreeRegressionPredictor" Kind="Class" />
      <Type Name="FastTreeRegressionTrainer" Kind="Class" />
      <Type Name="FastTreeRegressionTrainer+Arguments" Kind="Class" />
      <Type Name="FastTreeTrainerBase`3" DisplayName="FastTreeTrainerBase&lt;TArgs,TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="FastTreeTweediePredictor" Kind="Class" />
      <Type Name="FastTreeTweedieTrainer" Kind="Class" />
      <Type Name="FastTreeTweedieTrainer+Arguments" Kind="Class" />
      <Type Name="FindBestThresholdFromRawArrayFun" Kind="Delegate" />
      <Type Name="Gam" Kind="Class" />
      <Type Name="GamPredictorBase" Kind="Class" />
      <Type Name="GamPredictorBase+VisualizationCommand" Kind="Class" />
      <Type Name="GamPredictorBase+VisualizationCommand+Arguments" Kind="Class" />
      <Type Name="GamTrainerBase`3" DisplayName="GamTrainerBase&lt;TArgs,TTransformer,TPredictor&gt;" Kind="Class" />
      <Type Name="GamTrainerBase`3+ArgumentsBase" DisplayName="GamTrainerBase&lt;TArgs,TTransformer,TPredictor&gt;+ArgumentsBase" Kind="Class" />
      <Type Name="IFastTreeTrainerFactory" Kind="Interface" />
      <Type Name="IParallelTraining" Kind="Interface" />
      <Type Name="ISupportParallelTraining" Kind="Interface" />
      <Type Name="RandomForestTrainerBase`3" DisplayName="RandomForestTrainerBase&lt;TArgs,TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="RandomForestTrainerBase`3+RandomForestObjectiveFunction" DisplayName="RandomForestTrainerBase&lt;TArgs,TTransformer,TModel&gt;+RandomForestObjectiveFunction" Kind="Class" />
      <Type Name="RegressionGamPredictor" Kind="Class" />
      <Type Name="RegressionGamTrainer" Kind="Class" />
      <Type Name="RegressionGamTrainer+Arguments" Kind="Class" />
      <Type Name="SignatureParallelTrainer" Kind="Delegate" />
      <Type Name="SignatureTreeEnsembleTrainer" Kind="Delegate" />
      <Type Name="SingleTrainer" Kind="Class" />
      <Type Name="SingleTrainerFactory" Kind="Class" />
      <Type Name="SumupPerformanceCommand" Kind="Class" />
      <Type Name="SumupPerformanceCommand+Arguments" Kind="Class" />
      <Type Name="TreeArgs" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.FastTree.Internal">
      <Type Name="AcceleratedGradientDescent" Kind="Class" />
      <Type Name="AgdScoreTracker" Kind="Class" />
      <Type Name="Algorithms" Kind="Class" />
      <Type Name="BaggingProvider" Kind="Class" />
      <Type Name="BestStepRegressionGradientWrapper" Kind="Class" />
      <Type Name="BinaryClassificationTest" Kind="Class" />
      <Type Name="BlockingThreadPool" Kind="Class" />
      <Type Name="BufferPoolManager" Kind="Class" />
      <Type Name="ConjugateGradientDescent" Kind="Class" />
      <Type Name="CountEvent" Kind="Enumeration" />
      <Type Name="Dataset" Kind="Class" />
      <Type Name="Dataset+DatasetSkeleton" Kind="Class" />
      <Type Name="Dataset+DatasetSkeletonQueryDocData" Kind="Structure" />
      <Type Name="Dataset+DupeIdInfo" Kind="Enumeration" />
      <Type Name="Dataset+RowForwardIndexer" Kind="Class" />
      <Type Name="Dataset+RowForwardIndexer+Row" Kind="Structure" />
      <Type Name="DatasetUtils" Kind="Class" />
      <Type Name="DcgCalculator" Kind="Class" />
      <Type Name="DcgPermutationComparer" Kind="Class" />
      <Type Name="DcgPermutationComparerFactory" Kind="Class" />
      <Type Name="DescendingDotNetPermutationComparer" Kind="Class" />
      <Type Name="DescendingReversePermutationComparer" Kind="Class" />
      <Type Name="DescendingStableIdealComparer" Kind="Class" />
      <Type Name="DescendingStablePermutationComparer" Kind="Class" />
      <Type Name="DescendingStablePessimisticPermutationComparer" Kind="Class" />
      <Type Name="DocumentPartitioning" Kind="Class" />
      <Type Name="Ensemble" Kind="Class" />
      <Type Name="FastNdcgTest" Kind="Class" />
      <Type Name="FastNdcgTestForTrainSet" Kind="Class" />
      <Type Name="Feature" Kind="Class" />
      <Type Name="Feature+FeatureType" Kind="Enumeration" />
      <Type Name="FeatureFlockBase" Kind="Class" />
      <Type Name="FeatureFlockBase+FlockForwardIndexerBase" Kind="Class" />
      <Type Name="FeatureHistogram" Kind="Class" />
      <Type Name="FeaturesToContentMap" Kind="Class" />
      <Type Name="FeatureToGainMap" Kind="Class" />
      <Type Name="GradientDescent" Kind="Class" />
      <Type Name="IEnsembleCompressor`1" DisplayName="IEnsembleCompressor&lt;TLabel&gt;" Kind="Interface" />
      <Type Name="IFastTrainingScoresUpdate" Kind="Interface" />
      <Type Name="IGradientAdjuster" Kind="Interface" />
      <Type Name="IIntArrayForwardIndexer" Kind="Interface" />
      <Type Name="IntArray" Kind="Class" />
      <Type Name="IntArrayBits" Kind="Enumeration" />
      <Type Name="IntArrayType" Kind="Enumeration" />
      <Type Name="IStepSearch" Kind="Interface" />
      <Type Name="IThreadTask" Kind="Interface" />
      <Type Name="LassoBasedEnsembleCompressor" Kind="Class" />
      <Type Name="LassoFit" Kind="Class" />
      <Type Name="LeastSquaresRegressionTreeLearner" Kind="Class" />
      <Type Name="LeastSquaresRegressionTreeLearner+LeafSplitCandidates" Kind="Class" />
      <Type Name="LeastSquaresRegressionTreeLearner+SplitInfo" Kind="Structure" />
      <Type Name="LineSearch" Kind="Class" />
      <Type Name="LinqExtensions" Kind="Class" />
      <Type Name="MappedObjectPool`1" DisplayName="MappedObjectPool&lt;T&gt;" Kind="Class" />
      <Type Name="MD5Hash" Kind="Structure" />
      <Type Name="MD5Hasher" Kind="Class" />
      <Type Name="NdcgTest" Kind="Class" />
      <Type Name="ObjectiveFunctionBase" Kind="Class" />
      <Type Name="OptimizationAlgorithm" Kind="Class" />
      <Type Name="OptimizationAlgorithm+PreScoreUpdateHandler" Kind="Delegate" />
      <Type Name="PerBinStats" Kind="Structure" />
      <Type Name="PseudorandomFunction" Kind="Class" />
      <Type Name="QuantileRegressionTree" Kind="Class" />
      <Type Name="QueryWeightsBestResressionStepGradientWrapper" Kind="Class" />
      <Type Name="QueryWeightsGradientWrapper" Kind="Class" />
      <Type Name="RandomForestLeastSquaresTreeLearner" Kind="Class" />
      <Type Name="RandomForestOptimizer" Kind="Class" />
      <Type Name="RankingBaggingProvider" Kind="Class" />
      <Type Name="RecursiveRegressionTree" Kind="Class" />
      <Type Name="RegressionTest" Kind="Class" />
      <Type Name="RegressionTree" Kind="Class" />
      <Type Name="RegressionTree+TreeType" Kind="Enumeration" />
      <Type Name="RegressionTreeNodeDocuments" Kind="Class" />
      <Type Name="ScoreTracker" Kind="Class" />
      <Type Name="ScoreTracker+ScoresUpdatedDelegate" Kind="Delegate" />
      <Type Name="StreamExtensions" Kind="Class" />
      <Type Name="SufficientStatsBase" Kind="Class" />
      <Type Name="SufficientStatsBase`1" DisplayName="SufficientStatsBase&lt;TSuffStats&gt;" Kind="Class" />
      <Type Name="SumupInputData" Kind="Class" />
      <Type Name="Test" Kind="Class" />
      <Type Name="TestHistory" Kind="Class" />
      <Type Name="TestResult" Kind="Class" />
      <Type Name="TestResult+ValueOperator" Kind="Enumeration" />
      <Type Name="TestWindowWithTolerance" Kind="Class" />
      <Type Name="Timer" Kind="Class" />
      <Type Name="Timer+TimedEvent" Kind="Class" />
      <Type Name="TimerEvent" Kind="Enumeration" />
      <Type Name="ToByteArrayExtensions" Kind="Class" />
      <Type Name="TreeEnsembleCombiner" Kind="Class" />
      <Type Name="TreeLearner" Kind="Class" />
      <Type Name="TreeLearnerException" Kind="Class" />
      <Type Name="TrivialGradientWrapper" Kind="Class" />
      <Type Name="TsvFeature" Kind="Class" />
      <Type Name="VectorUtils" Kind="Class" />
      <Type Name="WinLossCalculator" Kind="Class" />
      <Type Name="WinLossSurplusTest" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Internal.Calibration">
      <Type Name="Calibrate" Kind="Class" />
      <Type Name="Calibrate+CalibrateInputBase" Kind="Class" />
      <Type Name="Calibrate+FixedPlattInput" Kind="Class" />
      <Type Name="Calibrate+NoArgumentsInput" Kind="Class" />
      <Type Name="CalibratedPredictor" Kind="Class" />
      <Type Name="CalibratedPredictorBase" Kind="Class" />
      <Type Name="CalibrationDataStore" Kind="Class" />
      <Type Name="CalibrationDataStore+DataItem" Kind="Structure" />
      <Type Name="CalibratorTrainerBase" Kind="Class" />
      <Type Name="CalibratorUtils" Kind="Class" />
      <Type Name="FeatureWeightsCalibratedPredictor" Kind="Class" />
      <Type Name="FixedPlattCalibratorTrainer" Kind="Class" />
      <Type Name="FixedPlattCalibratorTrainer+Arguments" Kind="Class" />
      <Type Name="ICalibrator" Kind="Interface" />
      <Type Name="ICalibratorTrainer" Kind="Interface" />
      <Type Name="ICalibratorTrainerFactory" Kind="Interface" />
      <Type Name="ISelfCalibratingPredictor" Kind="Interface" />
      <Type Name="NaiveCalibrator" Kind="Class" />
      <Type Name="NaiveCalibratorTrainer" Kind="Class" />
      <Type Name="NaiveCalibratorTrainerFactory" Kind="Class" />
      <Type Name="ParameterMixingCalibratedPredictor" Kind="Class" />
      <Type Name="PavCalibrator" Kind="Class" />
      <Type Name="PavCalibratorTrainer" Kind="Class" />
      <Type Name="PavCalibratorTrainerFactory" Kind="Class" />
      <Type Name="PlattCalibrator" Kind="Class" />
      <Type Name="PlattCalibratorTrainer" Kind="Class" />
      <Type Name="PlattCalibratorTrainerFactory" Kind="Class" />
      <Type Name="SchemaBindableCalibratedPredictor" Kind="Class" />
      <Type Name="SignatureCalibrator" Kind="Delegate" />
      <Type Name="ValueMapperCalibratedPredictorBase" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Internal.CpuMath">
      <Type Name="MemUtils" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Internal.Internallearn">
      <Type Name="EarlyStoppingCriterion`1" DisplayName="EarlyStoppingCriterion&lt;TArguments&gt;" Kind="Class" />
      <Type Name="EarlyStoppingCriterion`1+ArgumentsBase" DisplayName="EarlyStoppingCriterion&lt;TArguments&gt;+ArgumentsBase" Kind="Class" />
      <Type Name="FeatureNameCollection" Kind="Class" />
      <Type Name="GLEarlyStoppingCriterion" Kind="Class" />
      <Type Name="GLEarlyStoppingCriterion+Arguments" Kind="Class" />
      <Type Name="ICanGetSummaryAsIDataView" Kind="Interface" />
      <Type Name="ICanGetSummaryAsIRow" Kind="Interface" />
      <Type Name="ICanGetSummaryInKeyValuePairs" Kind="Interface" />
      <Type Name="ICanGetTrainingLabelNames" Kind="Interface" />
      <Type Name="ICanSaveInIniFormat" Kind="Interface" />
      <Type Name="ICanSaveInSourceCode" Kind="Interface" />
      <Type Name="ICanSaveInTextFormat" Kind="Interface" />
      <Type Name="ICanSaveSummary" Kind="Interface" />
      <Type Name="IDistribution`1" DisplayName="IDistribution&lt;TResult&gt;" Kind="Interface" />
      <Type Name="IEarlyStoppingCriterion" Kind="Interface" />
      <Type Name="IEarlyStoppingCriterionFactory" Kind="Interface" />
      <Type Name="IHasLabelGains" Kind="Interface" />
      <Type Name="IHaveFeatureWeights" Kind="Interface" />
      <Type Name="IParameterMixer" Kind="Interface" />
      <Type Name="IParameterMixer`1" DisplayName="IParameterMixer&lt;TOutput&gt;" Kind="Interface" />
      <Type Name="IPredictorWithFeatureWeights`1" DisplayName="IPredictorWithFeatureWeights&lt;TResult&gt;" Kind="Interface" />
      <Type Name="IQuantileDistribution`1" DisplayName="IQuantileDistribution&lt;TResult&gt;" Kind="Interface" />
      <Type Name="IQuantileRegressionPredictor" Kind="Interface" />
      <Type Name="IQuantileValueMapper" Kind="Interface" />
      <Type Name="ISampleableDistribution`1" DisplayName="ISampleableDistribution&lt;TResult&gt;" Kind="Interface" />
      <Type Name="IWhatTheFeatureValueMapper" Kind="Interface" />
      <Type Name="LPEarlyStoppingCriterion" Kind="Class" />
      <Type Name="LPEarlyStoppingCriterion+Arguments" Kind="Class" />
      <Type Name="MovingWindowEarlyStoppingCriterion" Kind="Class" />
      <Type Name="MovingWindowEarlyStoppingCriterion+Arguments" Kind="Class" />
      <Type Name="PQEarlyStoppingCriterion" Kind="Class" />
      <Type Name="PQEarlyStoppingCriterion+Arguments" Kind="Class" />
      <Type Name="PredictionUtil" Kind="Class" />
      <Type Name="PredictorBase`1" DisplayName="PredictorBase&lt;TOutput&gt;" Kind="Class" />
      <Type Name="PredictorUtils" Kind="Class" />
      <Type Name="ReverseComparer`1" DisplayName="ReverseComparer&lt;T&gt;" Kind="Class" />
      <Type Name="SignatureEarlyStoppingCriterion" Kind="Delegate" />
      <Type Name="SignatureFeatureScorerTrainer" Kind="Delegate" />
      <Type Name="SignaturePredictorFromFile" Kind="Delegate" />
      <Type Name="SlotDropper" Kind="Class" />
      <Type Name="TGUIAttribute" Kind="Class" />
      <Type Name="TolerantEarlyStoppingCriterion" Kind="Class" />
      <Type Name="TolerantEarlyStoppingCriterion+Arguments" Kind="Class" />
      <Type Name="TypeUtils" Kind="Class" />
      <Type Name="UPEarlyStoppingCriterion" Kind="Class" />
      <Type Name="UPEarlyStoppingCriterion+Arguments" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Internal.Internallearn.ResultProcessor">
      <Type Name="ExperimentItemResult" Kind="Structure" />
      <Type Name="PredictorResult" Kind="Class" />
      <Type Name="ResultMetric" Kind="Class" />
      <Type Name="ResultProcessor" Kind="Class" />
      <Type Name="ResultProcessorArguments" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Internal.IO">
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Internal.Tools">
      <Type Name="CSharpApiGenerator" Kind="Class" />
      <Type Name="CSharpApiGenerator+Arguments" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Internal.Utilities">
      <Type Name="BigArray`1" DisplayName="BigArray&lt;T&gt;" Kind="Class" />
      <Type Name="BigArray`1+Visitor" DisplayName="BigArray&lt;T&gt;+Visitor" Kind="Delegate" />
      <Type Name="BinFinderBase" Kind="Class" />
      <Type Name="CharUtils" Kind="Class" />
      <Type Name="CmdIndenter" Kind="Class" />
      <Type Name="DoubleParser" Kind="Class" />
      <Type Name="DoubleParser+Result" Kind="Enumeration" />
      <Type Name="DynamicBinFinder" Kind="Class" />
      <Type Name="ExceptionMarshaller" Kind="Class" />
      <Type Name="FixedSizeQueue`1" DisplayName="FixedSizeQueue&lt;T&gt;" Kind="Class" />
      <Type Name="FloatUtils" Kind="Class" />
      <Type Name="GreedyBinFinder" Kind="Class" />
      <Type Name="HashArray`1" DisplayName="HashArray&lt;TItem&gt;" Kind="Class" />
      <Type Name="Hashing" Kind="Class" />
      <Type Name="Heap`1" DisplayName="Heap&lt;T&gt;" Kind="Class" />
      <Type Name="HeapNode" Kind="Class" />
      <Type Name="HeapNode+Heap`1" DisplayName="HeapNode+Heap&lt;T&gt;" Kind="Class" />
      <Type Name="HybridMemoryStream" Kind="Class" />
      <Type Name="IndentingTextWriter" Kind="Class" />
      <Type Name="IndentingTextWriter+Scope" Kind="Structure" />
      <Type Name="IniFileUtils" Kind="Class" />
      <Type Name="IReservoirSampler`1" DisplayName="IReservoirSampler&lt;T&gt;" Kind="Interface" />
      <Type Name="LimitedConcurrencyLevelTaskScheduler" Kind="Class" />
      <Type Name="ListExtensions" Kind="Class" />
      <Type Name="LruCache`2" DisplayName="LruCache&lt;TKey,TValue&gt;" Kind="Class" />
      <Type Name="MadeObjectPool`1" DisplayName="MadeObjectPool&lt;T&gt;" Kind="Class" />
      <Type Name="MathUtils" Kind="Class" />
      <Type Name="MatrixTransposeOps" Kind="Class" />
      <Type Name="MinWaiter" Kind="Class" />
      <Type Name="NormStr" Kind="Class" />
      <Type Name="NormStr+Pool" Kind="Class" />
      <Type Name="ObjectPool`1" DisplayName="ObjectPool&lt;T&gt;" Kind="Class" />
      <Type Name="ObjectPoolBase`1" DisplayName="ObjectPoolBase&lt;T&gt;" Kind="Class" />
      <Type Name="OrderedWaiter" Kind="Class" />
      <Type Name="PlatformUtils" Kind="Class" />
      <Type Name="ReservoirSamplerWithoutReplacement`1" DisplayName="ReservoirSamplerWithoutReplacement&lt;T&gt;" Kind="Class" />
      <Type Name="ReservoirSamplerWithReplacement`1" DisplayName="ReservoirSamplerWithReplacement&lt;T&gt;" Kind="Class" />
      <Type Name="ResourceManagerUtils" Kind="Class" />
      <Type Name="ResourceManagerUtils+ResourceDownloadResults" Kind="Class" />
      <Type Name="SequencePool" Kind="Class" />
      <Type Name="Stats" Kind="Class" />
      <Type Name="StreamUtils" Kind="Class" />
      <Type Name="SubsetStream" Kind="Class" />
      <Type Name="SummaryStatistics" Kind="Class" />
      <Type Name="SummaryStatisticsBase" Kind="Class" />
      <Type Name="SummaryStatisticsUpToSecondOrderMoments" Kind="Class" />
      <Type Name="SupervisedBinFinder" Kind="Class" />
      <Type Name="TextReaderStream" Kind="Class" />
      <Type Name="TimerScope" Kind="Class" />
      <Type Name="Tree`2" DisplayName="Tree&lt;TKey,TValue&gt;" Kind="Class" />
      <Type Name="Utils" Kind="Class" />
      <Type Name="VBufferUtils" Kind="Class" />
      <Type Name="VBufferUtils+PairManipulator`2" DisplayName="VBufferUtils+PairManipulator&lt;TSrc,TDst&gt;" Kind="Delegate" />
      <Type Name="VBufferUtils+PairManipulatorCopy`2" DisplayName="VBufferUtils+PairManipulatorCopy&lt;TSrc,TDst&gt;" Kind="Delegate" />
      <Type Name="VBufferUtils+SlotValueManipulator`1" DisplayName="VBufferUtils+SlotValueManipulator&lt;T&gt;" Kind="Delegate" />
      <Type Name="VBufferUtils+ValuePredicate`1" DisplayName="VBufferUtils+ValuePredicate&lt;T&gt;" Kind="Delegate" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.KMeans">
      <Type Name="KMeansPlusPlusTrainer" Kind="Class" />
      <Type Name="KMeansPlusPlusTrainer+Arguments" Kind="Class" />
      <Type Name="KMeansPlusPlusTrainer+InitAlgorithm" Kind="Enumeration" />
      <Type Name="KMeansPredictor" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Learners">
      <Type Name="AveragedLinearArguments" Kind="Class" />
      <Type Name="AveragedLinearTrainer`2" DisplayName="AveragedLinearTrainer&lt;TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="AveragedPerceptronTrainer" Kind="Class" />
      <Type Name="AveragedPerceptronTrainer+Arguments" Kind="Class" />
      <Type Name="CoefficientStatistics" Kind="Structure" />
      <Type Name="LbfgsTrainerBase`3" DisplayName="LbfgsTrainerBase&lt;TArgs,TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="LbfgsTrainerBase`3+ArgumentsBase" DisplayName="LbfgsTrainerBase&lt;TArgs,TTransformer,TModel&gt;+ArgumentsBase" Kind="Class" />
      <Type Name="LinearBinaryPredictor" Kind="Class" />
      <Type Name="LinearClassificationTrainer" Kind="Class" />
      <Type Name="LinearClassificationTrainer+Arguments" Kind="Class" />
      <Type Name="LinearModelStatistics" Kind="Class" />
      <Type Name="LinearPredictor" Kind="Class" />
      <Type Name="LinearRegressionPredictor" Kind="Class" />
      <Type Name="LinearSvm" Kind="Class" />
      <Type Name="LinearSvm+Arguments" Kind="Class" />
      <Type Name="LinearTrainerBase`1" DisplayName="LinearTrainerBase&lt;TPredictor&gt;" Kind="Class" />
      <Type Name="LogisticRegression" Kind="Class" />
      <Type Name="LogisticRegression+Arguments" Kind="Class" />
      <Type Name="MetaMulticlassTrainer`2" DisplayName="MetaMulticlassTrainer&lt;TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="MetaMulticlassTrainer`2+ArgumentsBase" DisplayName="MetaMulticlassTrainer&lt;TTransformer,TModel&gt;+ArgumentsBase" Kind="Class" />
      <Type Name="MulticlassLogisticRegression" Kind="Class" />
      <Type Name="MulticlassLogisticRegression+Arguments" Kind="Class" />
      <Type Name="MulticlassLogisticRegressionPredictor" Kind="Class" />
      <Type Name="MultiClassNaiveBayesPredictor" Kind="Class" />
      <Type Name="MultiClassNaiveBayesTrainer" Kind="Class" />
      <Type Name="MultiClassNaiveBayesTrainer+Arguments" Kind="Class" />
      <Type Name="OnlineGradientDescentTrainer" Kind="Class" />
      <Type Name="OnlineGradientDescentTrainer+Arguments" Kind="Class" />
      <Type Name="OnlineLinearArguments" Kind="Class" />
      <Type Name="OnlineLinearTrainer`2" DisplayName="OnlineLinearTrainer&lt;TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="Ova" Kind="Class" />
      <Type Name="Ova+Arguments" Kind="Class" />
      <Type Name="OvaPredictor" Kind="Class" />
      <Type Name="Pkpd" Kind="Class" />
      <Type Name="Pkpd+Arguments" Kind="Class" />
      <Type Name="PkpdPredictor" Kind="Class" />
      <Type Name="PoissonRegression" Kind="Class" />
      <Type Name="PoissonRegression+Arguments" Kind="Class" />
      <Type Name="PoissonRegressionPredictor" Kind="Class" />
      <Type Name="PriorPredictor" Kind="Class" />
      <Type Name="PriorTrainer" Kind="Class" />
      <Type Name="PriorTrainer+Arguments" Kind="Class" />
      <Type Name="RandomPredictor" Kind="Class" />
      <Type Name="RandomTrainer" Kind="Class" />
      <Type Name="RandomTrainer+Arguments" Kind="Class" />
      <Type Name="RegressionPredictor" Kind="Class" />
      <Type Name="Sdca" Kind="Class" />
      <Type Name="SdcaMultiClassTrainer" Kind="Class" />
      <Type Name="SdcaMultiClassTrainer+Arguments" Kind="Class" />
      <Type Name="SdcaRegressionTrainer" Kind="Class" />
      <Type Name="SdcaRegressionTrainer+Arguments" Kind="Class" />
      <Type Name="SdcaTrainerBase`2" DisplayName="SdcaTrainerBase&lt;TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="SdcaTrainerBase`2+ArgumentsBase" DisplayName="SdcaTrainerBase&lt;TTransformer,TModel&gt;+ArgumentsBase" Kind="Class" />
      <Type Name="SdcaTrainerBase`2+DualsTableBase" DisplayName="SdcaTrainerBase&lt;TTransformer,TModel&gt;+DualsTableBase" Kind="Class" />
      <Type Name="SdcaTrainerBase`2+IdToIdxLookup" DisplayName="SdcaTrainerBase&lt;TTransformer,TModel&gt;+IdToIdxLookup" Kind="Class" />
      <Type Name="SdcaTrainerBase`2+MetricKind" DisplayName="SdcaTrainerBase&lt;TTransformer,TModel&gt;+MetricKind" Kind="Enumeration" />
      <Type Name="SdcaTrainerBase`2+Visitor" DisplayName="SdcaTrainerBase&lt;TTransformer,TModel&gt;+Visitor" Kind="Delegate" />
      <Type Name="StochasticGradientDescentClassificationTrainer" Kind="Class" />
      <Type Name="StochasticGradientDescentClassificationTrainer+Arguments" Kind="Class" />
      <Type Name="StochasticTrainerBase`2" DisplayName="StochasticTrainerBase&lt;TTransformer,TModel&gt;" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Model">
      <Type Name="ICanSaveInBinaryFormat" Kind="Interface" />
      <Type Name="ICanSaveModel" Kind="Interface" />
      <Type Name="ModelFileUtils" Kind="Class" />
      <Type Name="ModelHeader" Kind="Structure" />
      <Type Name="ModelLoadContext" Kind="Class" />
      <Type Name="ModelSaveContext" Kind="Class" />
      <Type Name="ModelUtils" Kind="Class" />
      <Type Name="Repository" Kind="Class" />
      <Type Name="Repository+Entry" Kind="Class" />
      <Type Name="RepositoryReader" Kind="Class" />
      <Type Name="RepositoryWriter" Kind="Class" />
      <Type Name="SignatureLoadModel" Kind="Delegate" />
      <Type Name="VersionInfo" Kind="Structure" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Model.Onnx">
      <Type Name="IBindableCanSaveOnnx" Kind="Interface" />
      <Type Name="ICanSaveOnnx" Kind="Interface" />
      <Type Name="IDistCanSaveOnnx" Kind="Interface" />
      <Type Name="ISaveAsOnnx" Kind="Interface" />
      <Type Name="ISingleCanSaveOnnx" Kind="Interface" />
      <Type Name="ITransformCanSaveOnnx" Kind="Interface" />
      <Type Name="OnnxContext" Kind="Class" />
      <Type Name="OnnxNode" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Model.Pfa">
      <Type Name="BoundPfaContext" Kind="Class" />
      <Type Name="IBindableCanSavePfa" Kind="Interface" />
      <Type Name="ICanSavePfa" Kind="Interface" />
      <Type Name="IDistCanSavePfa" Kind="Interface" />
      <Type Name="ISaveAsPfa" Kind="Interface" />
      <Type Name="ISingleCanSavePfa" Kind="Interface" />
      <Type Name="ITransformCanSavePfa" Kind="Interface" />
      <Type Name="PfaContext" Kind="Class" />
      <Type Name="PfaUtils" Kind="Class" />
      <Type Name="PfaUtils+Type" Kind="Class" />
      <Type Name="SavePfaCommand" Kind="Class" />
      <Type Name="SavePfaCommand+Arguments" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Numeric">
      <Type Name="BacktrackingLineSearch" Kind="Class" />
      <Type Name="CubicInterpLineSearch" Kind="Class" />
      <Type Name="DifferentiableFunction" Kind="Delegate" />
      <Type Name="DifferentiableFunctionAggregator" Kind="Class" />
      <Type Name="DiffFunc1D" Kind="Delegate" />
      <Type Name="DTerminate" Kind="Delegate" />
      <Type Name="GDOptimizer" Kind="Class" />
      <Type Name="GoldenSectionSearch" Kind="Class" />
      <Type Name="GradientCheckingMonitor" Kind="Class" />
      <Type Name="GradientTester" Kind="Class" />
      <Type Name="IDiffLineSearch" Kind="Interface" />
      <Type Name="ILineSearch" Kind="Interface" />
      <Type Name="IndexedDifferentiableFunction" Kind="Delegate" />
      <Type Name="ITerminationCriterion" Kind="Interface" />
      <Type Name="L1Optimizer" Kind="Class" />
      <Type Name="L1Optimizer+L1OptimizerState" Kind="Class" />
      <Type Name="MeanImprovementCriterion" Kind="Class" />
      <Type Name="MeanRelativeImprovementCriterion" Kind="Class" />
      <Type Name="Optimizer" Kind="Class" />
      <Type Name="Optimizer+OptimizerException" Kind="Class" />
      <Type Name="Optimizer+OptimizerState" Kind="Class" />
      <Type Name="Optimizer+PrematureConvergenceException" Kind="Class" />
      <Type Name="RelativeNormGradient" Kind="Class" />
      <Type Name="SgdOptimizer" Kind="Class" />
      <Type Name="SgdOptimizer+DStochasticGradient" Kind="Delegate" />
      <Type Name="SgdOptimizer+RateScheduleType" Kind="Enumeration" />
      <Type Name="StaticTerminationCriterion" Kind="Class" />
      <Type Name="UpperBoundOnDistanceWithL2" Kind="Class" />
      <Type Name="VectorUtils" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.PCA">
      <Type Name="PcaPredictor" Kind="Class" />
      <Type Name="RandomizedPcaTrainer" Kind="Class" />
      <Type Name="RandomizedPcaTrainer+Arguments" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.PipelineInference">
      <Type Name="AutoInference" Kind="Class" />
      <Type Name="AutoInference+AutoMlMlState" Kind="Class" />
      <Type Name="AutoInference+AutoMlMlState+Arguments" Kind="Class" />
      <Type Name="AutoInference+ColumnInfo" Kind="Structure" />
      <Type Name="AutoInference+DependencyMap" Kind="Class" />
      <Type Name="AutoInference+EntryPointGraphDef" Kind="Class" />
      <Type Name="AutoInference+ISupportAutoMlStateFactory" Kind="Interface" />
      <Type Name="AutoInference+LevelDependencyMap" Kind="Class" />
      <Type Name="AutoMlUtils" Kind="Class" />
      <Type Name="ColumnGroupingInference" Kind="Class" />
      <Type Name="ColumnGroupingInference+GroupingColumn" Kind="Structure" />
      <Type Name="ColumnGroupingInference+InferenceResult" Kind="Structure" />
      <Type Name="ColumnPurpose" Kind="Enumeration" />
      <Type Name="ColumnTypeInference" Kind="Class" />
      <Type Name="ColumnTypeInference+Arguments" Kind="Class" />
      <Type Name="ColumnTypeInference+Column" Kind="Structure" />
      <Type Name="ColumnTypeInference+InferenceResult" Kind="Structure" />
      <Type Name="DataAndModel`1" DisplayName="DataAndModel&lt;TModel&gt;" Kind="Class" />
      <Type Name="DatasetFeatureInference" Kind="Class" />
      <Type Name="DatasetFeatureInference+Arguments" Kind="Class" />
      <Type Name="DatasetFeatureInference+Column" Kind="Class" />
      <Type Name="DatasetFeatureInference+ColumnFeatures" Kind="Class" />
      <Type Name="DatasetFeatureInference+ColumnSchema" Kind="Class" />
      <Type Name="DatasetFeatureInference+ColumnSchema+Ratio" Kind="Structure" />
      <Type Name="DatasetFeatureInference+ColumnStatistics" Kind="Structure" />
      <Type Name="DatasetFeatureInference+LabelFeatures" Kind="Class" />
      <Type Name="DatasetFeatureInference+LabelFeatures+LabelColumnFeature" Kind="Structure" />
      <Type Name="DatasetFeatureInference+MissingValues" Kind="Class" />
      <Type Name="DatasetFeatureInference+Stats" Kind="Class" />
      <Type Name="DefaultsEngine" Kind="Class" />
      <Type Name="DefaultsEngine+Arguments" Kind="Class" />
      <Type Name="ExperimentsGenerator" Kind="Class" />
      <Type Name="ExperimentsGenerator+Pattern" Kind="Class" />
      <Type Name="ExperimentsGenerator+Sweep" Kind="Class" />
      <Type Name="ExperimentsGenerator+TrainerSweeper" Kind="Class" />
      <Type Name="FalseSweeper" Kind="Class" />
      <Type Name="InferenceUtils" Kind="Class" />
      <Type Name="IPipelineNode`1" DisplayName="IPipelineNode&lt;TModelType&gt;" Kind="Interface" />
      <Type Name="IPipelineOptimizer" Kind="Interface" />
      <Type Name="ISupportIPipelineOptimizerFactory" Kind="Interface" />
      <Type Name="ISupportITerminatorFactory" Kind="Interface" />
      <Type Name="IterationTerminator" Kind="Class" />
      <Type Name="IterationTerminator+Arguments" Kind="Class" />
      <Type Name="ITerminator" Kind="Interface" />
      <Type Name="PipelineNodeBase" Kind="Class" />
      <Type Name="PipelineOptimizerBase" Kind="Class" />
      <Type Name="PipelinePattern" Kind="Class" />
      <Type Name="PipelinePattern+PipelineResultRow" Kind="Class" />
      <Type Name="PipelineSweeperRunSummary" Kind="Class" />
      <Type Name="PipelineSweeperSupportedMetrics" Kind="Class" />
      <Type Name="PipelineSweeperSupportedMetrics+Metrics" Kind="Enumeration" />
      <Type Name="PredictorCategory" Kind="Class" />
      <Type Name="PredictorsList" Kind="Class" />
      <Type Name="PurposeInference" Kind="Class" />
      <Type Name="PurposeInference+Arguments" Kind="Class" />
      <Type Name="PurposeInference+Column" Kind="Structure" />
      <Type Name="PurposeInference+InferenceResult" Kind="Structure" />
      <Type Name="RecipeInference" Kind="Class" />
      <Type Name="RecipeInference+AccuracyFocusedRecipe" Kind="Class" />
      <Type Name="RecipeInference+BalancedTextClassificationRecipe" Kind="Class" />
      <Type Name="RecipeInference+DefaultRecipe" Kind="Class" />
      <Type Name="RecipeInference+ExplorationComboRecipe" Kind="Class" />
      <Type Name="RecipeInference+InferenceResult" Kind="Structure" />
      <Type Name="RecipeInference+MultiClassRecipies" Kind="Class" />
      <Type Name="RecipeInference+Recipe" Kind="Class" />
      <Type Name="RecipeInference+SuggestedRecipe" Kind="Structure" />
      <Type Name="RecipeInference+SuggestedRecipe+SuggestedLearner" Kind="Structure" />
      <Type Name="RecipeInference+TreeLeafRecipe" Kind="Class" />
      <Type Name="RocketEngine" Kind="Class" />
      <Type Name="RocketEngine+Arguments" Kind="Class" />
      <Type Name="SupportedMetric" Kind="Class" />
      <Type Name="TextFileContents" Kind="Class" />
      <Type Name="TextFileContents+ColumnSplitResult" Kind="Structure" />
      <Type Name="TextFileSample" Kind="Class" />
      <Type Name="TrainerPipelineNode" Kind="Class" />
      <Type Name="TransformInference" Kind="Class" />
      <Type Name="TransformInference+Arguments" Kind="Class" />
      <Type Name="TransformInference+Column" Kind="Structure" />
      <Type Name="TransformInference+ColumnRoutingStructure" Kind="Class" />
      <Type Name="TransformInference+ColumnRoutingStructure+AnnotatedName" Kind="Structure" />
      <Type Name="TransformInference+Experts" Kind="Class" />
      <Type Name="TransformInference+Experts+AutoLabel" Kind="Class" />
      <Type Name="TransformInference+Experts+Boolean" Kind="Class" />
      <Type Name="TransformInference+Experts+Categorical" Kind="Class" />
      <Type Name="TransformInference+Experts+FeaturesColumnConcatRename" Kind="Class" />
      <Type Name="TransformInference+Experts+FeaturesColumnConcatRenameIgnoreText" Kind="Class" />
      <Type Name="TransformInference+Experts+FeaturesColumnConcatRenameNumericOnly" Kind="Class" />
      <Type Name="TransformInference+Experts+GroupIdHashRename" Kind="Class" />
      <Type Name="TransformInference+Experts+LabelAdvisory" Kind="Class" />
      <Type Name="TransformInference+Experts+NaiveBayesTransform" Kind="Class" />
      <Type Name="TransformInference+Experts+NameColumnConcatRename" Kind="Class" />
      <Type Name="TransformInference+Experts+NumericMissing" Kind="Class" />
      <Type Name="TransformInference+Experts+SdcaTransform" Kind="Class" />
      <Type Name="TransformInference+Experts+Text" Kind="Class" />
      <Type Name="TransformInference+Experts+TextBiGramTriGram" Kind="Class" />
      <Type Name="TransformInference+Experts+TextUniGramTriGram" Kind="Class" />
      <Type Name="TransformInference+InferenceResult" Kind="Structure" />
      <Type Name="TransformInference+IntermediateColumn" Kind="Class" />
      <Type Name="TransformInference+ITransformInferenceExpert" Kind="Interface" />
      <Type Name="TransformInference+SuggestedTransform" Kind="Structure" />
      <Type Name="TransformInference+TransformInferenceExpertBase" Kind="Class" />
      <Type Name="TransformInference+TransformString" Kind="Structure" />
      <Type Name="TransformPipelineNode" Kind="Class" />
      <Type Name="UniformRandomEngine" Kind="Class" />
      <Type Name="UniformRandomEngine+Arguments" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Sweeper">
      <Type Name="BaseParamArguments" Kind="Class" />
      <Type Name="DeterministicSweeperAsync" Kind="Class" />
      <Type Name="DeterministicSweeperAsync+Arguments" Kind="Class" />
      <Type Name="DiscreteParamArguments" Kind="Class" />
      <Type Name="DiscreteValueGenerator" Kind="Class" />
      <Type Name="ExeConfigRunnerBase" Kind="Class" />
      <Type Name="ExeConfigRunnerBase+ArgumentsBase" Kind="Class" />
      <Type Name="FloatParamArguments" Kind="Class" />
      <Type Name="FloatParameterValue" Kind="Class" />
      <Type Name="FloatValueGenerator" Kind="Class" />
      <Type Name="IAsyncSweeper" Kind="Interface" />
      <Type Name="IConfigRunner" Kind="Interface" />
      <Type Name="InternalSweepResultEvaluator" Kind="Class" />
      <Type Name="InternalSweepResultEvaluator+Arguments" Kind="Class" />
      <Type Name="INumericValueGenerator" Kind="Interface" />
      <Type Name="LocalExeConfigRunner" Kind="Class" />
      <Type Name="LocalExeConfigRunner+Arguments" Kind="Class" />
      <Type Name="LongParamArguments" Kind="Class" />
      <Type Name="LongParameterValue" Kind="Class" />
      <Type Name="LongValueGenerator" Kind="Class" />
      <Type Name="NelderMeadSweeper" Kind="Class" />
      <Type Name="NelderMeadSweeper+Arguments" Kind="Class" />
      <Type Name="NumericParamArguments" Kind="Class" />
      <Type Name="ParameterSetWithId" Kind="Class" />
      <Type Name="RandomGridSweeper" Kind="Class" />
      <Type Name="RandomGridSweeper+Arguments" Kind="Class" />
      <Type Name="SignatureAsyncSweeper" Kind="Delegate" />
      <Type Name="SignatureConfigRunner" Kind="Delegate" />
      <Type Name="SignatureSweeperFromParameterList" Kind="Delegate" />
      <Type Name="SignatureSweeperParameter" Kind="Delegate" />
      <Type Name="SimpleAsyncSweeper" Kind="Class" />
      <Type Name="SmacSweeper" Kind="Class" />
      <Type Name="SmacSweeper+Arguments" Kind="Class" />
      <Type Name="StringParameterValue" Kind="Class" />
      <Type Name="SuggestedSweepsParser" Kind="Class" />
      <Type Name="SweepCommand" Kind="Class" />
      <Type Name="SweepCommand+Arguments" Kind="Class" />
      <Type Name="SweeperBase" Kind="Class" />
      <Type Name="SweeperBase+ArgumentsBase" Kind="Class" />
      <Type Name="SynthConfigRunner" Kind="Class" />
      <Type Name="SynthConfigRunner+Arguments" Kind="Class" />
      <Type Name="UniformRandomSweeper" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Sweeper.Algorithms">
      <Type Name="KdoSweeper" Kind="Class" />
      <Type Name="KdoSweeper+Arguments" Kind="Class" />
      <Type Name="SweeperProbabilityUtils" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.TextAnalytics">
      <Type Name="CharTokenizeTransform" Kind="Class" />
      <Type Name="CharTokenizeTransform+Arguments" Kind="Class" />
      <Type Name="CharTokenizeTransform+Column" Kind="Class" />
      <Type Name="CustomStopWordsRemoverTransform" Kind="Class" />
      <Type Name="CustomStopWordsRemoverTransform+Arguments" Kind="Class" />
      <Type Name="CustomStopWordsRemoverTransform+ArgumentsBase" Kind="Class" />
      <Type Name="CustomStopWordsRemoverTransform+Column" Kind="Class" />
      <Type Name="CustomStopWordsRemoverTransform+LoaderArguments" Kind="Class" />
      <Type Name="IStopWordsRemoverFactory" Kind="Interface" />
      <Type Name="IStopWordsRemoverTransform" Kind="Interface" />
      <Type Name="LdaTransform" Kind="Class" />
      <Type Name="LdaTransform+Arguments" Kind="Class" />
      <Type Name="LdaTransform+Column" Kind="Class" />
      <Type Name="PredefinedStopWordsRemoverFactory" Kind="Class" />
      <Type Name="SentimentAnalyzingTransform" Kind="Class" />
      <Type Name="SentimentAnalyzingTransform+Arguments" Kind="Class" />
      <Type Name="SignatureStopWordsRemoverTransform" Kind="Delegate" />
      <Type Name="StopWordsRemoverTransform" Kind="Class" />
      <Type Name="StopWordsRemoverTransform+Arguments" Kind="Class" />
      <Type Name="StopWordsRemoverTransform+Column" Kind="Class" />
      <Type Name="StopWordsRemoverTransform+Language" Kind="Enumeration" />
      <Type Name="TextNormalizerTransform" Kind="Class" />
      <Type Name="TextNormalizerTransform+Arguments" Kind="Class" />
      <Type Name="TextNormalizerTransform+CaseNormalizationMode" Kind="Enumeration" />
      <Type Name="TextNormalizerTransform+Column" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Tools">
      <Type Name="ChainCommand" Kind="Class" />
      <Type Name="ChainCommand+Arguments" Kind="Class" />
      <Type Name="HelpCommand" Kind="Class" />
      <Type Name="HelpCommand+Arguments" Kind="Class" />
      <Type Name="HelpCommand+Component" Kind="Structure" />
      <Type Name="IGenerator" Kind="Interface" />
      <Type Name="Maml" Kind="Class" />
      <Type Name="SavePredictorCommand" Kind="Class" />
      <Type Name="SavePredictorCommand+Arguments" Kind="Class" />
      <Type Name="SavePredictorUtils" Kind="Class" />
      <Type Name="SignatureModuleGenerator" Kind="Delegate" />
      <Type Name="VersionCommand" Kind="Class" />
      <Type Name="XmlGenerator" Kind="Class" />
      <Type Name="XmlGenerator+Arguments" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Training">
      <Type Name="CursOpt" Kind="Enumeration" />
      <Type Name="FeatureFloatVectorCursor" Kind="Class" />
      <Type Name="FeatureFloatVectorCursor+Factory" Kind="Class" />
      <Type Name="FloatLabelCursor" Kind="Class" />
      <Type Name="FloatLabelCursor+Factory" Kind="Class" />
      <Type Name="ITrainerEstimator`2" DisplayName="ITrainerEstimator&lt;TTransformer,TPredictor&gt;" Kind="Interface" />
      <Type Name="MultiClassLabelCursor" Kind="Class" />
      <Type Name="MultiClassLabelCursor+Factory" Kind="Class" />
      <Type Name="StandardScalarCursor" Kind="Class" />
      <Type Name="StandardScalarCursor+Factory" Kind="Class" />
      <Type Name="TrainerBase`1" DisplayName="TrainerBase&lt;TPredictor&gt;" Kind="Class" />
      <Type Name="TrainerEstimatorBase`2" DisplayName="TrainerEstimatorBase&lt;TTransformer,TModel&gt;" Kind="Class" />
      <Type Name="TrainerUtils" Kind="Class" />
      <Type Name="TrainingCursorBase" Kind="Class" />
      <Type Name="TrainingCursorBase+FactoryBase`1" DisplayName="TrainingCursorBase+FactoryBase&lt;TCurs&gt;" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.Transforms">
      <Type Name="TextAnalytics" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.TreePredictor">
      <Type Name="INode" Kind="Interface" />
      <Type Name="ITree" Kind="Interface" />
      <Type Name="ITree`1" DisplayName="ITree&lt;TFeatures&gt;" Kind="Interface" />
      <Type Name="ITreeEnsemble" Kind="Interface" />
      <Type Name="NodeKeys" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Runtime.UniversalModelFormat.Onnx">
    </Namespace>
    <Namespace Name="Microsoft.ML.StaticPipe">
      <Type Name="BinaryClassificationTrainers" Kind="Class" />
      <Type Name="ClusteringTrainers" Kind="Class" />
      <Type Name="DataReader`2" DisplayName="DataReader&lt;TIn,TTupleShape&gt;" Kind="Class" />
      <Type Name="DataReaderEstimator`3" DisplayName="DataReaderEstimator&lt;TIn,TTupleShape,TDataReader&gt;" Kind="Class" />
      <Type Name="DataView`1" DisplayName="DataView&lt;TTupleShape&gt;" Kind="Class" />
      <Type Name="DataViewExtensions" Kind="Class" />
      <Type Name="Estimator`3" DisplayName="Estimator&lt;TTupleInShape,TTupleOutShape,TTransformer&gt;" Kind="Class" />
      <Type Name="IsShapeAttribute" Kind="Class" />
      <Type Name="Key`1" DisplayName="Key&lt;T&gt;" Kind="Class" />
      <Type Name="Key`2" DisplayName="Key&lt;T,TVal&gt;" Kind="Class" />
      <Type Name="MultiClassClassificationTrainers" Kind="Class" />
      <Type Name="NormVector`1" DisplayName="NormVector&lt;T&gt;" Kind="Class" />
      <Type Name="PipelineColumn" Kind="Class" />
      <Type Name="RegressionTrainers" Kind="Class" />
      <Type Name="Scalar`1" DisplayName="Scalar&lt;T&gt;" Kind="Class" />
      <Type Name="SchemaBearing`1" DisplayName="SchemaBearing&lt;TTupleShape&gt;" Kind="Class" />
      <Type Name="StaticPipeExtensions" Kind="Class" />
      <Type Name="Transformer`3" DisplayName="Transformer&lt;TTupleInShape,TTupleOutShape,TTransformer&gt;" Kind="Class" />
      <Type Name="VarKey`1" DisplayName="VarKey&lt;T&gt;" Kind="Class" />
      <Type Name="VarVector`1" DisplayName="VarVector&lt;T&gt;" Kind="Class" />
      <Type Name="Vector`1" DisplayName="Vector&lt;T&gt;" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.StaticPipe.Runtime">
      <Type Name="EstimatorReconciler" Kind="Class" />
      <Type Name="ReaderReconciler`1" DisplayName="ReaderReconciler&lt;TIn&gt;" Kind="Class" />
      <Type Name="Reconciler" Kind="Class" />
      <Type Name="SchemaAssertionContext" Kind="Class" />
      <Type Name="SchemaAssertionContext+KeyTypeSelectorAssertions`1" DisplayName="SchemaAssertionContext+KeyTypeSelectorAssertions&lt;T&gt;" Kind="Structure" />
      <Type Name="SchemaAssertionContext+KeyTypeVectorAssertions`1" DisplayName="SchemaAssertionContext+KeyTypeVectorAssertions&lt;T&gt;" Kind="Structure" />
      <Type Name="SchemaAssertionContext+NormalizableTypeAssertions`1" DisplayName="SchemaAssertionContext+NormalizableTypeAssertions&lt;T&gt;" Kind="Structure" />
      <Type Name="SchemaAssertionContext+PrimitiveTypeAssertions`1" DisplayName="SchemaAssertionContext+PrimitiveTypeAssertions&lt;T&gt;" Kind="Structure" />
      <Type Name="StaticPipeUtils" Kind="Class" />
      <Type Name="StaticPipeUtils+IndexHelper`1" DisplayName="StaticPipeUtils+IndexHelper&lt;T&gt;" Kind="Class" />
      <Type Name="TrainerEstimatorReconciler" Kind="Class" />
      <Type Name="TrainerEstimatorReconciler+BinaryClassifier" Kind="Class" />
      <Type Name="TrainerEstimatorReconciler+BinaryClassifier+EstimatorFactory" Kind="Delegate" />
      <Type Name="TrainerEstimatorReconciler+BinaryClassifierNoCalibration" Kind="Class" />
      <Type Name="TrainerEstimatorReconciler+BinaryClassifierNoCalibration+EstimatorFactory" Kind="Delegate" />
      <Type Name="TrainerEstimatorReconciler+Clustering" Kind="Class" />
      <Type Name="TrainerEstimatorReconciler+Clustering+EstimatorFactory" Kind="Delegate" />
      <Type Name="TrainerEstimatorReconciler+MulticlassClassifier`1" DisplayName="TrainerEstimatorReconciler+MulticlassClassifier&lt;TVal&gt;" Kind="Class" />
      <Type Name="TrainerEstimatorReconciler+MulticlassClassifier`1+EstimatorFactory" DisplayName="TrainerEstimatorReconciler+MulticlassClassifier&lt;TVal&gt;+EstimatorFactory" Kind="Delegate" />
      <Type Name="TrainerEstimatorReconciler+Regression" Kind="Class" />
      <Type Name="TrainerEstimatorReconciler+Regression+EstimatorFactory" Kind="Delegate" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Trainers">
      <Type Name="FactorizationMachineStatic" Kind="Class" />
      <Type Name="FastTreeStatic" Kind="Class" />
      <Type Name="SdcaStatic" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Transforms">
      <Type Name="CharacterTokenizer" Kind="Class" />
      <Type Name="CountFeatureSelector" Kind="Class" />
      <Type Name="CountFeatureSelectorExtensions" Kind="Class" />
      <Type Name="GcNormalizerExtensions" Kind="Class" />
      <Type Name="GlobalContrastNormalizer" Kind="Class" />
      <Type Name="HashEstimator" Kind="Class" />
      <Type Name="HashEstimator+Defaults" Kind="Class" />
      <Type Name="HashTransformer" Kind="Class" />
      <Type Name="HashTransformer+Arguments" Kind="Class" />
      <Type Name="HashTransformer+Column" Kind="Class" />
      <Type Name="HashTransformer+ColumnInfo" Kind="Class" />
      <Type Name="LdaEstimator" Kind="Class" />
      <Type Name="LpNormalizer" Kind="Class" />
      <Type Name="LpNormNormalizerExtensions" Kind="Class" />
      <Type Name="MutualInformationFeatureSelector" Kind="Class" />
      <Type Name="MutualInformationFeatureSelectorExtensions" Kind="Class" />
      <Type Name="NgramEstimator" Kind="Class" />
      <Type Name="NgramHashEstimator" Kind="Class" />
      <Type Name="StopwordRemover" Kind="Class" />
      <Type Name="TensorFlowEstimator" Kind="Class" />
      <Type Name="TensorFlowStaticExtensions" Kind="Class" />
      <Type Name="TensorFlowTransform" Kind="Class" />
      <Type Name="TensorFlowTransform+Arguments" Kind="Class" />
      <Type Name="TextNormalizer" Kind="Class" />
      <Type Name="Whitening" Kind="Class" />
      <Type Name="WhiteningExtensions" Kind="Class" />
      <Type Name="WordBagEstimator" Kind="Class" />
      <Type Name="WordHashBagEstimator" Kind="Class" />
      <Type Name="WordTokenizer" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Transforms.TensorFlow">
      <Type Name="TensorFlowUtils" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.ML.Transforms.Text">
      <Type Name="CharacterTokenizerExtensions" Kind="Class" />
      <Type Name="LdaEstimatorExtensions" Kind="Class" />
      <Type Name="NgramEstimatorExtensions" Kind="Class" />
      <Type Name="NgramHashEstimatorExtensions" Kind="Class" />
      <Type Name="StopwordRemoverExtensions" Kind="Class" />
      <Type Name="TextNormalizerExtensions" Kind="Class" />
      <Type Name="WordBagEstimatorExtensions" Kind="Class" />
      <Type Name="WordHashBagEstimatorExtensions" Kind="Class" />
      <Type Name="WordTokenizerExtensions" Kind="Class" />
    </Namespace>
  </Types>
  <Title>Untitled</Title>
  <ExtensionMethods>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.IDataView" />
      </Targets>
      <Member MemberName="GetColumn&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; GetColumn&lt;T&gt; (this Microsoft.ML.Runtime.Data.IDataView data, Microsoft.ML.Runtime.IHostEnvironment env, string columnName);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; GetColumn&lt;T&gt;(class Microsoft.ML.Runtime.Data.IDataView data, class Microsoft.ML.Runtime.IHostEnvironment env, string columnName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Data.ColumnCursorExtensions.GetColumn``1(Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.IHostEnvironment,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetColumn(Of T) (data As IDataView, env As IHostEnvironment, columnName As String) As IEnumerable(Of T)" />
        <MemberSignature Language="F#" Value="static member GetColumn : Microsoft.ML.Runtime.Data.IDataView * Microsoft.ML.Runtime.IHostEnvironment * string -&gt; seq&lt;'T&gt;" Usage="Microsoft.ML.Data.ColumnCursorExtensions.GetColumn (data, env, columnName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.Runtime.Data.IDataView" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
          <Parameter Name="columnName" Type="System.String" />
        </Parameters>
        <Docs>
          <typeparam name="T">The type of the values. This must match the actual column type.</typeparam>
          <param name="data">The data view to get the column from.</param>
          <param name="env">The current host environment.</param>
          <param name="columnName">The name of the column to extract.</param>
          <summary>
            Extract all values of one column of the data view in a form of an <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Data.ColumnCursorExtensions" Member="M:Microsoft.ML.Data.ColumnCursorExtensions.GetColumn``1(Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.IHostEnvironment,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreateBatchPredictionEngine&lt;TSrc,TDst&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Api.BatchPredictionEngine&lt;TSrc,TDst&gt; CreateBatchPredictionEngine&lt;TSrc,TDst&gt; (this Microsoft.ML.Runtime.IHostEnvironment env, Microsoft.ML.Runtime.Data.IDataView dataPipe, bool ignoreMissingColumns = false, Microsoft.ML.Runtime.Api.SchemaDefinition inputSchemaDefinition = null, Microsoft.ML.Runtime.Api.SchemaDefinition outputSchemaDefinition = null) where TSrc : class where TDst : class, new();" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Api.BatchPredictionEngine`2&lt;!!TSrc, !!TDst&gt; CreateBatchPredictionEngine&lt;class TSrc, class .ctor TDst&gt;(class Microsoft.ML.Runtime.IHostEnvironment env, class Microsoft.ML.Runtime.Data.IDataView dataPipe, bool ignoreMissingColumns, class Microsoft.ML.Runtime.Api.SchemaDefinition inputSchemaDefinition, class Microsoft.ML.Runtime.Api.SchemaDefinition outputSchemaDefinition) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateBatchPredictionEngine``2(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.Boolean,Microsoft.ML.Runtime.Api.SchemaDefinition,Microsoft.ML.Runtime.Api.SchemaDefinition)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateBatchPredictionEngine(Of TSrc As Class, TDst As Class) (env As IHostEnvironment, dataPipe As IDataView, Optional ignoreMissingColumns As Boolean = false, Optional inputSchemaDefinition As SchemaDefinition = null, Optional outputSchemaDefinition As SchemaDefinition = null) As BatchPredictionEngine(Of TSrc, TDst)" />
        <MemberSignature Language="F#" Value="static member CreateBatchPredictionEngine : Microsoft.ML.Runtime.IHostEnvironment * Microsoft.ML.Runtime.Data.IDataView * bool * Microsoft.ML.Runtime.Api.SchemaDefinition * Microsoft.ML.Runtime.Api.SchemaDefinition -&gt; Microsoft.ML.Runtime.Api.BatchPredictionEngine&lt;'Src, 'Dst (requires 'Src : null and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))&gt; (requires 'Src : null and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))" Usage="Microsoft.ML.Runtime.Api.ComponentCreation.CreateBatchPredictionEngine (env, dataPipe, ignoreMissingColumns, inputSchemaDefinition, outputSchemaDefinition)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Api.BatchPredictionEngine&lt;TSrc,TDst&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSrc">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
          <TypeParameter Name="TDst">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" RefType="this" />
          <Parameter Name="dataPipe" Type="Microsoft.ML.Runtime.Data.IDataView" />
          <Parameter Name="ignoreMissingColumns" Type="System.Boolean" />
          <Parameter Name="inputSchemaDefinition" Type="Microsoft.ML.Runtime.Api.SchemaDefinition" />
          <Parameter Name="outputSchemaDefinition" Type="Microsoft.ML.Runtime.Api.SchemaDefinition" />
        </Parameters>
        <Docs>
          <typeparam name="TSrc">To be added.</typeparam>
          <typeparam name="TDst">To be added.</typeparam>
          <param name="env">The host environment to use.</param>
          <param name="dataPipe">The transformation pipe that may or may not include a scorer.</param>
          <param name="ignoreMissingColumns">Whether to ignore missing columns in the data view.</param>
          <param name="inputSchemaDefinition">The optional input schema. If <c>null</c>, the schema is inferred from the <typeparamref name="TSrc" /> type.</param>
          <param name="outputSchemaDefinition">The optional output schema. If <c>null</c>, the schema is inferred from the <typeparamref name="TDst" /> type.</param>
          <summary>
            Create a batch prediction engine.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Api.ComponentCreation" Member="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateBatchPredictionEngine``2(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.Boolean,Microsoft.ML.Runtime.Api.SchemaDefinition,Microsoft.ML.Runtime.Api.SchemaDefinition)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreateBatchPredictionEngine&lt;TSrc,TDst&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Api.BatchPredictionEngine&lt;TSrc,TDst&gt; CreateBatchPredictionEngine&lt;TSrc,TDst&gt; (this Microsoft.ML.Runtime.IHostEnvironment env, System.IO.Stream modelStream, bool ignoreMissingColumns = false, Microsoft.ML.Runtime.Api.SchemaDefinition inputSchemaDefinition = null, Microsoft.ML.Runtime.Api.SchemaDefinition outputSchemaDefinition = null) where TSrc : class where TDst : class, new();" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Api.BatchPredictionEngine`2&lt;!!TSrc, !!TDst&gt; CreateBatchPredictionEngine&lt;class TSrc, class .ctor TDst&gt;(class Microsoft.ML.Runtime.IHostEnvironment env, class System.IO.Stream modelStream, bool ignoreMissingColumns, class Microsoft.ML.Runtime.Api.SchemaDefinition inputSchemaDefinition, class Microsoft.ML.Runtime.Api.SchemaDefinition outputSchemaDefinition) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateBatchPredictionEngine``2(Microsoft.ML.Runtime.IHostEnvironment,System.IO.Stream,System.Boolean,Microsoft.ML.Runtime.Api.SchemaDefinition,Microsoft.ML.Runtime.Api.SchemaDefinition)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateBatchPredictionEngine(Of TSrc As Class, TDst As Class) (env As IHostEnvironment, modelStream As Stream, Optional ignoreMissingColumns As Boolean = false, Optional inputSchemaDefinition As SchemaDefinition = null, Optional outputSchemaDefinition As SchemaDefinition = null) As BatchPredictionEngine(Of TSrc, TDst)" />
        <MemberSignature Language="F#" Value="static member CreateBatchPredictionEngine : Microsoft.ML.Runtime.IHostEnvironment * System.IO.Stream * bool * Microsoft.ML.Runtime.Api.SchemaDefinition * Microsoft.ML.Runtime.Api.SchemaDefinition -&gt; Microsoft.ML.Runtime.Api.BatchPredictionEngine&lt;'Src, 'Dst (requires 'Src : null and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))&gt; (requires 'Src : null and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))" Usage="Microsoft.ML.Runtime.Api.ComponentCreation.CreateBatchPredictionEngine (env, modelStream, ignoreMissingColumns, inputSchemaDefinition, outputSchemaDefinition)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Api.BatchPredictionEngine&lt;TSrc,TDst&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSrc">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
          <TypeParameter Name="TDst">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" RefType="this" />
          <Parameter Name="modelStream" Type="System.IO.Stream" />
          <Parameter Name="ignoreMissingColumns" Type="System.Boolean" />
          <Parameter Name="inputSchemaDefinition" Type="Microsoft.ML.Runtime.Api.SchemaDefinition" />
          <Parameter Name="outputSchemaDefinition" Type="Microsoft.ML.Runtime.Api.SchemaDefinition" />
        </Parameters>
        <Docs>
          <typeparam name="TSrc">To be added.</typeparam>
          <typeparam name="TDst">To be added.</typeparam>
          <param name="env">The host environment to use.</param>
          <param name="modelStream">The stream to deserialize the pipeline (transforms and predictor) from.</param>
          <param name="ignoreMissingColumns">Whether to ignore missing columns in the data view.</param>
          <param name="inputSchemaDefinition">The optional input schema. If <c>null</c>, the schema is inferred from the <typeparamref name="TSrc" /> type.</param>
          <param name="outputSchemaDefinition">The optional output schema. If <c>null</c>, the schema is inferred from the <typeparamref name="TDst" /> type.</param>
          <summary>
            Create a batch prediction engine.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Api.ComponentCreation" Member="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateBatchPredictionEngine``2(Microsoft.ML.Runtime.IHostEnvironment,System.IO.Stream,System.Boolean,Microsoft.ML.Runtime.Api.SchemaDefinition,Microsoft.ML.Runtime.Api.SchemaDefinition)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreateDataView&lt;TRow&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.IDataView CreateDataView&lt;TRow&gt; (this Microsoft.ML.Runtime.IHostEnvironment env, System.Collections.Generic.IList&lt;TRow&gt; data, Microsoft.ML.Runtime.Api.SchemaDefinition schemaDefinition = null) where TRow : class;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.IDataView CreateDataView&lt;class TRow&gt;(class Microsoft.ML.Runtime.IHostEnvironment env, class System.Collections.Generic.IList`1&lt;!!TRow&gt; data, class Microsoft.ML.Runtime.Api.SchemaDefinition schemaDefinition) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateDataView``1(Microsoft.ML.Runtime.IHostEnvironment,System.Collections.Generic.IList{``0},Microsoft.ML.Runtime.Api.SchemaDefinition)" />
        <MemberSignature Language="F#" Value="static member CreateDataView : Microsoft.ML.Runtime.IHostEnvironment * System.Collections.Generic.IList&lt;'Row (requires 'Row : null)&gt; * Microsoft.ML.Runtime.Api.SchemaDefinition -&gt; Microsoft.ML.Runtime.Data.IDataView (requires 'Row : null)" Usage="Microsoft.ML.Runtime.Api.ComponentCreation.CreateDataView (env, data, schemaDefinition)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.IDataView</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRow">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" RefType="this" />
          <Parameter Name="data" Type="System.Collections.Generic.IList&lt;TRow&gt;" />
          <Parameter Name="schemaDefinition" Type="Microsoft.ML.Runtime.Api.SchemaDefinition" />
        </Parameters>
        <Docs>
          <typeparam name="TRow">The user-defined item type.</typeparam>
          <param name="env">The host environment to use for data view creation.</param>
          <param name="data">The data to wrap around.</param>
          <param name="schemaDefinition">The optional schema definition of the data view to create. If <c>null</c>,
             the schema definition is inferred from <typeparamref name="TRow" />.</param>
          <summary>
             Create a new <see cref="T:Microsoft.ML.Runtime.Data.IDataView" /> over an in-memory collection of the items of user-defined type.
             The user maintains ownership of the <paramref name="data" /> and the resulting data view will
             never alter the contents of the <paramref name="data" />.
             Since <see cref="T:Microsoft.ML.Runtime.Data.IDataView" /> is assumed to be immutable, the user is expected to not
             modify the contents of <paramref name="data" /> while the data view is being actively cursored.
            
             One typical usage for in-memory data view could be: create the data view, train a predictor.
             Once the predictor is fully trained, modify the contents of the underlying collection and
             train another predictor.
             </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Api.ComponentCreation" Member="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateDataView``1(Microsoft.ML.Runtime.IHostEnvironment,System.Collections.Generic.IList{``0},Microsoft.ML.Runtime.Api.SchemaDefinition)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreateDefaultScorer">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.IDataScorerTransform CreateDefaultScorer (this Microsoft.ML.Runtime.IHostEnvironment env, Microsoft.ML.Runtime.Data.RoleMappedData data, Microsoft.ML.Runtime.Api.Predictor predictor, Microsoft.ML.Runtime.Data.RoleMappedSchema trainSchema = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.IDataScorerTransform CreateDefaultScorer(class Microsoft.ML.Runtime.IHostEnvironment env, class Microsoft.ML.Runtime.Data.RoleMappedData data, class Microsoft.ML.Runtime.Api.Predictor predictor, class Microsoft.ML.Runtime.Data.RoleMappedSchema trainSchema) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateDefaultScorer(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.RoleMappedData,Microsoft.ML.Runtime.Api.Predictor,Microsoft.ML.Runtime.Data.RoleMappedSchema)" />
        <MemberSignature Language="F#" Value="static member CreateDefaultScorer : Microsoft.ML.Runtime.IHostEnvironment * Microsoft.ML.Runtime.Data.RoleMappedData * Microsoft.ML.Runtime.Api.Predictor * Microsoft.ML.Runtime.Data.RoleMappedSchema -&gt; Microsoft.ML.Runtime.Data.IDataScorerTransform" Usage="Microsoft.ML.Runtime.Api.ComponentCreation.CreateDefaultScorer (env, data, predictor, trainSchema)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.IDataScorerTransform</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.Runtime.Data.RoleMappedData" />
          <Parameter Name="predictor" Type="Microsoft.ML.Runtime.Api.Predictor" />
          <Parameter Name="trainSchema" Type="Microsoft.ML.Runtime.Data.RoleMappedSchema" />
        </Parameters>
        <Docs>
          <param name="env">The host environment to use.</param>
          <param name="data">The data to score.</param>
          <param name="predictor">The predictor to score.</param>
          <param name="trainSchema">The training data schema from which the scorer can optionally extract
            additional information, e.g., label names. If this is <c>null</c>, no information will be
            extracted.</param>
          <summary>
            Creates a default data scorer appropriate to the predictor's prediction kind.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Api.ComponentCreation" Member="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateDefaultScorer(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.RoleMappedData,Microsoft.ML.Runtime.Api.Predictor,Microsoft.ML.Runtime.Data.RoleMappedSchema)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreateEvaluator">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.IEvaluator CreateEvaluator (this Microsoft.ML.Runtime.IHostEnvironment env, string settings);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.IEvaluator CreateEvaluator(class Microsoft.ML.Runtime.IHostEnvironment env, string settings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateEvaluator(Microsoft.ML.Runtime.IHostEnvironment,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateEvaluator (env As IHostEnvironment, settings As String) As IEvaluator" />
        <MemberSignature Language="F#" Value="static member CreateEvaluator : Microsoft.ML.Runtime.IHostEnvironment * string -&gt; Microsoft.ML.Runtime.Data.IEvaluator" Usage="Microsoft.ML.Runtime.Api.ComponentCreation.CreateEvaluator (env, settings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.IEvaluator</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" RefType="this" />
          <Parameter Name="settings" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="env">To be added.</param>
          <param name="settings">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Api.ComponentCreation" Member="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateEvaluator(Microsoft.ML.Runtime.IHostEnvironment,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreateExamples">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.RoleMappedData CreateExamples (this Microsoft.ML.Runtime.IHostEnvironment env, Microsoft.ML.Runtime.Data.IDataView data, string features, string label = null, string group = null, string weight = null, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;Microsoft.ML.Runtime.Data.RoleMappedSchema.ColumnRole,string&gt;&gt; custom = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.RoleMappedData CreateExamples(class Microsoft.ML.Runtime.IHostEnvironment env, class Microsoft.ML.Runtime.Data.IDataView data, string features, string label, string group, string weight, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;valuetype Microsoft.ML.Runtime.Data.RoleMappedSchema/ColumnRole, string&gt;&gt; custom) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateExamples(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{Microsoft.ML.Runtime.Data.RoleMappedSchema.ColumnRole,System.String}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateExamples (env As IHostEnvironment, data As IDataView, features As String, Optional label As String = null, Optional group As String = null, Optional weight As String = null, Optional custom As IEnumerable(Of KeyValuePair(Of RoleMappedSchema.ColumnRole, String)) = null) As RoleMappedData" />
        <MemberSignature Language="F#" Value="static member CreateExamples : Microsoft.ML.Runtime.IHostEnvironment * Microsoft.ML.Runtime.Data.IDataView * string * string * string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;Microsoft.ML.Runtime.Data.RoleMappedSchema.ColumnRole, string&gt;&gt; -&gt; Microsoft.ML.Runtime.Data.RoleMappedData" Usage="Microsoft.ML.Runtime.Api.ComponentCreation.CreateExamples (env, data, features, label, group, weight, custom)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.RoleMappedData</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.Runtime.Data.IDataView" />
          <Parameter Name="features" Type="System.String" />
          <Parameter Name="label" Type="System.String" />
          <Parameter Name="group" Type="System.String" />
          <Parameter Name="weight" Type="System.String" />
          <Parameter Name="custom" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;Microsoft.ML.Runtime.Data.RoleMappedSchema+ColumnRole,System.String&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="env">The host environment to use.</param>
          <param name="data">The data to use for training or scoring.</param>
          <param name="features">The name of the features column. Can be null.</param>
          <param name="label">The name of the label column. Can be null.</param>
          <param name="group">The name of the group ID column (for ranking). Can be null.</param>
          <param name="weight">The name of the weight column. Can be null.</param>
          <param name="custom">Additional column mapping to be passed to the trainer or scorer (specific to the prediction type). Can be null or empty.</param>
          <summary>
            Generate training examples for training a predictor or instantiating a scorer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Api.ComponentCreation" Member="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateExamples(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{Microsoft.ML.Runtime.Data.RoleMappedSchema.ColumnRole,System.String}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreateLoader">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.IDataLoader CreateLoader (this Microsoft.ML.Runtime.IHostEnvironment env, string settings, Microsoft.ML.Runtime.Data.IMultiStreamSource files);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.IDataLoader CreateLoader(class Microsoft.ML.Runtime.IHostEnvironment env, string settings, class Microsoft.ML.Runtime.Data.IMultiStreamSource files) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateLoader(Microsoft.ML.Runtime.IHostEnvironment,System.String,Microsoft.ML.Runtime.Data.IMultiStreamSource)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateLoader (env As IHostEnvironment, settings As String, files As IMultiStreamSource) As IDataLoader" />
        <MemberSignature Language="F#" Value="static member CreateLoader : Microsoft.ML.Runtime.IHostEnvironment * string * Microsoft.ML.Runtime.Data.IMultiStreamSource -&gt; Microsoft.ML.Runtime.Data.IDataLoader" Usage="Microsoft.ML.Runtime.Api.ComponentCreation.CreateLoader (env, settings, files)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.IDataLoader</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" RefType="this" />
          <Parameter Name="settings" Type="System.String" />
          <Parameter Name="files" Type="Microsoft.ML.Runtime.Data.IMultiStreamSource" />
        </Parameters>
        <Docs>
          <param name="env">To be added.</param>
          <param name="settings">To be added.</param>
          <param name="files">To be added.</param>
          <summary>
            Creates a data loader from the 'LoadName{settings}' string.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Api.ComponentCreation" Member="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateLoader(Microsoft.ML.Runtime.IHostEnvironment,System.String,Microsoft.ML.Runtime.Data.IMultiStreamSource)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreateLoader&lt;TArgs&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.IDataLoader CreateLoader&lt;TArgs&gt; (this Microsoft.ML.Runtime.IHostEnvironment env, TArgs arguments, Microsoft.ML.Runtime.Data.IMultiStreamSource files) where TArgs : class, new();" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.IDataLoader CreateLoader&lt;class .ctor TArgs&gt;(class Microsoft.ML.Runtime.IHostEnvironment env, !!TArgs arguments, class Microsoft.ML.Runtime.Data.IMultiStreamSource files) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateLoader``1(Microsoft.ML.Runtime.IHostEnvironment,``0,Microsoft.ML.Runtime.Data.IMultiStreamSource)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateLoader(Of TArgs As {Class, New}) (env As IHostEnvironment, arguments As TArgs, files As IMultiStreamSource) As IDataLoader" />
        <MemberSignature Language="F#" Value="static member CreateLoader : Microsoft.ML.Runtime.IHostEnvironment * 'Args * Microsoft.ML.Runtime.Data.IMultiStreamSource -&gt; Microsoft.ML.Runtime.Data.IDataLoader (requires 'Args : null and 'Args : (new : unit -&gt; 'Args))" Usage="Microsoft.ML.Runtime.Api.ComponentCreation.CreateLoader (env, arguments, files)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.IDataLoader</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TArgs">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" RefType="this" />
          <Parameter Name="arguments" Type="TArgs" />
          <Parameter Name="files" Type="Microsoft.ML.Runtime.Data.IMultiStreamSource" />
        </Parameters>
        <Docs>
          <typeparam name="TArgs">To be added.</typeparam>
          <param name="env">To be added.</param>
          <param name="arguments">To be added.</param>
          <param name="files">To be added.</param>
          <summary>
            Creates a data loader from the arguments object.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Api.ComponentCreation" Member="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateLoader``1(Microsoft.ML.Runtime.IHostEnvironment,``0,Microsoft.ML.Runtime.Data.IMultiStreamSource)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreatePredictionEngine&lt;TSrc,TDst&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Api.PredictionEngine&lt;TSrc,TDst&gt; CreatePredictionEngine&lt;TSrc,TDst&gt; (this Microsoft.ML.Runtime.IHostEnvironment env, Microsoft.ML.Core.Data.ITransformer transformer, bool ignoreMissingColumns = false, Microsoft.ML.Runtime.Api.SchemaDefinition inputSchemaDefinition = null, Microsoft.ML.Runtime.Api.SchemaDefinition outputSchemaDefinition = null) where TSrc : class where TDst : class, new();" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Api.PredictionEngine`2&lt;!!TSrc, !!TDst&gt; CreatePredictionEngine&lt;class TSrc, class .ctor TDst&gt;(class Microsoft.ML.Runtime.IHostEnvironment env, class Microsoft.ML.Core.Data.ITransformer transformer, bool ignoreMissingColumns, class Microsoft.ML.Runtime.Api.SchemaDefinition inputSchemaDefinition, class Microsoft.ML.Runtime.Api.SchemaDefinition outputSchemaDefinition) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreatePredictionEngine``2(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Core.Data.ITransformer,System.Boolean,Microsoft.ML.Runtime.Api.SchemaDefinition,Microsoft.ML.Runtime.Api.SchemaDefinition)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreatePredictionEngine(Of TSrc As Class, TDst As Class) (env As IHostEnvironment, transformer As ITransformer, Optional ignoreMissingColumns As Boolean = false, Optional inputSchemaDefinition As SchemaDefinition = null, Optional outputSchemaDefinition As SchemaDefinition = null) As PredictionEngine(Of TSrc, TDst)" />
        <MemberSignature Language="F#" Value="static member CreatePredictionEngine : Microsoft.ML.Runtime.IHostEnvironment * Microsoft.ML.Core.Data.ITransformer * bool * Microsoft.ML.Runtime.Api.SchemaDefinition * Microsoft.ML.Runtime.Api.SchemaDefinition -&gt; Microsoft.ML.Runtime.Api.PredictionEngine&lt;'Src, 'Dst (requires 'Src : null and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))&gt; (requires 'Src : null and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))" Usage="Microsoft.ML.Runtime.Api.ComponentCreation.CreatePredictionEngine (env, transformer, ignoreMissingColumns, inputSchemaDefinition, outputSchemaDefinition)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Api.PredictionEngine&lt;TSrc,TDst&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSrc">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
          <TypeParameter Name="TDst">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" RefType="this" />
          <Parameter Name="transformer" Type="Microsoft.ML.Core.Data.ITransformer" />
          <Parameter Name="ignoreMissingColumns" Type="System.Boolean" />
          <Parameter Name="inputSchemaDefinition" Type="Microsoft.ML.Runtime.Api.SchemaDefinition" />
          <Parameter Name="outputSchemaDefinition" Type="Microsoft.ML.Runtime.Api.SchemaDefinition" />
        </Parameters>
        <Docs>
          <typeparam name="TSrc">To be added.</typeparam>
          <typeparam name="TDst">To be added.</typeparam>
          <param name="env">The host environment to use.</param>
          <param name="transformer">The transformer.</param>
          <param name="ignoreMissingColumns">Whether to ignore missing columns in the data view.</param>
          <param name="inputSchemaDefinition">The optional input schema. If <c>null</c>, the schema is inferred from the <typeparamref name="TSrc" /> type.</param>
          <param name="outputSchemaDefinition">The optional output schema. If <c>null</c>, the schema is inferred from the <typeparamref name="TDst" /> type.</param>
          <summary>
            Create an on-demand prediction engine.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Api.ComponentCreation" Member="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreatePredictionEngine``2(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Core.Data.ITransformer,System.Boolean,Microsoft.ML.Runtime.Api.SchemaDefinition,Microsoft.ML.Runtime.Api.SchemaDefinition)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreatePredictionEngine&lt;TSrc,TDst&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Api.PredictionEngine&lt;TSrc,TDst&gt; CreatePredictionEngine&lt;TSrc,TDst&gt; (this Microsoft.ML.Runtime.IHostEnvironment env, Microsoft.ML.Runtime.Data.IDataView dataPipe, bool ignoreMissingColumns = false, Microsoft.ML.Runtime.Api.SchemaDefinition inputSchemaDefinition = null, Microsoft.ML.Runtime.Api.SchemaDefinition outputSchemaDefinition = null) where TSrc : class where TDst : class, new();" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Api.PredictionEngine`2&lt;!!TSrc, !!TDst&gt; CreatePredictionEngine&lt;class TSrc, class .ctor TDst&gt;(class Microsoft.ML.Runtime.IHostEnvironment env, class Microsoft.ML.Runtime.Data.IDataView dataPipe, bool ignoreMissingColumns, class Microsoft.ML.Runtime.Api.SchemaDefinition inputSchemaDefinition, class Microsoft.ML.Runtime.Api.SchemaDefinition outputSchemaDefinition) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreatePredictionEngine``2(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.Boolean,Microsoft.ML.Runtime.Api.SchemaDefinition,Microsoft.ML.Runtime.Api.SchemaDefinition)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreatePredictionEngine(Of TSrc As Class, TDst As Class) (env As IHostEnvironment, dataPipe As IDataView, Optional ignoreMissingColumns As Boolean = false, Optional inputSchemaDefinition As SchemaDefinition = null, Optional outputSchemaDefinition As SchemaDefinition = null) As PredictionEngine(Of TSrc, TDst)" />
        <MemberSignature Language="F#" Value="static member CreatePredictionEngine : Microsoft.ML.Runtime.IHostEnvironment * Microsoft.ML.Runtime.Data.IDataView * bool * Microsoft.ML.Runtime.Api.SchemaDefinition * Microsoft.ML.Runtime.Api.SchemaDefinition -&gt; Microsoft.ML.Runtime.Api.PredictionEngine&lt;'Src, 'Dst (requires 'Src : null and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))&gt; (requires 'Src : null and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))" Usage="Microsoft.ML.Runtime.Api.ComponentCreation.CreatePredictionEngine (env, dataPipe, ignoreMissingColumns, inputSchemaDefinition, outputSchemaDefinition)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Api.PredictionEngine&lt;TSrc,TDst&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSrc">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
          <TypeParameter Name="TDst">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" RefType="this" />
          <Parameter Name="dataPipe" Type="Microsoft.ML.Runtime.Data.IDataView" />
          <Parameter Name="ignoreMissingColumns" Type="System.Boolean" />
          <Parameter Name="inputSchemaDefinition" Type="Microsoft.ML.Runtime.Api.SchemaDefinition" />
          <Parameter Name="outputSchemaDefinition" Type="Microsoft.ML.Runtime.Api.SchemaDefinition" />
        </Parameters>
        <Docs>
          <typeparam name="TSrc">To be added.</typeparam>
          <typeparam name="TDst">To be added.</typeparam>
          <param name="env">The host environment to use.</param>
          <param name="dataPipe">The transformation pipe that may or may not include a scorer.</param>
          <param name="ignoreMissingColumns">Whether to ignore missing columns in the data view.</param>
          <param name="inputSchemaDefinition">The optional input schema. If <c>null</c>, the schema is inferred from the <typeparamref name="TSrc" /> type.</param>
          <param name="outputSchemaDefinition">The optional output schema. If <c>null</c>, the schema is inferred from the <typeparamref name="TDst" /> type.</param>
          <summary>
            Create an on-demand prediction engine.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Api.ComponentCreation" Member="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreatePredictionEngine``2(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.Boolean,Microsoft.ML.Runtime.Api.SchemaDefinition,Microsoft.ML.Runtime.Api.SchemaDefinition)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreatePredictionEngine&lt;TSrc,TDst&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Api.PredictionEngine&lt;TSrc,TDst&gt; CreatePredictionEngine&lt;TSrc,TDst&gt; (this Microsoft.ML.Runtime.IHostEnvironment env, System.IO.Stream modelStream, bool ignoreMissingColumns = false, Microsoft.ML.Runtime.Api.SchemaDefinition inputSchemaDefinition = null, Microsoft.ML.Runtime.Api.SchemaDefinition outputSchemaDefinition = null) where TSrc : class where TDst : class, new();" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Api.PredictionEngine`2&lt;!!TSrc, !!TDst&gt; CreatePredictionEngine&lt;class TSrc, class .ctor TDst&gt;(class Microsoft.ML.Runtime.IHostEnvironment env, class System.IO.Stream modelStream, bool ignoreMissingColumns, class Microsoft.ML.Runtime.Api.SchemaDefinition inputSchemaDefinition, class Microsoft.ML.Runtime.Api.SchemaDefinition outputSchemaDefinition) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreatePredictionEngine``2(Microsoft.ML.Runtime.IHostEnvironment,System.IO.Stream,System.Boolean,Microsoft.ML.Runtime.Api.SchemaDefinition,Microsoft.ML.Runtime.Api.SchemaDefinition)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreatePredictionEngine(Of TSrc As Class, TDst As Class) (env As IHostEnvironment, modelStream As Stream, Optional ignoreMissingColumns As Boolean = false, Optional inputSchemaDefinition As SchemaDefinition = null, Optional outputSchemaDefinition As SchemaDefinition = null) As PredictionEngine(Of TSrc, TDst)" />
        <MemberSignature Language="F#" Value="static member CreatePredictionEngine : Microsoft.ML.Runtime.IHostEnvironment * System.IO.Stream * bool * Microsoft.ML.Runtime.Api.SchemaDefinition * Microsoft.ML.Runtime.Api.SchemaDefinition -&gt; Microsoft.ML.Runtime.Api.PredictionEngine&lt;'Src, 'Dst (requires 'Src : null and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))&gt; (requires 'Src : null and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))" Usage="Microsoft.ML.Runtime.Api.ComponentCreation.CreatePredictionEngine (env, modelStream, ignoreMissingColumns, inputSchemaDefinition, outputSchemaDefinition)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Api.PredictionEngine&lt;TSrc,TDst&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSrc">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
          <TypeParameter Name="TDst">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" RefType="this" />
          <Parameter Name="modelStream" Type="System.IO.Stream" />
          <Parameter Name="ignoreMissingColumns" Type="System.Boolean" />
          <Parameter Name="inputSchemaDefinition" Type="Microsoft.ML.Runtime.Api.SchemaDefinition" />
          <Parameter Name="outputSchemaDefinition" Type="Microsoft.ML.Runtime.Api.SchemaDefinition" />
        </Parameters>
        <Docs>
          <typeparam name="TSrc">To be added.</typeparam>
          <typeparam name="TDst">To be added.</typeparam>
          <param name="env">The host environment to use.</param>
          <param name="modelStream">The stream to deserialize the pipeline (transforms and predictor) from.</param>
          <param name="ignoreMissingColumns">Whether to ignore missing columns in the data view.</param>
          <param name="inputSchemaDefinition">The optional input schema. If <c>null</c>, the schema is inferred from the <typeparamref name="TSrc" /> type.</param>
          <param name="outputSchemaDefinition">The optional output schema. If <c>null</c>, the schema is inferred from the <typeparamref name="TDst" /> type.</param>
          <summary>
            Create an on-demand prediction engine.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Api.ComponentCreation" Member="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreatePredictionEngine``2(Microsoft.ML.Runtime.IHostEnvironment,System.IO.Stream,System.Boolean,Microsoft.ML.Runtime.Api.SchemaDefinition,Microsoft.ML.Runtime.Api.SchemaDefinition)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreateSaver">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.IDataSaver CreateSaver (this Microsoft.ML.Runtime.IHostEnvironment env, string settings);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.IDataSaver CreateSaver(class Microsoft.ML.Runtime.IHostEnvironment env, string settings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateSaver(Microsoft.ML.Runtime.IHostEnvironment,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateSaver (env As IHostEnvironment, settings As String) As IDataSaver" />
        <MemberSignature Language="F#" Value="static member CreateSaver : Microsoft.ML.Runtime.IHostEnvironment * string -&gt; Microsoft.ML.Runtime.Data.IDataSaver" Usage="Microsoft.ML.Runtime.Api.ComponentCreation.CreateSaver (env, settings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.IDataSaver</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" RefType="this" />
          <Parameter Name="settings" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="env">To be added.</param>
          <param name="settings">To be added.</param>
          <summary>
            Creates a data saver from the 'LoadName{settings}' string.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Api.ComponentCreation" Member="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateSaver(Microsoft.ML.Runtime.IHostEnvironment,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreateSaver&lt;TArgs&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.IDataSaver CreateSaver&lt;TArgs&gt; (this Microsoft.ML.Runtime.IHostEnvironment env, TArgs arguments) where TArgs : class, new();" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.IDataSaver CreateSaver&lt;class .ctor TArgs&gt;(class Microsoft.ML.Runtime.IHostEnvironment env, !!TArgs arguments) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateSaver``1(Microsoft.ML.Runtime.IHostEnvironment,``0)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateSaver(Of TArgs As {Class, New}) (env As IHostEnvironment, arguments As TArgs) As IDataSaver" />
        <MemberSignature Language="F#" Value="static member CreateSaver : Microsoft.ML.Runtime.IHostEnvironment * 'Args -&gt; Microsoft.ML.Runtime.Data.IDataSaver (requires 'Args : null and 'Args : (new : unit -&gt; 'Args))" Usage="Microsoft.ML.Runtime.Api.ComponentCreation.CreateSaver (env, arguments)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.IDataSaver</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TArgs">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" RefType="this" />
          <Parameter Name="arguments" Type="TArgs" />
        </Parameters>
        <Docs>
          <typeparam name="TArgs">To be added.</typeparam>
          <param name="env">To be added.</param>
          <param name="arguments">To be added.</param>
          <summary>
            Creates a data saver from the arguments object.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Api.ComponentCreation" Member="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateSaver``1(Microsoft.ML.Runtime.IHostEnvironment,``0)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreateScorer">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.IDataScorerTransform CreateScorer (this Microsoft.ML.Runtime.IHostEnvironment env, string settings, Microsoft.ML.Runtime.Data.RoleMappedData data, Microsoft.ML.Runtime.Api.Predictor predictor, Microsoft.ML.Runtime.Data.RoleMappedSchema trainSchema = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.IDataScorerTransform CreateScorer(class Microsoft.ML.Runtime.IHostEnvironment env, string settings, class Microsoft.ML.Runtime.Data.RoleMappedData data, class Microsoft.ML.Runtime.Api.Predictor predictor, class Microsoft.ML.Runtime.Data.RoleMappedSchema trainSchema) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateScorer(Microsoft.ML.Runtime.IHostEnvironment,System.String,Microsoft.ML.Runtime.Data.RoleMappedData,Microsoft.ML.Runtime.Api.Predictor,Microsoft.ML.Runtime.Data.RoleMappedSchema)" />
        <MemberSignature Language="F#" Value="static member CreateScorer : Microsoft.ML.Runtime.IHostEnvironment * string * Microsoft.ML.Runtime.Data.RoleMappedData * Microsoft.ML.Runtime.Api.Predictor * Microsoft.ML.Runtime.Data.RoleMappedSchema -&gt; Microsoft.ML.Runtime.Data.IDataScorerTransform" Usage="Microsoft.ML.Runtime.Api.ComponentCreation.CreateScorer (env, settings, data, predictor, trainSchema)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.IDataScorerTransform</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" RefType="this" />
          <Parameter Name="settings" Type="System.String" />
          <Parameter Name="data" Type="Microsoft.ML.Runtime.Data.RoleMappedData" />
          <Parameter Name="predictor" Type="Microsoft.ML.Runtime.Api.Predictor" />
          <Parameter Name="trainSchema" Type="Microsoft.ML.Runtime.Data.RoleMappedSchema" />
        </Parameters>
        <Docs>
          <param name="env">The host environment to use.</param>
          <param name="settings">The settings string.</param>
          <param name="data">The data to score.</param>
          <param name="predictor">The predictor to score.</param>
          <param name="trainSchema">The training data schema from which the scorer can optionally extract
            additional information, e.g., label names. If this is <c>null</c>, no information will be
            extracted.</param>
          <summary>
            Creates a data scorer from the 'LoadName{settings}' string.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Api.ComponentCreation" Member="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateScorer(Microsoft.ML.Runtime.IHostEnvironment,System.String,Microsoft.ML.Runtime.Data.RoleMappedData,Microsoft.ML.Runtime.Api.Predictor,Microsoft.ML.Runtime.Data.RoleMappedSchema)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreateSimplePredictionEngine">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Api.SimplePredictionEngine CreateSimplePredictionEngine (this Microsoft.ML.Runtime.IHostEnvironment env, System.IO.Stream modelStream, int nFeatures);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Api.SimplePredictionEngine CreateSimplePredictionEngine(class Microsoft.ML.Runtime.IHostEnvironment env, class System.IO.Stream modelStream, int32 nFeatures) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateSimplePredictionEngine(Microsoft.ML.Runtime.IHostEnvironment,System.IO.Stream,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateSimplePredictionEngine (env As IHostEnvironment, modelStream As Stream, nFeatures As Integer) As SimplePredictionEngine" />
        <MemberSignature Language="F#" Value="static member CreateSimplePredictionEngine : Microsoft.ML.Runtime.IHostEnvironment * System.IO.Stream * int -&gt; Microsoft.ML.Runtime.Api.SimplePredictionEngine" Usage="Microsoft.ML.Runtime.Api.ComponentCreation.CreateSimplePredictionEngine (env, modelStream, nFeatures)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Api.SimplePredictionEngine</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" RefType="this" />
          <Parameter Name="modelStream" Type="System.IO.Stream" />
          <Parameter Name="nFeatures" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="env">The host environment to use.</param>
          <param name="modelStream">The model stream to load pipeline from.</param>
          <param name="nFeatures">Number of features.</param>
          <summary>
            Create a prediction engine.
            This encapsulates the 'classic' prediction problem, where the input is denoted by the float array of features,
            and the output is a float score. For binary classification predictors that can output probability, there are output
            fields that report the predicted label and probability.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Api.ComponentCreation" Member="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateSimplePredictionEngine(Microsoft.ML.Runtime.IHostEnvironment,System.IO.Stream,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreateStreamingDataView&lt;TRow&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.IDataView CreateStreamingDataView&lt;TRow&gt; (this Microsoft.ML.Runtime.IHostEnvironment env, System.Collections.Generic.IEnumerable&lt;TRow&gt; data, Microsoft.ML.Runtime.Api.SchemaDefinition schemaDefinition = null) where TRow : class;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.IDataView CreateStreamingDataView&lt;class TRow&gt;(class Microsoft.ML.Runtime.IHostEnvironment env, class System.Collections.Generic.IEnumerable`1&lt;!!TRow&gt; data, class Microsoft.ML.Runtime.Api.SchemaDefinition schemaDefinition) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateStreamingDataView``1(Microsoft.ML.Runtime.IHostEnvironment,System.Collections.Generic.IEnumerable{``0},Microsoft.ML.Runtime.Api.SchemaDefinition)" />
        <MemberSignature Language="F#" Value="static member CreateStreamingDataView : Microsoft.ML.Runtime.IHostEnvironment * seq&lt;'Row (requires 'Row : null)&gt; * Microsoft.ML.Runtime.Api.SchemaDefinition -&gt; Microsoft.ML.Runtime.Data.IDataView (requires 'Row : null)" Usage="Microsoft.ML.Runtime.Api.ComponentCreation.CreateStreamingDataView (env, data, schemaDefinition)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.IDataView</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRow">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" RefType="this" />
          <Parameter Name="data" Type="System.Collections.Generic.IEnumerable&lt;TRow&gt;" />
          <Parameter Name="schemaDefinition" Type="Microsoft.ML.Runtime.Api.SchemaDefinition" />
        </Parameters>
        <Docs>
          <typeparam name="TRow">The user-defined item type.</typeparam>
          <param name="env">The host environment to use for data view creation.</param>
          <param name="data">The data to wrap around.</param>
          <param name="schemaDefinition">The optional schema definition of the data view to create. If <c>null</c>,
             the schema definition is inferred from <typeparamref name="TRow" />.</param>
          <summary>
             Create a new <see cref="T:Microsoft.ML.Runtime.Data.IDataView" /> over an enumerable of the items of user-defined type.
             The user maintains ownership of the <paramref name="data" /> and the resulting data view will
             never alter the contents of the <paramref name="data" />.
             Since <see cref="T:Microsoft.ML.Runtime.Data.IDataView" /> is assumed to be immutable, the user is expected to support
             multiple enumeration of the <paramref name="data" /> that would return the same results, unless
             the user knows that the data will only be cursored once.
            
             One typical usage for streaming data view could be: create the data view that lazily loads data
             as needed, then apply pre-trained transformations to it and cursor through it for transformation
             results. This is how <see cref="T:Microsoft.ML.Runtime.Api.BatchPredictionEngine`2" /> is implemented.
             </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Api.ComponentCreation" Member="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateStreamingDataView``1(Microsoft.ML.Runtime.IHostEnvironment,System.Collections.Generic.IEnumerable{``0},Microsoft.ML.Runtime.Api.SchemaDefinition)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreateTransform">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.IDataTransform CreateTransform (this Microsoft.ML.Runtime.IHostEnvironment env, string settings, Microsoft.ML.Runtime.Data.IDataView source);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.IDataTransform CreateTransform(class Microsoft.ML.Runtime.IHostEnvironment env, string settings, class Microsoft.ML.Runtime.Data.IDataView source) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateTransform(Microsoft.ML.Runtime.IHostEnvironment,System.String,Microsoft.ML.Runtime.Data.IDataView)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateTransform (env As IHostEnvironment, settings As String, source As IDataView) As IDataTransform" />
        <MemberSignature Language="F#" Value="static member CreateTransform : Microsoft.ML.Runtime.IHostEnvironment * string * Microsoft.ML.Runtime.Data.IDataView -&gt; Microsoft.ML.Runtime.Data.IDataTransform" Usage="Microsoft.ML.Runtime.Api.ComponentCreation.CreateTransform (env, settings, source)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.IDataTransform</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" RefType="this" />
          <Parameter Name="settings" Type="System.String" />
          <Parameter Name="source" Type="Microsoft.ML.Runtime.Data.IDataView" />
        </Parameters>
        <Docs>
          <param name="env">To be added.</param>
          <param name="settings">To be added.</param>
          <param name="source">To be added.</param>
          <summary>
            Creates a data transform from the 'LoadName{settings}' string.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Api.ComponentCreation" Member="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateTransform(Microsoft.ML.Runtime.IHostEnvironment,System.String,Microsoft.ML.Runtime.Data.IDataView)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreateTransform&lt;TArgs&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.IDataTransform CreateTransform&lt;TArgs&gt; (this Microsoft.ML.Runtime.IHostEnvironment env, TArgs arguments, Microsoft.ML.Runtime.Data.IDataView source) where TArgs : class, new();" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.IDataTransform CreateTransform&lt;class .ctor TArgs&gt;(class Microsoft.ML.Runtime.IHostEnvironment env, !!TArgs arguments, class Microsoft.ML.Runtime.Data.IDataView source) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateTransform``1(Microsoft.ML.Runtime.IHostEnvironment,``0,Microsoft.ML.Runtime.Data.IDataView)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateTransform(Of TArgs As {Class, New}) (env As IHostEnvironment, arguments As TArgs, source As IDataView) As IDataTransform" />
        <MemberSignature Language="F#" Value="static member CreateTransform : Microsoft.ML.Runtime.IHostEnvironment * 'Args * Microsoft.ML.Runtime.Data.IDataView -&gt; Microsoft.ML.Runtime.Data.IDataTransform (requires 'Args : null and 'Args : (new : unit -&gt; 'Args))" Usage="Microsoft.ML.Runtime.Api.ComponentCreation.CreateTransform (env, arguments, source)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.IDataTransform</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TArgs">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" RefType="this" />
          <Parameter Name="arguments" Type="TArgs" />
          <Parameter Name="source" Type="Microsoft.ML.Runtime.Data.IDataView" />
        </Parameters>
        <Docs>
          <typeparam name="TArgs">To be added.</typeparam>
          <param name="env">To be added.</param>
          <param name="arguments">To be added.</param>
          <param name="source">To be added.</param>
          <summary>
            Creates a data transform from the arguments object.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Api.ComponentCreation" Member="M:Microsoft.ML.Runtime.Api.ComponentCreation.CreateTransform``1(Microsoft.ML.Runtime.IHostEnvironment,``0,Microsoft.ML.Runtime.Data.IDataView)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IHostEnvironment" />
      </Targets>
      <Member MemberName="LoadPredictorOrNull">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Api.Predictor LoadPredictorOrNull (this Microsoft.ML.Runtime.IHostEnvironment env, System.IO.Stream modelStream);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Api.Predictor LoadPredictorOrNull(class Microsoft.ML.Runtime.IHostEnvironment env, class System.IO.Stream modelStream) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Api.ComponentCreation.LoadPredictorOrNull(Microsoft.ML.Runtime.IHostEnvironment,System.IO.Stream)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LoadPredictorOrNull (env As IHostEnvironment, modelStream As Stream) As Predictor" />
        <MemberSignature Language="F#" Value="static member LoadPredictorOrNull : Microsoft.ML.Runtime.IHostEnvironment * System.IO.Stream -&gt; Microsoft.ML.Runtime.Api.Predictor" Usage="Microsoft.ML.Runtime.Api.ComponentCreation.LoadPredictorOrNull (env, modelStream)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Api.Predictor</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" RefType="this" />
          <Parameter Name="modelStream" Type="System.IO.Stream" />
        </Parameters>
        <Docs>
          <param name="env">The host environment to use.</param>
          <param name="modelStream">The model stream.</param>
          <summary>
            Loads a predictor from the model stream. Returns null iff there's no predictor.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Api.ComponentCreation" Member="M:Microsoft.ML.Runtime.Api.ComponentCreation.LoadPredictorOrNull(Microsoft.ML.Runtime.IHostEnvironment,System.IO.Stream)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IHostEnvironment" />
      </Targets>
      <Member MemberName="LoadTransforms">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.IDataView LoadTransforms (this Microsoft.ML.Runtime.IHostEnvironment env, System.IO.Stream modelStream, Microsoft.ML.Runtime.Data.IDataView data);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.IDataView LoadTransforms(class Microsoft.ML.Runtime.IHostEnvironment env, class System.IO.Stream modelStream, class Microsoft.ML.Runtime.Data.IDataView data) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Api.ComponentCreation.LoadTransforms(Microsoft.ML.Runtime.IHostEnvironment,System.IO.Stream,Microsoft.ML.Runtime.Data.IDataView)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LoadTransforms (env As IHostEnvironment, modelStream As Stream, data As IDataView) As IDataView" />
        <MemberSignature Language="F#" Value="static member LoadTransforms : Microsoft.ML.Runtime.IHostEnvironment * System.IO.Stream * Microsoft.ML.Runtime.Data.IDataView -&gt; Microsoft.ML.Runtime.Data.IDataView" Usage="Microsoft.ML.Runtime.Api.ComponentCreation.LoadTransforms (env, modelStream, data)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.IDataView</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" RefType="this" />
          <Parameter Name="modelStream" Type="System.IO.Stream" />
          <Parameter Name="data" Type="Microsoft.ML.Runtime.Data.IDataView" />
        </Parameters>
        <Docs>
          <param name="env">The host environment to use.</param>
          <param name="modelStream">The model stream to load from.</param>
          <param name="data">The data to apply transforms to.</param>
          <summary>
            Load the transforms (but not loader) from the model steram and apply them to the specified data.
            It is acceptable to have no transforms in the model stream: in this case the original
            <paramref name="data" /> will be returned.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Api.ComponentCreation" Member="M:Microsoft.ML.Runtime.Api.ComponentCreation.LoadTransforms(Microsoft.ML.Runtime.IHostEnvironment,System.IO.Stream,Microsoft.ML.Runtime.Data.IDataView)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IHostEnvironment" />
      </Targets>
      <Member MemberName="Zip">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.IDataView Zip (this Microsoft.ML.Runtime.IHostEnvironment env, System.Collections.Generic.IEnumerable&lt;Microsoft.ML.Runtime.Data.IDataView&gt; sources);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.IDataView Zip(class Microsoft.ML.Runtime.IHostEnvironment env, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.ML.Runtime.Data.IDataView&gt; sources) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Api.ComponentCreation.Zip(Microsoft.ML.Runtime.IHostEnvironment,System.Collections.Generic.IEnumerable{Microsoft.ML.Runtime.Data.IDataView})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Zip (env As IHostEnvironment, sources As IEnumerable(Of IDataView)) As IDataView" />
        <MemberSignature Language="F#" Value="static member Zip : Microsoft.ML.Runtime.IHostEnvironment * seq&lt;Microsoft.ML.Runtime.Data.IDataView&gt; -&gt; Microsoft.ML.Runtime.Data.IDataView" Usage="Microsoft.ML.Runtime.Api.ComponentCreation.Zip (env, sources)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.IDataView</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" RefType="this" />
          <Parameter Name="sources" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.ML.Runtime.Data.IDataView&gt;" />
        </Parameters>
        <Docs>
          <param name="env">The host environment to use.</param>
          <param name="sources">A non-empty collection of data views to zip together.</param>
          <summary>
            Create a new data view which is obtained by appending all columns of all the source data views.
            If the data views are of different length, the resulting data view will have the length equal to the
            length of the shortest source.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Api.ComponentCreation" Member="M:Microsoft.ML.Runtime.Api.ComponentCreation.Zip(Microsoft.ML.Runtime.IHostEnvironment,System.Collections.Generic.IEnumerable{Microsoft.ML.Runtime.Data.IDataView})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.IDataView" />
      </Targets>
      <Member MemberName="AsCursorable&lt;TRow&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Api.ICursorable&lt;TRow&gt; AsCursorable&lt;TRow&gt; (this Microsoft.ML.Runtime.Data.IDataView data, Microsoft.ML.Runtime.IHostEnvironment env, bool ignoreMissingColumns = false, Microsoft.ML.Runtime.Api.SchemaDefinition schemaDefinition = null) where TRow : class, new();" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Api.ICursorable`1&lt;!!TRow&gt; AsCursorable&lt;class .ctor TRow&gt;(class Microsoft.ML.Runtime.Data.IDataView data, class Microsoft.ML.Runtime.IHostEnvironment env, bool ignoreMissingColumns, class Microsoft.ML.Runtime.Api.SchemaDefinition schemaDefinition) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Api.CursoringUtils.AsCursorable``1(Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.IHostEnvironment,System.Boolean,Microsoft.ML.Runtime.Api.SchemaDefinition)" />
        <MemberSignature Language="F#" Value="static member AsCursorable : Microsoft.ML.Runtime.Data.IDataView * Microsoft.ML.Runtime.IHostEnvironment * bool * Microsoft.ML.Runtime.Api.SchemaDefinition -&gt; Microsoft.ML.Runtime.Api.ICursorable&lt;'Row (requires 'Row : null and 'Row : (new : unit -&gt; 'Row))&gt; (requires 'Row : null and 'Row : (new : unit -&gt; 'Row))" Usage="Microsoft.ML.Runtime.Api.CursoringUtils.AsCursorable (data, env, ignoreMissingColumns, schemaDefinition)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Api.ICursorable&lt;TRow&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRow">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.Runtime.Data.IDataView" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
          <Parameter Name="ignoreMissingColumns" Type="System.Boolean" />
          <Parameter Name="schemaDefinition" Type="Microsoft.ML.Runtime.Api.SchemaDefinition" />
        </Parameters>
        <Docs>
          <typeparam name="TRow">The user-defined row type.</typeparam>
          <param name="data">The underlying data view.</param>
          <param name="env">The environment.</param>
          <param name="ignoreMissingColumns">Whether to ignore the case when a requested column is not present in the data view.</param>
          <param name="schemaDefinition">Optional user-provided schema definition. If it is not present, the schema is inferred from the definition of T.</param>
          <summary>
            Generate a strongly-typed cursorable wrapper of the <see cref="T:Microsoft.ML.Runtime.Data.IDataView" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Api.CursoringUtils" Member="M:Microsoft.ML.Runtime.Api.CursoringUtils.AsCursorable``1(Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.IHostEnvironment,System.Boolean,Microsoft.ML.Runtime.Api.SchemaDefinition)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.IDataView" />
      </Targets>
      <Member MemberName="AsCursorable&lt;TRow&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Api.ICursorable&lt;TRow&gt; AsCursorable&lt;TRow&gt; (this Microsoft.ML.Runtime.Data.IDataView data, bool ignoreMissingColumns = false, Microsoft.ML.Runtime.Api.SchemaDefinition schemaDefinition = null) where TRow : class, new();" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Api.ICursorable`1&lt;!!TRow&gt; AsCursorable&lt;class .ctor TRow&gt;(class Microsoft.ML.Runtime.Data.IDataView data, bool ignoreMissingColumns, class Microsoft.ML.Runtime.Api.SchemaDefinition schemaDefinition) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Api.CursoringUtils.AsCursorable``1(Microsoft.ML.Runtime.Data.IDataView,System.Boolean,Microsoft.ML.Runtime.Api.SchemaDefinition)" />
        <MemberSignature Language="F#" Value="static member AsCursorable : Microsoft.ML.Runtime.Data.IDataView * bool * Microsoft.ML.Runtime.Api.SchemaDefinition -&gt; Microsoft.ML.Runtime.Api.ICursorable&lt;'Row (requires 'Row : null and 'Row : (new : unit -&gt; 'Row))&gt; (requires 'Row : null and 'Row : (new : unit -&gt; 'Row))" Usage="Microsoft.ML.Runtime.Api.CursoringUtils.AsCursorable (data, ignoreMissingColumns, schemaDefinition)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Api.ICursorable&lt;TRow&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRow">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.Runtime.Data.IDataView" RefType="this" />
          <Parameter Name="ignoreMissingColumns" Type="System.Boolean" />
          <Parameter Name="schemaDefinition" Type="Microsoft.ML.Runtime.Api.SchemaDefinition" />
        </Parameters>
        <Docs>
          <typeparam name="TRow">The user-defined row type.</typeparam>
          <param name="data">The underlying data view.</param>
          <param name="ignoreMissingColumns">Whether to ignore the case when a requested column is not present in the data view.</param>
          <param name="schemaDefinition">Optional user-provided schema definition. If it is not present, the schema is inferred from the definition of T.</param>
          <summary>
            Generate a strongly-typed cursorable wrapper of the <see cref="T:Microsoft.ML.Runtime.Data.IDataView" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Api.CursoringUtils" Member="M:Microsoft.ML.Runtime.Api.CursoringUtils.AsCursorable``1(Microsoft.ML.Runtime.Data.IDataView,System.Boolean,Microsoft.ML.Runtime.Api.SchemaDefinition)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.IDataView" />
      </Targets>
      <Member MemberName="AsEnumerable&lt;TRow&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TRow&gt; AsEnumerable&lt;TRow&gt; (this Microsoft.ML.Runtime.Data.IDataView data, Microsoft.ML.Runtime.IHostEnvironment env, bool reuseRowObject, bool ignoreMissingColumns = false, Microsoft.ML.Runtime.Api.SchemaDefinition schemaDefinition = null) where TRow : class, new();" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TRow&gt; AsEnumerable&lt;class .ctor TRow&gt;(class Microsoft.ML.Runtime.Data.IDataView data, class Microsoft.ML.Runtime.IHostEnvironment env, bool reuseRowObject, bool ignoreMissingColumns, class Microsoft.ML.Runtime.Api.SchemaDefinition schemaDefinition) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Api.CursoringUtils.AsEnumerable``1(Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.IHostEnvironment,System.Boolean,System.Boolean,Microsoft.ML.Runtime.Api.SchemaDefinition)" />
        <MemberSignature Language="F#" Value="static member AsEnumerable : Microsoft.ML.Runtime.Data.IDataView * Microsoft.ML.Runtime.IHostEnvironment * bool * bool * Microsoft.ML.Runtime.Api.SchemaDefinition -&gt; seq&lt;'Row (requires 'Row : null and 'Row : (new : unit -&gt; 'Row))&gt; (requires 'Row : null and 'Row : (new : unit -&gt; 'Row))" Usage="Microsoft.ML.Runtime.Api.CursoringUtils.AsEnumerable (data, env, reuseRowObject, ignoreMissingColumns, schemaDefinition)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;TRow&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRow">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.Runtime.Data.IDataView" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
          <Parameter Name="reuseRowObject" Type="System.Boolean" />
          <Parameter Name="ignoreMissingColumns" Type="System.Boolean" />
          <Parameter Name="schemaDefinition" Type="Microsoft.ML.Runtime.Api.SchemaDefinition" />
        </Parameters>
        <Docs>
          <typeparam name="TRow">The user-defined row type.</typeparam>
          <param name="data">The underlying data view.</param>
          <param name="env">The environment.</param>
          <param name="reuseRowObject">Whether to return the same object on every row, or allocate a new one per row.</param>
          <param name="ignoreMissingColumns">Whether to ignore the case when a requested column is not present in the data view.</param>
          <param name="schemaDefinition">Optional user-provided schema definition. If it is not present, the schema is inferred from the definition of T.</param>
          <summary>
            Convert an <see cref="T:Microsoft.ML.Runtime.Data.IDataView" /> into a strongly-typed <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Api.CursoringUtils" Member="M:Microsoft.ML.Runtime.Api.CursoringUtils.AsEnumerable``1(Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.IHostEnvironment,System.Boolean,System.Boolean,Microsoft.ML.Runtime.Api.SchemaDefinition)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.IDataView" />
      </Targets>
      <Member MemberName="AsEnumerable&lt;TRow&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TRow&gt; AsEnumerable&lt;TRow&gt; (this Microsoft.ML.Runtime.Data.IDataView data, bool reuseRowObject, bool ignoreMissingColumns = false, Microsoft.ML.Runtime.Api.SchemaDefinition schemaDefinition = null) where TRow : class, new();" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TRow&gt; AsEnumerable&lt;class .ctor TRow&gt;(class Microsoft.ML.Runtime.Data.IDataView data, bool reuseRowObject, bool ignoreMissingColumns, class Microsoft.ML.Runtime.Api.SchemaDefinition schemaDefinition) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Api.CursoringUtils.AsEnumerable``1(Microsoft.ML.Runtime.Data.IDataView,System.Boolean,System.Boolean,Microsoft.ML.Runtime.Api.SchemaDefinition)" />
        <MemberSignature Language="F#" Value="static member AsEnumerable : Microsoft.ML.Runtime.Data.IDataView * bool * bool * Microsoft.ML.Runtime.Api.SchemaDefinition -&gt; seq&lt;'Row (requires 'Row : null and 'Row : (new : unit -&gt; 'Row))&gt; (requires 'Row : null and 'Row : (new : unit -&gt; 'Row))" Usage="Microsoft.ML.Runtime.Api.CursoringUtils.AsEnumerable (data, reuseRowObject, ignoreMissingColumns, schemaDefinition)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;TRow&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRow">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.Runtime.Data.IDataView" RefType="this" />
          <Parameter Name="reuseRowObject" Type="System.Boolean" />
          <Parameter Name="ignoreMissingColumns" Type="System.Boolean" />
          <Parameter Name="schemaDefinition" Type="Microsoft.ML.Runtime.Api.SchemaDefinition" />
        </Parameters>
        <Docs>
          <typeparam name="TRow">The user-defined row type.</typeparam>
          <param name="data">The underlying data view.</param>
          <param name="reuseRowObject">Whether to return the same object on every row, or allocate a new one per row.</param>
          <param name="ignoreMissingColumns">Whether to ignore the case when a requested column is not present in the data view.</param>
          <param name="schemaDefinition">Optional user-provided schema definition. If it is not present, the schema is inferred from the definition of T.</param>
          <summary>
            Convert an <see cref="T:Microsoft.ML.Runtime.Data.IDataView" /> into a strongly-typed <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Api.CursoringUtils" Member="M:Microsoft.ML.Runtime.Api.CursoringUtils.AsEnumerable``1(Microsoft.ML.Runtime.Data.IDataView,System.Boolean,System.Boolean,Microsoft.ML.Runtime.Api.SchemaDefinition)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="Assert">
        <MemberSignature Language="C#" Value="public static void Assert (this Microsoft.ML.Runtime.IExceptionContext ctx, bool f);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(class Microsoft.ML.Runtime.IExceptionContext ctx, bool f) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.Assert(Microsoft.ML.Runtime.IExceptionContext,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Assert (ctx As IExceptionContext, f As Boolean)" />
        <MemberSignature Language="F#" Value="static member Assert : Microsoft.ML.Runtime.IExceptionContext * bool -&gt; unit" Usage="Microsoft.ML.Runtime.Contracts.Assert (ctx, f)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="f" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="f">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.Assert(Microsoft.ML.Runtime.IExceptionContext,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="Assert">
        <MemberSignature Language="C#" Value="public static void Assert (this Microsoft.ML.Runtime.IExceptionContext ctx, bool f, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(class Microsoft.ML.Runtime.IExceptionContext ctx, bool f, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.Assert(Microsoft.ML.Runtime.IExceptionContext,System.Boolean,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Assert (ctx As IExceptionContext, f As Boolean, msg As String)" />
        <MemberSignature Language="F#" Value="static member Assert : Microsoft.ML.Runtime.IExceptionContext * bool * string -&gt; unit" Usage="Microsoft.ML.Runtime.Contracts.Assert (ctx, f, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="f" Type="System.Boolean" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="f">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.Assert(Microsoft.ML.Runtime.IExceptionContext,System.Boolean,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="AssertNonEmpty">
        <MemberSignature Language="C#" Value="public static void AssertNonEmpty (this Microsoft.ML.Runtime.IExceptionContext ctx, string s);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AssertNonEmpty(class Microsoft.ML.Runtime.IExceptionContext ctx, string s) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.AssertNonEmpty(Microsoft.ML.Runtime.IExceptionContext,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub AssertNonEmpty (ctx As IExceptionContext, s As String)" />
        <MemberSignature Language="F#" Value="static member AssertNonEmpty : Microsoft.ML.Runtime.IExceptionContext * string -&gt; unit" Usage="Microsoft.ML.Runtime.Contracts.AssertNonEmpty (ctx, s)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="s" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="s">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.AssertNonEmpty(Microsoft.ML.Runtime.IExceptionContext,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="AssertNonEmpty">
        <MemberSignature Language="C#" Value="public static void AssertNonEmpty (this Microsoft.ML.Runtime.IExceptionContext ctx, string s, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AssertNonEmpty(class Microsoft.ML.Runtime.IExceptionContext ctx, string s, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.AssertNonEmpty(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub AssertNonEmpty (ctx As IExceptionContext, s As String, msg As String)" />
        <MemberSignature Language="F#" Value="static member AssertNonEmpty : Microsoft.ML.Runtime.IExceptionContext * string * string -&gt; unit" Usage="Microsoft.ML.Runtime.Contracts.AssertNonEmpty (ctx, s, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="s" Type="System.String" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="s">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.AssertNonEmpty(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="AssertNonEmpty&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static void AssertNonEmpty&lt;T&gt; (this Microsoft.ML.Runtime.IExceptionContext ctx, System.Collections.Generic.ICollection&lt;T&gt; args);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AssertNonEmpty&lt;T&gt;(class Microsoft.ML.Runtime.IExceptionContext ctx, class System.Collections.Generic.ICollection`1&lt;!!T&gt; args) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.AssertNonEmpty``1(Microsoft.ML.Runtime.IExceptionContext,System.Collections.Generic.ICollection{``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub AssertNonEmpty(Of T) (ctx As IExceptionContext, args As ICollection(Of T))" />
        <MemberSignature Language="F#" Value="static member AssertNonEmpty : Microsoft.ML.Runtime.IExceptionContext * System.Collections.Generic.ICollection&lt;'T&gt; -&gt; unit" Usage="Microsoft.ML.Runtime.Contracts.AssertNonEmpty (ctx, args)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="args" Type="System.Collections.Generic.ICollection&lt;T&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="ctx">To be added.</param>
          <param name="args">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.AssertNonEmpty``1(Microsoft.ML.Runtime.IExceptionContext,System.Collections.Generic.ICollection{``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="AssertNonEmpty&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static void AssertNonEmpty&lt;T&gt; (this Microsoft.ML.Runtime.IExceptionContext ctx, System.Collections.Generic.ICollection&lt;T&gt; args, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AssertNonEmpty&lt;T&gt;(class Microsoft.ML.Runtime.IExceptionContext ctx, class System.Collections.Generic.ICollection`1&lt;!!T&gt; args, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.AssertNonEmpty``1(Microsoft.ML.Runtime.IExceptionContext,System.Collections.Generic.ICollection{``0},System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub AssertNonEmpty(Of T) (ctx As IExceptionContext, args As ICollection(Of T), msg As String)" />
        <MemberSignature Language="F#" Value="static member AssertNonEmpty : Microsoft.ML.Runtime.IExceptionContext * System.Collections.Generic.ICollection&lt;'T&gt; * string -&gt; unit" Usage="Microsoft.ML.Runtime.Contracts.AssertNonEmpty (ctx, args, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="args" Type="System.Collections.Generic.ICollection&lt;T&gt;" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="ctx">To be added.</param>
          <param name="args">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.AssertNonEmpty``1(Microsoft.ML.Runtime.IExceptionContext,System.Collections.Generic.ICollection{``0},System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="AssertNonWhiteSpace">
        <MemberSignature Language="C#" Value="public static void AssertNonWhiteSpace (this Microsoft.ML.Runtime.IExceptionContext ctx, string s);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AssertNonWhiteSpace(class Microsoft.ML.Runtime.IExceptionContext ctx, string s) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.AssertNonWhiteSpace(Microsoft.ML.Runtime.IExceptionContext,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub AssertNonWhiteSpace (ctx As IExceptionContext, s As String)" />
        <MemberSignature Language="F#" Value="static member AssertNonWhiteSpace : Microsoft.ML.Runtime.IExceptionContext * string -&gt; unit" Usage="Microsoft.ML.Runtime.Contracts.AssertNonWhiteSpace (ctx, s)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="s" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="s">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.AssertNonWhiteSpace(Microsoft.ML.Runtime.IExceptionContext,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="AssertNonWhiteSpace">
        <MemberSignature Language="C#" Value="public static void AssertNonWhiteSpace (this Microsoft.ML.Runtime.IExceptionContext ctx, string s, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AssertNonWhiteSpace(class Microsoft.ML.Runtime.IExceptionContext ctx, string s, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.AssertNonWhiteSpace(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub AssertNonWhiteSpace (ctx As IExceptionContext, s As String, msg As String)" />
        <MemberSignature Language="F#" Value="static member AssertNonWhiteSpace : Microsoft.ML.Runtime.IExceptionContext * string * string -&gt; unit" Usage="Microsoft.ML.Runtime.Contracts.AssertNonWhiteSpace (ctx, s, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="s" Type="System.String" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="s">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.AssertNonWhiteSpace(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="AssertValue&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static void AssertValue&lt;T&gt; (this Microsoft.ML.Runtime.IExceptionContext ctx, T val) where T : class;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AssertValue&lt;class T&gt;(class Microsoft.ML.Runtime.IExceptionContext ctx, !!T val) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.AssertValue``1(Microsoft.ML.Runtime.IExceptionContext,``0)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub AssertValue(Of T As Class) (ctx As IExceptionContext, val As T)" />
        <MemberSignature Language="F#" Value="static member AssertValue : Microsoft.ML.Runtime.IExceptionContext * 'T -&gt; unit (requires 'T : null)" Usage="Microsoft.ML.Runtime.Contracts.AssertValue (ctx, val)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="val" Type="T" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="ctx">To be added.</param>
          <param name="val">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.AssertValue``1(Microsoft.ML.Runtime.IExceptionContext,``0)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="AssertValue&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static void AssertValue&lt;T&gt; (this Microsoft.ML.Runtime.IExceptionContext ctx, T val, string paramName) where T : class;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AssertValue&lt;class T&gt;(class Microsoft.ML.Runtime.IExceptionContext ctx, !!T val, string paramName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.AssertValue``1(Microsoft.ML.Runtime.IExceptionContext,``0,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub AssertValue(Of T As Class) (ctx As IExceptionContext, val As T, paramName As String)" />
        <MemberSignature Language="F#" Value="static member AssertValue : Microsoft.ML.Runtime.IExceptionContext * 'T * string -&gt; unit (requires 'T : null)" Usage="Microsoft.ML.Runtime.Contracts.AssertValue (ctx, val, paramName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="val" Type="T" />
          <Parameter Name="paramName" Type="System.String" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="ctx">To be added.</param>
          <param name="val">To be added.</param>
          <param name="paramName">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.AssertValue``1(Microsoft.ML.Runtime.IExceptionContext,``0,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="AssertValue&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static void AssertValue&lt;T&gt; (this Microsoft.ML.Runtime.IExceptionContext ctx, T val, string name, string msg) where T : class;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AssertValue&lt;class T&gt;(class Microsoft.ML.Runtime.IExceptionContext ctx, !!T val, string name, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.AssertValue``1(Microsoft.ML.Runtime.IExceptionContext,``0,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub AssertValue(Of T As Class) (ctx As IExceptionContext, val As T, name As String, msg As String)" />
        <MemberSignature Language="F#" Value="static member AssertValue : Microsoft.ML.Runtime.IExceptionContext * 'T * string * string -&gt; unit (requires 'T : null)" Usage="Microsoft.ML.Runtime.Contracts.AssertValue (ctx, val, name, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="val" Type="T" />
          <Parameter Name="name" Type="System.String" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="ctx">To be added.</param>
          <param name="val">To be added.</param>
          <param name="name">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.AssertValue``1(Microsoft.ML.Runtime.IExceptionContext,``0,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="AssertValueOrNull&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static void AssertValueOrNull&lt;T&gt; (this Microsoft.ML.Runtime.IExceptionContext ctx, T val) where T : class;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AssertValueOrNull&lt;class T&gt;(class Microsoft.ML.Runtime.IExceptionContext ctx, !!T val) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.AssertValueOrNull``1(Microsoft.ML.Runtime.IExceptionContext,``0)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub AssertValueOrNull(Of T As Class) (ctx As IExceptionContext, val As T)" />
        <MemberSignature Language="F#" Value="static member AssertValueOrNull : Microsoft.ML.Runtime.IExceptionContext * 'T -&gt; unit (requires 'T : null)" Usage="Microsoft.ML.Runtime.Contracts.AssertValueOrNull (ctx, val)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="val" Type="T" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="ctx">To be added.</param>
          <param name="val">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.AssertValueOrNull``1(Microsoft.ML.Runtime.IExceptionContext,``0)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="Check">
        <MemberSignature Language="C#" Value="public static void Check (this Microsoft.ML.Runtime.IExceptionContext ctx, bool f);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Check(class Microsoft.ML.Runtime.IExceptionContext ctx, bool f) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.Check(Microsoft.ML.Runtime.IExceptionContext,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Check (ctx As IExceptionContext, f As Boolean)" />
        <MemberSignature Language="F#" Value="static member Check : Microsoft.ML.Runtime.IExceptionContext * bool -&gt; unit" Usage="Microsoft.ML.Runtime.Contracts.Check (ctx, f)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="f" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="f">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.Check(Microsoft.ML.Runtime.IExceptionContext,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="Check">
        <MemberSignature Language="C#" Value="public static void Check (this Microsoft.ML.Runtime.IExceptionContext ctx, bool f, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Check(class Microsoft.ML.Runtime.IExceptionContext ctx, bool f, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.Check(Microsoft.ML.Runtime.IExceptionContext,System.Boolean,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Check (ctx As IExceptionContext, f As Boolean, msg As String)" />
        <MemberSignature Language="F#" Value="static member Check : Microsoft.ML.Runtime.IExceptionContext * bool * string -&gt; unit" Usage="Microsoft.ML.Runtime.Contracts.Check (ctx, f, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="f" Type="System.Boolean" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="f">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.Check(Microsoft.ML.Runtime.IExceptionContext,System.Boolean,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IHostEnvironment" />
      </Targets>
      <Member MemberName="CheckAlive">
        <MemberSignature Language="C#" Value="public static void CheckAlive (this Microsoft.ML.Runtime.IHostEnvironment env);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CheckAlive(class Microsoft.ML.Runtime.IHostEnvironment env) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.CheckAlive(Microsoft.ML.Runtime.IHostEnvironment)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CheckAlive (env As IHostEnvironment)" />
        <MemberSignature Language="F#" Value="static member CheckAlive : Microsoft.ML.Runtime.IHostEnvironment -&gt; unit" Usage="Microsoft.ML.Runtime.Contracts.CheckAlive env" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" RefType="this" />
        </Parameters>
        <Docs>
          <param name="env">To be added.</param>
          <summary>
            Check state of the host and throw exception if host marked to stop all exection.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.CheckAlive(Microsoft.ML.Runtime.IHostEnvironment)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="CheckDecode">
        <MemberSignature Language="C#" Value="public static void CheckDecode (this Microsoft.ML.Runtime.IExceptionContext ctx, bool f);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CheckDecode(class Microsoft.ML.Runtime.IExceptionContext ctx, bool f) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.CheckDecode(Microsoft.ML.Runtime.IExceptionContext,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CheckDecode (ctx As IExceptionContext, f As Boolean)" />
        <MemberSignature Language="F#" Value="static member CheckDecode : Microsoft.ML.Runtime.IExceptionContext * bool -&gt; unit" Usage="Microsoft.ML.Runtime.Contracts.CheckDecode (ctx, f)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="f" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="f">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.CheckDecode(Microsoft.ML.Runtime.IExceptionContext,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="CheckDecode">
        <MemberSignature Language="C#" Value="public static void CheckDecode (this Microsoft.ML.Runtime.IExceptionContext ctx, bool f, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CheckDecode(class Microsoft.ML.Runtime.IExceptionContext ctx, bool f, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.CheckDecode(Microsoft.ML.Runtime.IExceptionContext,System.Boolean,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CheckDecode (ctx As IExceptionContext, f As Boolean, msg As String)" />
        <MemberSignature Language="F#" Value="static member CheckDecode : Microsoft.ML.Runtime.IExceptionContext * bool * string -&gt; unit" Usage="Microsoft.ML.Runtime.Contracts.CheckDecode (ctx, f, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="f" Type="System.Boolean" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="f">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.CheckDecode(Microsoft.ML.Runtime.IExceptionContext,System.Boolean,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="CheckIO">
        <MemberSignature Language="C#" Value="public static void CheckIO (this Microsoft.ML.Runtime.IExceptionContext ctx, bool f);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CheckIO(class Microsoft.ML.Runtime.IExceptionContext ctx, bool f) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.CheckIO(Microsoft.ML.Runtime.IExceptionContext,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CheckIO (ctx As IExceptionContext, f As Boolean)" />
        <MemberSignature Language="F#" Value="static member CheckIO : Microsoft.ML.Runtime.IExceptionContext * bool -&gt; unit" Usage="Microsoft.ML.Runtime.Contracts.CheckIO (ctx, f)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="f" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="f">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.CheckIO(Microsoft.ML.Runtime.IExceptionContext,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="CheckIO">
        <MemberSignature Language="C#" Value="public static void CheckIO (this Microsoft.ML.Runtime.IExceptionContext ctx, bool f, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CheckIO(class Microsoft.ML.Runtime.IExceptionContext ctx, bool f, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.CheckIO(Microsoft.ML.Runtime.IExceptionContext,System.Boolean,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CheckIO (ctx As IExceptionContext, f As Boolean, msg As String)" />
        <MemberSignature Language="F#" Value="static member CheckIO : Microsoft.ML.Runtime.IExceptionContext * bool * string -&gt; unit" Usage="Microsoft.ML.Runtime.Contracts.CheckIO (ctx, f, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="f" Type="System.Boolean" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="f">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.CheckIO(Microsoft.ML.Runtime.IExceptionContext,System.Boolean,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="CheckNonEmpty">
        <MemberSignature Language="C#" Value="public static string CheckNonEmpty (this Microsoft.ML.Runtime.IExceptionContext ctx, string s, string paramName);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CheckNonEmpty(class Microsoft.ML.Runtime.IExceptionContext ctx, string s, string paramName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.CheckNonEmpty(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CheckNonEmpty (ctx As IExceptionContext, s As String, paramName As String) As String" />
        <MemberSignature Language="F#" Value="static member CheckNonEmpty : Microsoft.ML.Runtime.IExceptionContext * string * string -&gt; string" Usage="Microsoft.ML.Runtime.Contracts.CheckNonEmpty (ctx, s, paramName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="s" Type="System.String" />
          <Parameter Name="paramName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="s">To be added.</param>
          <param name="paramName">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.CheckNonEmpty(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="CheckNonEmpty">
        <MemberSignature Language="C#" Value="public static string CheckNonEmpty (this Microsoft.ML.Runtime.IExceptionContext ctx, string s, string paramName, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CheckNonEmpty(class Microsoft.ML.Runtime.IExceptionContext ctx, string s, string paramName, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.CheckNonEmpty(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CheckNonEmpty (ctx As IExceptionContext, s As String, paramName As String, msg As String) As String" />
        <MemberSignature Language="F#" Value="static member CheckNonEmpty : Microsoft.ML.Runtime.IExceptionContext * string * string * string -&gt; string" Usage="Microsoft.ML.Runtime.Contracts.CheckNonEmpty (ctx, s, paramName, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="s" Type="System.String" />
          <Parameter Name="paramName" Type="System.String" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="s">To be added.</param>
          <param name="paramName">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.CheckNonEmpty(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="CheckNonEmpty&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static T[] CheckNonEmpty&lt;T&gt; (this Microsoft.ML.Runtime.IExceptionContext ctx, T[] args, string paramName);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] CheckNonEmpty&lt;T&gt;(class Microsoft.ML.Runtime.IExceptionContext ctx, !!T[] args, string paramName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.CheckNonEmpty``1(Microsoft.ML.Runtime.IExceptionContext,``0[],System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CheckNonEmpty(Of T) (ctx As IExceptionContext, args As T(), paramName As String) As T()" />
        <MemberSignature Language="F#" Value="static member CheckNonEmpty : Microsoft.ML.Runtime.IExceptionContext * 'T[] * string -&gt; 'T[]" Usage="Microsoft.ML.Runtime.Contracts.CheckNonEmpty (ctx, args, paramName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>T[]</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="args" Type="T[]" />
          <Parameter Name="paramName" Type="System.String" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="ctx">To be added.</param>
          <param name="args">To be added.</param>
          <param name="paramName">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.CheckNonEmpty``1(Microsoft.ML.Runtime.IExceptionContext,``0[],System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="CheckNonEmpty&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static T[] CheckNonEmpty&lt;T&gt; (this Microsoft.ML.Runtime.IExceptionContext ctx, T[] args, string paramName, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] CheckNonEmpty&lt;T&gt;(class Microsoft.ML.Runtime.IExceptionContext ctx, !!T[] args, string paramName, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.CheckNonEmpty``1(Microsoft.ML.Runtime.IExceptionContext,``0[],System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CheckNonEmpty(Of T) (ctx As IExceptionContext, args As T(), paramName As String, msg As String) As T()" />
        <MemberSignature Language="F#" Value="static member CheckNonEmpty : Microsoft.ML.Runtime.IExceptionContext * 'T[] * string * string -&gt; 'T[]" Usage="Microsoft.ML.Runtime.Contracts.CheckNonEmpty (ctx, args, paramName, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>T[]</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="args" Type="T[]" />
          <Parameter Name="paramName" Type="System.String" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="ctx">To be added.</param>
          <param name="args">To be added.</param>
          <param name="paramName">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.CheckNonEmpty``1(Microsoft.ML.Runtime.IExceptionContext,``0[],System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="CheckNonEmpty&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.ICollection&lt;T&gt; CheckNonEmpty&lt;T&gt; (this Microsoft.ML.Runtime.IExceptionContext ctx, System.Collections.Generic.ICollection&lt;T&gt; args, string paramName);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.ICollection`1&lt;!!T&gt; CheckNonEmpty&lt;T&gt;(class Microsoft.ML.Runtime.IExceptionContext ctx, class System.Collections.Generic.ICollection`1&lt;!!T&gt; args, string paramName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.CheckNonEmpty``1(Microsoft.ML.Runtime.IExceptionContext,System.Collections.Generic.ICollection{``0},System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CheckNonEmpty(Of T) (ctx As IExceptionContext, args As ICollection(Of T), paramName As String) As ICollection(Of T)" />
        <MemberSignature Language="F#" Value="static member CheckNonEmpty : Microsoft.ML.Runtime.IExceptionContext * System.Collections.Generic.ICollection&lt;'T&gt; * string -&gt; System.Collections.Generic.ICollection&lt;'T&gt;" Usage="Microsoft.ML.Runtime.Contracts.CheckNonEmpty (ctx, args, paramName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.ICollection&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="args" Type="System.Collections.Generic.ICollection&lt;T&gt;" />
          <Parameter Name="paramName" Type="System.String" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="ctx">To be added.</param>
          <param name="args">To be added.</param>
          <param name="paramName">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.CheckNonEmpty``1(Microsoft.ML.Runtime.IExceptionContext,System.Collections.Generic.ICollection{``0},System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="CheckNonEmpty&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.ICollection&lt;T&gt; CheckNonEmpty&lt;T&gt; (this Microsoft.ML.Runtime.IExceptionContext ctx, System.Collections.Generic.ICollection&lt;T&gt; args, string paramName, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.ICollection`1&lt;!!T&gt; CheckNonEmpty&lt;T&gt;(class Microsoft.ML.Runtime.IExceptionContext ctx, class System.Collections.Generic.ICollection`1&lt;!!T&gt; args, string paramName, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.CheckNonEmpty``1(Microsoft.ML.Runtime.IExceptionContext,System.Collections.Generic.ICollection{``0},System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CheckNonEmpty(Of T) (ctx As IExceptionContext, args As ICollection(Of T), paramName As String, msg As String) As ICollection(Of T)" />
        <MemberSignature Language="F#" Value="static member CheckNonEmpty : Microsoft.ML.Runtime.IExceptionContext * System.Collections.Generic.ICollection&lt;'T&gt; * string * string -&gt; System.Collections.Generic.ICollection&lt;'T&gt;" Usage="Microsoft.ML.Runtime.Contracts.CheckNonEmpty (ctx, args, paramName, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.ICollection&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="args" Type="System.Collections.Generic.ICollection&lt;T&gt;" />
          <Parameter Name="paramName" Type="System.String" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="ctx">To be added.</param>
          <param name="args">To be added.</param>
          <param name="paramName">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.CheckNonEmpty``1(Microsoft.ML.Runtime.IExceptionContext,System.Collections.Generic.ICollection{``0},System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="CheckNonWhiteSpace">
        <MemberSignature Language="C#" Value="public static string CheckNonWhiteSpace (this Microsoft.ML.Runtime.IExceptionContext ctx, string s, string paramName);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CheckNonWhiteSpace(class Microsoft.ML.Runtime.IExceptionContext ctx, string s, string paramName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.CheckNonWhiteSpace(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CheckNonWhiteSpace (ctx As IExceptionContext, s As String, paramName As String) As String" />
        <MemberSignature Language="F#" Value="static member CheckNonWhiteSpace : Microsoft.ML.Runtime.IExceptionContext * string * string -&gt; string" Usage="Microsoft.ML.Runtime.Contracts.CheckNonWhiteSpace (ctx, s, paramName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="s" Type="System.String" />
          <Parameter Name="paramName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="s">To be added.</param>
          <param name="paramName">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.CheckNonWhiteSpace(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="CheckNonWhiteSpace">
        <MemberSignature Language="C#" Value="public static string CheckNonWhiteSpace (this Microsoft.ML.Runtime.IExceptionContext ctx, string s, string paramName, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CheckNonWhiteSpace(class Microsoft.ML.Runtime.IExceptionContext ctx, string s, string paramName, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.CheckNonWhiteSpace(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CheckNonWhiteSpace (ctx As IExceptionContext, s As String, paramName As String, msg As String) As String" />
        <MemberSignature Language="F#" Value="static member CheckNonWhiteSpace : Microsoft.ML.Runtime.IExceptionContext * string * string * string -&gt; string" Usage="Microsoft.ML.Runtime.Contracts.CheckNonWhiteSpace (ctx, s, paramName, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="s" Type="System.String" />
          <Parameter Name="paramName" Type="System.String" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="s">To be added.</param>
          <param name="paramName">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.CheckNonWhiteSpace(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="CheckParam">
        <MemberSignature Language="C#" Value="public static void CheckParam (this Microsoft.ML.Runtime.IExceptionContext ctx, bool f, string paramName);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CheckParam(class Microsoft.ML.Runtime.IExceptionContext ctx, bool f, string paramName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.CheckParam(Microsoft.ML.Runtime.IExceptionContext,System.Boolean,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CheckParam (ctx As IExceptionContext, f As Boolean, paramName As String)" />
        <MemberSignature Language="F#" Value="static member CheckParam : Microsoft.ML.Runtime.IExceptionContext * bool * string -&gt; unit" Usage="Microsoft.ML.Runtime.Contracts.CheckParam (ctx, f, paramName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="f" Type="System.Boolean" />
          <Parameter Name="paramName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="f">To be added.</param>
          <param name="paramName">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.CheckParam(Microsoft.ML.Runtime.IExceptionContext,System.Boolean,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="CheckParam">
        <MemberSignature Language="C#" Value="public static void CheckParam (this Microsoft.ML.Runtime.IExceptionContext ctx, bool f, string paramName, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CheckParam(class Microsoft.ML.Runtime.IExceptionContext ctx, bool f, string paramName, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.CheckParam(Microsoft.ML.Runtime.IExceptionContext,System.Boolean,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CheckParam (ctx As IExceptionContext, f As Boolean, paramName As String, msg As String)" />
        <MemberSignature Language="F#" Value="static member CheckParam : Microsoft.ML.Runtime.IExceptionContext * bool * string * string -&gt; unit" Usage="Microsoft.ML.Runtime.Contracts.CheckParam (ctx, f, paramName, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="f" Type="System.Boolean" />
          <Parameter Name="paramName" Type="System.String" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="f">To be added.</param>
          <param name="paramName">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.CheckParam(Microsoft.ML.Runtime.IExceptionContext,System.Boolean,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="CheckParamValue&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static void CheckParamValue&lt;T&gt; (this Microsoft.ML.Runtime.IExceptionContext ctx, bool f, T value, string paramName, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CheckParamValue&lt;T&gt;(class Microsoft.ML.Runtime.IExceptionContext ctx, bool f, !!T value, string paramName, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.CheckParamValue``1(Microsoft.ML.Runtime.IExceptionContext,System.Boolean,``0,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CheckParamValue(Of T) (ctx As IExceptionContext, f As Boolean, value As T, paramName As String, msg As String)" />
        <MemberSignature Language="F#" Value="static member CheckParamValue : Microsoft.ML.Runtime.IExceptionContext * bool * 'T * string * string -&gt; unit" Usage="Microsoft.ML.Runtime.Contracts.CheckParamValue (ctx, f, value, paramName, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="f" Type="System.Boolean" />
          <Parameter Name="value" Type="T" />
          <Parameter Name="paramName" Type="System.String" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="ctx">To be added.</param>
          <param name="f">To be added.</param>
          <param name="value">To be added.</param>
          <param name="paramName">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.CheckParamValue``1(Microsoft.ML.Runtime.IExceptionContext,System.Boolean,``0,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="CheckRef&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static T CheckRef&lt;T&gt; (this Microsoft.ML.Runtime.IExceptionContext ctx, T val, string paramName) where T : class;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CheckRef&lt;class T&gt;(class Microsoft.ML.Runtime.IExceptionContext ctx, !!T val, string paramName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.CheckRef``1(Microsoft.ML.Runtime.IExceptionContext,``0,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CheckRef(Of T As Class) (ctx As IExceptionContext, val As T, paramName As String) As T" />
        <MemberSignature Language="F#" Value="static member CheckRef : Microsoft.ML.Runtime.IExceptionContext * 'T * string -&gt; 'T (requires 'T : null)" Usage="Microsoft.ML.Runtime.Contracts.CheckRef (ctx, val, paramName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>T</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="val" Type="T" />
          <Parameter Name="paramName" Type="System.String" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="ctx">To be added.</param>
          <param name="val">To be added.</param>
          <param name="paramName">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.CheckRef``1(Microsoft.ML.Runtime.IExceptionContext,``0,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="CheckRef&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static T CheckRef&lt;T&gt; (this Microsoft.ML.Runtime.IExceptionContext ctx, T val, string paramName, string msg) where T : class;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CheckRef&lt;class T&gt;(class Microsoft.ML.Runtime.IExceptionContext ctx, !!T val, string paramName, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.CheckRef``1(Microsoft.ML.Runtime.IExceptionContext,``0,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CheckRef(Of T As Class) (ctx As IExceptionContext, val As T, paramName As String, msg As String) As T" />
        <MemberSignature Language="F#" Value="static member CheckRef : Microsoft.ML.Runtime.IExceptionContext * 'T * string * string -&gt; 'T (requires 'T : null)" Usage="Microsoft.ML.Runtime.Contracts.CheckRef (ctx, val, paramName, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>T</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="val" Type="T" />
          <Parameter Name="paramName" Type="System.String" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="ctx">To be added.</param>
          <param name="val">To be added.</param>
          <param name="paramName">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.CheckRef``1(Microsoft.ML.Runtime.IExceptionContext,``0,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="CheckUserArg">
        <MemberSignature Language="C#" Value="public static void CheckUserArg (this Microsoft.ML.Runtime.IExceptionContext ctx, bool f, string name);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CheckUserArg(class Microsoft.ML.Runtime.IExceptionContext ctx, bool f, string name) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.CheckUserArg(Microsoft.ML.Runtime.IExceptionContext,System.Boolean,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CheckUserArg (ctx As IExceptionContext, f As Boolean, name As String)" />
        <MemberSignature Language="F#" Value="static member CheckUserArg : Microsoft.ML.Runtime.IExceptionContext * bool * string -&gt; unit" Usage="Microsoft.ML.Runtime.Contracts.CheckUserArg (ctx, f, name)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="f" Type="System.Boolean" />
          <Parameter Name="name" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="f">To be added.</param>
          <param name="name">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.CheckUserArg(Microsoft.ML.Runtime.IExceptionContext,System.Boolean,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="CheckUserArg">
        <MemberSignature Language="C#" Value="public static void CheckUserArg (this Microsoft.ML.Runtime.IExceptionContext ctx, bool f, string name, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CheckUserArg(class Microsoft.ML.Runtime.IExceptionContext ctx, bool f, string name, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.CheckUserArg(Microsoft.ML.Runtime.IExceptionContext,System.Boolean,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CheckUserArg (ctx As IExceptionContext, f As Boolean, name As String, msg As String)" />
        <MemberSignature Language="F#" Value="static member CheckUserArg : Microsoft.ML.Runtime.IExceptionContext * bool * string * string -&gt; unit" Usage="Microsoft.ML.Runtime.Contracts.CheckUserArg (ctx, f, name, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="f" Type="System.Boolean" />
          <Parameter Name="name" Type="System.String" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="f">To be added.</param>
          <param name="name">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.CheckUserArg(Microsoft.ML.Runtime.IExceptionContext,System.Boolean,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="CheckValue&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static void CheckValue&lt;T&gt; (this Microsoft.ML.Runtime.IExceptionContext ctx, T val, string paramName) where T : class;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CheckValue&lt;class T&gt;(class Microsoft.ML.Runtime.IExceptionContext ctx, !!T val, string paramName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.CheckValue``1(Microsoft.ML.Runtime.IExceptionContext,``0,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CheckValue(Of T As Class) (ctx As IExceptionContext, val As T, paramName As String)" />
        <MemberSignature Language="F#" Value="static member CheckValue : Microsoft.ML.Runtime.IExceptionContext * 'T * string -&gt; unit (requires 'T : null)" Usage="Microsoft.ML.Runtime.Contracts.CheckValue (ctx, val, paramName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="val" Type="T" />
          <Parameter Name="paramName" Type="System.String" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="ctx">To be added.</param>
          <param name="val">To be added.</param>
          <param name="paramName">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.CheckValue``1(Microsoft.ML.Runtime.IExceptionContext,``0,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="CheckValue&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static T CheckValue&lt;T&gt; (this Microsoft.ML.Runtime.IExceptionContext ctx, T val, string paramName, string msg) where T : class;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CheckValue&lt;class T&gt;(class Microsoft.ML.Runtime.IExceptionContext ctx, !!T val, string paramName, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.CheckValue``1(Microsoft.ML.Runtime.IExceptionContext,``0,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CheckValue(Of T As Class) (ctx As IExceptionContext, val As T, paramName As String, msg As String) As T" />
        <MemberSignature Language="F#" Value="static member CheckValue : Microsoft.ML.Runtime.IExceptionContext * 'T * string * string -&gt; 'T (requires 'T : null)" Usage="Microsoft.ML.Runtime.Contracts.CheckValue (ctx, val, paramName, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>T</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="val" Type="T" />
          <Parameter Name="paramName" Type="System.String" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="ctx">To be added.</param>
          <param name="val">To be added.</param>
          <param name="paramName">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.CheckValue``1(Microsoft.ML.Runtime.IExceptionContext,``0,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="CheckValueOrNull&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static void CheckValueOrNull&lt;T&gt; (this Microsoft.ML.Runtime.IExceptionContext ctx, T val) where T : class;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CheckValueOrNull&lt;class T&gt;(class Microsoft.ML.Runtime.IExceptionContext ctx, !!T val) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.CheckValueOrNull``1(Microsoft.ML.Runtime.IExceptionContext,``0)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CheckValueOrNull(Of T As Class) (ctx As IExceptionContext, val As T)" />
        <MemberSignature Language="F#" Value="static member CheckValueOrNull : Microsoft.ML.Runtime.IExceptionContext * 'T -&gt; unit (requires 'T : null)" Usage="Microsoft.ML.Runtime.Contracts.CheckValueOrNull (ctx, val)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="val" Type="T" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="ctx">To be added.</param>
          <param name="val">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.CheckValueOrNull``1(Microsoft.ML.Runtime.IExceptionContext,``0)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="Except">
        <MemberSignature Language="C#" Value="public static Exception Except (this Microsoft.ML.Runtime.IExceptionContext ctx);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception Except(class Microsoft.ML.Runtime.IExceptionContext ctx) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.Except(Microsoft.ML.Runtime.IExceptionContext)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except (ctx As IExceptionContext) As Exception" />
        <MemberSignature Language="F#" Value="static member Except : Microsoft.ML.Runtime.IExceptionContext -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.Except ctx" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.Except(Microsoft.ML.Runtime.IExceptionContext)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="Except">
        <MemberSignature Language="C#" Value="public static Exception Except (this Microsoft.ML.Runtime.IExceptionContext ctx, Exception inner, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception Except(class Microsoft.ML.Runtime.IExceptionContext ctx, class System.Exception inner, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.Except(Microsoft.ML.Runtime.IExceptionContext,System.Exception,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except (ctx As IExceptionContext, inner As Exception, msg As String) As Exception" />
        <MemberSignature Language="F#" Value="static member Except : Microsoft.ML.Runtime.IExceptionContext * Exception * string -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.Except (ctx, inner, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="inner" Type="System.Exception" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="inner">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.Except(Microsoft.ML.Runtime.IExceptionContext,System.Exception,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="Except">
        <MemberSignature Language="C#" Value="public static Exception Except (this Microsoft.ML.Runtime.IExceptionContext ctx, Exception inner, string msg, params object[] args);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception Except(class Microsoft.ML.Runtime.IExceptionContext ctx, class System.Exception inner, string msg, object[] args) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.Except(Microsoft.ML.Runtime.IExceptionContext,System.Exception,System.String,System.Object[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except (ctx As IExceptionContext, inner As Exception, msg As String, ParamArray args As Object()) As Exception" />
        <MemberSignature Language="F#" Value="static member Except : Microsoft.ML.Runtime.IExceptionContext * Exception * string * obj[] -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.Except (ctx, inner, msg, args)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="inner" Type="System.Exception" />
          <Parameter Name="msg" Type="System.String" />
          <Parameter Name="args" Type="System.Object[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="inner">To be added.</param>
          <param name="msg">To be added.</param>
          <param name="args">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.Except(Microsoft.ML.Runtime.IExceptionContext,System.Exception,System.String,System.Object[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="Except">
        <MemberSignature Language="C#" Value="public static Exception Except (this Microsoft.ML.Runtime.IExceptionContext ctx, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception Except(class Microsoft.ML.Runtime.IExceptionContext ctx, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.Except(Microsoft.ML.Runtime.IExceptionContext,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except (ctx As IExceptionContext, msg As String) As Exception" />
        <MemberSignature Language="F#" Value="static member Except : Microsoft.ML.Runtime.IExceptionContext * string -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.Except (ctx, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.Except(Microsoft.ML.Runtime.IExceptionContext,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="Except">
        <MemberSignature Language="C#" Value="public static Exception Except (this Microsoft.ML.Runtime.IExceptionContext ctx, string msg, params object[] args);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception Except(class Microsoft.ML.Runtime.IExceptionContext ctx, string msg, object[] args) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.Except(Microsoft.ML.Runtime.IExceptionContext,System.String,System.Object[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except (ctx As IExceptionContext, msg As String, ParamArray args As Object()) As Exception" />
        <MemberSignature Language="F#" Value="static member Except : Microsoft.ML.Runtime.IExceptionContext * string * obj[] -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.Except (ctx, msg, args)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="msg" Type="System.String" />
          <Parameter Name="args" Type="System.Object[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="msg">To be added.</param>
          <param name="args">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.Except(Microsoft.ML.Runtime.IExceptionContext,System.String,System.Object[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptDecode">
        <MemberSignature Language="C#" Value="public static Exception ExceptDecode (this Microsoft.ML.Runtime.IExceptionContext ctx);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptDecode(class Microsoft.ML.Runtime.IExceptionContext ctx) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptDecode(Microsoft.ML.Runtime.IExceptionContext)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptDecode (ctx As IExceptionContext) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptDecode : Microsoft.ML.Runtime.IExceptionContext -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptDecode ctx" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptDecode(Microsoft.ML.Runtime.IExceptionContext)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptDecode">
        <MemberSignature Language="C#" Value="public static Exception ExceptDecode (this Microsoft.ML.Runtime.IExceptionContext ctx, Exception inner, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptDecode(class Microsoft.ML.Runtime.IExceptionContext ctx, class System.Exception inner, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptDecode(Microsoft.ML.Runtime.IExceptionContext,System.Exception,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptDecode (ctx As IExceptionContext, inner As Exception, msg As String) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptDecode : Microsoft.ML.Runtime.IExceptionContext * Exception * string -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptDecode (ctx, inner, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="inner" Type="System.Exception" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="inner">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptDecode(Microsoft.ML.Runtime.IExceptionContext,System.Exception,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptDecode">
        <MemberSignature Language="C#" Value="public static Exception ExceptDecode (this Microsoft.ML.Runtime.IExceptionContext ctx, Exception inner, string msg, params object[] args);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptDecode(class Microsoft.ML.Runtime.IExceptionContext ctx, class System.Exception inner, string msg, object[] args) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptDecode(Microsoft.ML.Runtime.IExceptionContext,System.Exception,System.String,System.Object[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptDecode (ctx As IExceptionContext, inner As Exception, msg As String, ParamArray args As Object()) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptDecode : Microsoft.ML.Runtime.IExceptionContext * Exception * string * obj[] -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptDecode (ctx, inner, msg, args)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="inner" Type="System.Exception" />
          <Parameter Name="msg" Type="System.String" />
          <Parameter Name="args" Type="System.Object[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="inner">To be added.</param>
          <param name="msg">To be added.</param>
          <param name="args">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptDecode(Microsoft.ML.Runtime.IExceptionContext,System.Exception,System.String,System.Object[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptDecode">
        <MemberSignature Language="C#" Value="public static Exception ExceptDecode (this Microsoft.ML.Runtime.IExceptionContext ctx, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptDecode(class Microsoft.ML.Runtime.IExceptionContext ctx, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptDecode(Microsoft.ML.Runtime.IExceptionContext,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptDecode (ctx As IExceptionContext, msg As String) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptDecode : Microsoft.ML.Runtime.IExceptionContext * string -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptDecode (ctx, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptDecode(Microsoft.ML.Runtime.IExceptionContext,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptDecode">
        <MemberSignature Language="C#" Value="public static Exception ExceptDecode (this Microsoft.ML.Runtime.IExceptionContext ctx, string msg, params object[] args);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptDecode(class Microsoft.ML.Runtime.IExceptionContext ctx, string msg, object[] args) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptDecode(Microsoft.ML.Runtime.IExceptionContext,System.String,System.Object[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptDecode (ctx As IExceptionContext, msg As String, ParamArray args As Object()) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptDecode : Microsoft.ML.Runtime.IExceptionContext * string * obj[] -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptDecode (ctx, msg, args)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="msg" Type="System.String" />
          <Parameter Name="args" Type="System.Object[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="msg">To be added.</param>
          <param name="args">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptDecode(Microsoft.ML.Runtime.IExceptionContext,System.String,System.Object[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptEmpty">
        <MemberSignature Language="C#" Value="public static Exception ExceptEmpty (this Microsoft.ML.Runtime.IExceptionContext ctx, string paramName);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptEmpty(class Microsoft.ML.Runtime.IExceptionContext ctx, string paramName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptEmpty(Microsoft.ML.Runtime.IExceptionContext,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptEmpty (ctx As IExceptionContext, paramName As String) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptEmpty : Microsoft.ML.Runtime.IExceptionContext * string -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptEmpty (ctx, paramName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="paramName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="paramName">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptEmpty(Microsoft.ML.Runtime.IExceptionContext,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptEmpty">
        <MemberSignature Language="C#" Value="public static Exception ExceptEmpty (this Microsoft.ML.Runtime.IExceptionContext ctx, string paramName, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptEmpty(class Microsoft.ML.Runtime.IExceptionContext ctx, string paramName, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptEmpty(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptEmpty (ctx As IExceptionContext, paramName As String, msg As String) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptEmpty : Microsoft.ML.Runtime.IExceptionContext * string * string -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptEmpty (ctx, paramName, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="paramName" Type="System.String" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="paramName">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptEmpty(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptEmpty">
        <MemberSignature Language="C#" Value="public static Exception ExceptEmpty (this Microsoft.ML.Runtime.IExceptionContext ctx, string paramName, string msg, params object[] args);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptEmpty(class Microsoft.ML.Runtime.IExceptionContext ctx, string paramName, string msg, object[] args) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptEmpty(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String,System.Object[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptEmpty (ctx As IExceptionContext, paramName As String, msg As String, ParamArray args As Object()) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptEmpty : Microsoft.ML.Runtime.IExceptionContext * string * string * obj[] -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptEmpty (ctx, paramName, msg, args)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="paramName" Type="System.String" />
          <Parameter Name="msg" Type="System.String" />
          <Parameter Name="args" Type="System.Object[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="paramName">To be added.</param>
          <param name="msg">To be added.</param>
          <param name="args">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptEmpty(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String,System.Object[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptIO">
        <MemberSignature Language="C#" Value="public static Exception ExceptIO (this Microsoft.ML.Runtime.IExceptionContext ctx);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptIO(class Microsoft.ML.Runtime.IExceptionContext ctx) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptIO(Microsoft.ML.Runtime.IExceptionContext)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptIO (ctx As IExceptionContext) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptIO : Microsoft.ML.Runtime.IExceptionContext -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptIO ctx" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptIO(Microsoft.ML.Runtime.IExceptionContext)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptIO">
        <MemberSignature Language="C#" Value="public static Exception ExceptIO (this Microsoft.ML.Runtime.IExceptionContext ctx, Exception inner, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptIO(class Microsoft.ML.Runtime.IExceptionContext ctx, class System.Exception inner, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptIO(Microsoft.ML.Runtime.IExceptionContext,System.Exception,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptIO (ctx As IExceptionContext, inner As Exception, msg As String) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptIO : Microsoft.ML.Runtime.IExceptionContext * Exception * string -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptIO (ctx, inner, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="inner" Type="System.Exception" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="inner">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptIO(Microsoft.ML.Runtime.IExceptionContext,System.Exception,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptIO">
        <MemberSignature Language="C#" Value="public static Exception ExceptIO (this Microsoft.ML.Runtime.IExceptionContext ctx, Exception inner, string msg, params object[] args);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptIO(class Microsoft.ML.Runtime.IExceptionContext ctx, class System.Exception inner, string msg, object[] args) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptIO(Microsoft.ML.Runtime.IExceptionContext,System.Exception,System.String,System.Object[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptIO (ctx As IExceptionContext, inner As Exception, msg As String, ParamArray args As Object()) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptIO : Microsoft.ML.Runtime.IExceptionContext * Exception * string * obj[] -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptIO (ctx, inner, msg, args)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="inner" Type="System.Exception" />
          <Parameter Name="msg" Type="System.String" />
          <Parameter Name="args" Type="System.Object[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="inner">To be added.</param>
          <param name="msg">To be added.</param>
          <param name="args">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptIO(Microsoft.ML.Runtime.IExceptionContext,System.Exception,System.String,System.Object[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptIO">
        <MemberSignature Language="C#" Value="public static Exception ExceptIO (this Microsoft.ML.Runtime.IExceptionContext ctx, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptIO(class Microsoft.ML.Runtime.IExceptionContext ctx, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptIO(Microsoft.ML.Runtime.IExceptionContext,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptIO (ctx As IExceptionContext, msg As String) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptIO : Microsoft.ML.Runtime.IExceptionContext * string -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptIO (ctx, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptIO(Microsoft.ML.Runtime.IExceptionContext,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptIO">
        <MemberSignature Language="C#" Value="public static Exception ExceptIO (this Microsoft.ML.Runtime.IExceptionContext ctx, string msg, params object[] args);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptIO(class Microsoft.ML.Runtime.IExceptionContext ctx, string msg, object[] args) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptIO(Microsoft.ML.Runtime.IExceptionContext,System.String,System.Object[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptIO (ctx As IExceptionContext, msg As String, ParamArray args As Object()) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptIO : Microsoft.ML.Runtime.IExceptionContext * string * obj[] -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptIO (ctx, msg, args)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="msg" Type="System.String" />
          <Parameter Name="args" Type="System.Object[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="msg">To be added.</param>
          <param name="args">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptIO(Microsoft.ML.Runtime.IExceptionContext,System.String,System.Object[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptNotImpl">
        <MemberSignature Language="C#" Value="public static Exception ExceptNotImpl (this Microsoft.ML.Runtime.IExceptionContext ctx);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptNotImpl(class Microsoft.ML.Runtime.IExceptionContext ctx) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptNotImpl(Microsoft.ML.Runtime.IExceptionContext)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptNotImpl (ctx As IExceptionContext) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptNotImpl : Microsoft.ML.Runtime.IExceptionContext -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptNotImpl ctx" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptNotImpl(Microsoft.ML.Runtime.IExceptionContext)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptNotImpl">
        <MemberSignature Language="C#" Value="public static Exception ExceptNotImpl (this Microsoft.ML.Runtime.IExceptionContext ctx, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptNotImpl(class Microsoft.ML.Runtime.IExceptionContext ctx, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptNotImpl(Microsoft.ML.Runtime.IExceptionContext,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptNotImpl (ctx As IExceptionContext, msg As String) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptNotImpl : Microsoft.ML.Runtime.IExceptionContext * string -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptNotImpl (ctx, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptNotImpl(Microsoft.ML.Runtime.IExceptionContext,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptNotImpl">
        <MemberSignature Language="C#" Value="public static Exception ExceptNotImpl (this Microsoft.ML.Runtime.IExceptionContext ctx, string msg, params object[] args);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptNotImpl(class Microsoft.ML.Runtime.IExceptionContext ctx, string msg, object[] args) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptNotImpl(Microsoft.ML.Runtime.IExceptionContext,System.String,System.Object[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptNotImpl (ctx As IExceptionContext, msg As String, ParamArray args As Object()) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptNotImpl : Microsoft.ML.Runtime.IExceptionContext * string * obj[] -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptNotImpl (ctx, msg, args)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="msg" Type="System.String" />
          <Parameter Name="args" Type="System.Object[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="msg">To be added.</param>
          <param name="args">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptNotImpl(Microsoft.ML.Runtime.IExceptionContext,System.String,System.Object[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptNotSupp">
        <MemberSignature Language="C#" Value="public static Exception ExceptNotSupp (this Microsoft.ML.Runtime.IExceptionContext ctx);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptNotSupp(class Microsoft.ML.Runtime.IExceptionContext ctx) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptNotSupp(Microsoft.ML.Runtime.IExceptionContext)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptNotSupp (ctx As IExceptionContext) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptNotSupp : Microsoft.ML.Runtime.IExceptionContext -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptNotSupp ctx" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptNotSupp(Microsoft.ML.Runtime.IExceptionContext)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptNotSupp">
        <MemberSignature Language="C#" Value="public static Exception ExceptNotSupp (this Microsoft.ML.Runtime.IExceptionContext ctx, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptNotSupp(class Microsoft.ML.Runtime.IExceptionContext ctx, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptNotSupp(Microsoft.ML.Runtime.IExceptionContext,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptNotSupp (ctx As IExceptionContext, msg As String) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptNotSupp : Microsoft.ML.Runtime.IExceptionContext * string -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptNotSupp (ctx, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptNotSupp(Microsoft.ML.Runtime.IExceptionContext,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptNotSupp">
        <MemberSignature Language="C#" Value="public static Exception ExceptNotSupp (this Microsoft.ML.Runtime.IExceptionContext ctx, string msg, params object[] args);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptNotSupp(class Microsoft.ML.Runtime.IExceptionContext ctx, string msg, object[] args) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptNotSupp(Microsoft.ML.Runtime.IExceptionContext,System.String,System.Object[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptNotSupp (ctx As IExceptionContext, msg As String, ParamArray args As Object()) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptNotSupp : Microsoft.ML.Runtime.IExceptionContext * string * obj[] -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptNotSupp (ctx, msg, args)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="msg" Type="System.String" />
          <Parameter Name="args" Type="System.Object[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="msg">To be added.</param>
          <param name="args">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptNotSupp(Microsoft.ML.Runtime.IExceptionContext,System.String,System.Object[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptParam">
        <MemberSignature Language="C#" Value="public static Exception ExceptParam (this Microsoft.ML.Runtime.IExceptionContext ctx, string paramName);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptParam(class Microsoft.ML.Runtime.IExceptionContext ctx, string paramName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptParam(Microsoft.ML.Runtime.IExceptionContext,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptParam (ctx As IExceptionContext, paramName As String) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptParam : Microsoft.ML.Runtime.IExceptionContext * string -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptParam (ctx, paramName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="paramName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="paramName">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptParam(Microsoft.ML.Runtime.IExceptionContext,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptParam">
        <MemberSignature Language="C#" Value="public static Exception ExceptParam (this Microsoft.ML.Runtime.IExceptionContext ctx, string paramName, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptParam(class Microsoft.ML.Runtime.IExceptionContext ctx, string paramName, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptParam(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptParam (ctx As IExceptionContext, paramName As String, msg As String) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptParam : Microsoft.ML.Runtime.IExceptionContext * string * string -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptParam (ctx, paramName, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="paramName" Type="System.String" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="paramName">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptParam(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptParam">
        <MemberSignature Language="C#" Value="public static Exception ExceptParam (this Microsoft.ML.Runtime.IExceptionContext ctx, string paramName, string msg, params object[] args);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptParam(class Microsoft.ML.Runtime.IExceptionContext ctx, string paramName, string msg, object[] args) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptParam(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String,System.Object[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptParam (ctx As IExceptionContext, paramName As String, msg As String, ParamArray args As Object()) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptParam : Microsoft.ML.Runtime.IExceptionContext * string * string * obj[] -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptParam (ctx, paramName, msg, args)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="paramName" Type="System.String" />
          <Parameter Name="msg" Type="System.String" />
          <Parameter Name="args" Type="System.Object[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="paramName">To be added.</param>
          <param name="msg">To be added.</param>
          <param name="args">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptParam(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String,System.Object[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptParamValue&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Exception ExceptParamValue&lt;T&gt; (this Microsoft.ML.Runtime.IExceptionContext ctx, T value, string paramName, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptParamValue&lt;T&gt;(class Microsoft.ML.Runtime.IExceptionContext ctx, !!T value, string paramName, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptParamValue``1(Microsoft.ML.Runtime.IExceptionContext,``0,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptParamValue(Of T) (ctx As IExceptionContext, value As T, paramName As String, msg As String) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptParamValue : Microsoft.ML.Runtime.IExceptionContext * 'T * string * string -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptParamValue (ctx, value, paramName, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="value" Type="T" />
          <Parameter Name="paramName" Type="System.String" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="ctx">To be added.</param>
          <param name="value">To be added.</param>
          <param name="paramName">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptParamValue``1(Microsoft.ML.Runtime.IExceptionContext,``0,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptParamValue&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Exception ExceptParamValue&lt;T&gt; (this Microsoft.ML.Runtime.IExceptionContext ctx, T value, string paramName, string msg, params object[] args);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptParamValue&lt;T&gt;(class Microsoft.ML.Runtime.IExceptionContext ctx, !!T value, string paramName, string msg, object[] args) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptParamValue``1(Microsoft.ML.Runtime.IExceptionContext,``0,System.String,System.String,System.Object[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptParamValue(Of T) (ctx As IExceptionContext, value As T, paramName As String, msg As String, ParamArray args As Object()) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptParamValue : Microsoft.ML.Runtime.IExceptionContext * 'T * string * string * obj[] -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptParamValue (ctx, value, paramName, msg, args)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="value" Type="T" />
          <Parameter Name="paramName" Type="System.String" />
          <Parameter Name="msg" Type="System.String" />
          <Parameter Name="args" Type="System.Object[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="ctx">To be added.</param>
          <param name="value">To be added.</param>
          <param name="paramName">To be added.</param>
          <param name="msg">To be added.</param>
          <param name="args">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptParamValue``1(Microsoft.ML.Runtime.IExceptionContext,``0,System.String,System.String,System.Object[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptSchemaMismatch">
        <MemberSignature Language="C#" Value="public static Exception ExceptSchemaMismatch (this Microsoft.ML.Runtime.IExceptionContext ctx, string paramName, string columnRole, string columnName);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptSchemaMismatch(class Microsoft.ML.Runtime.IExceptionContext ctx, string paramName, string columnRole, string columnName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptSchemaMismatch(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptSchemaMismatch (ctx As IExceptionContext, paramName As String, columnRole As String, columnName As String) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptSchemaMismatch : Microsoft.ML.Runtime.IExceptionContext * string * string * string -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptSchemaMismatch (ctx, paramName, columnRole, columnName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="paramName" Type="System.String" />
          <Parameter Name="columnRole" Type="System.String" />
          <Parameter Name="columnName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="paramName">To be added.</param>
          <param name="columnRole">To be added.</param>
          <param name="columnName">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptSchemaMismatch(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptSchemaMismatch">
        <MemberSignature Language="C#" Value="public static Exception ExceptSchemaMismatch (this Microsoft.ML.Runtime.IExceptionContext ctx, string paramName, string columnRole, string columnName, string expectedType, string actualType);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptSchemaMismatch(class Microsoft.ML.Runtime.IExceptionContext ctx, string paramName, string columnRole, string columnName, string expectedType, string actualType) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptSchemaMismatch(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String,System.String,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptSchemaMismatch (ctx As IExceptionContext, paramName As String, columnRole As String, columnName As String, expectedType As String, actualType As String) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptSchemaMismatch : Microsoft.ML.Runtime.IExceptionContext * string * string * string * string * string -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptSchemaMismatch (ctx, paramName, columnRole, columnName, expectedType, actualType)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="paramName" Type="System.String" />
          <Parameter Name="columnRole" Type="System.String" />
          <Parameter Name="columnName" Type="System.String" />
          <Parameter Name="expectedType" Type="System.String" />
          <Parameter Name="actualType" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="paramName">To be added.</param>
          <param name="columnRole">To be added.</param>
          <param name="columnName">To be added.</param>
          <param name="expectedType">To be added.</param>
          <param name="actualType">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptSchemaMismatch(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String,System.String,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptUserArg">
        <MemberSignature Language="C#" Value="public static Exception ExceptUserArg (this Microsoft.ML.Runtime.IExceptionContext ctx, string name);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptUserArg(class Microsoft.ML.Runtime.IExceptionContext ctx, string name) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptUserArg(Microsoft.ML.Runtime.IExceptionContext,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptUserArg (ctx As IExceptionContext, name As String) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptUserArg : Microsoft.ML.Runtime.IExceptionContext * string -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptUserArg (ctx, name)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="name" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="name">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptUserArg(Microsoft.ML.Runtime.IExceptionContext,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptUserArg">
        <MemberSignature Language="C#" Value="public static Exception ExceptUserArg (this Microsoft.ML.Runtime.IExceptionContext ctx, string name, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptUserArg(class Microsoft.ML.Runtime.IExceptionContext ctx, string name, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptUserArg(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptUserArg (ctx As IExceptionContext, name As String, msg As String) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptUserArg : Microsoft.ML.Runtime.IExceptionContext * string * string -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptUserArg (ctx, name, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="name" Type="System.String" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="name">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptUserArg(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptUserArg">
        <MemberSignature Language="C#" Value="public static Exception ExceptUserArg (this Microsoft.ML.Runtime.IExceptionContext ctx, string name, string msg, params object[] args);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptUserArg(class Microsoft.ML.Runtime.IExceptionContext ctx, string name, string msg, object[] args) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptUserArg(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String,System.Object[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptUserArg (ctx As IExceptionContext, name As String, msg As String, ParamArray args As Object()) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptUserArg : Microsoft.ML.Runtime.IExceptionContext * string * string * obj[] -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptUserArg (ctx, name, msg, args)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="name" Type="System.String" />
          <Parameter Name="msg" Type="System.String" />
          <Parameter Name="args" Type="System.Object[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="name">To be added.</param>
          <param name="msg">To be added.</param>
          <param name="args">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptUserArg(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String,System.Object[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptValue">
        <MemberSignature Language="C#" Value="public static Exception ExceptValue (this Microsoft.ML.Runtime.IExceptionContext ctx, string paramName);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptValue(class Microsoft.ML.Runtime.IExceptionContext ctx, string paramName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptValue(Microsoft.ML.Runtime.IExceptionContext,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptValue (ctx As IExceptionContext, paramName As String) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptValue : Microsoft.ML.Runtime.IExceptionContext * string -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptValue (ctx, paramName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="paramName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="paramName">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptValue(Microsoft.ML.Runtime.IExceptionContext,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptValue">
        <MemberSignature Language="C#" Value="public static Exception ExceptValue (this Microsoft.ML.Runtime.IExceptionContext ctx, string paramName, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptValue(class Microsoft.ML.Runtime.IExceptionContext ctx, string paramName, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptValue(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptValue (ctx As IExceptionContext, paramName As String, msg As String) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptValue : Microsoft.ML.Runtime.IExceptionContext * string * string -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptValue (ctx, paramName, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="paramName" Type="System.String" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="paramName">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptValue(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptValue">
        <MemberSignature Language="C#" Value="public static Exception ExceptValue (this Microsoft.ML.Runtime.IExceptionContext ctx, string paramName, string msg, params object[] args);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptValue(class Microsoft.ML.Runtime.IExceptionContext ctx, string paramName, string msg, object[] args) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptValue(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String,System.Object[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptValue (ctx As IExceptionContext, paramName As String, msg As String, ParamArray args As Object()) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptValue : Microsoft.ML.Runtime.IExceptionContext * string * string * obj[] -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptValue (ctx, paramName, msg, args)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="paramName" Type="System.String" />
          <Parameter Name="msg" Type="System.String" />
          <Parameter Name="args" Type="System.Object[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="paramName">To be added.</param>
          <param name="msg">To be added.</param>
          <param name="args">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptValue(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String,System.Object[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptWhiteSpace">
        <MemberSignature Language="C#" Value="public static Exception ExceptWhiteSpace (this Microsoft.ML.Runtime.IExceptionContext ctx, string paramName);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptWhiteSpace(class Microsoft.ML.Runtime.IExceptionContext ctx, string paramName) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptWhiteSpace(Microsoft.ML.Runtime.IExceptionContext,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptWhiteSpace (ctx As IExceptionContext, paramName As String) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptWhiteSpace : Microsoft.ML.Runtime.IExceptionContext * string -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptWhiteSpace (ctx, paramName)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="paramName" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="paramName">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptWhiteSpace(Microsoft.ML.Runtime.IExceptionContext,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptWhiteSpace">
        <MemberSignature Language="C#" Value="public static Exception ExceptWhiteSpace (this Microsoft.ML.Runtime.IExceptionContext ctx, string paramName, string msg);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptWhiteSpace(class Microsoft.ML.Runtime.IExceptionContext ctx, string paramName, string msg) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.ExceptWhiteSpace(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptWhiteSpace (ctx As IExceptionContext, paramName As String, msg As String) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptWhiteSpace : Microsoft.ML.Runtime.IExceptionContext * string * string -&gt; Exception" Usage="Microsoft.ML.Runtime.Contracts.ExceptWhiteSpace (ctx, paramName, msg)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
          <Parameter Name="paramName" Type="System.String" />
          <Parameter Name="msg" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="paramName">To be added.</param>
          <param name="msg">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.ExceptWhiteSpace(Microsoft.ML.Runtime.IExceptionContext,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Exception" />
      </Targets>
      <Member MemberName="IsMarked">
        <MemberSignature Language="C#" Value="public static bool IsMarked (this Exception ex);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMarked(class System.Exception ex) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.IsMarked(System.Exception)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsMarked (ex As Exception) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsMarked : Exception -&gt; bool" Usage="Microsoft.ML.Runtime.Contracts.IsMarked ex" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ex" Type="System.Exception" RefType="this" />
        </Parameters>
        <Docs>
          <param name="ex">To be added.</param>
          <summary>
            Indicates whether the exception was "marked" the Contracts code.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.IsMarked(System.Exception)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Exception" />
      </Targets>
      <Member MemberName="MarkSensitive&lt;TException&gt;">
        <MemberSignature Language="C#" Value="public static TException MarkSensitive&lt;TException&gt; (this TException ex, Microsoft.ML.Runtime.MessageSensitivity sensitivity) where TException : Exception;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TException MarkSensitive&lt;(class System.Exception) TException&gt;(!!TException ex, valuetype Microsoft.ML.Runtime.MessageSensitivity sensitivity) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.MarkSensitive``1(``0,Microsoft.ML.Runtime.MessageSensitivity)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function MarkSensitive(Of TException As Exception) (ex As TException, sensitivity As MessageSensitivity) As TException" />
        <MemberSignature Language="F#" Value="static member MarkSensitive : 'Exception * Microsoft.ML.Runtime.MessageSensitivity -&gt; 'Exception (requires 'Exception :&gt; Exception)" Usage="Microsoft.ML.Runtime.Contracts.MarkSensitive (ex, sensitivity)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TException</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TException">
            <Constraints>
              <BaseTypeName>System.Exception</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="ex" Type="TException" RefType="this" />
          <Parameter Name="sensitivity" Type="Microsoft.ML.Runtime.MessageSensitivity" />
        </Parameters>
        <Docs>
          <typeparam name="TException">To be added.</typeparam>
          <param name="ex">To be added.</param>
          <param name="sensitivity">To be added.</param>
          <summary>
            Exceptions whose message communicates potentially sensitive information should be
            marked using this method, before they are thrown. Note that if the exception already
            had this flag set, the message will be flagged with the bitwise or of the existing
            flag, alongside the passed in sensivity.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.MarkSensitive``1(``0,Microsoft.ML.Runtime.MessageSensitivity)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="NotSensitive">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.IExceptionContext NotSensitive (this Microsoft.ML.Runtime.IExceptionContext ctx);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.IExceptionContext NotSensitive(class Microsoft.ML.Runtime.IExceptionContext ctx) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.NotSensitive(Microsoft.ML.Runtime.IExceptionContext)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NotSensitive (ctx As IExceptionContext) As IExceptionContext" />
        <MemberSignature Language="F#" Value="static member NotSensitive : Microsoft.ML.Runtime.IExceptionContext -&gt; Microsoft.ML.Runtime.IExceptionContext" Usage="Microsoft.ML.Runtime.Contracts.NotSensitive ctx" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.IExceptionContext</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <summary>
            A convenience context for marking exceptions from checks and excepts with <see cref="F:Microsoft.ML.Runtime.MessageSensitivity.None" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.NotSensitive(Microsoft.ML.Runtime.IExceptionContext)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Exception" />
      </Targets>
      <Member MemberName="Process&lt;TException&gt;">
        <MemberSignature Language="C#" Value="public static TException Process&lt;TException&gt; (this TException ex, Microsoft.ML.Runtime.IExceptionContext ectx = null) where TException : Exception;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TException Process&lt;(class System.Exception) TException&gt;(!!TException ex, class Microsoft.ML.Runtime.IExceptionContext ectx) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.Process``1(``0,Microsoft.ML.Runtime.IExceptionContext)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Process(Of TException As Exception) (ex As TException, Optional ectx As IExceptionContext = null) As TException" />
        <MemberSignature Language="F#" Value="static member Process : 'Exception * Microsoft.ML.Runtime.IExceptionContext -&gt; 'Exception (requires 'Exception :&gt; Exception)" Usage="Microsoft.ML.Runtime.Contracts.Process (ex, ectx)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TException</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TException">
            <Constraints>
              <BaseTypeName>System.Exception</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="ex" Type="TException" RefType="this" />
          <Parameter Name="ectx" Type="Microsoft.ML.Runtime.IExceptionContext" />
        </Parameters>
        <Docs>
          <typeparam name="TException">To be added.</typeparam>
          <param name="ex">To be added.</param>
          <param name="ectx">To be added.</param>
          <summary>
            Does standard processing of an exception (typically called after construction
            but before it is thrown).
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.Process``1(``0,Microsoft.ML.Runtime.IExceptionContext)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="SchemaSensitive">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.IExceptionContext SchemaSensitive (this Microsoft.ML.Runtime.IExceptionContext ctx);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.IExceptionContext SchemaSensitive(class Microsoft.ML.Runtime.IExceptionContext ctx) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.SchemaSensitive(Microsoft.ML.Runtime.IExceptionContext)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SchemaSensitive (ctx As IExceptionContext) As IExceptionContext" />
        <MemberSignature Language="F#" Value="static member SchemaSensitive : Microsoft.ML.Runtime.IExceptionContext -&gt; Microsoft.ML.Runtime.IExceptionContext" Usage="Microsoft.ML.Runtime.Contracts.SchemaSensitive ctx" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.IExceptionContext</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <summary>
            A convenience context for marking exceptions from checks and excepts with <see cref="F:Microsoft.ML.Runtime.MessageSensitivity.Schema" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.SchemaSensitive(Microsoft.ML.Runtime.IExceptionContext)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Exception" />
      </Targets>
      <Member MemberName="Sensitivity">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.MessageSensitivity Sensitivity (this Exception ex);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.ML.Runtime.MessageSensitivity Sensitivity(class System.Exception ex) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.Sensitivity(System.Exception)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sensitivity (ex As Exception) As MessageSensitivity" />
        <MemberSignature Language="F#" Value="static member Sensitivity : Exception -&gt; Microsoft.ML.Runtime.MessageSensitivity" Usage="Microsoft.ML.Runtime.Contracts.Sensitivity ex" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.MessageSensitivity</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ex" Type="System.Exception" RefType="this" />
        </Parameters>
        <Docs>
          <param name="ex">The exception to query</param>
          <summary>
            This is a convenience method to get the sensitivity of an exception,
            as encoded with <see cref="F:Microsoft.ML.Runtime.Contracts.SensitivityKey" />. If there is no key, then
            the message is assumed to be of unknown sensitivity, i.e., it is assumed
            that it might contain literally anything.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.Sensitivity(System.Exception)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="UserSensitive">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.IExceptionContext UserSensitive (this Microsoft.ML.Runtime.IExceptionContext ctx);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.IExceptionContext UserSensitive(class Microsoft.ML.Runtime.IExceptionContext ctx) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Contracts.UserSensitive(Microsoft.ML.Runtime.IExceptionContext)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function UserSensitive (ctx As IExceptionContext) As IExceptionContext" />
        <MemberSignature Language="F#" Value="static member UserSensitive : Microsoft.ML.Runtime.IExceptionContext -&gt; Microsoft.ML.Runtime.IExceptionContext" Usage="Microsoft.ML.Runtime.Contracts.UserSensitive ctx" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.IExceptionContext</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <summary>
            A convenience context for marking exceptions from checks and excepts with <see cref="F:Microsoft.ML.Runtime.MessageSensitivity.UserData" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Contracts" Member="M:Microsoft.ML.Runtime.Contracts.UserSensitive(Microsoft.ML.Runtime.IExceptionContext)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="OneHotEncoding">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; OneHotEncoding (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, Microsoft.ML.Runtime.Data.CategoricalStaticExtensions.OneHotScalarOutputKind outputKind = Microsoft.ML.Runtime.Data.CategoricalStaticExtensions+OneHotScalarOutputKind.Ind, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; OneHotEncoding(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, valuetype Microsoft.ML.Runtime.Data.CategoricalStaticExtensions/OneHotScalarOutputKind outputKind, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.CategoricalStaticExtensions.OneHotEncoding(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.Runtime.Data.CategoricalStaticExtensions.OneHotScalarOutputKind,Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.ReadOnlyMemory{System.Char}})" />
        <MemberSignature Language="F#" Value="static member OneHotEncoding : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * Microsoft.ML.Runtime.Data.CategoricalStaticExtensions.OneHotScalarOutputKind * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.CategoricalStaticExtensions.OneHotEncoding (input, outputKind, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="outputKind" Type="Microsoft.ML.Runtime.Data.CategoricalStaticExtensions+OneHotScalarOutputKind" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="outputKind">Specify output type of indicator array: array or binary encoded data.</param>
          <param name="order">How Id for each value would be assigined: by occurrence or by value.</param>
          <param name="maxItems">Maximum number of ids to keep during data scanning.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Converts the categorical value into an indicator array by building a dictionary of categories based on the data and using the id in the dictionary as the index in the array
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.CategoricalStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.CategoricalStaticExtensions.OneHotEncoding(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.Runtime.Data.CategoricalStaticExtensions.OneHotScalarOutputKind,Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="OneHotEncoding">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; OneHotEncoding (this Microsoft.ML.StaticPipe.Vector&lt;string&gt; input, Microsoft.ML.Runtime.Data.CategoricalStaticExtensions.OneHotVectorOutputKind outputKind = Microsoft.ML.Runtime.Data.CategoricalStaticExtensions+OneHotVectorOutputKind.Ind, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; OneHotEncoding(class Microsoft.ML.StaticPipe.Vector`1&lt;string&gt; input, valuetype Microsoft.ML.Runtime.Data.CategoricalStaticExtensions/OneHotVectorOutputKind outputKind, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.CategoricalStaticExtensions.OneHotEncoding(Microsoft.ML.StaticPipe.Vector{System.String},Microsoft.ML.Runtime.Data.CategoricalStaticExtensions.OneHotVectorOutputKind,Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.ReadOnlyMemory{System.Char}})" />
        <MemberSignature Language="F#" Value="static member OneHotEncoding : Microsoft.ML.StaticPipe.Vector&lt;string&gt; * Microsoft.ML.Runtime.Data.CategoricalStaticExtensions.OneHotVectorOutputKind * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.CategoricalStaticExtensions.OneHotEncoding (input, outputKind, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.String&gt;" RefType="this" />
          <Parameter Name="outputKind" Type="Microsoft.ML.Runtime.Data.CategoricalStaticExtensions+OneHotVectorOutputKind" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="outputKind">Specify output type of indicator array: Multiarray, array or binary encoded data.</param>
          <param name="order">How Id for each value would be assigined: by occurrence or by value.</param>
          <param name="maxItems">Maximum number of ids to keep during data scanning.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Converts the categorical value into an indicator array by building a dictionary of categories based on the data and using the id in the dictionary as the index in the array
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.CategoricalStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.CategoricalStaticExtensions.OneHotEncoding(Microsoft.ML.StaticPipe.Vector{System.String},Microsoft.ML.Runtime.Data.CategoricalStaticExtensions.OneHotVectorOutputKind,Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.IDataReader`1" />
      </Targets>
      <Member MemberName="SaveTo&lt;TSource&gt;">
        <MemberSignature Language="C#" Value="public static void SaveTo&lt;TSource&gt; (this Microsoft.ML.Core.Data.IDataReader&lt;TSource&gt; reader, Microsoft.ML.Runtime.IHostEnvironment env, System.IO.Stream outputStream);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SaveTo&lt;TSource&gt;(class Microsoft.ML.Core.Data.IDataReader`1&lt;!!TSource&gt; reader, class Microsoft.ML.Runtime.IHostEnvironment env, class System.IO.Stream outputStream) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.CompositeDataReader.SaveTo``1(Microsoft.ML.Core.Data.IDataReader{``0},Microsoft.ML.Runtime.IHostEnvironment,System.IO.Stream)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub SaveTo(Of TSource) (reader As IDataReader(Of TSource), env As IHostEnvironment, outputStream As Stream)" />
        <MemberSignature Language="F#" Value="static member SaveTo : Microsoft.ML.Core.Data.IDataReader&lt;'Source&gt; * Microsoft.ML.Runtime.IHostEnvironment * System.IO.Stream -&gt; unit" Usage="Microsoft.ML.Runtime.Data.CompositeDataReader.SaveTo (reader, env, outputStream)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSource" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="reader" Type="Microsoft.ML.Core.Data.IDataReader&lt;TSource&gt;" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
          <Parameter Name="outputStream" Type="System.IO.Stream" />
        </Parameters>
        <Docs>
          <typeparam name="TSource">To be added.</typeparam>
          <param name="reader">To be added.</param>
          <param name="env">To be added.</param>
          <param name="outputStream">To be added.</param>
          <summary>
            Save the contents to a stream, as a "model file".
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.CompositeDataReader" Member="M:Microsoft.ML.Runtime.Data.CompositeDataReader.SaveTo``1(Microsoft.ML.Core.Data.IDataReader{``0},Microsoft.ML.Runtime.IHostEnvironment,System.IO.Stream)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="AsVector&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;T&gt; AsVector&lt;T&gt; (this Microsoft.ML.StaticPipe.Scalar&lt;T&gt; me);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;!!T&gt; AsVector&lt;T&gt;(class Microsoft.ML.StaticPipe.Scalar`1&lt;!!T&gt; me) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.AsVector``1(Microsoft.ML.StaticPipe.Scalar{``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsVector(Of T) (me As Scalar(Of T)) As Vector(Of T)" />
        <MemberSignature Language="F#" Value="static member AsVector : Microsoft.ML.StaticPipe.Scalar&lt;'T&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;'T&gt;" Usage="Microsoft.ML.Runtime.Data.ConcatStaticExtensions.AsVector me" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="me" Type="Microsoft.ML.StaticPipe.Scalar&lt;T&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="T">The value type.</typeparam>
          <param name="me">The scalar column.</param>
          <summary>
            Given a scalar vector, produce a vector of length one.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.ConcatStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.AsVector``1(Microsoft.ML.StaticPipe.Scalar{``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.NormVector`1" />
      </Targets>
      <Member MemberName="ConcatWith&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;T&gt; ConcatWith&lt;T&gt; (this Microsoft.ML.StaticPipe.NormVector&lt;T&gt; me, params Microsoft.ML.StaticPipe.NormVector&lt;T&gt;[] others);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;!!T&gt; ConcatWith&lt;T&gt;(class Microsoft.ML.StaticPipe.NormVector`1&lt;!!T&gt; me, class Microsoft.ML.StaticPipe.NormVector`1&lt;!!T&gt;[] others) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.NormVector{``0},Microsoft.ML.StaticPipe.NormVector{``0}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConcatWith(Of T) (me As NormVector(Of T), ParamArray others As NormVector(Of T)()) As NormVector(Of T)" />
        <MemberSignature Language="F#" Value="static member ConcatWith : Microsoft.ML.StaticPipe.NormVector&lt;'T&gt; * Microsoft.ML.StaticPipe.NormVector&lt;'T&gt;[] -&gt; Microsoft.ML.StaticPipe.NormVector&lt;'T&gt;" Usage="Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith (me, others)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="me" Type="Microsoft.ML.StaticPipe.NormVector&lt;T&gt;" RefType="this" />
          <Parameter Name="others" Type="Microsoft.ML.StaticPipe.NormVector&lt;T&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">The value type.</typeparam>
          <param name="me">The first input column.</param>
          <param name="others">Subsequent input columns.</param>
          <summary>
            Given a bunch of normalized vectors, concatenate them together into a normalized vector.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.ConcatStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.NormVector{``0},Microsoft.ML.StaticPipe.NormVector{``0}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ConcatWith&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;T&gt; ConcatWith&lt;T&gt; (this Microsoft.ML.StaticPipe.Scalar&lt;T&gt; me, params Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVector&lt;T&gt;[] others);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;!!T&gt; ConcatWith&lt;T&gt;(class Microsoft.ML.StaticPipe.Scalar`1&lt;!!T&gt; me, class Microsoft.ML.Runtime.Data.ConcatStaticExtensions/ScalarOrVector`1&lt;!!T&gt;[] others) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Scalar{``0},Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVector{``0}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConcatWith(Of T) (me As Scalar(Of T), ParamArray others As ConcatStaticExtensions.ScalarOrVector(Of T)()) As Vector(Of T)" />
        <MemberSignature Language="F#" Value="static member ConcatWith : Microsoft.ML.StaticPipe.Scalar&lt;'T&gt; * Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVector&lt;'T&gt;[] -&gt; Microsoft.ML.StaticPipe.Vector&lt;'T&gt;" Usage="Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith (me, others)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="me" Type="Microsoft.ML.StaticPipe.Scalar&lt;T&gt;" RefType="this" />
          <Parameter Name="others" Type="Microsoft.ML.Runtime.Data.ConcatStaticExtensions+ScalarOrVector&lt;T&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">The value type.</typeparam>
          <param name="me">The first input column.</param>
          <param name="others">Subsequent input columns.</param>
          <summary>
            Given a set of columns, concatenate them together into a vector valued column of the same type.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.ConcatStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Scalar{``0},Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVector{``0}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ConcatWith&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;T&gt; ConcatWith&lt;T&gt; (this Microsoft.ML.StaticPipe.Scalar&lt;T&gt; me, params Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVectorOrVarVector&lt;T&gt;[] others);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;!!T&gt; ConcatWith&lt;T&gt;(class Microsoft.ML.StaticPipe.Scalar`1&lt;!!T&gt; me, class Microsoft.ML.Runtime.Data.ConcatStaticExtensions/ScalarOrVectorOrVarVector`1&lt;!!T&gt;[] others) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Scalar{``0},Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVectorOrVarVector{``0}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConcatWith(Of T) (me As Scalar(Of T), ParamArray others As ConcatStaticExtensions.ScalarOrVectorOrVarVector(Of T)()) As VarVector(Of T)" />
        <MemberSignature Language="F#" Value="static member ConcatWith : Microsoft.ML.StaticPipe.Scalar&lt;'T&gt; * Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVectorOrVarVector&lt;'T&gt;[] -&gt; Microsoft.ML.StaticPipe.VarVector&lt;'T&gt;" Usage="Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith (me, others)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="me" Type="Microsoft.ML.StaticPipe.Scalar&lt;T&gt;" RefType="this" />
          <Parameter Name="others" Type="Microsoft.ML.Runtime.Data.ConcatStaticExtensions+ScalarOrVectorOrVarVector&lt;T&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">The value type.</typeparam>
          <param name="me">The first input column.</param>
          <param name="others">Subsequent input columns.</param>
          <summary>
            Given a set of columns including at least one variable sized vector column, concatenate them
            together into a vector valued column of the same type.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.ConcatStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Scalar{``0},Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVectorOrVarVector{``0}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ConcatWith&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;T&gt; ConcatWith&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;T&gt; me, params Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVectorOrVarVector&lt;T&gt;[] others);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;!!T&gt; ConcatWith&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;!!T&gt; me, class Microsoft.ML.Runtime.Data.ConcatStaticExtensions/ScalarOrVectorOrVarVector`1&lt;!!T&gt;[] others) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.VarVector{``0},Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVectorOrVarVector{``0}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConcatWith(Of T) (me As VarVector(Of T), ParamArray others As ConcatStaticExtensions.ScalarOrVectorOrVarVector(Of T)()) As VarVector(Of T)" />
        <MemberSignature Language="F#" Value="static member ConcatWith : Microsoft.ML.StaticPipe.VarVector&lt;'T&gt; * Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVectorOrVarVector&lt;'T&gt;[] -&gt; Microsoft.ML.StaticPipe.VarVector&lt;'T&gt;" Usage="Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith (me, others)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="me" Type="Microsoft.ML.StaticPipe.VarVector&lt;T&gt;" RefType="this" />
          <Parameter Name="others" Type="Microsoft.ML.Runtime.Data.ConcatStaticExtensions+ScalarOrVectorOrVarVector&lt;T&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">The value type.</typeparam>
          <param name="me">The first input column.</param>
          <param name="others">Subsequent input columns.</param>
          <summary>
            Given a set of columns including at least one variable sized vector column, concatenate them
            together into a vector valued column of the same type.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.ConcatStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.VarVector{``0},Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVectorOrVarVector{``0}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ConcatWith&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;T&gt; ConcatWith&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;T&gt; me, params Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVector&lt;T&gt;[] others);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;!!T&gt; ConcatWith&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;!!T&gt; me, class Microsoft.ML.Runtime.Data.ConcatStaticExtensions/ScalarOrVector`1&lt;!!T&gt;[] others) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Vector{``0},Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVector{``0}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConcatWith(Of T) (me As Vector(Of T), ParamArray others As ConcatStaticExtensions.ScalarOrVector(Of T)()) As Vector(Of T)" />
        <MemberSignature Language="F#" Value="static member ConcatWith : Microsoft.ML.StaticPipe.Vector&lt;'T&gt; * Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVector&lt;'T&gt;[] -&gt; Microsoft.ML.StaticPipe.Vector&lt;'T&gt;" Usage="Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith (me, others)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="me" Type="Microsoft.ML.StaticPipe.Vector&lt;T&gt;" RefType="this" />
          <Parameter Name="others" Type="Microsoft.ML.Runtime.Data.ConcatStaticExtensions+ScalarOrVector&lt;T&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">The value type.</typeparam>
          <param name="me">The first input column.</param>
          <param name="others">Subsequent input columns.</param>
          <summary>
            Given a set of columns, concatenate them together into a vector valued column of the same type.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.ConcatStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Vector{``0},Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVector{``0}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ConcatWith&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;T&gt; ConcatWith&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;T&gt; me, params Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVectorOrVarVector&lt;T&gt;[] others);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;!!T&gt; ConcatWith&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;!!T&gt; me, class Microsoft.ML.Runtime.Data.ConcatStaticExtensions/ScalarOrVectorOrVarVector`1&lt;!!T&gt;[] others) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Vector{``0},Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVectorOrVarVector{``0}[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ConcatWith(Of T) (me As Vector(Of T), ParamArray others As ConcatStaticExtensions.ScalarOrVectorOrVarVector(Of T)()) As VarVector(Of T)" />
        <MemberSignature Language="F#" Value="static member ConcatWith : Microsoft.ML.StaticPipe.Vector&lt;'T&gt; * Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVectorOrVarVector&lt;'T&gt;[] -&gt; Microsoft.ML.StaticPipe.VarVector&lt;'T&gt;" Usage="Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith (me, others)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="me" Type="Microsoft.ML.StaticPipe.Vector&lt;T&gt;" RefType="this" />
          <Parameter Name="others" Type="Microsoft.ML.Runtime.Data.ConcatStaticExtensions+ScalarOrVectorOrVarVector&lt;T&gt;[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">The value type.</typeparam>
          <param name="me">The first input column.</param>
          <param name="others">Subsequent input columns.</param>
          <summary>
            Given a set of columns including at least one variable sized vector column, concatenate them
            together into a vector valued column of the same type.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.ConcatStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Vector{``0},Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVectorOrVarVector{``0}[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.DataKind" />
      </Targets>
      <Member MemberName="GetString">
        <MemberSignature Language="C#" Value="public static string GetString (this Microsoft.ML.Runtime.Data.DataKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetString(valuetype Microsoft.ML.Runtime.Data.DataKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.DataKindExtensions.GetString(Microsoft.ML.Runtime.Data.DataKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetString (kind As DataKind) As String" />
        <MemberSignature Language="F#" Value="static member GetString : Microsoft.ML.Runtime.Data.DataKind -&gt; string" Usage="Microsoft.ML.Runtime.Data.DataKindExtensions.GetString kind" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="kind" Type="Microsoft.ML.Runtime.Data.DataKind" RefType="this" />
        </Parameters>
        <Docs>
          <param name="kind">To be added.</param>
          <summary>
            Get the canonical string for a DataKind. Note that using DataKind.ToString() is not stable
            and is also slow, so use this instead.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.DataKindExtensions" Member="M:Microsoft.ML.Runtime.Data.DataKindExtensions.GetString(Microsoft.ML.Runtime.Data.DataKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.DataKind" />
      </Targets>
      <Member MemberName="ToIndex">
        <MemberSignature Language="C#" Value="public static int ToIndex (this Microsoft.ML.Runtime.Data.DataKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToIndex(valuetype Microsoft.ML.Runtime.Data.DataKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.DataKindExtensions.ToIndex(Microsoft.ML.Runtime.Data.DataKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToIndex (kind As DataKind) As Integer" />
        <MemberSignature Language="F#" Value="static member ToIndex : Microsoft.ML.Runtime.Data.DataKind -&gt; int" Usage="Microsoft.ML.Runtime.Data.DataKindExtensions.ToIndex kind" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="kind" Type="Microsoft.ML.Runtime.Data.DataKind" RefType="this" />
        </Parameters>
        <Docs>
          <param name="kind">To be added.</param>
          <summary>
            Maps a DataKind to a value suitable for indexing into an array of size KindCount.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.DataKindExtensions" Member="M:Microsoft.ML.Runtime.Data.DataKindExtensions.ToIndex(Microsoft.ML.Runtime.Data.DataKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.DataKind" />
      </Targets>
      <Member MemberName="ToMaxInt">
        <MemberSignature Language="C#" Value="public static ulong ToMaxInt (this Microsoft.ML.Runtime.Data.DataKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ToMaxInt(valuetype Microsoft.ML.Runtime.Data.DataKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.DataKindExtensions.ToMaxInt(Microsoft.ML.Runtime.Data.DataKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToMaxInt (kind As DataKind) As ULong" />
        <MemberSignature Language="F#" Value="static member ToMaxInt : Microsoft.ML.Runtime.Data.DataKind -&gt; uint64" Usage="Microsoft.ML.Runtime.Data.DataKindExtensions.ToMaxInt kind" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.UInt64</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="kind" Type="Microsoft.ML.Runtime.Data.DataKind" RefType="this" />
        </Parameters>
        <Docs>
          <param name="kind">To be added.</param>
          <summary>
            For integer DataKinds, this returns the maximum legal value. For un-supported kinds,
            it returns zero.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.DataKindExtensions" Member="M:Microsoft.ML.Runtime.Data.DataKindExtensions.ToMaxInt(Microsoft.ML.Runtime.Data.DataKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.DataKind" />
      </Targets>
      <Member MemberName="ToMinInt">
        <MemberSignature Language="C#" Value="public static long ToMinInt (this Microsoft.ML.Runtime.Data.DataKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToMinInt(valuetype Microsoft.ML.Runtime.Data.DataKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.DataKindExtensions.ToMinInt(Microsoft.ML.Runtime.Data.DataKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToMinInt (kind As DataKind) As Long" />
        <MemberSignature Language="F#" Value="static member ToMinInt : Microsoft.ML.Runtime.Data.DataKind -&gt; int64" Usage="Microsoft.ML.Runtime.Data.DataKindExtensions.ToMinInt kind" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int64</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="kind" Type="Microsoft.ML.Runtime.Data.DataKind" RefType="this" />
        </Parameters>
        <Docs>
          <param name="kind">To be added.</param>
          <summary>
            For integer DataKinds, this returns the minimum legal value. For un-supported kinds,
            it returns one.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.DataKindExtensions" Member="M:Microsoft.ML.Runtime.Data.DataKindExtensions.ToMinInt(Microsoft.ML.Runtime.Data.DataKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.DataKind" />
      </Targets>
      <Member MemberName="ToType">
        <MemberSignature Language="C#" Value="public static Type ToType (this Microsoft.ML.Runtime.Data.DataKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ToType(valuetype Microsoft.ML.Runtime.Data.DataKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.DataKindExtensions.ToType(Microsoft.ML.Runtime.Data.DataKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToType (kind As DataKind) As Type" />
        <MemberSignature Language="F#" Value="static member ToType : Microsoft.ML.Runtime.Data.DataKind -&gt; Type" Usage="Microsoft.ML.Runtime.Data.DataKindExtensions.ToType kind" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Type</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="kind" Type="Microsoft.ML.Runtime.Data.DataKind" RefType="this" />
        </Parameters>
        <Docs>
          <param name="kind">To be added.</param>
          <summary>
            Maps a DataKind to the associated .Net representation type.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.DataKindExtensions" Member="M:Microsoft.ML.Runtime.Data.DataKindExtensions.ToType(Microsoft.ML.Runtime.Data.DataKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Type" />
      </Targets>
      <Member MemberName="TryGetDataKind">
        <MemberSignature Language="C#" Value="public static bool TryGetDataKind (this Type type, out Microsoft.ML.Runtime.Data.DataKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetDataKind(class System.Type type, [out] valuetype Microsoft.ML.Runtime.Data.DataKind&amp; kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.DataKindExtensions.TryGetDataKind(System.Type,Microsoft.ML.Runtime.Data.DataKind@)" />
        <MemberSignature Language="F#" Value="static member TryGetDataKind : Type *  -&gt; bool" Usage="Microsoft.ML.Runtime.Data.DataKindExtensions.TryGetDataKind (type, kind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="type" Type="System.Type" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.ML.Runtime.Data.DataKind" RefType="out" />
        </Parameters>
        <Docs>
          <param name="type">To be added.</param>
          <param name="kind">To be added.</param>
          <summary>
            Try to map a System.Type to a corresponding DataKind value.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.DataKindExtensions" Member="M:Microsoft.ML.Runtime.Data.DataKindExtensions.TryGetDataKind(System.Type,Microsoft.ML.Runtime.Data.DataKind@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.ISchema" />
      </Targets>
      <Member MemberName="GetTempColumnName">
        <MemberSignature Language="C#" Value="public static string GetTempColumnName (this Microsoft.ML.Runtime.Data.ISchema schema, string tag = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempColumnName(class Microsoft.ML.Runtime.Data.ISchema schema, string tag) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.DataViewUtils.GetTempColumnName(Microsoft.ML.Runtime.Data.ISchema,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetTempColumnName (schema As ISchema, Optional tag As String = null) As String" />
        <MemberSignature Language="F#" Value="static member GetTempColumnName : Microsoft.ML.Runtime.Data.ISchema * string -&gt; string" Usage="Microsoft.ML.Runtime.Data.DataViewUtils.GetTempColumnName (schema, tag)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="schema" Type="Microsoft.ML.Runtime.Data.ISchema" RefType="this" />
          <Parameter Name="tag" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="schema">To be added.</param>
          <param name="tag">To be added.</param>
          <summary>
            Generate a unique temporary column name for the given schema.
            Use tag to independently create multiple temporary, unique column
            names for a single transform.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.DataViewUtils" Member="M:Microsoft.ML.Runtime.Data.DataViewUtils.GetTempColumnName(Microsoft.ML.Runtime.Data.ISchema,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.ISchema" />
      </Targets>
      <Member MemberName="GetTempColumnNames">
        <MemberSignature Language="C#" Value="public static string[] GetTempColumnNames (this Microsoft.ML.Runtime.Data.ISchema schema, int n, string tag = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetTempColumnNames(class Microsoft.ML.Runtime.Data.ISchema schema, int32 n, string tag) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.DataViewUtils.GetTempColumnNames(Microsoft.ML.Runtime.Data.ISchema,System.Int32,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetTempColumnNames (schema As ISchema, n As Integer, Optional tag As String = null) As String()" />
        <MemberSignature Language="F#" Value="static member GetTempColumnNames : Microsoft.ML.Runtime.Data.ISchema * int * string -&gt; string[]" Usage="Microsoft.ML.Runtime.Data.DataViewUtils.GetTempColumnNames (schema, n, tag)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="schema" Type="Microsoft.ML.Runtime.Data.ISchema" RefType="this" />
          <Parameter Name="n" Type="System.Int32" />
          <Parameter Name="tag" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="schema">To be added.</param>
          <param name="n">To be added.</param>
          <param name="tag">To be added.</param>
          <summary>
            Generate n unique temporary column names for the given schema.
            Use tag to independently create multiple temporary, unique column
            names for a single transform.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.DataViewUtils" Member="M:Microsoft.ML.Runtime.Data.DataViewUtils.GetTempColumnNames(Microsoft.ML.Runtime.Data.ISchema,System.Int32,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.ColumnType" />
      </Targets>
      <Member MemberName="IsCachable">
        <MemberSignature Language="C#" Value="public static bool IsCachable (this Microsoft.ML.Runtime.Data.ColumnType type);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsCachable(class Microsoft.ML.Runtime.Data.ColumnType type) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.DataViewUtils.IsCachable(Microsoft.ML.Runtime.Data.ColumnType)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsCachable (type As ColumnType) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsCachable : Microsoft.ML.Runtime.Data.ColumnType -&gt; bool" Usage="Microsoft.ML.Runtime.Data.DataViewUtils.IsCachable type" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="type" Type="Microsoft.ML.Runtime.Data.ColumnType" RefType="this" />
        </Parameters>
        <Docs>
          <param name="type">To be added.</param>
          <summary>
            Determine whether the given type is cachable - either a primitive type or a vector type.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.DataViewUtils" Member="M:Microsoft.ML.Runtime.Data.DataViewUtils.IsCachable(Microsoft.ML.Runtime.Data.ColumnType)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext" />
      </Targets>
      <Member MemberName="Evaluate&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator.Result Evaluate&lt;T&gt; (this Microsoft.ML.BinaryClassificationContext ctx, Microsoft.ML.StaticPipe.DataView&lt;T&gt; data, Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; label, Func&lt;T,ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;&gt; pred);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator/Result Evaluate&lt;T&gt;(class Microsoft.ML.BinaryClassificationContext ctx, class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt; data, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; label, class System.Func`2&lt;!!T, valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt;&gt; pred) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.BinaryClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Func{``0,System.ValueTuple{Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Boolean}}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Evaluate(Of T) (ctx As BinaryClassificationContext, data As DataView(Of T), label As Func(Of T, Scalar(Of Boolean)), pred As Func(Of T, ValueTuple(Of Scalar(Of Single), Scalar(Of Boolean)))) As BinaryClassifierEvaluator.Result" />
        <MemberSignature Language="F#" Value="static member Evaluate : Microsoft.ML.BinaryClassificationContext * Microsoft.ML.StaticPipe.DataView&lt;'T&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; * Func&lt;'T, ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;&gt; -&gt; Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator.Result" Usage="Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions.Evaluate (ctx, data, label, pred)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator+Result</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;T&gt;" />
          <Parameter Name="label" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;" />
          <Parameter Name="pred" Type="System.Func&lt;T,System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;&gt;">
            <Attributes>
              <Attribute>
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">The shape type for the input data.</typeparam>
          <param name="ctx">The binary classification context.</param>
          <param name="data">The data to evaluate.</param>
          <param name="label">The index delegate for the label column.</param>
          <param name="pred">The index delegate for columns from uncalibrated prediction of a binary classifier.
            Under typical scenarios, this will just be the same tuple of results returned from the trainer.</param>
          <summary>
            Evaluates scored binary classification data, if the predictions are not calibrated.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.BinaryClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Func{``0,System.ValueTuple{Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Boolean}}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext" />
      </Targets>
      <Member MemberName="Evaluate&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator.CalibratedResult Evaluate&lt;T&gt; (this Microsoft.ML.BinaryClassificationContext ctx, Microsoft.ML.StaticPipe.DataView&lt;T&gt; data, Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; label, Func&lt;T,ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;&gt; pred);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator/CalibratedResult Evaluate&lt;T&gt;(class Microsoft.ML.BinaryClassificationContext ctx, class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt; data, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; label, class System.Func`2&lt;!!T, valuetype System.ValueTuple`3&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt;&gt; pred) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.BinaryClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Func{``0,System.ValueTuple{Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Boolean}}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Evaluate(Of T) (ctx As BinaryClassificationContext, data As DataView(Of T), label As Func(Of T, Scalar(Of Boolean)), pred As Func(Of T, ValueTuple(Of Scalar(Of Single), Scalar(Of Single), Scalar(Of Boolean)))) As BinaryClassifierEvaluator.CalibratedResult" />
        <MemberSignature Language="F#" Value="static member Evaluate : Microsoft.ML.BinaryClassificationContext * Microsoft.ML.StaticPipe.DataView&lt;'T&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; * Func&lt;'T, ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;&gt; -&gt; Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator.CalibratedResult" Usage="Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions.Evaluate (ctx, data, label, pred)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator+CalibratedResult</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;T&gt;" />
          <Parameter Name="label" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;" />
          <Parameter Name="pred" Type="System.Func&lt;T,System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;&gt;">
            <Attributes>
              <Attribute>
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "probability", "predictedLabel" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">The shape type for the input data.</typeparam>
          <param name="ctx">The binary classification context.</param>
          <param name="data">The data to evaluate.</param>
          <param name="label">The index delegate for the label column.</param>
          <param name="pred">The index delegate for columns from calibrated prediction of a binary classifier.
            Under typical scenarios, this will just be the same tuple of results returned from the trainer.</param>
          <summary>
            Evaluates scored binary classification data.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.BinaryClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Func{``0,System.ValueTuple{Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Boolean}}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.ClusteringContext" />
      </Targets>
      <Member MemberName="Evaluate&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.ClusteringEvaluator.Result Evaluate&lt;T&gt; (this Microsoft.ML.ClusteringContext ctx, Microsoft.ML.StaticPipe.DataView&lt;T&gt; data, Func&lt;T,Microsoft.ML.StaticPipe.Vector&lt;float&gt;&gt; score, Func&lt;T,Microsoft.ML.StaticPipe.Key&lt;uint&gt;&gt; label = null, Func&lt;T,Microsoft.ML.StaticPipe.Vector&lt;float&gt;&gt; features = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.ClusteringEvaluator/Result Evaluate&lt;T&gt;(class Microsoft.ML.ClusteringContext ctx, class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt; data, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;&gt; score, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Key`1&lt;unsigned int32&gt;&gt; label, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;&gt; features) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.ClusteringContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Vector{System.Single}},System.Func{``0,Microsoft.ML.StaticPipe.Key{System.UInt32}},System.Func{``0,Microsoft.ML.StaticPipe.Vector{System.Single}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Evaluate(Of T) (ctx As ClusteringContext, data As DataView(Of T), score As Func(Of T, Vector(Of Single)), Optional label As Func(Of T, Key(Of UInteger)) = null, Optional features As Func(Of T, Vector(Of Single)) = null) As ClusteringEvaluator.Result" />
        <MemberSignature Language="F#" Value="static member Evaluate : Microsoft.ML.ClusteringContext * Microsoft.ML.StaticPipe.DataView&lt;'T&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Vector&lt;single&gt;&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Key&lt;uint32&gt;&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Vector&lt;single&gt;&gt; -&gt; Microsoft.ML.Runtime.Data.ClusteringEvaluator.Result" Usage="Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions.Evaluate (ctx, data, score, label, features)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.ClusteringEvaluator+Result</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.ClusteringContext" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;T&gt;" />
          <Parameter Name="score" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;&gt;" />
          <Parameter Name="label" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Key&lt;System.UInt32&gt;&gt;" />
          <Parameter Name="features" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="T">The shape type for the input data.</typeparam>
          <param name="ctx">The clustering context.</param>
          <param name="data">The data to evaluate.</param>
          <param name="score">The index delegate for the predicted score column.</param>
          <param name="label">The optional index delegate for the label column.</param>
          <param name="features">The optional index delegate for the features column.</param>
          <summary>
            Evaluates scored clustering prediction data.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.ClusteringContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Vector{System.Single}},System.Func{``0,Microsoft.ML.StaticPipe.Key{System.UInt32}},System.Func{``0,Microsoft.ML.StaticPipe.Vector{System.Single}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionContext" />
      </Targets>
      <Member MemberName="Evaluate&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.RegressionEvaluator.Result Evaluate&lt;T&gt; (this Microsoft.ML.RegressionContext ctx, Microsoft.ML.StaticPipe.DataView&lt;T&gt; data, Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;&gt; label, Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;&gt; score, Microsoft.ML.Runtime.IRegressionLoss loss = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.RegressionEvaluator/Result Evaluate&lt;T&gt;(class Microsoft.ML.RegressionContext ctx, class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt; data, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;&gt; label, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;&gt; score, class Microsoft.ML.Runtime.IRegressionLoss loss) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.RegressionContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Single}},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Single}},Microsoft.ML.Runtime.IRegressionLoss)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Evaluate(Of T) (ctx As RegressionContext, data As DataView(Of T), label As Func(Of T, Scalar(Of Single)), score As Func(Of T, Scalar(Of Single)), Optional loss As IRegressionLoss = null) As RegressionEvaluator.Result" />
        <MemberSignature Language="F#" Value="static member Evaluate : Microsoft.ML.RegressionContext * Microsoft.ML.StaticPipe.DataView&lt;'T&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;&gt; * Microsoft.ML.Runtime.IRegressionLoss -&gt; Microsoft.ML.Runtime.Data.RegressionEvaluator.Result" Usage="Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions.Evaluate (ctx, data, label, score, loss)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.RegressionEvaluator+Result</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RegressionContext" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;T&gt;" />
          <Parameter Name="label" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;&gt;" />
          <Parameter Name="score" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;&gt;" />
          <Parameter Name="loss" Type="Microsoft.ML.Runtime.IRegressionLoss" />
        </Parameters>
        <Docs>
          <typeparam name="T">The shape type for the input data.</typeparam>
          <param name="ctx">The regression context.</param>
          <param name="data">The data to evaluate.</param>
          <param name="label">The index delegate for the label column.</param>
          <param name="score">The index delegate for predicted score column.</param>
          <param name="loss">Potentially custom loss function. If left unspecified defaults to <see cref="T:Microsoft.ML.Runtime.SquaredLoss" />.</param>
          <summary>
            Evaluates scored regression data.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.RegressionContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Single}},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Single}},Microsoft.ML.Runtime.IRegressionLoss)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationContext" />
      </Targets>
      <Member MemberName="Evaluate&lt;T,TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.MultiClassClassifierEvaluator.Result Evaluate&lt;T,TKey&gt; (this Microsoft.ML.MulticlassClassificationContext ctx, Microsoft.ML.StaticPipe.DataView&lt;T&gt; data, Func&lt;T,Microsoft.ML.StaticPipe.Key&lt;uint,TKey&gt;&gt; label, Func&lt;T,ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;float&gt;,Microsoft.ML.StaticPipe.Key&lt;uint,TKey&gt;&gt;&gt; pred, int topK = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.MultiClassClassifierEvaluator/Result Evaluate&lt;T, TKey&gt;(class Microsoft.ML.MulticlassClassificationContext ctx, class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt; data, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TKey&gt;&gt; label, class System.Func`2&lt;!!T, valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TKey&gt;&gt;&gt; pred, int32 topK) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions.Evaluate``2(Microsoft.ML.MulticlassClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Key{System.UInt32,``1}},System.Func{``0,System.ValueTuple{Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Key{System.UInt32,``1}}},System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Evaluate(Of T, TKey) (ctx As MulticlassClassificationContext, data As DataView(Of T), label As Func(Of T, Key(Of UInteger, TKey)), pred As Func(Of T, ValueTuple(Of Vector(Of Single), Key(Of UInteger, TKey))), Optional topK As Integer = 0) As MultiClassClassifierEvaluator.Result" />
        <MemberSignature Language="F#" Value="static member Evaluate : Microsoft.ML.MulticlassClassificationContext * Microsoft.ML.StaticPipe.DataView&lt;'T&gt; * Func&lt;'T, Microsoft.ML.StaticPipe.Key&lt;uint32, 'Key&gt;&gt; * Func&lt;'T, ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;single&gt;, Microsoft.ML.StaticPipe.Key&lt;uint32, 'Key&gt;&gt;&gt; * int -&gt; Microsoft.ML.Runtime.Data.MultiClassClassifierEvaluator.Result" Usage="Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions.Evaluate (ctx, data, label, pred, topK)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.MultiClassClassifierEvaluator+Result</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.MulticlassClassificationContext" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;T&gt;" />
          <Parameter Name="label" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TKey&gt;&gt;" />
          <Parameter Name="pred" Type="System.Func&lt;T,System.ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TKey&gt;&gt;&gt;">
            <Attributes>
              <Attribute>
                <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
          <Parameter Name="topK" Type="System.Int32" />
        </Parameters>
        <Docs>
          <typeparam name="T">The shape type for the input data.</typeparam>
          <typeparam name="TKey">The value type for the key label.</typeparam>
          <param name="ctx">The multiclass classification context.</param>
          <param name="data">The data to evaluate.</param>
          <param name="label">The index delegate for the label column.</param>
          <param name="pred">The index delegate for columns from the prediction of a multiclass classifier.
            Under typical scenarios, this will just be the same tuple of results returned from the trainer.</param>
          <param name="topK">If given a positive value, the <see cref="P:Microsoft.ML.Runtime.Data.MultiClassClassifierEvaluator.Result.TopKAccuracy" /> will be filled with
            the top-K accuracy, that is, the accuracy assuming we consider an example with the correct class within
            the top-K values as being stored "correctly."</param>
          <summary>
            Evaluates scored multiclass classification data.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions.Evaluate``2(Microsoft.ML.MulticlassClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Key{System.UInt32,``1}},System.Func{``0,System.ValueTuple{Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Key{System.UInt32,``1}}},System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.IO.CompressionKind" />
      </Targets>
      <Member MemberName="CompressStream">
        <MemberSignature Language="C#" Value="public static System.IO.Stream CompressStream (this Microsoft.ML.Runtime.Data.IO.CompressionKind compression, System.IO.Stream stream);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream CompressStream(valuetype Microsoft.ML.Runtime.Data.IO.CompressionKind compression, class System.IO.Stream stream) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.IO.CompressionCodecExtension.CompressStream(Microsoft.ML.Runtime.Data.IO.CompressionKind,System.IO.Stream)" />
        <MemberSignature Language="F#" Value="static member CompressStream : Microsoft.ML.Runtime.Data.IO.CompressionKind * System.IO.Stream -&gt; System.IO.Stream" Usage="Microsoft.ML.Runtime.Data.IO.CompressionCodecExtension.CompressStream (compression, stream)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.IO.Stream</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="compression" Type="Microsoft.ML.Runtime.Data.IO.CompressionKind" RefType="this" />
          <Parameter Name="stream" Type="System.IO.Stream" />
        </Parameters>
        <Docs>
          <param name="compression">The compression codec</param>
          <param name="stream">The stream to which compressed data will be written</param>
          <summary>
            Generate an appropriate wrapping compressing stream for the codec. This
            stream will be closable and disposable, without closing or disposing of
            the passed in stream. The scheme for compression is not in any way
            parameterizable.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.IO.CompressionCodecExtension" Member="M:Microsoft.ML.Runtime.Data.IO.CompressionCodecExtension.CompressStream(Microsoft.ML.Runtime.Data.IO.CompressionKind,System.IO.Stream)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.IO.CompressionKind" />
      </Targets>
      <Member MemberName="DecompressStream">
        <MemberSignature Language="C#" Value="public static System.IO.Stream DecompressStream (this Microsoft.ML.Runtime.Data.IO.CompressionKind compression, System.IO.Stream stream);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream DecompressStream(valuetype Microsoft.ML.Runtime.Data.IO.CompressionKind compression, class System.IO.Stream stream) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.IO.CompressionCodecExtension.DecompressStream(Microsoft.ML.Runtime.Data.IO.CompressionKind,System.IO.Stream)" />
        <MemberSignature Language="F#" Value="static member DecompressStream : Microsoft.ML.Runtime.Data.IO.CompressionKind * System.IO.Stream -&gt; System.IO.Stream" Usage="Microsoft.ML.Runtime.Data.IO.CompressionCodecExtension.DecompressStream (compression, stream)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.IO.Stream</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="compression" Type="Microsoft.ML.Runtime.Data.IO.CompressionKind" RefType="this" />
          <Parameter Name="stream" Type="System.IO.Stream" />
        </Parameters>
        <Docs>
          <param name="compression">The compression codec</param>
          <param name="stream">The stream from which compressed data will be written</param>
          <summary>
            Generate an appropriate wrapping decompressing stream for the codec.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.IO.CompressionCodecExtension" Member="M:Microsoft.ML.Runtime.Data.IO.CompressionCodecExtension.DecompressStream(Microsoft.ML.Runtime.Data.IO.CompressionKind,System.IO.Stream)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`1" />
      </Targets>
      <Member MemberName="ToBinaryVector&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBinaryVector&lt;TKey&gt; (this Microsoft.ML.StaticPipe.Key&lt;TKey&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBinaryVector&lt;TKey&gt;(class Microsoft.ML.StaticPipe.Key`1&lt;!!TKey&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.KeyToBinaryVectorExtensions.ToBinaryVector``1(Microsoft.ML.StaticPipe.Key{``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBinaryVector(Of TKey) (input As Key(Of TKey)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBinaryVector : Microsoft.ML.StaticPipe.Key&lt;'Key&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.KeyToBinaryVectorExtensions.ToBinaryVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;TKey&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces a vector of bits representing the key in binary form.
            The first value is encoded as all zeros and missing values are encoded as all ones.
            In the case where a vector has multiple keys, the encoded values are concatenated.
            Number of bits per key is determined as the number of bits needed to represent the cardinality of the keys plus one.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.KeyToBinaryVectorExtensions" Member="M:Microsoft.ML.Runtime.Data.KeyToBinaryVectorExtensions.ToBinaryVector``1(Microsoft.ML.StaticPipe.Key{``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToBinaryVector&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToBinaryVector&lt;TKey&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToBinaryVector&lt;TKey&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`1&lt;!!TKey&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.KeyToBinaryVectorExtensions.ToBinaryVector``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBinaryVector(Of TKey) (input As VarVector(Of Key(Of TKey))) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBinaryVector : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key&gt;&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.KeyToBinaryVectorExtensions.ToBinaryVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces a vector of bits representing the key in binary form.
            The first value is encoded as all zeros and missing values are encoded as all ones.
            In the case where a vector has multiple keys, the encoded values are concatenated.
            Number of bits per key is determined as the number of bits needed to represent the cardinality of the keys plus one.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.KeyToBinaryVectorExtensions" Member="M:Microsoft.ML.Runtime.Data.KeyToBinaryVectorExtensions.ToBinaryVector``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToBinaryVector&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBinaryVector&lt;TKey&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBinaryVector&lt;TKey&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`1&lt;!!TKey&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.KeyToBinaryVectorExtensions.ToBinaryVector``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBinaryVector(Of TKey) (input As Vector(Of Key(Of TKey))) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBinaryVector : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.KeyToBinaryVectorExtensions.ToBinaryVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces a vector of bits representing the key in binary form.
            The first value is encoded as all zeros and missing values are encoded as all ones.
            In the case where a vector has multiple keys, the encoded values are concatenated.
            Number of bits per key is determined as the number of bits needed to represent the cardinality of the keys plus one.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.KeyToBinaryVectorExtensions" Member="M:Microsoft.ML.Runtime.Data.KeyToBinaryVectorExtensions.ToBinaryVector``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToBinaryVector&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBinaryVector&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBinaryVector&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.KeyToBinaryVectorExtensions.ToBinaryVector``2(Microsoft.ML.StaticPipe.Key{``0,``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBinaryVector(Of TKey, TValue) (input As Key(Of TKey, TValue)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBinaryVector : Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.KeyToBinaryVectorExtensions.ToBinaryVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces a vector of bits representing the key in binary form.
            The first value is encoded as all zeros and missing values are encoded as all ones.
            In the case where a vector has multiple keys, the encoded values are concatenated.
            Number of bits per key is determined as the number of bits needed to represent the cardinality of the keys plus one.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.KeyToBinaryVectorExtensions" Member="M:Microsoft.ML.Runtime.Data.KeyToBinaryVectorExtensions.ToBinaryVector``2(Microsoft.ML.StaticPipe.Key{``0,``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToBinaryVector&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToBinaryVector&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToBinaryVector&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.KeyToBinaryVectorExtensions.ToBinaryVector``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBinaryVector(Of TKey, TValue) (input As VarVector(Of Key(Of TKey, TValue))) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBinaryVector : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt;&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.KeyToBinaryVectorExtensions.ToBinaryVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces a vector of bits representing the key in binary form.
            The first value is encoded as all zeros and missing values are encoded as all ones.
            In the case where a vector has multiple keys, the encoded values are concatenated.
            Number of bits per key is determined as the number of bits needed to represent the cardinality of the keys plus one.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.KeyToBinaryVectorExtensions" Member="M:Microsoft.ML.Runtime.Data.KeyToBinaryVectorExtensions.ToBinaryVector``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToBinaryVector&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBinaryVector&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBinaryVector&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.KeyToBinaryVectorExtensions.ToBinaryVector``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBinaryVector(Of TKey, TValue) (input As Vector(Of Key(Of TKey, TValue))) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBinaryVector : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.KeyToBinaryVectorExtensions.ToBinaryVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces a vector of bits representing the key in binary form.
            The first value is encoded as all zeros and missing values are encoded as all ones.
            In the case where a vector has multiple keys, the encoded values are concatenated.
            Number of bits per key is determined as the number of bits needed to represent the cardinality of the keys plus one.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.KeyToBinaryVectorExtensions" Member="M:Microsoft.ML.Runtime.Data.KeyToBinaryVectorExtensions.ToBinaryVector``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToValue&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;TValue&gt; ToValue&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;!!TValue&gt; ToValue&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.Key{``0,``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToValue(Of TKey, TValue) (input As Key(Of TKey, TValue)) As Scalar(Of TValue)" />
        <MemberSignature Language="F#" Value="static member ToValue : Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;'Value&gt;" Usage="Microsoft.ML.Runtime.Data.KeyToValueStaticExtensions.ToValue input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;TValue&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Convert a key column to a column containing the corresponding value.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.KeyToValueStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.Key{``0,``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToValue&lt;TOuterKey,TInnerKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;TInnerKey&gt; ToValue&lt;TOuterKey,TInnerKey&gt; (this Microsoft.ML.StaticPipe.Key&lt;TOuterKey,Microsoft.ML.StaticPipe.Key&lt;TInnerKey&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`1&lt;!!TInnerKey&gt; ToValue&lt;TOuterKey, TInnerKey&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!TOuterKey, class Microsoft.ML.StaticPipe.Key`1&lt;!!TInnerKey&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.Key{``0,Microsoft.ML.StaticPipe.Key{``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToValue(Of TOuterKey, TInnerKey) (input As Key(Of TOuterKey, Key(Of TInnerKey))) As Key(Of TInnerKey)" />
        <MemberSignature Language="F#" Value="static member ToValue : Microsoft.ML.StaticPipe.Key&lt;'OuterKey, Microsoft.ML.StaticPipe.Key&lt;'InnerKey&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Key&lt;'InnerKey&gt;" Usage="Microsoft.ML.Runtime.Data.KeyToValueStaticExtensions.ToValue input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;TInnerKey&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TOuterKey" />
          <TypeParameter Name="TInnerKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;TOuterKey,Microsoft.ML.StaticPipe.Key&lt;TInnerKey&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TOuterKey">To be added.</typeparam>
          <typeparam name="TInnerKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Convert a key column to a column containing the corresponding value.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.KeyToValueStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.Key{``0,Microsoft.ML.StaticPipe.Key{``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToValue&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;TValue&gt; ToValue&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;!!TValue&gt; ToValue&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToValue(Of TKey, TValue) (input As VarVector(Of Key(Of TKey, TValue))) As VarVector(Of TValue)" />
        <MemberSignature Language="F#" Value="static member ToValue : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt;&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;'Value&gt;" Usage="Microsoft.ML.Runtime.Data.KeyToValueStaticExtensions.ToValue input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;TValue&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Convert a key column to a column containing the corresponding value.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.KeyToValueStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToValue&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;TValue&gt; ToValue&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;!!TValue&gt; ToValue&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToValue(Of TKey, TValue) (input As Vector(Of Key(Of TKey, TValue))) As Vector(Of TValue)" />
        <MemberSignature Language="F#" Value="static member ToValue : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;'Value&gt;" Usage="Microsoft.ML.Runtime.Data.KeyToValueStaticExtensions.ToValue input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;TValue&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Convert a key column to a column containing the corresponding value.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.KeyToValueStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToBaggedVector&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBaggedVector&lt;TKey&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBaggedVector&lt;TKey&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`1&lt;!!TKey&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToBaggedVector``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBaggedVector(Of TKey) (input As VarVector(Of Key(Of TKey))) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBaggedVector : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToBaggedVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            In this case then the indicator vectors for all values in the column will be simply added together,
            to produce the final vector with type equal to the key cardinality; so, in all cases, whether vector or scalar,
            the output column will be a vector type of length equal to that cardinality.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.KeyToVectorExtensions" Member="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToBaggedVector``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToBaggedVector&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBaggedVector&lt;TKey&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBaggedVector&lt;TKey&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`1&lt;!!TKey&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToBaggedVector``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBaggedVector(Of TKey) (input As Vector(Of Key(Of TKey))) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBaggedVector : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToBaggedVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            In this case then the indicator vectors for all values in the column will be simply added together,
            to produce the final vector with type equal to the key cardinality; so, in all cases, whether vector or scalar,
            the output column will be a vector type of length equal to that cardinality.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.KeyToVectorExtensions" Member="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToBaggedVector``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToBaggedVector&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBaggedVector&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBaggedVector&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToBaggedVector``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBaggedVector(Of TKey, TValue) (input As VarVector(Of Key(Of TKey, TValue))) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBaggedVector : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToBaggedVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            In this case then the indicator vectors for all values in the column will be simply added together,
            to produce the final vector with type equal to the key cardinality; so, in all cases, whether vector or scalar,
            the output column will be a vector type of length equal to that cardinality.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.KeyToVectorExtensions" Member="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToBaggedVector``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToBaggedVector&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBaggedVector&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBaggedVector&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToBaggedVector``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBaggedVector(Of TKey, TValue) (input As Vector(Of Key(Of TKey, TValue))) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBaggedVector : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToBaggedVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            In this case then the indicator vectors for all values in the column will be simply added together,
            to produce the final vector with type equal to the key cardinality; so, in all cases, whether vector or scalar,
            the output column will be a vector type of length equal to that cardinality.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.KeyToVectorExtensions" Member="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToBaggedVector``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`1" />
      </Targets>
      <Member MemberName="ToVector&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToVector&lt;TKey&gt; (this Microsoft.ML.StaticPipe.Key&lt;TKey&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToVector&lt;TKey&gt;(class Microsoft.ML.StaticPipe.Key`1&lt;!!TKey&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToVector``1(Microsoft.ML.StaticPipe.Key{``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToVector(Of TKey) (input As Key(Of TKey)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToVector : Microsoft.ML.StaticPipe.Key&lt;'Key&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;TKey&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.KeyToVectorExtensions" Member="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToVector``1(Microsoft.ML.StaticPipe.Key{``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToVector&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToVector&lt;TKey&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToVector&lt;TKey&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`1&lt;!!TKey&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToVector``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToVector(Of TKey) (input As VarVector(Of Key(Of TKey))) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToVector : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key&gt;&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            In this case then the indicator vectors for all values in the column will be simply added together,
            to produce the final vector with type equal to the key cardinality; so, in all cases, whether vector or scalar,
            the output column will be a vector type of length equal to that cardinality.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.KeyToVectorExtensions" Member="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToVector``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToVector&lt;TKey&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToVector&lt;TKey&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToVector&lt;TKey&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`1&lt;!!TKey&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToVector``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToVector(Of TKey) (input As Vector(Of Key(Of TKey))) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToVector : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.KeyToVectorExtensions" Member="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToVector``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToVector&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToVector&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToVector&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToVector``2(Microsoft.ML.StaticPipe.Key{``0,``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToVector(Of TKey, TValue) (input As Key(Of TKey, TValue)) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToVector : Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.KeyToVectorExtensions" Member="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToVector``2(Microsoft.ML.StaticPipe.Key{``0,``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToVector&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ToVector&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ToVector&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToVector``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToVector(Of TKey, TValue) (input As VarVector(Of Key(Of TKey, TValue))) As VarVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToVector : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt;&gt; -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            In this case then the indicator vectors for all values in the column will be simply added together,
            to produce the final vector with type equal to the key cardinality; so, in all cases, whether vector or scalar,
            the output column will be a vector type of length equal to that cardinality.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.KeyToVectorExtensions" Member="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToVector``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToVector&lt;TKey,TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToVector&lt;TKey,TValue&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt; input);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToVector&lt;TKey, TValue&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!TKey, !!TValue&gt;&gt; input) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToVector``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToVector(Of TKey, TValue) (input As Vector(Of Key(Of TKey, TValue))) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToVector : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'Key, 'Value&gt;&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToVector input" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TKey" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;TKey,TValue&gt;&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TKey">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.KeyToVectorExtensions" Member="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToVector``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.IEstimator`1" />
      </Targets>
      <Member MemberName="Append&lt;TTrans&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.EstimatorChain&lt;TTrans&gt; Append&lt;TTrans&gt; (this Microsoft.ML.Core.Data.IEstimator&lt;Microsoft.ML.Core.Data.ITransformer&gt; start, Microsoft.ML.Core.Data.IEstimator&lt;TTrans&gt; estimator, Microsoft.ML.Runtime.Data.TransformerScope scope = Microsoft.ML.Runtime.Data.TransformerScope.Everything) where TTrans : class, Microsoft.ML.Core.Data.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.EstimatorChain`1&lt;!!TTrans&gt; Append&lt;class (class Microsoft.ML.Core.Data.ITransformer) TTrans&gt;(class Microsoft.ML.Core.Data.IEstimator`1&lt;class Microsoft.ML.Core.Data.ITransformer&gt; start, class Microsoft.ML.Core.Data.IEstimator`1&lt;!!TTrans&gt; estimator, valuetype Microsoft.ML.Runtime.Data.TransformerScope scope) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.LearningPipelineExtensions.Append``1(Microsoft.ML.Core.Data.IEstimator{Microsoft.ML.Core.Data.ITransformer},Microsoft.ML.Core.Data.IEstimator{``0},Microsoft.ML.Runtime.Data.TransformerScope)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Append(Of TTrans As {Class, ITransformer}) (start As IEstimator(Of ITransformer), estimator As IEstimator(Of TTrans), Optional scope As TransformerScope = Microsoft.ML.Runtime.Data.TransformerScope.Everything) As EstimatorChain(Of TTrans)" />
        <MemberSignature Language="F#" Value="static member Append : Microsoft.ML.Core.Data.IEstimator&lt;Microsoft.ML.Core.Data.ITransformer&gt; * Microsoft.ML.Core.Data.IEstimator&lt;'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; * Microsoft.ML.Runtime.Data.TransformerScope -&gt; Microsoft.ML.Runtime.Data.EstimatorChain&lt;'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)" Usage="Microsoft.ML.Runtime.Data.LearningPipelineExtensions.Append (start, estimator, scope)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.EstimatorChain&lt;TTrans&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TTrans">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="start" Type="Microsoft.ML.Core.Data.IEstimator&lt;Microsoft.ML.Core.Data.ITransformer&gt;" RefType="this" />
          <Parameter Name="estimator" Type="Microsoft.ML.Core.Data.IEstimator&lt;TTrans&gt;" />
          <Parameter Name="scope" Type="Microsoft.ML.Runtime.Data.TransformerScope" />
        </Parameters>
        <Docs>
          <typeparam name="TTrans">To be added.</typeparam>
          <param name="start">To be added.</param>
          <param name="estimator">To be added.</param>
          <param name="scope">To be added.</param>
          <summary>
            Create an estimator chain by appending an estimator to an estimator.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.LearningPipelineExtensions" Member="M:Microsoft.ML.Runtime.Data.LearningPipelineExtensions.Append``1(Microsoft.ML.Core.Data.IEstimator{Microsoft.ML.Core.Data.ITransformer},Microsoft.ML.Core.Data.IEstimator{``0},Microsoft.ML.Runtime.Data.TransformerScope)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.ITransformer" />
      </Targets>
      <Member MemberName="Append&lt;TTrans&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.TransformerChain&lt;TTrans&gt; Append&lt;TTrans&gt; (this Microsoft.ML.Core.Data.ITransformer start, TTrans transformer) where TTrans : class, Microsoft.ML.Core.Data.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.TransformerChain`1&lt;!!TTrans&gt; Append&lt;class (class Microsoft.ML.Core.Data.ITransformer) TTrans&gt;(class Microsoft.ML.Core.Data.ITransformer start, !!TTrans transformer) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.LearningPipelineExtensions.Append``1(Microsoft.ML.Core.Data.ITransformer,``0)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Append(Of TTrans As {Class, ITransformer}) (start As ITransformer, transformer As TTrans) As TransformerChain(Of TTrans)" />
        <MemberSignature Language="F#" Value="static member Append : Microsoft.ML.Core.Data.ITransformer * 'rans -&gt; Microsoft.ML.Runtime.Data.TransformerChain&lt;'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)" Usage="Microsoft.ML.Runtime.Data.LearningPipelineExtensions.Append (start, transformer)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.TransformerChain&lt;TTrans&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TTrans">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="start" Type="Microsoft.ML.Core.Data.ITransformer" RefType="this" />
          <Parameter Name="transformer" Type="TTrans" />
        </Parameters>
        <Docs>
          <typeparam name="TTrans">To be added.</typeparam>
          <param name="start">To be added.</param>
          <param name="transformer">To be added.</param>
          <summary>
            Create a transformer chain by appending a transformer to a transformer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.LearningPipelineExtensions" Member="M:Microsoft.ML.Runtime.Data.LearningPipelineExtensions.Append``1(Microsoft.ML.Core.Data.ITransformer,``0)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.IDataReader`1" />
      </Targets>
      <Member MemberName="Append&lt;TSource,TTrans&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.CompositeDataReader&lt;TSource,TTrans&gt; Append&lt;TSource,TTrans&gt; (this Microsoft.ML.Core.Data.IDataReader&lt;TSource&gt; reader, TTrans transformer) where TTrans : class, Microsoft.ML.Core.Data.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.CompositeDataReader`2&lt;!!TSource, !!TTrans&gt; Append&lt;TSource, class (class Microsoft.ML.Core.Data.ITransformer) TTrans&gt;(class Microsoft.ML.Core.Data.IDataReader`1&lt;!!TSource&gt; reader, !!TTrans transformer) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.LearningPipelineExtensions.Append``2(Microsoft.ML.Core.Data.IDataReader{``0},``1)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Append(Of TSource, TTrans) (reader As IDataReader(Of TSource), transformer As TTrans) As CompositeDataReader(Of TSource, TTrans)" />
        <MemberSignature Language="F#" Value="static member Append : Microsoft.ML.Core.Data.IDataReader&lt;'Source&gt; * 'rans -&gt; Microsoft.ML.Runtime.Data.CompositeDataReader&lt;'Source, 'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)" Usage="Microsoft.ML.Runtime.Data.LearningPipelineExtensions.Append (reader, transformer)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.CompositeDataReader&lt;TSource,TTrans&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSource" />
          <TypeParameter Name="TTrans">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="reader" Type="Microsoft.ML.Core.Data.IDataReader&lt;TSource&gt;" RefType="this" />
          <Parameter Name="transformer" Type="TTrans" />
        </Parameters>
        <Docs>
          <typeparam name="TSource">To be added.</typeparam>
          <typeparam name="TTrans">To be added.</typeparam>
          <param name="reader">To be added.</param>
          <param name="transformer">To be added.</param>
          <summary>
            Create a composite reader by appending a transformer to a data reader.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.LearningPipelineExtensions" Member="M:Microsoft.ML.Runtime.Data.LearningPipelineExtensions.Append``2(Microsoft.ML.Core.Data.IDataReader{``0},``1)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.IDataReader`1" />
      </Targets>
      <Member MemberName="Append&lt;TSource,TTrans&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.CompositeReaderEstimator&lt;TSource,TTrans&gt; Append&lt;TSource,TTrans&gt; (this Microsoft.ML.Core.Data.IDataReader&lt;TSource&gt; start, Microsoft.ML.Core.Data.IEstimator&lt;TTrans&gt; estimator) where TTrans : class, Microsoft.ML.Core.Data.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.CompositeReaderEstimator`2&lt;!!TSource, !!TTrans&gt; Append&lt;TSource, class (class Microsoft.ML.Core.Data.ITransformer) TTrans&gt;(class Microsoft.ML.Core.Data.IDataReader`1&lt;!!TSource&gt; start, class Microsoft.ML.Core.Data.IEstimator`1&lt;!!TTrans&gt; estimator) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.LearningPipelineExtensions.Append``2(Microsoft.ML.Core.Data.IDataReader{``0},Microsoft.ML.Core.Data.IEstimator{``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Append(Of TSource, TTrans) (start As IDataReader(Of TSource), estimator As IEstimator(Of TTrans)) As CompositeReaderEstimator(Of TSource, TTrans)" />
        <MemberSignature Language="F#" Value="static member Append : Microsoft.ML.Core.Data.IDataReader&lt;'Source&gt; * Microsoft.ML.Core.Data.IEstimator&lt;'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; -&gt; Microsoft.ML.Runtime.Data.CompositeReaderEstimator&lt;'Source, 'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)" Usage="Microsoft.ML.Runtime.Data.LearningPipelineExtensions.Append (start, estimator)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.CompositeReaderEstimator&lt;TSource,TTrans&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSource" />
          <TypeParameter Name="TTrans">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="start" Type="Microsoft.ML.Core.Data.IDataReader&lt;TSource&gt;" RefType="this" />
          <Parameter Name="estimator" Type="Microsoft.ML.Core.Data.IEstimator&lt;TTrans&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TSource">To be added.</typeparam>
          <typeparam name="TTrans">To be added.</typeparam>
          <param name="start">To be added.</param>
          <param name="estimator">To be added.</param>
          <summary>
            Create a composite reader estimator by appending an estimator to a reader.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.LearningPipelineExtensions" Member="M:Microsoft.ML.Runtime.Data.LearningPipelineExtensions.Append``2(Microsoft.ML.Core.Data.IDataReader{``0},Microsoft.ML.Core.Data.IEstimator{``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.IDataReaderEstimator`2" />
      </Targets>
      <Member MemberName="Append&lt;TSource,TTrans&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.CompositeReaderEstimator&lt;TSource,TTrans&gt; Append&lt;TSource,TTrans&gt; (this Microsoft.ML.Core.Data.IDataReaderEstimator&lt;TSource,Microsoft.ML.Core.Data.IDataReader&lt;TSource&gt;&gt; start, Microsoft.ML.Core.Data.IEstimator&lt;TTrans&gt; estimator) where TTrans : class, Microsoft.ML.Core.Data.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.CompositeReaderEstimator`2&lt;!!TSource, !!TTrans&gt; Append&lt;TSource, class (class Microsoft.ML.Core.Data.ITransformer) TTrans&gt;(class Microsoft.ML.Core.Data.IDataReaderEstimator`2&lt;!!TSource, class Microsoft.ML.Core.Data.IDataReader`1&lt;!!TSource&gt;&gt; start, class Microsoft.ML.Core.Data.IEstimator`1&lt;!!TTrans&gt; estimator) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.LearningPipelineExtensions.Append``2(Microsoft.ML.Core.Data.IDataReaderEstimator{``0,Microsoft.ML.Core.Data.IDataReader{``0}},Microsoft.ML.Core.Data.IEstimator{``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Append(Of TSource, TTrans) (start As IDataReaderEstimator(Of TSource, IDataReader(Of TSource)), estimator As IEstimator(Of TTrans)) As CompositeReaderEstimator(Of TSource, TTrans)" />
        <MemberSignature Language="F#" Value="static member Append : Microsoft.ML.Core.Data.IDataReaderEstimator&lt;'Source, Microsoft.ML.Core.Data.IDataReader&lt;'Source&gt;&gt; * Microsoft.ML.Core.Data.IEstimator&lt;'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; -&gt; Microsoft.ML.Runtime.Data.CompositeReaderEstimator&lt;'Source, 'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)" Usage="Microsoft.ML.Runtime.Data.LearningPipelineExtensions.Append (start, estimator)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.CompositeReaderEstimator&lt;TSource,TTrans&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSource" />
          <TypeParameter Name="TTrans">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="start" Type="Microsoft.ML.Core.Data.IDataReaderEstimator&lt;TSource,Microsoft.ML.Core.Data.IDataReader&lt;TSource&gt;&gt;" RefType="this" />
          <Parameter Name="estimator" Type="Microsoft.ML.Core.Data.IEstimator&lt;TTrans&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TSource">To be added.</typeparam>
          <typeparam name="TTrans">To be added.</typeparam>
          <param name="start">To be added.</param>
          <param name="estimator">To be added.</param>
          <summary>
            Create a composite reader estimator by appending an estimator to a reader estimator.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.LearningPipelineExtensions" Member="M:Microsoft.ML.Runtime.Data.LearningPipelineExtensions.Append``2(Microsoft.ML.Core.Data.IDataReaderEstimator{``0,Microsoft.ML.Core.Data.IDataReader{``0}},Microsoft.ML.Core.Data.IEstimator{``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.IEstimator`1" />
      </Targets>
      <Member MemberName="WithOnFitDelegate&lt;TTransformer&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Core.Data.IEstimator&lt;TTransformer&gt; WithOnFitDelegate&lt;TTransformer&gt; (this Microsoft.ML.Core.Data.IEstimator&lt;TTransformer&gt; estimator, Action&lt;TTransformer&gt; onFit) where TTransformer : class, Microsoft.ML.Core.Data.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Core.Data.IEstimator`1&lt;!!TTransformer&gt; WithOnFitDelegate&lt;class (class Microsoft.ML.Core.Data.ITransformer) TTransformer&gt;(class Microsoft.ML.Core.Data.IEstimator`1&lt;!!TTransformer&gt; estimator, class System.Action`1&lt;!!TTransformer&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.LearningPipelineExtensions.WithOnFitDelegate``1(Microsoft.ML.Core.Data.IEstimator{``0},System.Action{``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithOnFitDelegate(Of TTransformer As {Class, ITransformer}) (estimator As IEstimator(Of TTransformer), onFit As Action(Of TTransformer)) As IEstimator(Of TTransformer)" />
        <MemberSignature Language="F#" Value="static member WithOnFitDelegate : Microsoft.ML.Core.Data.IEstimator&lt;'ransformer (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; * Action&lt;'ransformer (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; -&gt; Microsoft.ML.Core.Data.IEstimator&lt;'ransformer (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.Core.Data.ITransformer)" Usage="Microsoft.ML.Runtime.Data.LearningPipelineExtensions.WithOnFitDelegate (estimator, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Core.Data.IEstimator&lt;TTransformer&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TTransformer">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="estimator" Type="Microsoft.ML.Core.Data.IEstimator&lt;TTransformer&gt;" RefType="this" />
          <Parameter Name="onFit" Type="System.Action&lt;TTransformer&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TTransformer">The type of <see cref="T:Microsoft.ML.Core.Data.ITransformer" /> returned by <paramref name="estimator" /></typeparam>
          <param name="estimator">The estimator to wrap</param>
          <param name="onFit">The delegate that is called with the resulting <typeparamref name="TTransformer" /> instances once
            <see cref="M:Microsoft.ML.Core.Data.IEstimator`1.Fit(Microsoft.ML.Runtime.Data.IDataView)" /> is called. Because <see cref="M:Microsoft.ML.Core.Data.IEstimator`1.Fit(Microsoft.ML.Runtime.Data.IDataView)" />
            may be called multiple times, this delegate may also be called multiple times.</param>
          <summary>
            Given an estimator, return a wrapping object that will call a delegate once <see cref="M:Microsoft.ML.Core.Data.IEstimator`1.Fit(Microsoft.ML.Runtime.Data.IDataView)" />
            is called. It is often important for an estimator to return information about what was fit, which is why the
            <see cref="M:Microsoft.ML.Core.Data.IEstimator`1.Fit(Microsoft.ML.Runtime.Data.IDataView)" /> method returns a specifically typed object, rather than just a general
            <see cref="T:Microsoft.ML.Core.Data.ITransformer" />. However, at the same time, <see cref="T:Microsoft.ML.Core.Data.IEstimator`1" /> are often formed into pipelines
            with many objects, so we may need to build a chain of estimators via <see cref="T:Microsoft.ML.Runtime.Data.EstimatorChain`1" /> where the
            estimator for which we want to get the transformer is buried somewhere in this chain. For that scenario, we can through this
            method attach a delegate that will be called once fit is called.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.LearningPipelineExtensions" Member="M:Microsoft.ML.Runtime.Data.LearningPipelineExtensions.WithOnFitDelegate``1(Microsoft.ML.Core.Data.IEstimator{``0},System.Action{``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IExceptionContext" />
      </Targets>
      <Member MemberName="ExceptGetMetadata">
        <MemberSignature Language="C#" Value="public static Exception ExceptGetMetadata (this Microsoft.ML.Runtime.IExceptionContext ctx);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception ExceptGetMetadata(class Microsoft.ML.Runtime.IExceptionContext ctx) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.MetadataUtils.ExceptGetMetadata(Microsoft.ML.Runtime.IExceptionContext)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ExceptGetMetadata (ctx As IExceptionContext) As Exception" />
        <MemberSignature Language="F#" Value="static member ExceptGetMetadata : Microsoft.ML.Runtime.IExceptionContext -&gt; Exception" Usage="Microsoft.ML.Runtime.Data.MetadataUtils.ExceptGetMetadata ctx" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Exception</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" RefType="this" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <summary>
            Returns a standard exception for responding to an invalid call to GetMetadata.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.MetadataUtils" Member="M:Microsoft.ML.Runtime.Data.MetadataUtils.ExceptGetMetadata(Microsoft.ML.Runtime.IExceptionContext)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.ISchema" />
      </Targets>
      <Member MemberName="GetColumnSet">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;int&gt; GetColumnSet (this Microsoft.ML.Runtime.Data.ISchema schema, string metadataKind, string value);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;int32&gt; GetColumnSet(class Microsoft.ML.Runtime.Data.ISchema schema, string metadataKind, string value) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.MetadataUtils.GetColumnSet(Microsoft.ML.Runtime.Data.ISchema,System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Iterator Function GetColumnSet (schema As ISchema, metadataKind As String, value As String) As IEnumerable(Of Integer)" />
        <MemberSignature Language="F#" Value="static member GetColumnSet : Microsoft.ML.Runtime.Data.ISchema * string * string -&gt; seq&lt;int&gt;" Usage="Microsoft.ML.Runtime.Data.MetadataUtils.GetColumnSet (schema, metadataKind, value)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Int32&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="schema" Type="Microsoft.ML.Runtime.Data.ISchema" RefType="this" />
          <Parameter Name="metadataKind" Type="System.String" />
          <Parameter Name="value" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="schema">To be added.</param>
          <param name="metadataKind">To be added.</param>
          <param name="value">To be added.</param>
          <summary>
            Returns the set of column ids which match the value of specified metadata kind.
            The metadata type should be of type text.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.MetadataUtils" Member="M:Microsoft.ML.Runtime.Data.MetadataUtils.GetColumnSet(Microsoft.ML.Runtime.Data.ISchema,System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.ISchema" />
      </Targets>
      <Member MemberName="GetColumnSet">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;int&gt; GetColumnSet (this Microsoft.ML.Runtime.Data.ISchema schema, string metadataKind, uint value);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;int32&gt; GetColumnSet(class Microsoft.ML.Runtime.Data.ISchema schema, string metadataKind, unsigned int32 value) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.MetadataUtils.GetColumnSet(Microsoft.ML.Runtime.Data.ISchema,System.String,System.UInt32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Iterator Function GetColumnSet (schema As ISchema, metadataKind As String, value As UInteger) As IEnumerable(Of Integer)" />
        <MemberSignature Language="F#" Value="static member GetColumnSet : Microsoft.ML.Runtime.Data.ISchema * string * uint32 -&gt; seq&lt;int&gt;" Usage="Microsoft.ML.Runtime.Data.MetadataUtils.GetColumnSet (schema, metadataKind, value)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Int32&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="schema" Type="Microsoft.ML.Runtime.Data.ISchema" RefType="this" />
          <Parameter Name="metadataKind" Type="System.String" />
          <Parameter Name="value" Type="System.UInt32" />
        </Parameters>
        <Docs>
          <param name="schema">To be added.</param>
          <param name="metadataKind">To be added.</param>
          <param name="value">To be added.</param>
          <summary>
            Returns the set of column ids which match the value of specified metadata kind.
            The metadata type should be a KeyType with raw type U4.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.MetadataUtils" Member="M:Microsoft.ML.Runtime.Data.MetadataUtils.GetColumnSet(Microsoft.ML.Runtime.Data.ISchema,System.String,System.UInt32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.ISchema" />
      </Targets>
      <Member MemberName="GetMaxMetadataKind">
        <MemberSignature Language="C#" Value="public static uint GetMaxMetadataKind (this Microsoft.ML.Runtime.Data.ISchema schema, out int colMax, string metadataKind, Func&lt;Microsoft.ML.Runtime.Data.ISchema,int,bool&gt; filterFunc = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 GetMaxMetadataKind(class Microsoft.ML.Runtime.Data.ISchema schema, [out] int32&amp; colMax, string metadataKind, class System.Func`3&lt;class Microsoft.ML.Runtime.Data.ISchema, int32, bool&gt; filterFunc) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.MetadataUtils.GetMaxMetadataKind(Microsoft.ML.Runtime.Data.ISchema,System.Int32@,System.String,System.Func{Microsoft.ML.Runtime.Data.ISchema,System.Int32,System.Boolean})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetMaxMetadataKind (schema As ISchema, ByRef colMax As Integer, metadataKind As String, Optional filterFunc As Func(Of ISchema, Integer, Boolean) = null) As UInteger" />
        <MemberSignature Language="F#" Value="static member GetMaxMetadataKind : Microsoft.ML.Runtime.Data.ISchema *  * string * Func&lt;Microsoft.ML.Runtime.Data.ISchema, int, bool&gt; -&gt; uint32" Usage="Microsoft.ML.Runtime.Data.MetadataUtils.GetMaxMetadataKind (schema, colMax, metadataKind, filterFunc)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.UInt32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="schema" Type="Microsoft.ML.Runtime.Data.ISchema" RefType="this" />
          <Parameter Name="colMax" Type="System.Int32" RefType="out" />
          <Parameter Name="metadataKind" Type="System.String" />
          <Parameter Name="filterFunc" Type="System.Func&lt;Microsoft.ML.Runtime.Data.ISchema,System.Int32,System.Boolean&gt;" />
        </Parameters>
        <Docs>
          <param name="schema">To be added.</param>
          <param name="colMax">To be added.</param>
          <param name="metadataKind">To be added.</param>
          <param name="filterFunc">To be added.</param>
          <summary>
            Returns the max value for the specified metadata kind.
            The metadata type should be a KeyType with raw type U4.
            colMax will be set to the first column that has the max value for the specified metadata.
            If no column has the specified metadata, colMax is set to -1 and the method returns zero.
            The filter function is called for each column, passing in the schema and the column index, and returns
            true if the column should be considered, false if the column should be skipped.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.MetadataUtils" Member="M:Microsoft.ML.Runtime.Data.MetadataUtils.GetMaxMetadataKind(Microsoft.ML.Runtime.Data.ISchema,System.Int32@,System.String,System.Func{Microsoft.ML.Runtime.Data.ISchema,System.Int32,System.Boolean})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.ColumnType" />
      </Targets>
      <Member MemberName="GetPair">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.KeyValuePair&lt;string,Microsoft.ML.Runtime.Data.ColumnType&gt; GetPair (this Microsoft.ML.Runtime.Data.ColumnType type, string kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class Microsoft.ML.Runtime.Data.ColumnType&gt; GetPair(class Microsoft.ML.Runtime.Data.ColumnType type, string kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.MetadataUtils.GetPair(Microsoft.ML.Runtime.Data.ColumnType,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetPair (type As ColumnType, kind As String) As KeyValuePair(Of String, ColumnType)" />
        <MemberSignature Language="F#" Value="static member GetPair : Microsoft.ML.Runtime.Data.ColumnType * string -&gt; System.Collections.Generic.KeyValuePair&lt;string, Microsoft.ML.Runtime.Data.ColumnType&gt;" Usage="Microsoft.ML.Runtime.Data.MetadataUtils.GetPair (type, kind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.KeyValuePair&lt;System.String,Microsoft.ML.Runtime.Data.ColumnType&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="type" Type="Microsoft.ML.Runtime.Data.ColumnType" RefType="this" />
          <Parameter Name="kind" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="type">To be added.</param>
          <param name="kind">To be added.</param>
          <summary>
            Given a type and metadata kind string, returns a key-value pair. This is useful when
            implementing GetMetadataTypes(col).
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.MetadataUtils" Member="M:Microsoft.ML.Runtime.Data.MetadataUtils.GetPair(Microsoft.ML.Runtime.Data.ColumnType,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.ISchema" />
      </Targets>
      <Member MemberName="HasKeyNames">
        <MemberSignature Language="C#" Value="public static bool HasKeyNames (this Microsoft.ML.Runtime.Data.ISchema schema, int col, int keyCount);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasKeyNames(class Microsoft.ML.Runtime.Data.ISchema schema, int32 col, int32 keyCount) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.MetadataUtils.HasKeyNames(Microsoft.ML.Runtime.Data.ISchema,System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function HasKeyNames (schema As ISchema, col As Integer, keyCount As Integer) As Boolean" />
        <MemberSignature Language="F#" Value="static member HasKeyNames : Microsoft.ML.Runtime.Data.ISchema * int * int -&gt; bool" Usage="Microsoft.ML.Runtime.Data.MetadataUtils.HasKeyNames (schema, col, keyCount)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="schema" Type="Microsoft.ML.Runtime.Data.ISchema" RefType="this" />
          <Parameter Name="col" Type="System.Int32" />
          <Parameter Name="keyCount" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="schema">To be added.</param>
          <param name="col">To be added.</param>
          <param name="keyCount">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.MetadataUtils" Member="M:Microsoft.ML.Runtime.Data.MetadataUtils.HasKeyNames(Microsoft.ML.Runtime.Data.ISchema,System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.SchemaShape.Column" />
      </Targets>
      <Member MemberName="HasSlotNames">
        <MemberSignature Language="C#" Value="public static bool HasSlotNames (this Microsoft.ML.Core.Data.SchemaShape.Column col);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasSlotNames(class Microsoft.ML.Core.Data.SchemaShape/Column col) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.MetadataUtils.HasSlotNames(Microsoft.ML.Core.Data.SchemaShape.Column)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function HasSlotNames (col As SchemaShape.Column) As Boolean" />
        <MemberSignature Language="F#" Value="static member HasSlotNames : Microsoft.ML.Core.Data.SchemaShape.Column -&gt; bool" Usage="Microsoft.ML.Runtime.Data.MetadataUtils.HasSlotNames col" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="col" Type="Microsoft.ML.Core.Data.SchemaShape+Column" RefType="this" />
        </Parameters>
        <Docs>
          <param name="col">The schema shape column to query</param>
          <summary>
            Returns whether a column has the <see cref="F:Microsoft.ML.Runtime.Data.MetadataUtils.Kinds.SlotNames" /> metadata indicated by
            the schema shape.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.MetadataUtils" Member="M:Microsoft.ML.Runtime.Data.MetadataUtils.HasSlotNames(Microsoft.ML.Core.Data.SchemaShape.Column)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.ISchema" />
      </Targets>
      <Member MemberName="HasSlotNames">
        <MemberSignature Language="C#" Value="public static bool HasSlotNames (this Microsoft.ML.Runtime.Data.ISchema schema, int col, int vectorSize);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasSlotNames(class Microsoft.ML.Runtime.Data.ISchema schema, int32 col, int32 vectorSize) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.MetadataUtils.HasSlotNames(Microsoft.ML.Runtime.Data.ISchema,System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function HasSlotNames (schema As ISchema, col As Integer, vectorSize As Integer) As Boolean" />
        <MemberSignature Language="F#" Value="static member HasSlotNames : Microsoft.ML.Runtime.Data.ISchema * int * int -&gt; bool" Usage="Microsoft.ML.Runtime.Data.MetadataUtils.HasSlotNames (schema, col, vectorSize)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="schema" Type="Microsoft.ML.Runtime.Data.ISchema" RefType="this" />
          <Parameter Name="col" Type="System.Int32" />
          <Parameter Name="vectorSize" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="schema">To be added.</param>
          <param name="col">To be added.</param>
          <param name="vectorSize">To be added.</param>
          <summary>
            Returns <c>true</c> if the specified column:
             * is a vector of length N (including 0)
             * has a SlotNames metadata
             * metadata type is VBuffer&lt;ReadOnlyMemory&lt;char&gt;&gt; of length N
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.MetadataUtils" Member="M:Microsoft.ML.Runtime.Data.MetadataUtils.HasSlotNames(Microsoft.ML.Runtime.Data.ISchema,System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.ISchema" />
      </Targets>
      <Member MemberName="IsHidden">
        <MemberSignature Language="C#" Value="public static bool IsHidden (this Microsoft.ML.Runtime.Data.ISchema schema, int col);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHidden(class Microsoft.ML.Runtime.Data.ISchema schema, int32 col) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.MetadataUtils.IsHidden(Microsoft.ML.Runtime.Data.ISchema,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsHidden (schema As ISchema, col As Integer) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsHidden : Microsoft.ML.Runtime.Data.ISchema * int -&gt; bool" Usage="Microsoft.ML.Runtime.Data.MetadataUtils.IsHidden (schema, col)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="schema" Type="Microsoft.ML.Runtime.Data.ISchema" RefType="this" />
          <Parameter Name="col" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="schema">To be added.</param>
          <param name="col">To be added.</param>
          <summary>
            Return whether the given column index is hidden in the given schema.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.MetadataUtils" Member="M:Microsoft.ML.Runtime.Data.MetadataUtils.IsHidden(Microsoft.ML.Runtime.Data.ISchema,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.SchemaShape.Column" />
      </Targets>
      <Member MemberName="IsNormalized">
        <MemberSignature Language="C#" Value="public static bool IsNormalized (this Microsoft.ML.Core.Data.SchemaShape.Column col);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormalized(class Microsoft.ML.Core.Data.SchemaShape/Column col) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.MetadataUtils.IsNormalized(Microsoft.ML.Core.Data.SchemaShape.Column)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsNormalized (col As SchemaShape.Column) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsNormalized : Microsoft.ML.Core.Data.SchemaShape.Column -&gt; bool" Usage="Microsoft.ML.Runtime.Data.MetadataUtils.IsNormalized col" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="col" Type="Microsoft.ML.Core.Data.SchemaShape+Column" RefType="this" />
        </Parameters>
        <Docs>
          <param name="col">The schema shape column to query</param>
          <summary>
            Returns whether a column has the <see cref="F:Microsoft.ML.Runtime.Data.MetadataUtils.Kinds.IsNormalized" /> metadata indicated by
            the schema shape.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.MetadataUtils" Member="M:Microsoft.ML.Runtime.Data.MetadataUtils.IsNormalized(Microsoft.ML.Core.Data.SchemaShape.Column)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.ISchema" />
      </Targets>
      <Member MemberName="IsNormalized">
        <MemberSignature Language="C#" Value="public static bool IsNormalized (this Microsoft.ML.Runtime.Data.ISchema schema, int col);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormalized(class Microsoft.ML.Runtime.Data.ISchema schema, int32 col) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.MetadataUtils.IsNormalized(Microsoft.ML.Runtime.Data.ISchema,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsNormalized (schema As ISchema, col As Integer) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsNormalized : Microsoft.ML.Runtime.Data.ISchema * int -&gt; bool" Usage="Microsoft.ML.Runtime.Data.MetadataUtils.IsNormalized (schema, col)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="schema" Type="Microsoft.ML.Runtime.Data.ISchema" RefType="this" />
          <Parameter Name="col" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="schema">The schema to query</param>
          <param name="col">Which column in the schema to query</param>
          <summary>
            Returns whether a column has the <see cref="F:Microsoft.ML.Runtime.Data.MetadataUtils.Kinds.IsNormalized" /> metadata set to true.
            That metadata should be set when the data has undergone transforms that would render it
            "normalized."
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.MetadataUtils" Member="M:Microsoft.ML.Runtime.Data.MetadataUtils.IsNormalized(Microsoft.ML.Runtime.Data.ISchema,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.MetadataUtils.MetadataGetter`1" />
      </Targets>
      <Member MemberName="Marshal&lt;THave,TNeed&gt;">
        <MemberSignature Language="C#" Value="public static void Marshal&lt;THave,TNeed&gt; (this Microsoft.ML.Runtime.Data.MetadataUtils.MetadataGetter&lt;THave&gt; getter, int col, ref TNeed dst);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Marshal&lt;THave, TNeed&gt;(class Microsoft.ML.Runtime.Data.MetadataUtils/MetadataGetter`1&lt;!!THave&gt; getter, int32 col, !!TNeed&amp; dst) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.MetadataUtils.Marshal``2(Microsoft.ML.Runtime.Data.MetadataUtils.MetadataGetter{``0},System.Int32,``1@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Marshal(Of THave, TNeed) (getter As MetadataUtils.MetadataGetter(Of THave), col As Integer, ByRef dst As TNeed)" />
        <MemberSignature Language="F#" Value="static member Marshal : Microsoft.ML.Runtime.Data.MetadataUtils.MetadataGetter&lt;'Have&gt; * int *  -&gt; unit" Usage="Microsoft.ML.Runtime.Data.MetadataUtils.Marshal (getter, col, dst)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="THave" />
          <TypeParameter Name="TNeed" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="getter" Type="Microsoft.ML.Runtime.Data.MetadataUtils+MetadataGetter&lt;THave&gt;" RefType="this" />
          <Parameter Name="col" Type="System.Int32" />
          <Parameter Name="dst" Type="TNeed" RefType="ref" />
        </Parameters>
        <Docs>
          <typeparam name="THave">To be added.</typeparam>
          <typeparam name="TNeed">To be added.</typeparam>
          <param name="getter">To be added.</param>
          <param name="col">To be added.</param>
          <param name="dst">To be added.</param>
          <summary>
            Helper to marshal a call to GetMetadata{TValue} to a specific type.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.MetadataUtils" Member="M:Microsoft.ML.Runtime.Data.MetadataUtils.Marshal``2(Microsoft.ML.Runtime.Data.MetadataUtils.MetadataGetter{``0},System.Int32,``1@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IEnumerable`1" />
      </Targets>
      <Member MemberName="Prepend&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; Prepend&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; tail, params T[] head);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; Prepend&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; tail, !!T[] head) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.MetadataUtils.Prepend``1(System.Collections.Generic.IEnumerable{``0},``0[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Prepend(Of T) (tail As IEnumerable(Of T), ParamArray head As T()) As IEnumerable(Of T)" />
        <MemberSignature Language="F#" Value="static member Prepend : seq&lt;'T&gt; * 'T[] -&gt; seq&lt;'T&gt;" Usage="Microsoft.ML.Runtime.Data.MetadataUtils.Prepend (tail, head)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="tail" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
          <Parameter Name="head" Type="T[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="tail">To be added.</param>
          <param name="head">To be added.</param>
          <summary>
            Prepends a params array to an enumerable. Useful when implementing GetMetadataTypes.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.MetadataUtils" Member="M:Microsoft.ML.Runtime.Data.MetadataUtils.Prepend``1(System.Collections.Generic.IEnumerable{``0},``0[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.ISchema" />
      </Targets>
      <Member MemberName="TryGetMetadata&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static bool TryGetMetadata&lt;T&gt; (this Microsoft.ML.Runtime.Data.ISchema schema, Microsoft.ML.Runtime.Data.PrimitiveType type, string kind, int col, ref T value);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetMetadata&lt;T&gt;(class Microsoft.ML.Runtime.Data.ISchema schema, class Microsoft.ML.Runtime.Data.PrimitiveType type, string kind, int32 col, !!T&amp; value) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.MetadataUtils.TryGetMetadata``1(Microsoft.ML.Runtime.Data.ISchema,Microsoft.ML.Runtime.Data.PrimitiveType,System.String,System.Int32,``0@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TryGetMetadata(Of T) (schema As ISchema, type As PrimitiveType, kind As String, col As Integer, ByRef value As T) As Boolean" />
        <MemberSignature Language="F#" Value="static member TryGetMetadata : Microsoft.ML.Runtime.Data.ISchema * Microsoft.ML.Runtime.Data.PrimitiveType * string * int *  -&gt; bool" Usage="Microsoft.ML.Runtime.Data.MetadataUtils.TryGetMetadata (schema, type, kind, col, value)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="schema" Type="Microsoft.ML.Runtime.Data.ISchema" RefType="this" />
          <Parameter Name="type" Type="Microsoft.ML.Runtime.Data.PrimitiveType" />
          <Parameter Name="kind" Type="System.String" />
          <Parameter Name="col" Type="System.Int32" />
          <Parameter Name="value" Type="T" RefType="ref" />
        </Parameters>
        <Docs>
          <typeparam name="T">The raw type of the metadata, should match the PrimitiveType type</typeparam>
          <param name="schema">The schema</param>
          <param name="type">The type of the metadata</param>
          <param name="kind">The metadata kind</param>
          <param name="col">The column</param>
          <param name="value">The value to return, if successful</param>
          <summary>
            Tries to get the metadata kind of the specified type for a column.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.MetadataUtils" Member="M:Microsoft.ML.Runtime.Data.MetadataUtils.TryGetMetadata``1(Microsoft.ML.Runtime.Data.ISchema,Microsoft.ML.Runtime.Data.PrimitiveType,System.String,System.Int32,``0@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="NAReplace">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;double&gt; NAReplace (this Microsoft.ML.StaticPipe.VarVector&lt;double&gt; input, Microsoft.ML.Runtime.Data.NAReplaceTransform.ColumnInfo.ReplacementMode replacementMode = Microsoft.ML.Runtime.Data.NAReplaceTransform+ColumnInfo+ReplacementMode.DefaultValue);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float64&gt; NAReplace(class Microsoft.ML.StaticPipe.VarVector`1&lt;float64&gt; input, valuetype Microsoft.ML.Runtime.Data.NAReplaceTransform/ColumnInfo/ReplacementMode replacementMode) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.NAReplaceExtensions.NAReplace(Microsoft.ML.StaticPipe.VarVector{System.Double},Microsoft.ML.Runtime.Data.NAReplaceTransform.ColumnInfo.ReplacementMode)" />
        <MemberSignature Language="F#" Value="static member NAReplace : Microsoft.ML.StaticPipe.VarVector&lt;double&gt; * Microsoft.ML.Runtime.Data.NAReplaceTransform.ColumnInfo.ReplacementMode -&gt; Microsoft.ML.StaticPipe.VarVector&lt;double&gt;" Usage="Microsoft.ML.Runtime.Data.NAReplaceExtensions.NAReplace (input, replacementMode)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="replacementMode" Type="Microsoft.ML.Runtime.Data.NAReplaceTransform+ColumnInfo+ReplacementMode" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="replacementMode">How NaN should be replaced</param>
          <summary>
            Scan through all rows and replace NaN values according to replacement strategy.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.NAReplaceExtensions" Member="M:Microsoft.ML.Runtime.Data.NAReplaceExtensions.NAReplace(Microsoft.ML.StaticPipe.VarVector{System.Double},Microsoft.ML.Runtime.Data.NAReplaceTransform.ColumnInfo.ReplacementMode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ReplaceNaNValues">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;double&gt; ReplaceNaNValues (this Microsoft.ML.StaticPipe.Scalar&lt;double&gt; input, Microsoft.ML.Runtime.Data.NAReplaceTransform.ColumnInfo.ReplacementMode replacementMode = Microsoft.ML.Runtime.Data.NAReplaceTransform+ColumnInfo+ReplacementMode.DefaultValue);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float64&gt; ReplaceNaNValues(class Microsoft.ML.StaticPipe.Scalar`1&lt;float64&gt; input, valuetype Microsoft.ML.Runtime.Data.NAReplaceTransform/ColumnInfo/ReplacementMode replacementMode) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.NAReplaceExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.Scalar{System.Double},Microsoft.ML.Runtime.Data.NAReplaceTransform.ColumnInfo.ReplacementMode)" />
        <MemberSignature Language="F#" Value="static member ReplaceNaNValues : Microsoft.ML.StaticPipe.Scalar&lt;double&gt; * Microsoft.ML.Runtime.Data.NAReplaceTransform.ColumnInfo.ReplacementMode -&gt; Microsoft.ML.StaticPipe.Scalar&lt;double&gt;" Usage="Microsoft.ML.Runtime.Data.NAReplaceExtensions.ReplaceNaNValues (input, replacementMode)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="replacementMode" Type="Microsoft.ML.Runtime.Data.NAReplaceTransform+ColumnInfo+ReplacementMode" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="replacementMode">How NaN should be replaced</param>
          <summary>
            Scan through all rows and replace NaN values according to replacement strategy.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.NAReplaceExtensions" Member="M:Microsoft.ML.Runtime.Data.NAReplaceExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.Scalar{System.Double},Microsoft.ML.Runtime.Data.NAReplaceTransform.ColumnInfo.ReplacementMode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ReplaceNaNValues">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; ReplaceNaNValues (this Microsoft.ML.StaticPipe.Scalar&lt;float&gt; input, Microsoft.ML.Runtime.Data.NAReplaceTransform.ColumnInfo.ReplacementMode replacementMode = Microsoft.ML.Runtime.Data.NAReplaceTransform+ColumnInfo+ReplacementMode.DefaultValue);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; ReplaceNaNValues(class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; input, valuetype Microsoft.ML.Runtime.Data.NAReplaceTransform/ColumnInfo/ReplacementMode replacementMode) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.NAReplaceExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Runtime.Data.NAReplaceTransform.ColumnInfo.ReplacementMode)" />
        <MemberSignature Language="F#" Value="static member ReplaceNaNValues : Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.Runtime.Data.NAReplaceTransform.ColumnInfo.ReplacementMode -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.NAReplaceExtensions.ReplaceNaNValues (input, replacementMode)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="replacementMode" Type="Microsoft.ML.Runtime.Data.NAReplaceTransform+ColumnInfo+ReplacementMode" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="replacementMode">How NaN should be replaced</param>
          <summary>
            Scan through all rows and replace NaN values according to replacement strategy.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.NAReplaceExtensions" Member="M:Microsoft.ML.Runtime.Data.NAReplaceExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Runtime.Data.NAReplaceTransform.ColumnInfo.ReplacementMode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ReplaceNaNValues">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;float&gt; ReplaceNaNValues (this Microsoft.ML.StaticPipe.VarVector&lt;float&gt; input, Microsoft.ML.Runtime.Data.NAReplaceTransform.ColumnInfo.ReplacementMode replacementMode = Microsoft.ML.Runtime.Data.NAReplaceTransform+ColumnInfo+ReplacementMode.DefaultValue);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; ReplaceNaNValues(class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; input, valuetype Microsoft.ML.Runtime.Data.NAReplaceTransform/ColumnInfo/ReplacementMode replacementMode) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.NAReplaceExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.VarVector{System.Single},Microsoft.ML.Runtime.Data.NAReplaceTransform.ColumnInfo.ReplacementMode)" />
        <MemberSignature Language="F#" Value="static member ReplaceNaNValues : Microsoft.ML.StaticPipe.VarVector&lt;single&gt; * Microsoft.ML.Runtime.Data.NAReplaceTransform.ColumnInfo.ReplacementMode -&gt; Microsoft.ML.StaticPipe.VarVector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.NAReplaceExtensions.ReplaceNaNValues (input, replacementMode)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="replacementMode" Type="Microsoft.ML.Runtime.Data.NAReplaceTransform+ColumnInfo+ReplacementMode" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="replacementMode">How NaN should be replaced</param>
          <summary>
            Scan through all rows and replace NaN values according to replacement strategy.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.NAReplaceExtensions" Member="M:Microsoft.ML.Runtime.Data.NAReplaceExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.VarVector{System.Single},Microsoft.ML.Runtime.Data.NAReplaceTransform.ColumnInfo.ReplacementMode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ReplaceNaNValues">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;double&gt; ReplaceNaNValues (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, Microsoft.ML.Runtime.Data.NAReplaceTransform.ColumnInfo.ReplacementMode replacementMode = Microsoft.ML.Runtime.Data.NAReplaceTransform+ColumnInfo+ReplacementMode.DefaultValue, bool imputeBySlot = true);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; ReplaceNaNValues(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, valuetype Microsoft.ML.Runtime.Data.NAReplaceTransform/ColumnInfo/ReplacementMode replacementMode, bool imputeBySlot) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.NAReplaceExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.Vector{System.Double},Microsoft.ML.Runtime.Data.NAReplaceTransform.ColumnInfo.ReplacementMode,System.Boolean)" />
        <MemberSignature Language="F#" Value="static member ReplaceNaNValues : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * Microsoft.ML.Runtime.Data.NAReplaceTransform.ColumnInfo.ReplacementMode * bool -&gt; Microsoft.ML.StaticPipe.Vector&lt;double&gt;" Usage="Microsoft.ML.Runtime.Data.NAReplaceExtensions.ReplaceNaNValues (input, replacementMode, imputeBySlot)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="replacementMode" Type="Microsoft.ML.Runtime.Data.NAReplaceTransform+ColumnInfo+ReplacementMode" />
          <Parameter Name="imputeBySlot" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="replacementMode">How NaN should be replaced</param>
          <param name="imputeBySlot">If true, per-slot imputation of replacement is performed.
            Otherwise, replacement value is imputed for the entire vector column. This setting is ignored for scalars and variable vectors,
            where imputation is always for the entire column.</param>
          <summary>
            Scan through all rows and replace NaN values according to replacement strategy.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.NAReplaceExtensions" Member="M:Microsoft.ML.Runtime.Data.NAReplaceExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.Vector{System.Double},Microsoft.ML.Runtime.Data.NAReplaceTransform.ColumnInfo.ReplacementMode,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ReplaceNaNValues">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ReplaceNaNValues (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, Microsoft.ML.Runtime.Data.NAReplaceTransform.ColumnInfo.ReplacementMode replacementMode = Microsoft.ML.Runtime.Data.NAReplaceTransform+ColumnInfo+ReplacementMode.DefaultValue, bool imputeBySlot = true);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ReplaceNaNValues(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, valuetype Microsoft.ML.Runtime.Data.NAReplaceTransform/ColumnInfo/ReplacementMode replacementMode, bool imputeBySlot) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.NAReplaceExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.Runtime.Data.NAReplaceTransform.ColumnInfo.ReplacementMode,System.Boolean)" />
        <MemberSignature Language="F#" Value="static member ReplaceNaNValues : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.Runtime.Data.NAReplaceTransform.ColumnInfo.ReplacementMode * bool -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.NAReplaceExtensions.ReplaceNaNValues (input, replacementMode, imputeBySlot)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="replacementMode" Type="Microsoft.ML.Runtime.Data.NAReplaceTransform+ColumnInfo+ReplacementMode" />
          <Parameter Name="imputeBySlot" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="input">Incoming data.</param>
          <param name="replacementMode">How NaN should be replaced</param>
          <param name="imputeBySlot">If true, per-slot imputation of replacement is performed.
            Otherwise, replacement value is imputed for the entire vector column. This setting is ignored for scalars and variable vectors,
            where imputation is always for the entire column.</param>
          <summary>
            Scan through all rows and replace NaN values according to replacement strategy.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.NAReplaceExtensions" Member="M:Microsoft.ML.Runtime.Data.NAReplaceExtensions.ReplaceNaNValues(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.Runtime.Data.NAReplaceTransform.ColumnInfo.ReplacementMode,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="Normalize">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;double&gt; Normalize (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, bool fixZero = true, long maxTrainingExamples = 1000000000, Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;double&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;float64&gt; Normalize(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, bool fixZero, int64 maxTrainingExamples, class Microsoft.ML.Runtime.Data.NormalizerStaticExtensions/OnFitAffine`1&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;float64&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.Normalize(Microsoft.ML.StaticPipe.Vector{System.Double},System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Double}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Normalize (input As Vector(Of Double), Optional fixZero As Boolean = true, Optional maxTrainingExamples As Long = 1000000000, Optional onFit As NormalizerStaticExtensions.OnFitAffine(Of ImmutableArray(Of Double)) = null) As NormVector(Of Double)" />
        <MemberSignature Language="F#" Value="static member Normalize : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * bool * int64 * Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;double&gt;&gt; -&gt; Microsoft.ML.StaticPipe.NormVector&lt;double&gt;" Usage="Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.Normalize (input, fixZero, maxTrainingExamples, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="fixZero" Type="System.Boolean" />
          <Parameter Name="maxTrainingExamples" Type="System.Int64" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.NormalizerStaticExtensions+OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;System.Double&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="fixZero">If set to <c>false</c>, then the observed minimum and maximum during fitting
            will map to -1 and 1 respectively, exactly. If however set to <c>true</c>, then 0 will always map to 0.
            This is valuable for the sake of sparsity preservation, if normalizing sparse vectors.</param>
          <param name="maxTrainingExamples">When gathering statistics only look at most this many examples.</param>
          <param name="onFit">A delegate called whenever the estimator is fit, with the learned slopes
            and, if <paramref name="fixZero" /> is <c>false</c>, the offsets as well.</param>
          <summary>
            Learns an affine function based on the minimum and maximum, so that all values between the minimum and
            maximum observed during fitting fall into the range of -1 to 1.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.NormalizerStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.Normalize(Microsoft.ML.StaticPipe.Vector{System.Double},System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Double}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="Normalize">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;float&gt; Normalize (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, bool fixZero = true, long maxTrainingExamples = 1000000000, Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;float&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;float32&gt; Normalize(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, bool fixZero, int64 maxTrainingExamples, class Microsoft.ML.Runtime.Data.NormalizerStaticExtensions/OnFitAffine`1&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;float32&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.Normalize(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Single}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Normalize (input As Vector(Of Single), Optional fixZero As Boolean = true, Optional maxTrainingExamples As Long = 1000000000, Optional onFit As NormalizerStaticExtensions.OnFitAffine(Of ImmutableArray(Of Single)) = null) As NormVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member Normalize : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * bool * int64 * Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;single&gt;&gt; -&gt; Microsoft.ML.StaticPipe.NormVector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.Normalize (input, fixZero, maxTrainingExamples, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="fixZero" Type="System.Boolean" />
          <Parameter Name="maxTrainingExamples" Type="System.Int64" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.NormalizerStaticExtensions+OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;System.Single&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="fixZero">If set to <c>false</c>, then the observed minimum and maximum during fitting
            will map to -1 and 1 respectively, exactly. If however set to <c>true</c>, then 0 will always map to 0.
            This is valuable for the sake of sparsity preservation, if normalizing sparse vectors.</param>
          <param name="maxTrainingExamples">When gathering statistics only look at most this many examples.</param>
          <param name="onFit">A delegate that can be called whenever the function is fit, with the learned slopes
            and, if <paramref name="fixZero" /> is <c>false</c>, the offsets as well.</param>
          <summary>
            Learns an affine function based on the minimum and maximum, so that all values between the minimum and
            maximum observed during fitting fall into the range of -1 to 1.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.NormalizerStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.Normalize(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Single}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="NormalizeByBinning">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;double&gt; NormalizeByBinning (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, int maxBins = 1024, bool fixZero = true, long maxTrainingExamples = 1000000000, Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitBinned&lt;System.Collections.Immutable.ImmutableArray&lt;double&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;float64&gt; NormalizeByBinning(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, int32 maxBins, bool fixZero, int64 maxTrainingExamples, class Microsoft.ML.Runtime.Data.NormalizerStaticExtensions/OnFitBinned`1&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;float64&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.NormalizeByBinning(Microsoft.ML.StaticPipe.Vector{System.Double},System.Int32,System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitBinned{System.Collections.Immutable.ImmutableArray{System.Double}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeByBinning (input As Vector(Of Double), Optional maxBins As Integer = 1024, Optional fixZero As Boolean = true, Optional maxTrainingExamples As Long = 1000000000, Optional onFit As NormalizerStaticExtensions.OnFitBinned(Of ImmutableArray(Of Double)) = null) As NormVector(Of Double)" />
        <MemberSignature Language="F#" Value="static member NormalizeByBinning : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * int * bool * int64 * Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitBinned&lt;System.Collections.Immutable.ImmutableArray&lt;double&gt;&gt; -&gt; Microsoft.ML.StaticPipe.NormVector&lt;double&gt;" Usage="Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.NormalizeByBinning (input, maxBins, fixZero, maxTrainingExamples, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="maxBins" Type="System.Int32" />
          <Parameter Name="fixZero" Type="System.Boolean" />
          <Parameter Name="maxTrainingExamples" Type="System.Int64" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.NormalizerStaticExtensions+OnFitBinned&lt;System.Collections.Immutable.ImmutableArray&lt;System.Double&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="maxBins">The maximum number of discretization points to learn per slot.</param>
          <param name="fixZero">Normally the output is in the range of 0 to 1, but if set to <c>true</c>, then what
            would have been the output for a zero input is subtracted off the value.
            This is valuable for the sake of sparsity preservation, if normalizing sparse vectors.</param>
          <param name="maxTrainingExamples">When gathering statistics only look at most this many examples.</param>
          <param name="onFit">A delegate called whenever the estimator is fit, with the bin upper bounds for each slot.</param>
          <summary>
            Learns a function based on a discretization of the input values. The observed values for each slot are
            analyzed, and the range of numbers is partitioned into monotonically increasing bins. An attempt is made
            to make these bins equal in population, but under some circumstances this may be impossible (e.g., a slot
            with a very dominant mode). The way the mapping works is, if there are <c>N</c> bins in a slot, and a value
            falls in the range of bin <c>n</c> (indexed from 0), the output value is <c>n / (N - 1)</c>, and then possibly
            subtracting off the binned value for what 0 would have been if <paramref name="fixZero" /> is true.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.NormalizerStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.NormalizeByBinning(Microsoft.ML.StaticPipe.Vector{System.Double},System.Int32,System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitBinned{System.Collections.Immutable.ImmutableArray{System.Double}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="NormalizeByBinning">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;float&gt; NormalizeByBinning (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, int maxBins = 1024, bool fixZero = true, long maxTrainingExamples = 1000000000, Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitBinned&lt;System.Collections.Immutable.ImmutableArray&lt;float&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;float32&gt; NormalizeByBinning(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, int32 maxBins, bool fixZero, int64 maxTrainingExamples, class Microsoft.ML.Runtime.Data.NormalizerStaticExtensions/OnFitBinned`1&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;float32&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.NormalizeByBinning(Microsoft.ML.StaticPipe.Vector{System.Single},System.Int32,System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitBinned{System.Collections.Immutable.ImmutableArray{System.Single}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeByBinning (input As Vector(Of Single), Optional maxBins As Integer = 1024, Optional fixZero As Boolean = true, Optional maxTrainingExamples As Long = 1000000000, Optional onFit As NormalizerStaticExtensions.OnFitBinned(Of ImmutableArray(Of Single)) = null) As NormVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member NormalizeByBinning : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * int * bool * int64 * Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitBinned&lt;System.Collections.Immutable.ImmutableArray&lt;single&gt;&gt; -&gt; Microsoft.ML.StaticPipe.NormVector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.NormalizeByBinning (input, maxBins, fixZero, maxTrainingExamples, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="maxBins" Type="System.Int32" />
          <Parameter Name="fixZero" Type="System.Boolean" />
          <Parameter Name="maxTrainingExamples" Type="System.Int64" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.NormalizerStaticExtensions+OnFitBinned&lt;System.Collections.Immutable.ImmutableArray&lt;System.Single&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="maxBins">The maximum number of discretization points to learn per slot.</param>
          <param name="fixZero">Normally the output is in the range of 0 to 1, but if set to <c>true</c>, then what
            would have been the output for a zero input is subtracted off the value.
            This is valuable for the sake of sparsity preservation, if normalizing sparse vectors.</param>
          <param name="maxTrainingExamples">When gathering statistics only look at most this many examples.</param>
          <param name="onFit">A delegate called whenever the estimator is fit, with the bin upper bounds for each slot.</param>
          <summary>
            Learns a function based on a discretization of the input values. The observed values for each slot are
            analyzed, and the range of numbers is partitioned into monotonically increasing bins. An attempt is made
            to make these bins equal in population, but under some circumstances this may be impossible (e.g., a slot
            with a very dominant mode). The way the mapping works is, if there are <c>N</c> bins in a slot, and a value
            falls in the range of bin <c>n</c> (indexed from 0), the output value is <c>n / (N - 1)</c>, and then possibly
            subtracting off the binned value for what 0 would have been if <paramref name="fixZero" /> is true.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.NormalizerStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.NormalizeByBinning(Microsoft.ML.StaticPipe.Vector{System.Single},System.Int32,System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitBinned{System.Collections.Immutable.ImmutableArray{System.Single}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="NormalizeByCumulativeDistribution">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;double&gt; NormalizeByCumulativeDistribution (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, bool fixZero = true, bool useLog = false, long maxTrainingExamples = 1000000000, Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitCumulativeDistribution&lt;System.Collections.Immutable.ImmutableArray&lt;double&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;float64&gt; NormalizeByCumulativeDistribution(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, bool fixZero, bool useLog, int64 maxTrainingExamples, class Microsoft.ML.Runtime.Data.NormalizerStaticExtensions/OnFitCumulativeDistribution`1&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;float64&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.NormalizeByCumulativeDistribution(Microsoft.ML.StaticPipe.Vector{System.Double},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitCumulativeDistribution{System.Collections.Immutable.ImmutableArray{System.Double}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeByCumulativeDistribution (input As Vector(Of Double), Optional fixZero As Boolean = true, Optional useLog As Boolean = false, Optional maxTrainingExamples As Long = 1000000000, Optional onFit As NormalizerStaticExtensions.OnFitCumulativeDistribution(Of ImmutableArray(Of Double)) = null) As NormVector(Of Double)" />
        <MemberSignature Language="F#" Value="static member NormalizeByCumulativeDistribution : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * bool * bool * int64 * Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitCumulativeDistribution&lt;System.Collections.Immutable.ImmutableArray&lt;double&gt;&gt; -&gt; Microsoft.ML.StaticPipe.NormVector&lt;double&gt;" Usage="Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.NormalizeByCumulativeDistribution (input, fixZero, useLog, maxTrainingExamples, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="fixZero" Type="System.Boolean" />
          <Parameter Name="useLog" Type="System.Boolean" />
          <Parameter Name="maxTrainingExamples" Type="System.Int64" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.NormalizerStaticExtensions+OnFitCumulativeDistribution&lt;System.Collections.Immutable.ImmutableArray&lt;System.Double&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="fixZero">If set to <c>false</c>, then the learned distributional parameters will be
            adjusted in such a way as to ensure that the input 0 maps to the output 0.
            This is valuable for the sake of sparsity preservation, if normalizing sparse vectors.</param>
          <param name="useLog">If set to true then we transform over the logarithm of the values, rather
            than just the raw values. If this is set to <c>true</c> then <paramref name="fixZero" /> is ignored.</param>
          <param name="maxTrainingExamples">When gathering statistics only look at most this many examples.</param>
          <param name="onFit">A delegate called whenever the estimator is fit, with the learned mean and standard
            deviation for all slots.</param>
          <summary>
            Learns a function based on the cumulative density function of a normal distribution parameterized by
            a mean and variance as observed during fitting.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.NormalizerStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.NormalizeByCumulativeDistribution(Microsoft.ML.StaticPipe.Vector{System.Double},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitCumulativeDistribution{System.Collections.Immutable.ImmutableArray{System.Double}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="NormalizeByCumulativeDistribution">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;float&gt; NormalizeByCumulativeDistribution (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, bool fixZero = true, bool useLog = false, long maxTrainingExamples = 1000000000, Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitCumulativeDistribution&lt;System.Collections.Immutable.ImmutableArray&lt;float&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;float32&gt; NormalizeByCumulativeDistribution(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, bool fixZero, bool useLog, int64 maxTrainingExamples, class Microsoft.ML.Runtime.Data.NormalizerStaticExtensions/OnFitCumulativeDistribution`1&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;float32&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.NormalizeByCumulativeDistribution(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitCumulativeDistribution{System.Collections.Immutable.ImmutableArray{System.Single}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeByCumulativeDistribution (input As Vector(Of Single), Optional fixZero As Boolean = true, Optional useLog As Boolean = false, Optional maxTrainingExamples As Long = 1000000000, Optional onFit As NormalizerStaticExtensions.OnFitCumulativeDistribution(Of ImmutableArray(Of Single)) = null) As NormVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member NormalizeByCumulativeDistribution : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * bool * bool * int64 * Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitCumulativeDistribution&lt;System.Collections.Immutable.ImmutableArray&lt;single&gt;&gt; -&gt; Microsoft.ML.StaticPipe.NormVector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.NormalizeByCumulativeDistribution (input, fixZero, useLog, maxTrainingExamples, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="fixZero" Type="System.Boolean" />
          <Parameter Name="useLog" Type="System.Boolean" />
          <Parameter Name="maxTrainingExamples" Type="System.Int64" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.NormalizerStaticExtensions+OnFitCumulativeDistribution&lt;System.Collections.Immutable.ImmutableArray&lt;System.Single&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="fixZero">If set to <c>false</c>, then the learned distributional parameters will be
            adjusted in such a way as to ensure that the input 0 maps to the output 0.
            This is valuable for the sake of sparsity preservation, if normalizing sparse vectors.</param>
          <param name="useLog">If set to true then we transform over the logarithm of the values, rather
            than just the raw values. If this is set to <c>true</c> then <paramref name="fixZero" /> is ignored.</param>
          <param name="maxTrainingExamples">When gathering statistics only look at most this many examples.</param>
          <param name="onFit">A delegate called whenever the estimator is fit, with the learned mean and standard
            deviation for all slots.</param>
          <summary>
            Learns a function based on the cumulative density function of a normal distribution parameterized by
            a mean and variance as observed during fitting.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.NormalizerStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.NormalizeByCumulativeDistribution(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitCumulativeDistribution{System.Collections.Immutable.ImmutableArray{System.Single}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="NormalizeByMeanVar">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;double&gt; NormalizeByMeanVar (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, bool fixZero = true, bool useLog = false, long maxTrainingExamples = 1000000000, Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;double&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;float64&gt; NormalizeByMeanVar(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, bool fixZero, bool useLog, int64 maxTrainingExamples, class Microsoft.ML.Runtime.Data.NormalizerStaticExtensions/OnFitAffine`1&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;float64&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.NormalizeByMeanVar(Microsoft.ML.StaticPipe.Vector{System.Double},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Double}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeByMeanVar (input As Vector(Of Double), Optional fixZero As Boolean = true, Optional useLog As Boolean = false, Optional maxTrainingExamples As Long = 1000000000, Optional onFit As NormalizerStaticExtensions.OnFitAffine(Of ImmutableArray(Of Double)) = null) As NormVector(Of Double)" />
        <MemberSignature Language="F#" Value="static member NormalizeByMeanVar : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * bool * bool * int64 * Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;double&gt;&gt; -&gt; Microsoft.ML.StaticPipe.NormVector&lt;double&gt;" Usage="Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.NormalizeByMeanVar (input, fixZero, useLog, maxTrainingExamples, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="fixZero" Type="System.Boolean" />
          <Parameter Name="useLog" Type="System.Boolean" />
          <Parameter Name="maxTrainingExamples" Type="System.Int64" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.NormalizerStaticExtensions+OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;System.Double&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="fixZero">If set to <c>true</c> then the offset will always be considered zero.</param>
          <param name="useLog">If set to true then we transform over the logarithm of the values, rather
            than just the raw values. If this is set to <c>true</c> then <paramref name="fixZero" /> is ignored.</param>
          <param name="maxTrainingExamples">When gathering statistics only look at most this many examples.</param>
          <param name="onFit">A delegate called whenever the estimator is fit, with the learned slopes
            and, if <paramref name="fixZero" /> is <c>false</c>, the offsets as well.</param>
          <summary>
            Learns an affine function based on the observed mean and standard deviation. This is less susceptible
            to outliers as compared to <see cref="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.Normalize(Microsoft.ML.StaticPipe.Vector{System.Double},System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Double}})" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.NormalizerStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.NormalizeByMeanVar(Microsoft.ML.StaticPipe.Vector{System.Double},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Double}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="NormalizeByMeanVar">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.NormVector&lt;float&gt; NormalizeByMeanVar (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, bool fixZero = true, bool useLog = false, long maxTrainingExamples = 1000000000, Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;float&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.NormVector`1&lt;float32&gt; NormalizeByMeanVar(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, bool fixZero, bool useLog, int64 maxTrainingExamples, class Microsoft.ML.Runtime.Data.NormalizerStaticExtensions/OnFitAffine`1&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;float32&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.NormalizeByMeanVar(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Single}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeByMeanVar (input As Vector(Of Single), Optional fixZero As Boolean = true, Optional useLog As Boolean = false, Optional maxTrainingExamples As Long = 1000000000, Optional onFit As NormalizerStaticExtensions.OnFitAffine(Of ImmutableArray(Of Single)) = null) As NormVector(Of Single)" />
        <MemberSignature Language="F#" Value="static member NormalizeByMeanVar : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * bool * bool * int64 * Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;single&gt;&gt; -&gt; Microsoft.ML.StaticPipe.NormVector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.NormalizeByMeanVar (input, fixZero, useLog, maxTrainingExamples, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.NormVector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="fixZero" Type="System.Boolean" />
          <Parameter Name="useLog" Type="System.Boolean" />
          <Parameter Name="maxTrainingExamples" Type="System.Int64" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.NormalizerStaticExtensions+OnFitAffine&lt;System.Collections.Immutable.ImmutableArray&lt;System.Single&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="fixZero">If set to <c>true</c> then the offset will always be considered zero.</param>
          <param name="useLog">If set to true then we transform over the logarithm of the values, rather
            than just the raw values. If this is set to <c>true</c> then <paramref name="fixZero" /> is ignored.</param>
          <param name="maxTrainingExamples">When gathering statistics only look at most this many examples.</param>
          <param name="onFit">A delegate called whenever the estimator is fit, with the learned slopes
            and, if <paramref name="fixZero" /> is <c>false</c>, the offsets as well.</param>
          <summary>
            Learns an affine function based on the observed mean and standard deviation. This is less susceptible
            to outliers as compared to <see cref="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.Normalize(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Single}})" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.NormalizerStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.NormalizeByMeanVar(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Single}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.RoleMappedSchema" />
      </Targets>
      <Member MemberName="FeaturesAreNormalized">
        <MemberSignature Language="C#" Value="public static Nullable&lt;bool&gt; FeaturesAreNormalized (this Microsoft.ML.Runtime.Data.RoleMappedSchema schema);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;bool&gt; FeaturesAreNormalized(class Microsoft.ML.Runtime.Data.RoleMappedSchema schema) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.NormalizeUtils.FeaturesAreNormalized(Microsoft.ML.Runtime.Data.RoleMappedSchema)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FeaturesAreNormalized (schema As RoleMappedSchema) As Nullable(Of Boolean)" />
        <MemberSignature Language="F#" Value="static member FeaturesAreNormalized : Microsoft.ML.Runtime.Data.RoleMappedSchema -&gt; Nullable&lt;bool&gt;" Usage="Microsoft.ML.Runtime.Data.NormalizeUtils.FeaturesAreNormalized schema" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="schema" Type="Microsoft.ML.Runtime.Data.RoleMappedSchema" RefType="this" />
        </Parameters>
        <Docs>
          <param name="schema">The role-mapped schema to query</param>
          <summary>
            Returns whether the feature column in the schema is indicated to be normalized. If the features column is not
            specified on the schema, then this will return <c>null</c>.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.NormalizeUtils" Member="M:Microsoft.ML.Runtime.Data.NormalizeUtils.FeaturesAreNormalized(Microsoft.ML.Runtime.Data.RoleMappedSchema)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToPrincipalComponents">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToPrincipalComponents (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, int rank = 20, Action&lt;Microsoft.ML.Runtime.Data.PcaTransform.Arguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToPrincipalComponents(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, int32 rank, class System.Action`1&lt;class Microsoft.ML.Runtime.Data.PcaTransform/Arguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.PcaEstimatorExtensions.ToPrincipalComponents(Microsoft.ML.StaticPipe.Vector{System.Single},System.Int32,System.Action{Microsoft.ML.Runtime.Data.PcaTransform.Arguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToPrincipalComponents (input As Vector(Of Single), Optional rank As Integer = 20, Optional advancedSettings As Action(Of PcaTransform.Arguments) = null) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToPrincipalComponents : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * int * Action&lt;Microsoft.ML.Runtime.Data.PcaTransform.Arguments&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.PcaEstimatorExtensions.ToPrincipalComponents (input, rank, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="rank" Type="System.Int32" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Runtime.Data.PcaTransform+Arguments&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply PCA to.</param>
          <param name="rank">The number of components in the PCA.</param>
          <param name="advancedSettings">A delegate to apply all the advanced arguments to the algorithm.</param>
          <summary>Replace current vector with its principal components. Can significantly reduce size of vector.</summary>
          <summary>
        PCA is a dimensionality-reduction transform which computes the projection of the feature vector onto a low-rank subspace. 
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.PcaEstimatorExtensions" Member="M:Microsoft.ML.Runtime.Data.PcaEstimatorExtensions.ToPrincipalComponents(Microsoft.ML.StaticPipe.Vector{System.Single},System.Int32,System.Action{Microsoft.ML.Runtime.Data.PcaTransform.Arguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.ITransformer" />
      </Targets>
      <Member MemberName="MakePredictionFunction&lt;TSrc,TDst&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.PredictionFunction&lt;TSrc,TDst&gt; MakePredictionFunction&lt;TSrc,TDst&gt; (this Microsoft.ML.Core.Data.ITransformer transformer, Microsoft.ML.Runtime.IHostEnvironment env) where TSrc : class where TDst : class, new();" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.PredictionFunction`2&lt;!!TSrc, !!TDst&gt; MakePredictionFunction&lt;class TSrc, class .ctor TDst&gt;(class Microsoft.ML.Core.Data.ITransformer transformer, class Microsoft.ML.Runtime.IHostEnvironment env) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.PredictionFunctionExtensions.MakePredictionFunction``2(Microsoft.ML.Core.Data.ITransformer,Microsoft.ML.Runtime.IHostEnvironment)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function MakePredictionFunction(Of TSrc As Class, TDst As Class) (transformer As ITransformer, env As IHostEnvironment) As PredictionFunction(Of TSrc, TDst)" />
        <MemberSignature Language="F#" Value="static member MakePredictionFunction : Microsoft.ML.Core.Data.ITransformer * Microsoft.ML.Runtime.IHostEnvironment -&gt; Microsoft.ML.Runtime.Data.PredictionFunction&lt;'Src, 'Dst (requires 'Src : null and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))&gt; (requires 'Src : null and 'Dst : null and 'Dst : (new : unit -&gt; 'Dst))" Usage="Microsoft.ML.Runtime.Data.PredictionFunctionExtensions.MakePredictionFunction (transformer, env)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.PredictionFunction&lt;TSrc,TDst&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSrc">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
          <TypeParameter Name="TDst">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="transformer" Type="Microsoft.ML.Core.Data.ITransformer" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
        </Parameters>
        <Docs>
          <typeparam name="TSrc">To be added.</typeparam>
          <typeparam name="TDst">To be added.</typeparam>
          <param name="transformer">To be added.</param>
          <param name="env">To be added.</param>
          <summary>
            Create an instance of the 'prediction function', or 'prediction machine', from a model
            denoted by <paramref name="transformer" />.
            It will be accepting instances of <typeparamref name="TSrc" /> as input, and produce
            instances of <typeparamref name="TDst" /> as output.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.PredictionFunctionExtensions" Member="M:Microsoft.ML.Runtime.Data.PredictionFunctionExtensions.MakePredictionFunction``2(Microsoft.ML.Core.Data.ITransformer,Microsoft.ML.Runtime.IHostEnvironment)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Text.StringBuilder" />
      </Targets>
      <Member MemberName="AppendMemory">
        <MemberSignature Language="C#" Value="public static System.Text.StringBuilder AppendMemory (this System.Text.StringBuilder sb, ReadOnlyMemory&lt;char&gt; memory);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.StringBuilder AppendMemory(class System.Text.StringBuilder sb, valuetype System.ReadOnlyMemory`1&lt;char&gt; memory) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.ReadOnlyMemoryUtils.AppendMemory(System.Text.StringBuilder,System.ReadOnlyMemory{System.Char})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AppendMemory (sb As StringBuilder, memory As ReadOnlyMemory(Of Char)) As StringBuilder" />
        <MemberSignature Language="F#" Value="static member AppendMemory : System.Text.StringBuilder * ReadOnlyMemory&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="Microsoft.ML.Runtime.Data.ReadOnlyMemoryUtils.AppendMemory (sb, memory)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Text.StringBuilder</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="sb" Type="System.Text.StringBuilder" RefType="this" />
          <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;System.Char&gt;" />
        </Parameters>
        <Docs>
          <param name="sb">To be added.</param>
          <param name="memory">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.ReadOnlyMemoryUtils" Member="M:Microsoft.ML.Runtime.Data.ReadOnlyMemoryUtils.AppendMemory(System.Text.StringBuilder,System.ReadOnlyMemory{System.Char})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Text.StringBuilder" />
      </Targets>
      <Member MemberName="AppendSpan">
        <MemberSignature Language="C#" Value="public static System.Text.StringBuilder AppendSpan (this System.Text.StringBuilder sb, ReadOnlySpan&lt;char&gt; span);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.StringBuilder AppendSpan(class System.Text.StringBuilder sb, valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.ReadOnlyMemoryUtils.AppendSpan(System.Text.StringBuilder,System.ReadOnlySpan{System.Char})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AppendSpan (sb As StringBuilder, span As ReadOnlySpan(Of Char)) As StringBuilder" />
        <MemberSignature Language="F#" Value="static member AppendSpan : System.Text.StringBuilder * ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="Microsoft.ML.Runtime.Data.ReadOnlyMemoryUtils.AppendSpan (sb, span)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Text.StringBuilder</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="sb" Type="System.Text.StringBuilder" RefType="this" />
          <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        </Parameters>
        <Docs>
          <param name="sb">To be added.</param>
          <param name="span">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.ReadOnlyMemoryUtils" Member="M:Microsoft.ML.Runtime.Data.ReadOnlyMemoryUtils.AppendSpan(System.Text.StringBuilder,System.ReadOnlySpan{System.Char})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,bool&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;bool&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, bool&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;bool&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Boolean})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;bool&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, bool&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Boolean&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Boolean&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Boolean}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,byte&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;byte&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;byte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int8&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;unsigned int8&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;unsigned int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Byte},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Byte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;byte&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;byte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, byte&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Byte&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Byte&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Byte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Byte},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Byte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,double&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;double&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;double&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float64&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;float64&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;float64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Double},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Double})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;double&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;double&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, double&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Double&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Double},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Double}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,short&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;short&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;short&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int16&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;int16&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Int16},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Int16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;int16&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;int16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, int16&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int16&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Int16&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Int16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Int16},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,int&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;int&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;int&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int32&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;int32&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Int32},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Int32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;int&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;int&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, int&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int32&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Int32&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Int32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Int32},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,long&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;long&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;long&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int64&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;int64&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Int64},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Int64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;int64&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;int64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, int64&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int64&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Int64&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Int64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Int64},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,sbyte&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;sbyte&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;sbyte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int8&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;int8&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.SByte},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.SByte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;sbyte&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;sbyte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, sbyte&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.SByte&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.SByte&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.SByte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.SByte},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.SByte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,float&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;float&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;float&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float32&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;float32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Single})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;single&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, single&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Single&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Single}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,string&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, string&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.ReadOnlyMemory{System.Char}})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, string&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.String&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because the empty string is never entered into the dictionary, it will always map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,ushort&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;ushort&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ushort&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int16&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;unsigned int16&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;unsigned int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.UInt16},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.UInt16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;uint16&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;uint16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, uint16&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt16&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.UInt16&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.UInt16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.UInt16},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,uint&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;uint&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;uint&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int32&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;unsigned int32&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;unsigned int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.UInt32},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.UInt32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;uint32&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;uint32&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, uint32&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt32&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.UInt32&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.UInt32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.UInt32},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,ulong&gt; ToKey (this Microsoft.ML.StaticPipe.Scalar&lt;ulong&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ulong&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int64&gt; ToKey(class Microsoft.ML.StaticPipe.Scalar`1&lt;unsigned int64&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;unsigned int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.UInt64},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.UInt64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Scalar&lt;uint64&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;uint64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, uint64&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt64&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.UInt64&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.UInt64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.UInt64},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,bool&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;bool&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;bool&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, bool&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;bool&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;bool&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Boolean},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Boolean})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;bool&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;bool&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, bool&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Boolean&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Boolean&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Boolean&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Boolean},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Boolean}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,byte&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;byte&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;byte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int8&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;unsigned int8&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;unsigned int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Byte},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Byte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;byte&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;byte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, byte&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Byte&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Byte&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Byte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Byte},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Byte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,double&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;double&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;double&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float64&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;float64&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;float64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Double},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Double})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;double&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;double&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, double&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Double&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Double&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Double},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Double}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,short&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;short&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;short&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int16&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;int16&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Int16},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Int16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;int16&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;int16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int16&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int16&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Int16&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Int16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Int16},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,int&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;int&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;int&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int32&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;int32&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Int32},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Int32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;int&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;int&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int32&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Int32&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Int32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Int32},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,long&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;long&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;long&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int64&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;int64&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Int64},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Int64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;int64&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;int64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int64&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int64&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Int64&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Int64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Int64},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,sbyte&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;sbyte&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;sbyte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int8&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;int8&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.SByte},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.SByte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;sbyte&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;sbyte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, sbyte&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.SByte&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.SByte&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.SByte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.SByte},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.SByte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,float&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;float&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;float&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float32&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;float32&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;float32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Single},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Single})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;single&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;single&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, single&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Single&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Single&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Single},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Single}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,string&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;string&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, string&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;string&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.String},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.ReadOnlyMemory{System.Char}})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;string&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, string&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.String&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.String&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because the empty string is never entered into the dictionary, it will always map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.String},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,ushort&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;ushort&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ushort&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int16&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;unsigned int16&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;unsigned int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.UInt16},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.UInt16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;uint16&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;uint16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint16&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt16&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.UInt16&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.UInt16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.UInt16},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,uint&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;uint&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;uint&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int32&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;unsigned int32&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;unsigned int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.UInt32},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.UInt32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;uint32&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;uint32&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint32&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt32&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.UInt32&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.UInt32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.UInt32},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,ulong&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.VarVector&lt;ulong&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ulong&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int64&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.VarVector`1&lt;unsigned int64&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;unsigned int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.UInt64},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.UInt64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;uint64&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;uint64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint64&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt64&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.UInt64&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.UInt64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.UInt64},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,bool&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;bool&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;bool&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, bool&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;bool&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;bool&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Boolean},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Boolean})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;bool&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;bool&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, bool&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Boolean&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Boolean&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Boolean&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Boolean},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Boolean}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,byte&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;byte&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;byte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int8&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;unsigned int8&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;unsigned int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Byte},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Byte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;byte&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;byte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, byte&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Byte&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Byte&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Byte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Byte},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Byte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,double&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;double&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float64&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;float64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Double},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Double})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;double&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, double&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Double&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Double&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Double},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Double}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,short&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;short&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;short&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int16&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;int16&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Int16},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Int16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;int16&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;int16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int16&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int16&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Int16&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Int16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Int16},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,int&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;int&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;int&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int32&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;int32&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Int32},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Int32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;int&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;int&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int32&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Int32&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Int32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Int32},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,long&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;long&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;long&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int64&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;int64&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Int64},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Int64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;int64&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;int64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int64&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int64&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Int64&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Int64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Int64},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,sbyte&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;sbyte&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;sbyte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int8&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;int8&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.SByte},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.SByte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;sbyte&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;sbyte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, sbyte&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.SByte&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.SByte&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.SByte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.SByte},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.SByte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,float&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;float&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float32&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;float32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Single})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;single&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, single&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Single&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Single&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Single}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,string&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;string&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, string&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;string&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.String},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.ReadOnlyMemory{System.Char}})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;string&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, string&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.String&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.String&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because the empty string is never entered into the dictionary, it will always map to the missing key.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.String},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,ushort&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;ushort&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ushort&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int16&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;unsigned int16&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;unsigned int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.UInt16},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.UInt16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;uint16&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;uint16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint16&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt16&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.UInt16&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.UInt16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.UInt16},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,uint&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;uint&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;uint&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int32&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;unsigned int32&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;unsigned int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.UInt32},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.UInt32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;uint32&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;uint32&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint32&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt32&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.UInt32&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.UInt32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.UInt32},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,ulong&gt;&gt; ToKey (this Microsoft.ML.StaticPipe.Vector&lt;ulong&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ulong&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int64&gt;&gt; ToKey(class Microsoft.ML.StaticPipe.Vector`1&lt;unsigned int64&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;unsigned int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.UInt64},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.UInt64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;uint64&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;uint64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint64&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt64&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.UInt64&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.UInt64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.UInt64},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,bool&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,bool&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;bool&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, bool&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, bool&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;bool&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Boolean},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Boolean})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, bool&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;bool&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, bool&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Boolean&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.Boolean&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Boolean&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Boolean},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Boolean}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,byte&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,byte&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;byte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int8&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int8&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;unsigned int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Byte},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Byte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, byte&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;byte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, byte&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Byte&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.Byte&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Byte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Byte},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Byte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,double&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,double&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;double&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float64&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, float64&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;float64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Double},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Double})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, double&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;double&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, double&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Double&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.Double&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Double&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Double},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Double}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,short&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,short&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;short&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int16&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int16&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Int16},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Int16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, int16&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;int16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, int16&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int16&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.Int16&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Int16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Int16},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,int&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,int&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;int&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int32&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int32&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Int32},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Int32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, int&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;int&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, int&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int32&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.Int32&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Int32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Int32},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,long&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,long&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;long&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int64&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int64&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Int64},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Int64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, int64&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;int64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, int64&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int64&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.Int64&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Int64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Int64},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,sbyte&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,sbyte&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;sbyte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int8&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int8&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.SByte},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.SByte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, sbyte&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;sbyte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, sbyte&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.SByte&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.SByte&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.SByte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.SByte},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.SByte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,float&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,float&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;float&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float32&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, float32&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;float32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Single},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Single})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, single&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;single&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, single&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Single&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.Single&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Single&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Single},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Single}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,string&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,string&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, string&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, string&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.String},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.ReadOnlyMemory{System.Char}})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, string&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, string&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.String&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.String&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because the empty string is never entered into the dictionary, it will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.String},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,ushort&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,ushort&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ushort&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int16&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int16&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;unsigned int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.UInt16},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.UInt16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, uint16&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;uint16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, uint16&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt16&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.UInt16&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.UInt16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.UInt16},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,uint&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,uint&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;uint&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int32&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int32&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;unsigned int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.UInt32},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.UInt32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, uint32&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;uint32&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, uint32&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt32&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.UInt32&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.UInt32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.UInt32},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Key`2" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Key&lt;uint,ulong&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Key&lt;T,ulong&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ulong&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int64&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int64&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;unsigned int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.UInt64},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.UInt64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Key&lt;'T, uint64&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;uint64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Key&lt;uint32, uint64&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt64&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Key&lt;T,System.UInt64&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.UInt64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.UInt64},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,bool&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,bool&gt;&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;bool&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, bool&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, bool&gt;&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;bool&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Boolean}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Boolean})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, bool&gt;&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;bool&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, bool&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Boolean&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Boolean&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Boolean&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Boolean}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Boolean}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,byte&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,byte&gt;&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;byte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int8&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int8&gt;&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;unsigned int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Byte}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Byte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, byte&gt;&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;byte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, byte&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Byte&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Byte&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Byte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Byte}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Byte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,double&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,double&gt;&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;double&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float64&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, float64&gt;&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;float64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Double}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Double})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, double&gt;&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;double&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, double&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Double&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Double&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Double&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Double}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Double}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,short&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,short&gt;&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;short&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int16&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int16&gt;&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Int16}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Int16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, int16&gt;&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;int16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int16&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int16&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Int16&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Int16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Int16}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,int&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,int&gt;&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;int&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int32&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int32&gt;&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Int32}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Int32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, int&gt;&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;int&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int32&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Int32&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Int32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Int32}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,long&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,long&gt;&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;long&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int64&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int64&gt;&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Int64}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Int64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, int64&gt;&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;int64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int64&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int64&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Int64&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Int64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Int64}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,sbyte&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,sbyte&gt;&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;sbyte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int8&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int8&gt;&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.SByte}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.SByte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, sbyte&gt;&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;sbyte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, sbyte&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.SByte&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.SByte&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.SByte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.SByte}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.SByte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,float&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,float&gt;&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;float&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float32&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, float32&gt;&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;float32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Single}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Single})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, single&gt;&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;single&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, single&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Single&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Single&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Single&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Single}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Single}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,string&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,string&gt;&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, string&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, string&gt;&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.String}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.ReadOnlyMemory{System.Char}})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, string&gt;&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, string&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.String&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.String&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because the empty string is never entered into the dictionary, it will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.String}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,ushort&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,ushort&gt;&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ushort&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int16&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int16&gt;&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;unsigned int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.UInt16}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.UInt16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, uint16&gt;&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;uint16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint16&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt16&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.UInt16&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.UInt16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.UInt16}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,uint&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,uint&gt;&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;uint&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int32&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int32&gt;&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;unsigned int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.UInt32}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.UInt32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, uint32&gt;&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;uint32&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint32&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt32&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.UInt32&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.UInt32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.UInt32}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,ulong&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,ulong&gt;&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ulong&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int64&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int64&gt;&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;unsigned int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.UInt64}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.UInt64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, uint64&gt;&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;uint64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint64&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt64&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.UInt64&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.UInt64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.UInt64}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,bool&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,bool&gt;&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;bool&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, bool&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, bool&gt;&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;bool&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Boolean}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Boolean})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, bool&gt;&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;bool&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, bool&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Boolean&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Boolean&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Boolean&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Boolean}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Boolean}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,byte&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,byte&gt;&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;byte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int8&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int8&gt;&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;unsigned int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Byte}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Byte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, byte&gt;&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;byte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, byte&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Byte&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Byte&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Byte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Byte}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Byte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,double&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,double&gt;&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;double&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float64&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, float64&gt;&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;float64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Double}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Double})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, double&gt;&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;double&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, double&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Double&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Double&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Double&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Double}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Double}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,short&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,short&gt;&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;short&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int16&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int16&gt;&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Int16}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Int16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, int16&gt;&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;int16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int16&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int16&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Int16&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Int16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Int16}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,int&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,int&gt;&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;int&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int32&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int32&gt;&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Int32}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Int32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, int&gt;&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;int&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int32&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Int32&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Int32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Int32}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,long&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,long&gt;&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;long&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int64&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int64&gt;&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Int64}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Int64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, int64&gt;&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;int64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, int64&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Int64&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Int64&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Int64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Int64}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,sbyte&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,sbyte&gt;&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;sbyte&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, int8&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, int8&gt;&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;int8&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.SByte}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.SByte})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, sbyte&gt;&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;sbyte&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, sbyte&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.SByte&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.SByte&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.SByte&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.SByte}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.SByte}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,float&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,float&gt;&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;float&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, float32&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, float32&gt;&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;float32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Single}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.Single})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, single&gt;&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;single&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, single&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.Single&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.Single&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.Single&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Single}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Single}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,string&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,string&gt;&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, string&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, string&gt;&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;valuetype System.ReadOnlyMemory`1&lt;char&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.String}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.ReadOnlyMemory{System.Char}})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, string&gt;&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ReadOnlyMemory&lt;char&gt;&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, string&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.String&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.String&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.ReadOnlyMemory&lt;System.Char&gt;&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because the empty string is never entered into the dictionary, it will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.String}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,ushort&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,ushort&gt;&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ushort&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int16&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int16&gt;&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;unsigned int16&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.UInt16}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.UInt16})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, uint16&gt;&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;uint16&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint16&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt16&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.UInt16&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.UInt16&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.UInt16}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt16}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,uint&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,uint&gt;&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;uint&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int32&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int32&gt;&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;unsigned int32&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.UInt32}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.UInt32})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, uint32&gt;&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;uint32&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint32&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt32&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.UInt32&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.UInt32&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.UInt32}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt32}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToKey&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,ulong&gt;&gt; ToKey&lt;T&gt; (this Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,ulong&gt;&gt; input, Microsoft.ML.Runtime.Data.KeyValueOrder order = Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence, int maxItems = 1000000, Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;ulong&gt;.OnFit onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, unsigned int64&gt;&gt; ToKey&lt;T&gt;(class Microsoft.ML.StaticPipe.Vector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;!!T, unsigned int64&gt;&gt; input, valuetype Microsoft.ML.Runtime.Data.KeyValueOrder order, int32 maxItems, class Microsoft.ML.Runtime.Data.ToKeyFitResult`1/OnFit&lt;unsigned int64&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.UInt64}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit{System.UInt64})" />
        <MemberSignature Language="F#" Value="static member ToKey : Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;'T, uint64&gt;&gt; * Microsoft.ML.Runtime.Data.KeyValueOrder * int * Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;uint64&gt;.OnFit -&gt; Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, uint64&gt;&gt;" Usage="Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey (input, order, maxItems, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.UInt64&gt;&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;Microsoft.ML.StaticPipe.Key&lt;T,System.UInt64&gt;&gt;" RefType="this" />
          <Parameter Name="order" Type="Microsoft.ML.Runtime.Data.KeyValueOrder" />
          <Parameter Name="maxItems" Type="System.Int32" />
          <Parameter Name="onFit" Type="Microsoft.ML.Runtime.Data.ToKeyFitResult&lt;System.UInt64&gt;+OnFit" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">The input column.</param>
          <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
          <param name="maxItems">The maximum number of items.</param>
          <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
          <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TermStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.UInt64}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt64}.OnFit)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="FeaturizeText">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; FeaturizeText (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, Microsoft.ML.StaticPipe.Scalar&lt;string&gt;[] otherInputs = null, Action&lt;Microsoft.ML.Runtime.Data.TextTransform.Settings&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; FeaturizeText(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt;[] otherInputs, class System.Action`1&lt;class Microsoft.ML.Runtime.Data.TextTransform/Settings&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TextFeaturizerStaticPipe.FeaturizeText(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.StaticPipe.Scalar{System.String}[],System.Action{Microsoft.ML.Runtime.Data.TextTransform.Settings})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FeaturizeText (input As Scalar(Of String), Optional otherInputs As Scalar(Of String)() = null, Optional advancedSettings As Action(Of TextTransform.Settings) = null) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member FeaturizeText : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * Microsoft.ML.StaticPipe.Scalar&lt;string&gt;[] * Action&lt;Microsoft.ML.Runtime.Data.TextTransform.Settings&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.TextFeaturizerStaticPipe.FeaturizeText (input, otherInputs, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="otherInputs" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;[]" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Runtime.Data.TextTransform+Settings&gt;" />
        </Parameters>
        <Docs>
          <param name="input">Input data.</param>
          <param name="otherInputs">Additional data.</param>
          <param name="advancedSettings">Delegate which allows you to set transformation settings.</param>
          <summary>
            Accept text data and converts it to array which represent combinations of ngram/skip-gram token counts.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TextFeaturizerStaticPipe" Member="M:Microsoft.ML.Runtime.Data.TextFeaturizerStaticPipe.FeaturizeText(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.StaticPipe.Scalar{System.String}[],System.Action{Microsoft.ML.Runtime.Data.TextTransform.Settings})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.ITransformer" />
      </Targets>
      <Member MemberName="SaveTo">
        <MemberSignature Language="C#" Value="public static void SaveTo (this Microsoft.ML.Core.Data.ITransformer transformer, Microsoft.ML.Runtime.IHostEnvironment env, System.IO.Stream outputStream);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SaveTo(class Microsoft.ML.Core.Data.ITransformer transformer, class Microsoft.ML.Runtime.IHostEnvironment env, class System.IO.Stream outputStream) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TransformerChain.SaveTo(Microsoft.ML.Core.Data.ITransformer,Microsoft.ML.Runtime.IHostEnvironment,System.IO.Stream)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub SaveTo (transformer As ITransformer, env As IHostEnvironment, outputStream As Stream)" />
        <MemberSignature Language="F#" Value="static member SaveTo : Microsoft.ML.Core.Data.ITransformer * Microsoft.ML.Runtime.IHostEnvironment * System.IO.Stream -&gt; unit" Usage="Microsoft.ML.Runtime.Data.TransformerChain.SaveTo (transformer, env, outputStream)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="transformer" Type="Microsoft.ML.Core.Data.ITransformer" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
          <Parameter Name="outputStream" Type="System.IO.Stream" />
        </Parameters>
        <Docs>
          <param name="transformer">To be added.</param>
          <param name="env">To be added.</param>
          <param name="outputStream">To be added.</param>
          <summary>
            Save any transformer to a stream by wrapping it into a transformer chain.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TransformerChain" Member="M:Microsoft.ML.Runtime.Data.TransformerChain.SaveTo(Microsoft.ML.Core.Data.ITransformer,Microsoft.ML.Runtime.IHostEnvironment,System.IO.Stream)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.ISlotCursor" />
      </Targets>
      <Member MemberName="GetGetterWithVectorType&lt;TValue&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.ValueGetter&lt;TValue&gt; GetGetterWithVectorType&lt;TValue&gt; (this Microsoft.ML.Runtime.Data.ISlotCursor cursor, Microsoft.ML.Runtime.IExceptionContext ctx = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.ValueGetter`1&lt;!!TValue&gt; GetGetterWithVectorType&lt;TValue&gt;(class Microsoft.ML.Runtime.Data.ISlotCursor cursor, class Microsoft.ML.Runtime.IExceptionContext ctx) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TransposerUtils.GetGetterWithVectorType``1(Microsoft.ML.Runtime.Data.ISlotCursor,Microsoft.ML.Runtime.IExceptionContext)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetGetterWithVectorType(Of TValue) (cursor As ISlotCursor, Optional ctx As IExceptionContext = null) As ValueGetter(Of TValue)" />
        <MemberSignature Language="F#" Value="static member GetGetterWithVectorType : Microsoft.ML.Runtime.Data.ISlotCursor * Microsoft.ML.Runtime.IExceptionContext -&gt; Microsoft.ML.Runtime.Data.ValueGetter&lt;'Value&gt;" Usage="Microsoft.ML.Runtime.Data.TransposerUtils.GetGetterWithVectorType (cursor, ctx)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.ValueGetter&lt;TValue&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="cursor" Type="Microsoft.ML.Runtime.Data.ISlotCursor" RefType="this" />
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.IExceptionContext" />
        </Parameters>
        <Docs>
          <typeparam name="TValue">The type, must be a <see cref="T:Microsoft.ML.Runtime.Data.VBuffer`1" /> generic type,
            though enforcement of this has to be done only at runtime for practical reasons</typeparam>
          <param name="cursor">The cursor to get the getter for</param>
          <param name="ctx">The exception contxt</param>
          <summary>
            The <see cref="M:Microsoft.ML.Runtime.Data.ISlotCursor.GetGetter``1" /> is parameterized by a type that becomes the
            type parameter for a <see cref="T:Microsoft.ML.Runtime.Data.VBuffer`1" />, and this is generally preferable and more
            sensible but for various reasons it's often a lot simpler to have a get-getter be over
            the actual type returned by the getter, that is, parameterize this by the actual
            <see cref="T:Microsoft.ML.Runtime.Data.VBuffer`1" /> type.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TransposerUtils" Member="M:Microsoft.ML.Runtime.Data.TransposerUtils.GetGetterWithVectorType``1(Microsoft.ML.Runtime.Data.ISlotCursor,Microsoft.ML.Runtime.IExceptionContext)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.ITransposeDataView" />
      </Targets>
      <Member MemberName="GetSingleSlotValue&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static void GetSingleSlotValue&lt;T&gt; (this Microsoft.ML.Runtime.Data.ITransposeDataView view, int col, ref Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt; dst);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetSingleSlotValue&lt;T&gt;(class Microsoft.ML.Runtime.Data.ITransposeDataView view, int32 col, valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;!!T&gt;&amp; dst) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.TransposerUtils.GetSingleSlotValue``1(Microsoft.ML.Runtime.Data.ITransposeDataView,System.Int32,Microsoft.ML.Runtime.Data.VBuffer{``0}@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub GetSingleSlotValue(Of T) (view As ITransposeDataView, col As Integer, ByRef dst As VBuffer(Of T))" />
        <MemberSignature Language="F#" Value="static member GetSingleSlotValue : Microsoft.ML.Runtime.Data.ITransposeDataView * int *  -&gt; unit" Usage="Microsoft.ML.Runtime.Data.TransposerUtils.GetSingleSlotValue (view, col, dst)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="view" Type="Microsoft.ML.Runtime.Data.ITransposeDataView" RefType="this" />
          <Parameter Name="col" Type="System.Int32" />
          <Parameter Name="dst" Type="Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt;" RefType="ref" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="view">To be added.</param>
          <param name="col">To be added.</param>
          <param name="dst">To be added.</param>
          <summary>
            This is a convenience method that extracts a single slot value's vector,
            while simultaneously verifying that there is exactly one value.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.TransposerUtils" Member="M:Microsoft.ML.Runtime.Data.TransposerUtils.GetSingleSlotValue``1(Microsoft.ML.Runtime.Data.ITransposeDataView,System.Int32,Microsoft.ML.Runtime.Data.VBuffer{``0}@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="WordEmbeddings">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; WordEmbeddings (this Microsoft.ML.StaticPipe.VarVector&lt;string&gt; input, Microsoft.ML.Runtime.Data.WordEmbeddingsTransform.PretrainedModelKind modelKind = Microsoft.ML.Runtime.Data.WordEmbeddingsTransform+PretrainedModelKind.Sswe);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; WordEmbeddings(class Microsoft.ML.StaticPipe.VarVector`1&lt;string&gt; input, valuetype Microsoft.ML.Runtime.Data.WordEmbeddingsTransform/PretrainedModelKind modelKind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.WordEmbeddingsStaticExtensions.WordEmbeddings(Microsoft.ML.StaticPipe.VarVector{System.String},Microsoft.ML.Runtime.Data.WordEmbeddingsTransform.PretrainedModelKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WordEmbeddings (input As VarVector(Of String), Optional modelKind As WordEmbeddingsTransform.PretrainedModelKind = Microsoft.ML.Runtime.Data.WordEmbeddingsTransform+PretrainedModelKind.Sswe) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member WordEmbeddings : Microsoft.ML.StaticPipe.VarVector&lt;string&gt; * Microsoft.ML.Runtime.Data.WordEmbeddingsTransform.PretrainedModelKind -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.WordEmbeddingsStaticExtensions.WordEmbeddings (input, modelKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.String&gt;" RefType="this" />
          <Parameter Name="modelKind" Type="Microsoft.ML.Runtime.Data.WordEmbeddingsTransform+PretrainedModelKind" />
        </Parameters>
        <Docs>
          <param name="input">Vector of tokenized text.</param>
          <param name="modelKind">The pretrained word embedding model.</param>
          <summary>
        Word Embeddings transform is a text featurizer which converts vectors of text tokens into sentence vectors using a pre-trained model.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.WordEmbeddingsStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.WordEmbeddingsStaticExtensions.WordEmbeddings(Microsoft.ML.StaticPipe.VarVector{System.String},Microsoft.ML.Runtime.Data.WordEmbeddingsTransform.PretrainedModelKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="WordEmbeddings">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; WordEmbeddings (this Microsoft.ML.StaticPipe.VarVector&lt;string&gt; input, string customModelFile);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; WordEmbeddings(class Microsoft.ML.StaticPipe.VarVector`1&lt;string&gt; input, string customModelFile) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Data.WordEmbeddingsStaticExtensions.WordEmbeddings(Microsoft.ML.StaticPipe.VarVector{System.String},System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WordEmbeddings (input As VarVector(Of String), customModelFile As String) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member WordEmbeddings : Microsoft.ML.StaticPipe.VarVector&lt;string&gt; * string -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Runtime.Data.WordEmbeddingsStaticExtensions.WordEmbeddings (input, customModelFile)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.String&gt;" RefType="this" />
          <Parameter Name="customModelFile" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="input">Vector of tokenized text.</param>
          <param name="customModelFile">The custom word embedding model file.</param>
          <summary>
        Word Embeddings transform is a text featurizer which converts vectors of text tokens into sentence vectors using a pre-trained model.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Data.WordEmbeddingsStaticExtensions" Member="M:Microsoft.ML.Runtime.Data.WordEmbeddingsStaticExtensions.WordEmbeddings(Microsoft.ML.StaticPipe.VarVector{System.String},System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.EntryPoints.Optional`1" />
      </Targets>
      <Member MemberName="AsNullable&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Nullable&lt;T&gt; AsNullable&lt;T&gt; (this Microsoft.ML.Runtime.EntryPoints.Optional&lt;T&gt; opt) where T : struct;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;!!T&gt; AsNullable&lt;struct .ctor (class System.ValueType) T&gt;(class Microsoft.ML.Runtime.EntryPoints.Optional`1&lt;!!T&gt; opt) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.EntryPoints.EntryPointUtils.AsNullable``1(Microsoft.ML.Runtime.EntryPoints.Optional{``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsNullable(Of T As Structure) (opt As Optional(Of T)) As Nullable(Of T)" />
        <MemberSignature Language="F#" Value="static member AsNullable : Microsoft.ML.Runtime.EntryPoints.Optional&lt;'T (requires 'T : struct)&gt; -&gt; Nullable&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="Microsoft.ML.Runtime.EntryPoints.EntryPointUtils.AsNullable opt" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Nullable&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
              <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
              <BaseTypeName>System.ValueType</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="opt" Type="Microsoft.ML.Runtime.EntryPoints.Optional&lt;T&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="opt">To be added.</param>
          <summary>
            Converts EntryPoint Optional{T} types into nullable types, with the
            implicit value being converted to the null value.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.EntryPoints.EntryPointUtils" Member="M:Microsoft.ML.Runtime.EntryPoints.EntryPointUtils.AsNullable``1(Microsoft.ML.Runtime.EntryPoints.Optional{``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.EntryPoints.TlcModule.RangeAttribute" />
      </Targets>
      <Member MemberName="IsValueWithinRange">
        <MemberSignature Language="C#" Value="public static bool IsValueWithinRange (this Microsoft.ML.Runtime.EntryPoints.TlcModule.RangeAttribute range, object val);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsValueWithinRange(class Microsoft.ML.Runtime.EntryPoints.TlcModule/RangeAttribute range, object val) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.EntryPoints.EntryPointUtils.IsValueWithinRange(Microsoft.ML.Runtime.EntryPoints.TlcModule.RangeAttribute,System.Object)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsValueWithinRange (range As TlcModule.RangeAttribute, val As Object) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsValueWithinRange : Microsoft.ML.Runtime.EntryPoints.TlcModule.RangeAttribute * obj -&gt; bool" Usage="Microsoft.ML.Runtime.EntryPoints.EntryPointUtils.IsValueWithinRange (range, val)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="range" Type="Microsoft.ML.Runtime.EntryPoints.TlcModule+RangeAttribute" RefType="this" />
          <Parameter Name="val" Type="System.Object" />
        </Parameters>
        <Docs>
          <param name="range">To be added.</param>
          <param name="val">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.EntryPoints.EntryPointUtils" Member="M:Microsoft.ML.Runtime.EntryPoints.EntryPointUtils.IsValueWithinRange(Microsoft.ML.Runtime.EntryPoints.TlcModule.RangeAttribute,System.Object)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IHostEnvironment" />
      </Targets>
      <Member MemberName="CreateExperiment">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Experiment CreateExperiment (this Microsoft.ML.Runtime.IHostEnvironment env);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Experiment CreateExperiment(class Microsoft.ML.Runtime.IHostEnvironment env) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.ExperimentUtils.CreateExperiment(Microsoft.ML.Runtime.IHostEnvironment)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateExperiment (env As IHostEnvironment) As Experiment" />
        <MemberSignature Language="F#" Value="static member CreateExperiment : Microsoft.ML.Runtime.IHostEnvironment -&gt; Microsoft.ML.Runtime.Experiment" Usage="Microsoft.ML.Runtime.ExperimentUtils.CreateExperiment env" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Experiment</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" RefType="this" />
        </Parameters>
        <Docs>
          <param name="env">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.ExperimentUtils" Member="M:Microsoft.ML.Runtime.ExperimentUtils.CreateExperiment(Microsoft.ML.Runtime.IHostEnvironment)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Array" />
      </Targets>
      <Member MemberName="ArgMax&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static int ArgMax&lt;T&gt; (this T[] arr) where T : IComparable&lt;T&gt;;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ArgMax&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(!!T[] arr) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMax``1(``0[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ArgMax(Of T As IComparable(Of T)) (arr As T()) As Integer" />
        <MemberSignature Language="F#" Value="static member ArgMax : 'T[] -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMax arr" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="arr" Type="T[]" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="arr">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMax``1(``0[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Array" />
      </Targets>
      <Member MemberName="ArgMax&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static int ArgMax&lt;T&gt; (this T[] arr, int prefix) where T : IComparable&lt;T&gt;;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ArgMax&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(!!T[] arr, int32 prefix) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMax``1(``0[],System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ArgMax(Of T As IComparable(Of T)) (arr As T(), prefix As Integer) As Integer" />
        <MemberSignature Language="F#" Value="static member ArgMax : 'T[] * int -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMax (arr, prefix)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="arr" Type="T[]" RefType="this" />
          <Parameter Name="prefix" Type="System.Int32" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="arr">To be added.</param>
          <param name="prefix">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMax``1(``0[],System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IEnumerable`1" />
      </Targets>
      <Member MemberName="ArgMax&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static int ArgMax&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; e) where T : IComparable&lt;T&gt;;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ArgMax&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; e) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMax``1(System.Collections.Generic.IEnumerable{``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ArgMax(Of T As IComparable(Of T)) (e As IEnumerable(Of T)) As Integer" />
        <MemberSignature Language="F#" Value="static member ArgMax : seq&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMax e" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="e" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="e">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMax``1(System.Collections.Generic.IEnumerable{``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IEnumerable`1" />
      </Targets>
      <Member MemberName="ArgMax&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static int ArgMax&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; e, int prefix) where T : IComparable&lt;T&gt;;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ArgMax&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; e, int32 prefix) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMax``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ArgMax(Of T As IComparable(Of T)) (e As IEnumerable(Of T), prefix As Integer) As Integer" />
        <MemberSignature Language="F#" Value="static member ArgMax : seq&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; * int -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMax (e, prefix)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="e" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
          <Parameter Name="prefix" Type="System.Int32" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="e">To be added.</param>
          <param name="prefix">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMax``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IEnumerable`1" />
      </Targets>
      <Member MemberName="ArgMaxRand&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static int ArgMaxRand&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; e, int prefix, Random rnd, double fraction) where T : IComparable&lt;T&gt;;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ArgMaxRand&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; e, int32 prefix, class System.Random rnd, float64 fraction) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMaxRand``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Random,System.Double)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ArgMaxRand(Of T As IComparable(Of T)) (e As IEnumerable(Of T), prefix As Integer, rnd As Random, fraction As Double) As Integer" />
        <MemberSignature Language="F#" Value="static member ArgMaxRand : seq&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; * int * Random * double -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMaxRand (e, prefix, rnd, fraction)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="e" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
          <Parameter Name="prefix" Type="System.Int32" />
          <Parameter Name="rnd" Type="System.Random" />
          <Parameter Name="fraction" Type="System.Double" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="e">To be added.</param>
          <param name="prefix">To be added.</param>
          <param name="rnd">To be added.</param>
          <param name="fraction">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMaxRand``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Random,System.Double)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IEnumerable`1" />
      </Targets>
      <Member MemberName="ArgMaxRand&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static int ArgMaxRand&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; e, Random rnd, double fraction) where T : IComparable&lt;T&gt;;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ArgMaxRand&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; e, class System.Random rnd, float64 fraction) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMaxRand``1(System.Collections.Generic.IEnumerable{``0},System.Random,System.Double)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ArgMaxRand(Of T As IComparable(Of T)) (e As IEnumerable(Of T), rnd As Random, fraction As Double) As Integer" />
        <MemberSignature Language="F#" Value="static member ArgMaxRand : seq&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; * Random * double -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMaxRand (e, rnd, fraction)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="e" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
          <Parameter Name="rnd" Type="System.Random" />
          <Parameter Name="fraction" Type="System.Double" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="e">To be added.</param>
          <param name="rnd">To be added.</param>
          <param name="fraction">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMaxRand``1(System.Collections.Generic.IEnumerable{``0},System.Random,System.Double)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Array" />
      </Targets>
      <Member MemberName="ArgMin&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static int ArgMin&lt;T&gt; (this T[] arr) where T : IComparable&lt;T&gt;;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ArgMin&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(!!T[] arr) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMin``1(``0[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ArgMin(Of T As IComparable(Of T)) (arr As T()) As Integer" />
        <MemberSignature Language="F#" Value="static member ArgMin : 'T[] -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMin arr" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="arr" Type="T[]" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="arr">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMin``1(``0[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Array" />
      </Targets>
      <Member MemberName="ArgMin&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static int ArgMin&lt;T&gt; (this T[] arr, int prefix) where T : IComparable&lt;T&gt;;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ArgMin&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(!!T[] arr, int32 prefix) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMin``1(``0[],System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ArgMin(Of T As IComparable(Of T)) (arr As T(), prefix As Integer) As Integer" />
        <MemberSignature Language="F#" Value="static member ArgMin : 'T[] * int -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMin (arr, prefix)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="arr" Type="T[]" RefType="this" />
          <Parameter Name="prefix" Type="System.Int32" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="arr">To be added.</param>
          <param name="prefix">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMin``1(``0[],System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IEnumerable`1" />
      </Targets>
      <Member MemberName="ArgMin&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static int ArgMin&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; e) where T : IComparable&lt;T&gt;;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ArgMin&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; e) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMin``1(System.Collections.Generic.IEnumerable{``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ArgMin(Of T As IComparable(Of T)) (e As IEnumerable(Of T)) As Integer" />
        <MemberSignature Language="F#" Value="static member ArgMin : seq&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMin e" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="e" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="e">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMin``1(System.Collections.Generic.IEnumerable{``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IEnumerable`1" />
      </Targets>
      <Member MemberName="ArgMin&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static int ArgMin&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; e, int prefix) where T : IComparable&lt;T&gt;;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ArgMin&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; e, int32 prefix) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMin``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ArgMin(Of T As IComparable(Of T)) (e As IEnumerable(Of T), prefix As Integer) As Integer" />
        <MemberSignature Language="F#" Value="static member ArgMin : seq&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; * int -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMin (e, prefix)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="e" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
          <Parameter Name="prefix" Type="System.Int32" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="e">To be added.</param>
          <param name="prefix">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ArgMin``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IEnumerable`1" />
      </Targets>
      <Member MemberName="CumulativeSum&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;int&gt; CumulativeSum&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;int&gt; s);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;int32&gt; CumulativeSum&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; s) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.CumulativeSum``1(System.Collections.Generic.IEnumerable{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Iterator Function CumulativeSum(Of T) (s As IEnumerable(Of Integer)) As IEnumerable(Of Integer)" />
        <MemberSignature Language="F#" Value="static member CumulativeSum : seq&lt;int&gt; -&gt; seq&lt;int&gt;" Usage="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.CumulativeSum s" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Int32&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="s" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="s">To be added.</param>
          <summary>
            RunningLength. Converts sequence like 1, 2, 3, 4
            to  1, 3, 6, 10
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.CumulativeSum``1(System.Collections.Generic.IEnumerable{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IEnumerable`1" />
      </Targets>
      <Member MemberName="MergeSortedList&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; MergeSortedList&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; s1, System.Collections.Generic.IEnumerable&lt;T&gt; s2) where T : IComparable&lt;T&gt;;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; MergeSortedList&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; s1, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; s2) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.MergeSortedList``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Iterator Function MergeSortedList(Of T As IComparable(Of T)) (s1 As IEnumerable(Of T), s2 As IEnumerable(Of T)) As IEnumerable(Of T)" />
        <MemberSignature Language="F#" Value="static member MergeSortedList : seq&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; * seq&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; -&gt; seq&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.MergeSortedList (s1, s2)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Constraints>
              <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="s1" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
          <Parameter Name="s2" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="s1">To be added.</param>
          <param name="s2">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.MergeSortedList``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IEnumerable`1" />
      </Targets>
      <Member MemberName="SoftArgMax">
        <MemberSignature Language="C#" Value="public static int SoftArgMax (this System.Collections.Generic.IEnumerable&lt;double&gt; values, Random rand);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SoftArgMax(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; values, class System.Random rand) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.SoftArgMax(System.Collections.Generic.IEnumerable{System.Double},System.Random)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SoftArgMax (values As IEnumerable(Of Double), rand As Random) As Integer" />
        <MemberSignature Language="F#" Value="static member SoftArgMax : seq&lt;double&gt; * Random -&gt; int" Usage="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.SoftArgMax (values, rand)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="rand" Type="System.Random" />
        </Parameters>
        <Docs>
          <param name="values">To be added.</param>
          <param name="rand">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.SoftArgMax(System.Collections.Generic.IEnumerable{System.Double},System.Random)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IEnumerable`1" />
      </Targets>
      <Member MemberName="ToArray&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static T[] ToArray&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; me, int length);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] ToArray&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; me, int32 length) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ToArray``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToArray(Of T) (me As IEnumerable(Of T), length As Integer) As T()" />
        <MemberSignature Language="F#" Value="static member ToArray : seq&lt;'T&gt; * int -&gt; 'T[]" Usage="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ToArray (me, length)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>T[]</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="me" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
          <Parameter Name="length" Type="System.Int32" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="me">To be added.</param>
          <param name="length">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.LinqExtensions.ToArray``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.Stream" />
      </Targets>
      <Member MemberName="ReadCompressed">
        <MemberSignature Language="C#" Value="public static byte[] ReadCompressed (this System.IO.Stream stream);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ReadCompressed(class System.IO.Stream stream) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.StreamExtensions.ReadCompressed(System.IO.Stream)" />
        <MemberSignature Language="F#" Value="static member ReadCompressed : System.IO.Stream -&gt; byte[]" Usage="Microsoft.ML.Runtime.FastTree.Internal.StreamExtensions.ReadCompressed stream" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Byte[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="stream" Type="System.IO.Stream" RefType="this" />
        </Parameters>
        <Docs>
          <param name="stream">The stream to read from</param>
          <summary>
            Reads a compressed array of byte from the stream (written by WriteCompressed)
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.StreamExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.StreamExtensions.ReadCompressed(System.IO.Stream)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.Stream" />
      </Targets>
      <Member MemberName="WriteCompressed">
        <MemberSignature Language="C#" Value="public static void WriteCompressed (this System.IO.Stream stream, byte[] array);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteCompressed(class System.IO.Stream stream, unsigned int8[] array) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.StreamExtensions.WriteCompressed(System.IO.Stream,System.Byte[])" />
        <MemberSignature Language="F#" Value="static member WriteCompressed : System.IO.Stream * byte[] -&gt; unit" Usage="Microsoft.ML.Runtime.FastTree.Internal.StreamExtensions.WriteCompressed (stream, array)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="stream" Type="System.IO.Stream" RefType="this" />
          <Parameter Name="array" Type="System.Byte[]" />
        </Parameters>
        <Docs>
          <param name="stream">Stream to write to</param>
          <param name="array">Array to write</param>
          <summary>
            Writes an array of bytes to the stream with compression
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.StreamExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.StreamExtensions.WriteCompressed(System.IO.Stream,System.Byte[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.Stream" />
      </Targets>
      <Member MemberName="WriteCompressed">
        <MemberSignature Language="C#" Value="public static void WriteCompressed (this System.IO.Stream stream, byte[] array, int offset, int count);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteCompressed(class System.IO.Stream stream, unsigned int8[] array, int32 offset, int32 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.StreamExtensions.WriteCompressed(System.IO.Stream,System.Byte[],System.Int32,System.Int32)" />
        <MemberSignature Language="F#" Value="static member WriteCompressed : System.IO.Stream * byte[] * int * int -&gt; unit" Usage="Microsoft.ML.Runtime.FastTree.Internal.StreamExtensions.WriteCompressed (stream, array, offset, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="stream" Type="System.IO.Stream" RefType="this" />
          <Parameter Name="array" Type="System.Byte[]" />
          <Parameter Name="offset" Type="System.Int32" />
          <Parameter Name="count" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="stream">Stream to write to</param>
          <param name="array">Array to write</param>
          <param name="offset">The byte offset into the array to write</param>
          <param name="count">The number of bytes from the array to write</param>
          <summary>
            Writes an array of bytes to the stream with compression
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.StreamExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.StreamExtensions.WriteCompressed(System.IO.Stream,System.Byte[],System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.FastTree.Internal.MD5Hash" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this Microsoft.ML.Runtime.FastTree.Internal.MD5Hash[] array);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(valuetype Microsoft.ML.Runtime.FastTree.Internal.MD5Hash[] array) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(Microsoft.ML.Runtime.FastTree.Internal.MD5Hash[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (array As MD5Hash()) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : Microsoft.ML.Runtime.FastTree.Internal.MD5Hash[] -&gt; int" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes array" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="array" Type="Microsoft.ML.Runtime.FastTree.Internal.MD5Hash[]" RefType="this" />
        </Parameters>
        <Docs>
          <param name="array">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(Microsoft.ML.Runtime.FastTree.Internal.MD5Hash[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this byte a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(unsigned int8 a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Byte)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As Byte) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : byte -&gt; int" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Byte" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Byte)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this byte[] a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(unsigned int8[] a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Byte[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As Byte()) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : byte[] -&gt; int" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Byte[]" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Byte[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Double" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this double a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(float64 a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Double)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As Double) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : double -&gt; int" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Double" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Double)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Double" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this double[] array);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(float64[] array) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Double[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (array As Double()) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : double[] -&gt; int" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes array" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="array" Type="System.Double[]" RefType="this" />
        </Parameters>
        <Docs>
          <param name="array">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Double[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Double" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this double[][] array);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(float64[][] array) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Double[][])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (array As Double()()) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : double[][] -&gt; int" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes array" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="array" Type="System.Double[][]" RefType="this" />
        </Parameters>
        <Docs>
          <param name="array">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Double[][])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int16" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this short a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(int16 a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Int16)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As Short) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : int16 -&gt; int" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Int16" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Int16)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int16" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this short[] a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(int16[] a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Int16[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As Short()) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : int16[] -&gt; int" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Int16[]" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Int16[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int32" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this int a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(int32 a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As Integer) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : int -&gt; int" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Int32" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int32" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this int[] array);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(int32[] array) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Int32[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (array As Integer()) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : int[] -&gt; int" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes array" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="array" Type="System.Int32[]" RefType="this" />
        </Parameters>
        <Docs>
          <param name="array">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Int32[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int64" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this long a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(int64 a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Int64)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As Long) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : int64 -&gt; int" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Int64" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Int64)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int64" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this long[] array);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(int64[] array) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Int64[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (array As Long()) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : int64[] -&gt; int" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes array" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="array" Type="System.Int64[]" RefType="this" />
        </Parameters>
        <Docs>
          <param name="array">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Int64[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Single" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this float a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(float32 a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Single)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As Single) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : single -&gt; int" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Single" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Single)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Single" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this float[] array);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(float32[] array) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Single[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (array As Single()) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : single[] -&gt; int" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes array" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="array" Type="System.Single[]" RefType="this" />
        </Parameters>
        <Docs>
          <param name="array">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.Single[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.String" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this string a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(string a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As String) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : string -&gt; int" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.String" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.String" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static long SizeInBytes (this string[] array);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 SizeInBytes(string[] array) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.String[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (array As String()) As Long" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : string[] -&gt; int64" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes array" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int64</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="array" Type="System.String[]" RefType="this" />
        </Parameters>
        <Docs>
          <param name="array">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.String[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.UInt16" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this ushort a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(unsigned int16 a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.UInt16)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As UShort) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : uint16 -&gt; int" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.UInt16" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.UInt16)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.UInt16" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this ushort[] a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(unsigned int16[] a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.UInt16[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As UShort()) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : uint16[] -&gt; int" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.UInt16[]" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.UInt16[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.UInt32" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this uint a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(unsigned int32 a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.UInt32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As UInteger) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : uint32 -&gt; int" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.UInt32" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.UInt32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.UInt32" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this uint[] array);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(unsigned int32[] array) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.UInt32[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (array As UInteger()) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : uint32[] -&gt; int" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes array" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="array" Type="System.UInt32[]" RefType="this" />
        </Parameters>
        <Docs>
          <param name="array">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.UInt32[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.UInt64" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this ulong a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(unsigned int64 a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.UInt64)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (a As ULong) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : uint64 -&gt; int" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.UInt64" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.UInt64)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.UInt64" />
      </Targets>
      <Member MemberName="SizeInBytes">
        <MemberSignature Language="C#" Value="public static int SizeInBytes (this ulong[] array);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeInBytes(unsigned int64[] array) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.UInt64[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SizeInBytes (array As ULong()) As Integer" />
        <MemberSignature Language="F#" Value="static member SizeInBytes : uint64[] -&gt; int" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes array" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="array" Type="System.UInt64[]" RefType="this" />
        </Parameters>
        <Docs>
          <param name="array">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.SizeInBytes(System.UInt64[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToByte">
        <MemberSignature Language="C#" Value="public static byte ToByte (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ToByte(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByte(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToByte (buffer As Byte(), ByRef position As Integer) As Byte" />
        <MemberSignature Language="F#" Value="static member ToByte : byte[] *  -&gt; byte" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByte (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Byte</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByte(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.FastTree.Internal.MD5Hash" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this Microsoft.ML.Runtime.FastTree.Internal.MD5Hash[] a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(valuetype Microsoft.ML.Runtime.FastTree.Internal.MD5Hash[] a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(Microsoft.ML.Runtime.FastTree.Internal.MD5Hash[],System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As MD5Hash(), buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : Microsoft.ML.Runtime.FastTree.Internal.MD5Hash[] * byte[] *  -&gt; unit" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="Microsoft.ML.Runtime.FastTree.Internal.MD5Hash[]" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(Microsoft.ML.Runtime.FastTree.Internal.MD5Hash[],System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this byte a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(unsigned int8 a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Byte,System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Byte, buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : byte * byte[] *  -&gt; unit" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Byte" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Byte,System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this byte[] a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(unsigned int8[] a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Byte[],System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Byte(), buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : byte[] * byte[] *  -&gt; unit" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Byte[]" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Byte[],System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static byte[] ToByteArray (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ToByteArray(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToByteArray (buffer As Byte(), ByRef position As Integer) As Byte()" />
        <MemberSignature Language="F#" Value="static member ToByteArray : byte[] *  -&gt; byte[]" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Byte[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Double" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this double a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(float64 a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Double,System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Double, buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : double * byte[] *  -&gt; unit" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Double" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Double,System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Double" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this double[] a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(float64[] a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Double[],System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Double(), buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : double[] * byte[] *  -&gt; unit" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Double[]" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Double[],System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Double" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this double[][] a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(float64[][] a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Double[][],System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Double()(), buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : double[][] * byte[] *  -&gt; unit" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Double[][]" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Double[][],System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int16" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this short a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(int16 a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Int16,System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Short, buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : int16 * byte[] *  -&gt; unit" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Int16" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Int16,System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int16" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this short[] a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(int16[] a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Int16[],System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Short(), buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : int16[] * byte[] *  -&gt; unit" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Int16[]" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Int16[],System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int32" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this int a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(int32 a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Int32,System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Integer, buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : int * byte[] *  -&gt; unit" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Int32" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Int32,System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int32" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this int[] a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(int32[] a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Int32[],System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Integer(), buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : int[] * byte[] *  -&gt; unit" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Int32[]" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Int32[],System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int64" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this long a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(int64 a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Int64,System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Long, buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : int64 * byte[] *  -&gt; unit" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Int64" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Int64,System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int64" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this long[] a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(int64[] a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Int64[],System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Long(), buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : int64[] * byte[] *  -&gt; unit" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Int64[]" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Int64[],System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Single" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this float a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(float32 a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Single,System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Single, buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : single * byte[] *  -&gt; unit" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Single" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Single,System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Single" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this float[] a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(float32[] a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Single[],System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As Single(), buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : single[] * byte[] *  -&gt; unit" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.Single[]" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.Single[],System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.String" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static byte[] ToByteArray (this string a);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ToByteArray(string a) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToByteArray (a As String) As Byte()" />
        <MemberSignature Language="F#" Value="static member ToByteArray : string -&gt; byte[]" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray a" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Byte[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.String" RefType="this" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.String" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this string a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(string a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.String,System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As String, buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : string * byte[] *  -&gt; unit" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.String" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.String,System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.String" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this string[] a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(string[] a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.String[],System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As String(), buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : string[] * byte[] *  -&gt; unit" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.String[]" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.String[],System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.UInt16" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this ushort a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(unsigned int16 a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.UInt16,System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As UShort, buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : uint16 * byte[] *  -&gt; unit" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.UInt16" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.UInt16,System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.UInt16" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this ushort[] a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(unsigned int16[] a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.UInt16[],System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As UShort(), buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : uint16[] * byte[] *  -&gt; unit" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.UInt16[]" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.UInt16[],System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.UInt32" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this uint a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(unsigned int32 a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.UInt32,System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As UInteger, buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : uint32 * byte[] *  -&gt; unit" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.UInt32" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.UInt32,System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.UInt32" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this uint[] a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(unsigned int32[] a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.UInt32[],System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As UInteger(), buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : uint32[] * byte[] *  -&gt; unit" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.UInt32[]" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.UInt32[],System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.UInt64" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this ulong a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(unsigned int64 a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.UInt64,System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As ULong, buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : uint64 * byte[] *  -&gt; unit" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.UInt64" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.UInt64,System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.UInt64" />
      </Targets>
      <Member MemberName="ToByteArray">
        <MemberSignature Language="C#" Value="public static void ToByteArray (this ulong[] a, byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToByteArray(unsigned int64[] a, unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.UInt64[],System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToByteArray (a As ULong(), buffer As Byte(), ByRef position As Integer)" />
        <MemberSignature Language="F#" Value="static member ToByteArray : uint64[] * byte[] *  -&gt; unit" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray (a, buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="a" Type="System.UInt64[]" RefType="this" />
          <Parameter Name="buffer" Type="System.Byte[]" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="a">To be added.</param>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToByteArray(System.UInt64[],System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToDouble">
        <MemberSignature Language="C#" Value="public static double ToDouble (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ToDouble(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToDouble(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDouble (buffer As Byte(), ByRef position As Integer) As Double" />
        <MemberSignature Language="F#" Value="static member ToDouble : byte[] *  -&gt; double" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToDouble (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Double</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToDouble(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToDoubleArray">
        <MemberSignature Language="C#" Value="public static double[] ToDoubleArray (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64[] ToDoubleArray(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToDoubleArray(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDoubleArray (buffer As Byte(), ByRef position As Integer) As Double()" />
        <MemberSignature Language="F#" Value="static member ToDoubleArray : byte[] *  -&gt; double[]" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToDoubleArray (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Double[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToDoubleArray(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToDoubleJaggedArray">
        <MemberSignature Language="C#" Value="public static double[][] ToDoubleJaggedArray (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64[][] ToDoubleJaggedArray(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToDoubleJaggedArray(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDoubleJaggedArray (buffer As Byte(), ByRef position As Integer) As Double()()" />
        <MemberSignature Language="F#" Value="static member ToDoubleJaggedArray : byte[] *  -&gt; double[][]" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToDoubleJaggedArray (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Double[][]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToDoubleJaggedArray(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static float ToFloat (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ToFloat(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToFloat(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (buffer As Byte(), ByRef position As Integer) As Single" />
        <MemberSignature Language="F#" Value="static member ToFloat : byte[] *  -&gt; single" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToFloat (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Single</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToFloat(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToFloatArray">
        <MemberSignature Language="C#" Value="public static float[] ToFloatArray (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32[] ToFloatArray(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToFloatArray(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloatArray (buffer As Byte(), ByRef position As Integer) As Single()" />
        <MemberSignature Language="F#" Value="static member ToFloatArray : byte[] *  -&gt; single[]" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToFloatArray (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Single[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToFloatArray(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToInt">
        <MemberSignature Language="C#" Value="public static int ToInt (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToInt(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToInt(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToInt (buffer As Byte(), ByRef position As Integer) As Integer" />
        <MemberSignature Language="F#" Value="static member ToInt : byte[] *  -&gt; int" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToInt (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToInt(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToIntArray">
        <MemberSignature Language="C#" Value="public static int[] ToIntArray (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32[] ToIntArray(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToIntArray(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToIntArray (buffer As Byte(), ByRef position As Integer) As Integer()" />
        <MemberSignature Language="F#" Value="static member ToIntArray : byte[] *  -&gt; int[]" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToIntArray (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToIntArray(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToIntArray">
        <MemberSignature Language="C#" Value="public static int[] ToIntArray (this byte[] buffer, ref int position, int length);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32[] ToIntArray(unsigned int8[] buffer, int32&amp; position, int32 length) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToIntArray(System.Byte[],System.Int32@,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToIntArray (buffer As Byte(), ByRef position As Integer, length As Integer) As Integer()" />
        <MemberSignature Language="F#" Value="static member ToIntArray : byte[] *  * int -&gt; int[]" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToIntArray (buffer, position, length)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
          <Parameter Name="length" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <param name="length">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToIntArray(System.Byte[],System.Int32@,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToLong">
        <MemberSignature Language="C#" Value="public static long ToLong (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToLong(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToLong(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLong (buffer As Byte(), ByRef position As Integer) As Long" />
        <MemberSignature Language="F#" Value="static member ToLong : byte[] *  -&gt; int64" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToLong (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int64</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToLong(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToLongArray">
        <MemberSignature Language="C#" Value="public static long[] ToLongArray (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64[] ToLongArray(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToLongArray(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLongArray (buffer As Byte(), ByRef position As Integer) As Long()" />
        <MemberSignature Language="F#" Value="static member ToLongArray : byte[] *  -&gt; int64[]" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToLongArray (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int64[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToLongArray(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToShort">
        <MemberSignature Language="C#" Value="public static short ToShort (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ToShort(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToShort(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToShort (buffer As Byte(), ByRef position As Integer) As Short" />
        <MemberSignature Language="F#" Value="static member ToShort : byte[] *  -&gt; int16" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToShort (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int16</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToShort(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToShortArray">
        <MemberSignature Language="C#" Value="public static short[] ToShortArray (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16[] ToShortArray(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToShortArray(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToShortArray (buffer As Byte(), ByRef position As Integer) As Short()" />
        <MemberSignature Language="F#" Value="static member ToShortArray : byte[] *  -&gt; int16[]" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToShortArray (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int16[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToShortArray(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToString">
        <MemberSignature Language="C#" Value="public static string ToString (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToString(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToString (buffer As Byte(), ByRef position As Integer) As String" />
        <MemberSignature Language="F#" Value="static member ToString : byte[] *  -&gt; string" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToString (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToString(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToStringArray">
        <MemberSignature Language="C#" Value="public static string[] ToStringArray (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] ToStringArray(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToStringArray(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToStringArray (buffer As Byte(), ByRef position As Integer) As String()" />
        <MemberSignature Language="F#" Value="static member ToStringArray : byte[] *  -&gt; string[]" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToStringArray (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToStringArray(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToUInt">
        <MemberSignature Language="C#" Value="public static uint ToUInt (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ToUInt(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToUInt(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToUInt (buffer As Byte(), ByRef position As Integer) As UInteger" />
        <MemberSignature Language="F#" Value="static member ToUInt : byte[] *  -&gt; uint32" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToUInt (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.UInt32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToUInt(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToUInt128">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.FastTree.Internal.MD5Hash ToUInt128 (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.ML.Runtime.FastTree.Internal.MD5Hash ToUInt128(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToUInt128(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToUInt128 (buffer As Byte(), ByRef position As Integer) As MD5Hash" />
        <MemberSignature Language="F#" Value="static member ToUInt128 : byte[] *  -&gt; Microsoft.ML.Runtime.FastTree.Internal.MD5Hash" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToUInt128 (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.FastTree.Internal.MD5Hash</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToUInt128(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToUInt128Array">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.FastTree.Internal.MD5Hash[] ToUInt128Array (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.ML.Runtime.FastTree.Internal.MD5Hash[] ToUInt128Array(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToUInt128Array(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToUInt128Array (buffer As Byte(), ByRef position As Integer) As MD5Hash()" />
        <MemberSignature Language="F#" Value="static member ToUInt128Array : byte[] *  -&gt; Microsoft.ML.Runtime.FastTree.Internal.MD5Hash[]" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToUInt128Array (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.FastTree.Internal.MD5Hash[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToUInt128Array(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToUIntArray">
        <MemberSignature Language="C#" Value="public static uint[] ToUIntArray (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32[] ToUIntArray(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToUIntArray(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToUIntArray (buffer As Byte(), ByRef position As Integer) As UInteger()" />
        <MemberSignature Language="F#" Value="static member ToUIntArray : byte[] *  -&gt; uint32[]" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToUIntArray (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.UInt32[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToUIntArray(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToULong">
        <MemberSignature Language="C#" Value="public static ulong ToULong (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ToULong(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToULong(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToULong (buffer As Byte(), ByRef position As Integer) As ULong" />
        <MemberSignature Language="F#" Value="static member ToULong : byte[] *  -&gt; uint64" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToULong (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.UInt64</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToULong(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToULongArray">
        <MemberSignature Language="C#" Value="public static ulong[] ToULongArray (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64[] ToULongArray(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToULongArray(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToULongArray (buffer As Byte(), ByRef position As Integer) As ULong()" />
        <MemberSignature Language="F#" Value="static member ToULongArray : byte[] *  -&gt; uint64[]" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToULongArray (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.UInt64[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToULongArray(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToUShort">
        <MemberSignature Language="C#" Value="public static ushort ToUShort (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ToUShort(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToUShort(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToUShort (buffer As Byte(), ByRef position As Integer) As UShort" />
        <MemberSignature Language="F#" Value="static member ToUShort : byte[] *  -&gt; uint16" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToUShort (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.UInt16</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToUShort(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Byte" />
      </Targets>
      <Member MemberName="ToUShortArray">
        <MemberSignature Language="C#" Value="public static ushort[] ToUShortArray (this byte[] buffer, ref int position);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16[] ToUShortArray(unsigned int8[] buffer, int32&amp; position) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToUShortArray(System.Byte[],System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToUShortArray (buffer As Byte(), ByRef position As Integer) As UShort()" />
        <MemberSignature Language="F#" Value="static member ToUShortArray : byte[] *  -&gt; uint16[]" Usage="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToUShortArray (buffer, position)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.UInt16[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="buffer" Type="System.Byte[]" RefType="this" />
          <Parameter Name="position" Type="System.Int32" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="buffer">To be added.</param>
          <param name="position">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions" Member="M:Microsoft.ML.Runtime.FastTree.Internal.ToByteArrayExtensions.ToUShortArray(System.Byte[],System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IHost" />
      </Targets>
      <Member MemberName="Apply&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static T Apply&lt;T&gt; (this Microsoft.ML.Runtime.IHost host, string channelName, Func&lt;Microsoft.ML.Runtime.IChannel,T&gt; func);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Apply&lt;T&gt;(class Microsoft.ML.Runtime.IHost host, string channelName, class System.Func`2&lt;class Microsoft.ML.Runtime.IChannel, !!T&gt; func) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.HostExtensions.Apply``1(Microsoft.ML.Runtime.IHost,System.String,System.Func{Microsoft.ML.Runtime.IChannel,``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Apply(Of T) (host As IHost, channelName As String, func As Func(Of IChannel, T)) As T" />
        <MemberSignature Language="F#" Value="static member Apply : Microsoft.ML.Runtime.IHost * string * Func&lt;Microsoft.ML.Runtime.IChannel, 'T&gt; -&gt; 'T" Usage="Microsoft.ML.Runtime.HostExtensions.Apply (host, channelName, func)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>T</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="host" Type="Microsoft.ML.Runtime.IHost" RefType="this" />
          <Parameter Name="channelName" Type="System.String" />
          <Parameter Name="func" Type="System.Func&lt;Microsoft.ML.Runtime.IChannel,T&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="host">To be added.</param>
          <param name="channelName">To be added.</param>
          <param name="func">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.HostExtensions" Member="M:Microsoft.ML.Runtime.HostExtensions.Apply``1(Microsoft.ML.Runtime.IHost,System.String,System.Func{Microsoft.ML.Runtime.IChannel,``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IChannel" />
      </Targets>
      <Member MemberName="Error">
        <MemberSignature Language="C#" Value="public static void Error (this Microsoft.ML.Runtime.IChannel ch, string fmt);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Error(class Microsoft.ML.Runtime.IChannel ch, string fmt) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.HostExtensions.Error(Microsoft.ML.Runtime.IChannel,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Error (ch As IChannel, fmt As String)" />
        <MemberSignature Language="F#" Value="static member Error : Microsoft.ML.Runtime.IChannel * string -&gt; unit" Usage="Microsoft.ML.Runtime.HostExtensions.Error (ch, fmt)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ch" Type="Microsoft.ML.Runtime.IChannel" RefType="this" />
          <Parameter Name="fmt" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ch">To be added.</param>
          <param name="fmt">To be added.</param>
          <summary>
            Convenience variant of <see cref="M:Microsoft.ML.Runtime.IChannel.Error(Microsoft.ML.Runtime.MessageSensitivity,System.String)" />
            setting <see cref="F:Microsoft.ML.Runtime.MessageSensitivity.Unknown" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.HostExtensions" Member="M:Microsoft.ML.Runtime.HostExtensions.Error(Microsoft.ML.Runtime.IChannel,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IChannel" />
      </Targets>
      <Member MemberName="Error">
        <MemberSignature Language="C#" Value="public static void Error (this Microsoft.ML.Runtime.IChannel ch, string fmt, params object[] args);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Error(class Microsoft.ML.Runtime.IChannel ch, string fmt, object[] args) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.HostExtensions.Error(Microsoft.ML.Runtime.IChannel,System.String,System.Object[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Error (ch As IChannel, fmt As String, ParamArray args As Object())" />
        <MemberSignature Language="F#" Value="static member Error : Microsoft.ML.Runtime.IChannel * string * obj[] -&gt; unit" Usage="Microsoft.ML.Runtime.HostExtensions.Error (ch, fmt, args)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ch" Type="Microsoft.ML.Runtime.IChannel" RefType="this" />
          <Parameter Name="fmt" Type="System.String" />
          <Parameter Name="args" Type="System.Object[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="ch">To be added.</param>
          <param name="fmt">To be added.</param>
          <param name="args">To be added.</param>
          <summary>
            Convenience variant of <see cref="M:Microsoft.ML.Runtime.IChannel.Error(Microsoft.ML.Runtime.MessageSensitivity,System.String,System.Object[])" />
            setting <see cref="F:Microsoft.ML.Runtime.MessageSensitivity.Unknown" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.HostExtensions" Member="M:Microsoft.ML.Runtime.HostExtensions.Error(Microsoft.ML.Runtime.IChannel,System.String,System.Object[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IChannel" />
      </Targets>
      <Member MemberName="Info">
        <MemberSignature Language="C#" Value="public static void Info (this Microsoft.ML.Runtime.IChannel ch, string fmt);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Info(class Microsoft.ML.Runtime.IChannel ch, string fmt) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.HostExtensions.Info(Microsoft.ML.Runtime.IChannel,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Info (ch As IChannel, fmt As String)" />
        <MemberSignature Language="F#" Value="static member Info : Microsoft.ML.Runtime.IChannel * string -&gt; unit" Usage="Microsoft.ML.Runtime.HostExtensions.Info (ch, fmt)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ch" Type="Microsoft.ML.Runtime.IChannel" RefType="this" />
          <Parameter Name="fmt" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ch">To be added.</param>
          <param name="fmt">To be added.</param>
          <summary>
            Convenience variant of <see cref="M:Microsoft.ML.Runtime.IChannel.Info(Microsoft.ML.Runtime.MessageSensitivity,System.String)" />
            setting <see cref="F:Microsoft.ML.Runtime.MessageSensitivity.Unknown" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.HostExtensions" Member="M:Microsoft.ML.Runtime.HostExtensions.Info(Microsoft.ML.Runtime.IChannel,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IChannel" />
      </Targets>
      <Member MemberName="Info">
        <MemberSignature Language="C#" Value="public static void Info (this Microsoft.ML.Runtime.IChannel ch, string fmt, params object[] args);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Info(class Microsoft.ML.Runtime.IChannel ch, string fmt, object[] args) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.HostExtensions.Info(Microsoft.ML.Runtime.IChannel,System.String,System.Object[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Info (ch As IChannel, fmt As String, ParamArray args As Object())" />
        <MemberSignature Language="F#" Value="static member Info : Microsoft.ML.Runtime.IChannel * string * obj[] -&gt; unit" Usage="Microsoft.ML.Runtime.HostExtensions.Info (ch, fmt, args)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ch" Type="Microsoft.ML.Runtime.IChannel" RefType="this" />
          <Parameter Name="fmt" Type="System.String" />
          <Parameter Name="args" Type="System.Object[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="ch">To be added.</param>
          <param name="fmt">To be added.</param>
          <param name="args">To be added.</param>
          <summary>
            Convenience variant of <see cref="M:Microsoft.ML.Runtime.IChannel.Info(Microsoft.ML.Runtime.MessageSensitivity,System.String,System.Object[])" />
            setting <see cref="F:Microsoft.ML.Runtime.MessageSensitivity.Unknown" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.HostExtensions" Member="M:Microsoft.ML.Runtime.HostExtensions.Info(Microsoft.ML.Runtime.IChannel,System.String,System.Object[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IChannel" />
      </Targets>
      <Member MemberName="Trace">
        <MemberSignature Language="C#" Value="public static void Trace (this Microsoft.ML.Runtime.IChannel ch, string fmt);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Trace(class Microsoft.ML.Runtime.IChannel ch, string fmt) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.HostExtensions.Trace(Microsoft.ML.Runtime.IChannel,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Trace (ch As IChannel, fmt As String)" />
        <MemberSignature Language="F#" Value="static member Trace : Microsoft.ML.Runtime.IChannel * string -&gt; unit" Usage="Microsoft.ML.Runtime.HostExtensions.Trace (ch, fmt)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ch" Type="Microsoft.ML.Runtime.IChannel" RefType="this" />
          <Parameter Name="fmt" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ch">To be added.</param>
          <param name="fmt">To be added.</param>
          <summary>
            Convenience variant of <see cref="M:Microsoft.ML.Runtime.IChannel.Trace(Microsoft.ML.Runtime.MessageSensitivity,System.String)" />
            setting <see cref="F:Microsoft.ML.Runtime.MessageSensitivity.Unknown" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.HostExtensions" Member="M:Microsoft.ML.Runtime.HostExtensions.Trace(Microsoft.ML.Runtime.IChannel,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IChannel" />
      </Targets>
      <Member MemberName="Trace">
        <MemberSignature Language="C#" Value="public static void Trace (this Microsoft.ML.Runtime.IChannel ch, string fmt, params object[] args);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Trace(class Microsoft.ML.Runtime.IChannel ch, string fmt, object[] args) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.HostExtensions.Trace(Microsoft.ML.Runtime.IChannel,System.String,System.Object[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Trace (ch As IChannel, fmt As String, ParamArray args As Object())" />
        <MemberSignature Language="F#" Value="static member Trace : Microsoft.ML.Runtime.IChannel * string * obj[] -&gt; unit" Usage="Microsoft.ML.Runtime.HostExtensions.Trace (ch, fmt, args)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ch" Type="Microsoft.ML.Runtime.IChannel" RefType="this" />
          <Parameter Name="fmt" Type="System.String" />
          <Parameter Name="args" Type="System.Object[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="ch">To be added.</param>
          <param name="fmt">To be added.</param>
          <param name="args">To be added.</param>
          <summary>
            Convenience variant of <see cref="M:Microsoft.ML.Runtime.IChannel.Trace(Microsoft.ML.Runtime.MessageSensitivity,System.String,System.Object[])" />
            setting <see cref="F:Microsoft.ML.Runtime.MessageSensitivity.Unknown" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.HostExtensions" Member="M:Microsoft.ML.Runtime.HostExtensions.Trace(Microsoft.ML.Runtime.IChannel,System.String,System.Object[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IChannel" />
      </Targets>
      <Member MemberName="Warning">
        <MemberSignature Language="C#" Value="public static void Warning (this Microsoft.ML.Runtime.IChannel ch, string fmt);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Warning(class Microsoft.ML.Runtime.IChannel ch, string fmt) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.HostExtensions.Warning(Microsoft.ML.Runtime.IChannel,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Warning (ch As IChannel, fmt As String)" />
        <MemberSignature Language="F#" Value="static member Warning : Microsoft.ML.Runtime.IChannel * string -&gt; unit" Usage="Microsoft.ML.Runtime.HostExtensions.Warning (ch, fmt)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ch" Type="Microsoft.ML.Runtime.IChannel" RefType="this" />
          <Parameter Name="fmt" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="ch">To be added.</param>
          <param name="fmt">To be added.</param>
          <summary>
            Convenience variant of <see cref="M:Microsoft.ML.Runtime.IChannel.Warning(Microsoft.ML.Runtime.MessageSensitivity,System.String)" />
            setting <see cref="F:Microsoft.ML.Runtime.MessageSensitivity.Unknown" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.HostExtensions" Member="M:Microsoft.ML.Runtime.HostExtensions.Warning(Microsoft.ML.Runtime.IChannel,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IChannel" />
      </Targets>
      <Member MemberName="Warning">
        <MemberSignature Language="C#" Value="public static void Warning (this Microsoft.ML.Runtime.IChannel ch, string fmt, params object[] args);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Warning(class Microsoft.ML.Runtime.IChannel ch, string fmt, object[] args) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.HostExtensions.Warning(Microsoft.ML.Runtime.IChannel,System.String,System.Object[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Warning (ch As IChannel, fmt As String, ParamArray args As Object())" />
        <MemberSignature Language="F#" Value="static member Warning : Microsoft.ML.Runtime.IChannel * string * obj[] -&gt; unit" Usage="Microsoft.ML.Runtime.HostExtensions.Warning (ch, fmt, args)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ch" Type="Microsoft.ML.Runtime.IChannel" RefType="this" />
          <Parameter Name="fmt" Type="System.String" />
          <Parameter Name="args" Type="System.Object[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="ch">To be added.</param>
          <param name="fmt">To be added.</param>
          <param name="args">To be added.</param>
          <summary>
            Convenience variant of <see cref="M:Microsoft.ML.Runtime.IChannel.Warning(Microsoft.ML.Runtime.MessageSensitivity,System.String,System.Object[])" />
            setting <see cref="F:Microsoft.ML.Runtime.MessageSensitivity.Unknown" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.HostExtensions" Member="M:Microsoft.ML.Runtime.HostExtensions.Warning(Microsoft.ML.Runtime.IChannel,System.String,System.Object[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.List`1" />
      </Targets>
      <Member MemberName="Peek&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static T Peek&lt;T&gt; (this System.Collections.Generic.List&lt;T&gt; list);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Peek&lt;T&gt;(class System.Collections.Generic.List`1&lt;!!T&gt; list) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.ListExtensions.Peek``1(System.Collections.Generic.List{``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Peek(Of T) (list As List(Of T)) As T" />
        <MemberSignature Language="F#" Value="static member Peek : System.Collections.Generic.List&lt;'T&gt; -&gt; 'T" Usage="Microsoft.ML.Runtime.Internal.Utilities.ListExtensions.Peek list" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>T</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="list" Type="System.Collections.Generic.List&lt;T&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="list">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.ListExtensions" Member="M:Microsoft.ML.Runtime.Internal.Utilities.ListExtensions.Peek``1(System.Collections.Generic.List{``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.List`1" />
      </Targets>
      <Member MemberName="Pop&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static T Pop&lt;T&gt; (this System.Collections.Generic.List&lt;T&gt; list);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Pop&lt;T&gt;(class System.Collections.Generic.List`1&lt;!!T&gt; list) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.ListExtensions.Pop``1(System.Collections.Generic.List{``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Pop(Of T) (list As List(Of T)) As T" />
        <MemberSignature Language="F#" Value="static member Pop : System.Collections.Generic.List&lt;'T&gt; -&gt; 'T" Usage="Microsoft.ML.Runtime.Internal.Utilities.ListExtensions.Pop list" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>T</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="list" Type="System.Collections.Generic.List&lt;T&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="list">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.ListExtensions" Member="M:Microsoft.ML.Runtime.Internal.Utilities.ListExtensions.Pop``1(System.Collections.Generic.List{``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.List`1" />
      </Targets>
      <Member MemberName="PopTo&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static void PopTo&lt;T&gt; (this System.Collections.Generic.List&lt;T&gt; list, int depth);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PopTo&lt;T&gt;(class System.Collections.Generic.List`1&lt;!!T&gt; list, int32 depth) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.ListExtensions.PopTo``1(System.Collections.Generic.List{``0},System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub PopTo(Of T) (list As List(Of T), depth As Integer)" />
        <MemberSignature Language="F#" Value="static member PopTo : System.Collections.Generic.List&lt;'T&gt; * int -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.ListExtensions.PopTo (list, depth)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="list" Type="System.Collections.Generic.List&lt;T&gt;" RefType="this" />
          <Parameter Name="depth" Type="System.Int32" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="list">To be added.</param>
          <param name="depth">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.ListExtensions" Member="M:Microsoft.ML.Runtime.Internal.Utilities.ListExtensions.PopTo``1(System.Collections.Generic.List{``0},System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.List`1" />
      </Targets>
      <Member MemberName="Push&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static void Push&lt;T&gt; (this System.Collections.Generic.List&lt;T&gt; list, T item);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Push&lt;T&gt;(class System.Collections.Generic.List`1&lt;!!T&gt; list, !!T item) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.ListExtensions.Push``1(System.Collections.Generic.List{``0},``0)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Push(Of T) (list As List(Of T), item As T)" />
        <MemberSignature Language="F#" Value="static member Push : System.Collections.Generic.List&lt;'T&gt; * 'T -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.ListExtensions.Push (list, item)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="list" Type="System.Collections.Generic.List&lt;T&gt;" RefType="this" />
          <Parameter Name="item" Type="T" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="list">To be added.</param>
          <param name="item">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.ListExtensions" Member="M:Microsoft.ML.Runtime.Internal.Utilities.ListExtensions.Push``1(System.Collections.Generic.List{``0},``0)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Double" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static float ToFloat (this double dbl);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ToFloat(float64 dbl) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.MathUtils.ToFloat(System.Double)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToFloat (dbl As Double) As Single" />
        <MemberSignature Language="F#" Value="static member ToFloat : double -&gt; single" Usage="Microsoft.ML.Runtime.Internal.Utilities.MathUtils.ToFloat dbl" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Single</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="dbl" Type="System.Double" RefType="this" />
        </Parameters>
        <Docs>
          <param name="dbl">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.MathUtils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.MathUtils.ToFloat(System.Double)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Single" />
      </Targets>
      <Member MemberName="ToFloat">
        <MemberSignature Language="C#" Value="public static void ToFloat (this float dbl);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ToFloat(float32 dbl) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.MathUtils.ToFloat(System.Single)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ToFloat (dbl As Single)" />
        <MemberSignature Language="F#" Value="static member ToFloat : single -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.MathUtils.ToFloat dbl" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="dbl" Type="System.Single" RefType="this" />
        </Parameters>
        <Docs>
          <param name="dbl">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.MathUtils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.MathUtils.ToFloat(System.Single)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Array" />
      </Targets>
      <Member MemberName="AsReadOnly&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (this T[] items);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] items) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.PlatformUtils.AsReadOnly``1(``0[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsReadOnly(Of T) (items As T()) As ReadOnlyCollection(Of T)" />
        <MemberSignature Language="F#" Value="static member AsReadOnly : 'T[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="Microsoft.ML.Runtime.Internal.Utilities.PlatformUtils.AsReadOnly items" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="items" Type="T[]" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="items">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.PlatformUtils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.PlatformUtils.AsReadOnly``1(``0[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Type" />
      </Targets>
      <Member MemberName="GetGenericTypeArgumentsEx">
        <MemberSignature Language="C#" Value="public static Type[] GetGenericTypeArgumentsEx (this Type type);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetGenericTypeArgumentsEx(class System.Type type) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.PlatformUtils.GetGenericTypeArgumentsEx(System.Type)" />
        <MemberSignature Language="F#" Value="static member GetGenericTypeArgumentsEx : Type -&gt; Type[]" Usage="Microsoft.ML.Runtime.Internal.Utilities.PlatformUtils.GetGenericTypeArgumentsEx type" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Type[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="type" Type="System.Type" RefType="this" />
        </Parameters>
        <Docs>
          <param name="type">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.PlatformUtils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.PlatformUtils.GetGenericTypeArgumentsEx(System.Type)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Type" />
      </Targets>
      <Member MemberName="IsGenericEx">
        <MemberSignature Language="C#" Value="public static bool IsGenericEx (this Type type, Type typeDef);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsGenericEx(class System.Type type, class System.Type typeDef) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.PlatformUtils.IsGenericEx(System.Type,System.Type)" />
        <MemberSignature Language="F#" Value="static member IsGenericEx : Type * Type -&gt; bool" Usage="Microsoft.ML.Runtime.Internal.Utilities.PlatformUtils.IsGenericEx (type, typeDef)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="type" Type="System.Type" RefType="this" />
          <Parameter Name="typeDef" Type="System.Type" />
        </Parameters>
        <Docs>
          <param name="type">To be added.</param>
          <param name="typeDef">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.PlatformUtils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.PlatformUtils.IsGenericEx(System.Type,System.Type)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.Stream" />
      </Targets>
      <Member MemberName="CloseEx">
        <MemberSignature Language="C#" Value="public static void CloseEx (this System.IO.Stream stream);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CloseEx(class System.IO.Stream stream) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.CloseEx(System.IO.Stream)" />
        <MemberSignature Language="F#" Value="static member CloseEx : System.IO.Stream -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.CloseEx stream" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="stream" Type="System.IO.Stream" RefType="this" />
        </Parameters>
        <Docs>
          <param name="stream">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.CloseEx(System.IO.Stream)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.TextWriter" />
      </Targets>
      <Member MemberName="CloseEx">
        <MemberSignature Language="C#" Value="public static void CloseEx (this System.IO.TextWriter writer);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CloseEx(class System.IO.TextWriter writer) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.CloseEx(System.IO.TextWriter)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CloseEx (writer As TextWriter)" />
        <MemberSignature Language="F#" Value="static member CloseEx : System.IO.TextWriter -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.CloseEx writer" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.TextWriter" RefType="this" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.CloseEx(System.IO.TextWriter)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.Stream" />
      </Targets>
      <Member MemberName="CopyRange">
        <MemberSignature Language="C#" Value="public static long CopyRange (this System.IO.Stream source, System.IO.Stream destination, long length, int bufferSize = 81920);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 CopyRange(class System.IO.Stream source, class System.IO.Stream destination, int64 length, int32 bufferSize) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.CopyRange(System.IO.Stream,System.IO.Stream,System.Int64,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CopyRange (source As Stream, destination As Stream, length As Long, Optional bufferSize As Integer = 81920) As Long" />
        <MemberSignature Language="F#" Value="static member CopyRange : System.IO.Stream * System.IO.Stream * int64 * int -&gt; int64" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.CopyRange (source, destination, length, bufferSize)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int64</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="source" Type="System.IO.Stream" RefType="this" />
          <Parameter Name="destination" Type="System.IO.Stream" />
          <Parameter Name="length" Type="System.Int64" />
          <Parameter Name="bufferSize" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="source">Source stream to copy from</param>
          <param name="destination">Destination stream to copy to</param>
          <param name="length">Number of bytes to copy</param>
          <param name="bufferSize">Size of buffer to use when copying, default is 81920 to match that of Stream</param>
          <summary>
            Similar to Stream.CopyTo but takes a length rather than assuming copy to end.  Returns amount copied.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.CopyRange(System.IO.Stream,System.IO.Stream,System.Int64,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IList`1" />
      </Targets>
      <Member MemberName="FindIndexSorted">
        <MemberSignature Language="C#" Value="public static int FindIndexSorted (this System.Collections.Generic.IList&lt;int&gt; input, int value);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndexSorted(class System.Collections.Generic.IList`1&lt;int32&gt; input, int32 value) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted(System.Collections.Generic.IList{System.Int32},System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FindIndexSorted (input As IList(Of Integer), value As Integer) As Integer" />
        <MemberSignature Language="F#" Value="static member FindIndexSorted : System.Collections.Generic.IList&lt;int&gt; * int -&gt; int" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted (input, value)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="System.Collections.Generic.IList&lt;System.Int32&gt;" RefType="this" />
          <Parameter Name="value" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">To be added.</param>
          <param name="value">To be added.</param>
          <summary>
            Assumes input is sorted and finds value using BinarySearch.
            If value is not found, returns the logical index of 'value' in the sorted list i.e index of the first element greater than value.
            In case of duplicates it returns the index of the first one.
            It guarantees that items before the returned index are &lt; value, while those at and after the returned index are &gt;= value.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted(System.Collections.Generic.IList{System.Int32},System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IList`1" />
      </Targets>
      <Member MemberName="FindIndexSorted">
        <MemberSignature Language="C#" Value="public static int FindIndexSorted (this System.Collections.Generic.IList&lt;int&gt; input, int min, int lim, int value);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndexSorted(class System.Collections.Generic.IList`1&lt;int32&gt; input, int32 min, int32 lim, int32 value) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted(System.Collections.Generic.IList{System.Int32},System.Int32,System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FindIndexSorted (input As IList(Of Integer), min As Integer, lim As Integer, value As Integer) As Integer" />
        <MemberSignature Language="F#" Value="static member FindIndexSorted : System.Collections.Generic.IList&lt;int&gt; * int * int * int -&gt; int" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted (input, min, lim, value)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="System.Collections.Generic.IList&lt;System.Int32&gt;" RefType="this" />
          <Parameter Name="min" Type="System.Int32" />
          <Parameter Name="lim" Type="System.Int32" />
          <Parameter Name="value" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">To be added.</param>
          <param name="min">To be added.</param>
          <param name="lim">To be added.</param>
          <param name="value">To be added.</param>
          <summary>
            Assumes input is sorted and finds value using BinarySearch.
            If value is not found, returns the logical index of 'value' in the sorted list i.e index of the first element greater than value.
            In case of duplicates it returns the index of the first one.
            It guarantees that items before the returned index are &lt; value, while those at and after the returned index are &gt;= value.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted(System.Collections.Generic.IList{System.Int32},System.Int32,System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Double" />
      </Targets>
      <Member MemberName="FindIndexSorted">
        <MemberSignature Language="C#" Value="public static int FindIndexSorted (this double[] input, double value);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndexSorted(float64[] input, float64 value) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted(System.Double[],System.Double)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FindIndexSorted (input As Double(), value As Double) As Integer" />
        <MemberSignature Language="F#" Value="static member FindIndexSorted : double[] * double -&gt; int" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted (input, value)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="System.Double[]" RefType="this" />
          <Parameter Name="value" Type="System.Double" />
        </Parameters>
        <Docs>
          <param name="input">To be added.</param>
          <param name="value">To be added.</param>
          <summary>
            Assumes input is sorted and finds value using BinarySearch.
            If value is not found, returns the logical index of 'value' in the sorted list i.e index of the first element greater than value.
            In case of duplicates it returns the index of the first one.
            It guarantees that items before the returned index are &lt; value, while those at and after the returned index are &gt;= value.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted(System.Double[],System.Double)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Double" />
      </Targets>
      <Member MemberName="FindIndexSorted">
        <MemberSignature Language="C#" Value="public static int FindIndexSorted (this double[] input, int min, int lim, double value);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndexSorted(float64[] input, int32 min, int32 lim, float64 value) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted(System.Double[],System.Int32,System.Int32,System.Double)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FindIndexSorted (input As Double(), min As Integer, lim As Integer, value As Double) As Integer" />
        <MemberSignature Language="F#" Value="static member FindIndexSorted : double[] * int * int * double -&gt; int" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted (input, min, lim, value)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="System.Double[]" RefType="this" />
          <Parameter Name="min" Type="System.Int32" />
          <Parameter Name="lim" Type="System.Int32" />
          <Parameter Name="value" Type="System.Double" />
        </Parameters>
        <Docs>
          <param name="input">To be added.</param>
          <param name="min">To be added.</param>
          <param name="lim">To be added.</param>
          <param name="value">To be added.</param>
          <summary>
            Assumes input is sorted and finds value using BinarySearch.
            If value is not found, returns the logical index of 'value' in the sorted list i.e index of the first element greater than value.
            In case of duplicates it returns the index of the first one.
            It guarantees that items before the returned index are &lt; value, while those at and after the returned index are &gt;= value.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted(System.Double[],System.Int32,System.Int32,System.Double)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int32" />
      </Targets>
      <Member MemberName="FindIndexSorted">
        <MemberSignature Language="C#" Value="public static int FindIndexSorted (this int[] input, int value);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndexSorted(int32[] input, int32 value) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted(System.Int32[],System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FindIndexSorted (input As Integer(), value As Integer) As Integer" />
        <MemberSignature Language="F#" Value="static member FindIndexSorted : int[] * int -&gt; int" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted (input, value)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="System.Int32[]" RefType="this" />
          <Parameter Name="value" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">To be added.</param>
          <param name="value">To be added.</param>
          <summary>
            Assumes input is sorted and finds value using BinarySearch.
            If value is not found, returns the logical index of 'value' in the sorted list i.e index of the first element greater than value.
            In case of duplicates it returns the index of the first one.
            It guarantees that items before the returned index are &lt; value, while those at and after the returned index are &gt;= value.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted(System.Int32[],System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int32" />
      </Targets>
      <Member MemberName="FindIndexSorted">
        <MemberSignature Language="C#" Value="public static int FindIndexSorted (this int[] input, int min, int lim, int value);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndexSorted(int32[] input, int32 min, int32 lim, int32 value) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted(System.Int32[],System.Int32,System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FindIndexSorted (input As Integer(), min As Integer, lim As Integer, value As Integer) As Integer" />
        <MemberSignature Language="F#" Value="static member FindIndexSorted : int[] * int * int * int -&gt; int" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted (input, min, lim, value)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="System.Int32[]" RefType="this" />
          <Parameter Name="min" Type="System.Int32" />
          <Parameter Name="lim" Type="System.Int32" />
          <Parameter Name="value" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">To be added.</param>
          <param name="min">To be added.</param>
          <param name="lim">To be added.</param>
          <param name="value">To be added.</param>
          <summary>
            Assumes input is sorted and finds value using BinarySearch.
            If value is not found, returns the logical index of 'value' in the sorted list i.e index of the first element greater than value.
            In case of duplicates it returns the index of the first one.
            It guarantees that items before the returned index are &lt; value, while those at and after the returned index are &gt;= value.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted(System.Int32[],System.Int32,System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Single" />
      </Targets>
      <Member MemberName="FindIndexSorted">
        <MemberSignature Language="C#" Value="public static int FindIndexSorted (this float[] input, int min, int lim, float value);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndexSorted(float32[] input, int32 min, int32 lim, float32 value) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted(System.Single[],System.Int32,System.Int32,System.Single)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FindIndexSorted (input As Single(), min As Integer, lim As Integer, value As Single) As Integer" />
        <MemberSignature Language="F#" Value="static member FindIndexSorted : single[] * int * int * single -&gt; int" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted (input, min, lim, value)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="System.Single[]" RefType="this" />
          <Parameter Name="min" Type="System.Int32" />
          <Parameter Name="lim" Type="System.Int32" />
          <Parameter Name="value" Type="System.Single" />
        </Parameters>
        <Docs>
          <param name="input">To be added.</param>
          <param name="min">To be added.</param>
          <param name="lim">To be added.</param>
          <param name="value">To be added.</param>
          <summary>
            Assumes input is sorted and finds value using BinarySearch.
            If value is not found, returns the logical index of 'value' in the sorted list i.e index of the first element greater than value.
            In case of duplicates it returns the index of the first one.
            It guarantees that items before the returned index are &lt; value, while those at and after the returned index are &gt;= value.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted(System.Single[],System.Int32,System.Int32,System.Single)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Single" />
      </Targets>
      <Member MemberName="FindIndexSorted">
        <MemberSignature Language="C#" Value="public static int FindIndexSorted (this float[] input, float value);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndexSorted(float32[] input, float32 value) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted(System.Single[],System.Single)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FindIndexSorted (input As Single(), value As Single) As Integer" />
        <MemberSignature Language="F#" Value="static member FindIndexSorted : single[] * single -&gt; int" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted (input, value)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="System.Single[]" RefType="this" />
          <Parameter Name="value" Type="System.Single" />
        </Parameters>
        <Docs>
          <param name="input">To be added.</param>
          <param name="value">To be added.</param>
          <summary>
            Assumes input is sorted and finds value using BinarySearch.
            If value is not found, returns the logical index of 'value' in the sorted list i.e index of the first element greater than value.
            In case of duplicates it returns the index of the first one.
            It guarantees that items before the returned index are &lt; value, while those at and after the returned index are &gt;= value.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted(System.Single[],System.Single)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Array" />
      </Targets>
      <Member MemberName="FindIndexSorted&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static int FindIndexSorted&lt;T&gt; (this T[] input, int min, int lim, Func&lt;T,bool&gt; func);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndexSorted&lt;T&gt;(!!T[] input, int32 min, int32 lim, class System.Func`2&lt;!!T, bool&gt; func) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted``1(``0[],System.Int32,System.Int32,System.Func{``0,System.Boolean})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FindIndexSorted(Of T) (input As T(), min As Integer, lim As Integer, func As Func(Of T, Boolean)) As Integer" />
        <MemberSignature Language="F#" Value="static member FindIndexSorted : 'T[] * int * int * Func&lt;'T, bool&gt; -&gt; int" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted (input, min, lim, func)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="T[]" RefType="this" />
          <Parameter Name="min" Type="System.Int32" />
          <Parameter Name="lim" Type="System.Int32" />
          <Parameter Name="func" Type="System.Func&lt;T,System.Boolean&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <param name="input">To be added.</param>
          <param name="min">To be added.</param>
          <param name="lim">To be added.</param>
          <param name="func">To be added.</param>
          <summary>
            Finds the unique index for which func(input[i]) == false whenever i &lt; index and
            func(input[i]) == true whenever i &gt;= index.
            Callers should guarantee that there is such an index. Uses binary search.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted``1(``0[],System.Int32,System.Int32,System.Func{``0,System.Boolean})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Array" />
      </Targets>
      <Member MemberName="FindIndexSorted&lt;T,TValue&gt;">
        <MemberSignature Language="C#" Value="public static int FindIndexSorted&lt;T,TValue&gt; (this T[] input, int min, int lim, Func&lt;T,TValue,bool&gt; func, TValue value);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndexSorted&lt;T, TValue&gt;(!!T[] input, int32 min, int32 lim, class System.Func`3&lt;!!T, !!TValue, bool&gt; func, !!TValue value) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted``2(``0[],System.Int32,System.Int32,System.Func{``0,``1,System.Boolean},``1)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FindIndexSorted(Of T, TValue) (input As T(), min As Integer, lim As Integer, func As Func(Of T, TValue, Boolean), value As TValue) As Integer" />
        <MemberSignature Language="F#" Value="static member FindIndexSorted : 'T[] * int * int * Func&lt;'T, 'Value, bool&gt; * 'Value -&gt; int" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted (input, min, lim, func, value)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
          <TypeParameter Name="TValue" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="input" Type="T[]" RefType="this" />
          <Parameter Name="min" Type="System.Int32" />
          <Parameter Name="lim" Type="System.Int32" />
          <Parameter Name="func" Type="System.Func&lt;T,TValue,System.Boolean&gt;" />
          <Parameter Name="value" Type="TValue" />
        </Parameters>
        <Docs>
          <typeparam name="T">To be added.</typeparam>
          <typeparam name="TValue">To be added.</typeparam>
          <param name="input">To be added.</param>
          <param name="min">To be added.</param>
          <param name="lim">To be added.</param>
          <param name="func">To be added.</param>
          <param name="value">To be added.</param>
          <summary>
            Finds the unique index for which func(input[i], value) == false whenever i &lt; index and
            func(input[i], value) == true whenever i &gt;= index.
            Callers should guarantee that there is such an index. Uses binary search.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.FindIndexSorted``2(``0[],System.Int32,System.Int32,System.Func{``0,``1,System.Boolean},``1)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="FpCur">
        <MemberSignature Language="C#" Value="public static long FpCur (this System.IO.BinaryReader reader);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 FpCur(class System.IO.BinaryReader reader) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.FpCur(System.IO.BinaryReader)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FpCur (reader As BinaryReader) As Long" />
        <MemberSignature Language="F#" Value="static member FpCur : System.IO.BinaryReader -&gt; int64" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.FpCur reader" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int64</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.FpCur(System.IO.BinaryReader)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="FpCur">
        <MemberSignature Language="C#" Value="public static long FpCur (this System.IO.BinaryWriter writer);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 FpCur(class System.IO.BinaryWriter writer) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.FpCur(System.IO.BinaryWriter)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FpCur (writer As BinaryWriter) As Long" />
        <MemberSignature Language="F#" Value="static member FpCur : System.IO.BinaryWriter -&gt; int64" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.FpCur writer" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int64</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.FpCur(System.IO.BinaryWriter)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Enum" />
      </Targets>
      <Member MemberName="GetDescription">
        <MemberSignature Language="C#" Value="public static string GetDescription (this Enum value);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDescription(class System.Enum value) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.GetDescription(System.Enum)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetDescription (value As Enum) As String" />
        <MemberSignature Language="F#" Value="static member GetDescription : Enum -&gt; string" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.GetDescription value" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="value" Type="System.Enum" RefType="this" />
        </Parameters>
        <Docs>
          <param name="value">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.GetDescription(System.Enum)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="ReadBitArray">
        <MemberSignature Language="C#" Value="public static System.Collections.BitArray ReadBitArray (this System.IO.BinaryReader reader);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.BitArray ReadBitArray(class System.IO.BinaryReader reader) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadBitArray(System.IO.BinaryReader)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadBitArray (reader As BinaryReader) As BitArray" />
        <MemberSignature Language="F#" Value="static member ReadBitArray : System.IO.BinaryReader -&gt; System.Collections.BitArray" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadBitArray reader" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.BitArray</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadBitArray(System.IO.BinaryReader)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.Stream" />
      </Targets>
      <Member MemberName="ReadBlock">
        <MemberSignature Language="C#" Value="public static void ReadBlock (this System.IO.Stream s, byte[] buff, int offset, int length);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReadBlock(class System.IO.Stream s, unsigned int8[] buff, int32 offset, int32 length) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadBlock(System.IO.Stream,System.Byte[],System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ReadBlock (s As Stream, buff As Byte(), offset As Integer, length As Integer)" />
        <MemberSignature Language="F#" Value="static member ReadBlock : System.IO.Stream * byte[] * int * int -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadBlock (s, buff, offset, length)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="s" Type="System.IO.Stream" RefType="this" />
          <Parameter Name="buff" Type="System.Byte[]" />
          <Parameter Name="offset" Type="System.Int32" />
          <Parameter Name="length" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="s">The stream</param>
          <param name="buff">The buffer into which to write the data.</param>
          <param name="offset">The offset of the output array into which to write.</param>
          <param name="length">The number of bytes to read.</param>
          <summary>
            If this return it will read exactly length bytes, and unlike the
            regular read method fails if it cannot.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadBlock(System.IO.Stream,System.Byte[],System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="ReadBoolArray">
        <MemberSignature Language="C#" Value="public static bool[] ReadBoolArray (this System.IO.BinaryReader reader);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool[] ReadBoolArray(class System.IO.BinaryReader reader) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadBoolArray(System.IO.BinaryReader)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadBoolArray (reader As BinaryReader) As Boolean()" />
        <MemberSignature Language="F#" Value="static member ReadBoolArray : System.IO.BinaryReader -&gt; bool[]" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadBoolArray reader" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadBoolArray(System.IO.BinaryReader)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="ReadBoolArray">
        <MemberSignature Language="C#" Value="public static bool[] ReadBoolArray (this System.IO.BinaryReader reader, int size);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool[] ReadBoolArray(class System.IO.BinaryReader reader, int32 size) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadBoolArray(System.IO.BinaryReader,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadBoolArray (reader As BinaryReader, size As Integer) As Boolean()" />
        <MemberSignature Language="F#" Value="static member ReadBoolArray : System.IO.BinaryReader * int -&gt; bool[]" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadBoolArray (reader, size)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
          <Parameter Name="size" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <param name="size">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadBoolArray(System.IO.BinaryReader,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="ReadBoolByte">
        <MemberSignature Language="C#" Value="public static bool ReadBoolByte (this System.IO.BinaryReader reader);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReadBoolByte(class System.IO.BinaryReader reader) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadBoolByte(System.IO.BinaryReader)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadBoolByte (reader As BinaryReader) As Boolean" />
        <MemberSignature Language="F#" Value="static member ReadBoolByte : System.IO.BinaryReader -&gt; bool" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadBoolByte reader" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadBoolByte(System.IO.BinaryReader)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="ReadByteArray">
        <MemberSignature Language="C#" Value="public static byte[] ReadByteArray (this System.IO.BinaryReader reader);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ReadByteArray(class System.IO.BinaryReader reader) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadByteArray(System.IO.BinaryReader)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadByteArray (reader As BinaryReader) As Byte()" />
        <MemberSignature Language="F#" Value="static member ReadByteArray : System.IO.BinaryReader -&gt; byte[]" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadByteArray reader" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Byte[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadByteArray(System.IO.BinaryReader)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="ReadByteArray">
        <MemberSignature Language="C#" Value="public static byte[] ReadByteArray (this System.IO.BinaryReader reader, int size);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ReadByteArray(class System.IO.BinaryReader reader, int32 size) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadByteArray(System.IO.BinaryReader,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadByteArray (reader As BinaryReader, size As Integer) As Byte()" />
        <MemberSignature Language="F#" Value="static member ReadByteArray : System.IO.BinaryReader * int -&gt; byte[]" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadByteArray (reader, size)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Byte[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
          <Parameter Name="size" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <param name="size">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadByteArray(System.IO.BinaryReader,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="ReadBytes">
        <MemberSignature Language="C#" Value="public static void ReadBytes (this System.IO.BinaryReader reader, void* destination, long destinationSizeInBytes, long bytesToRead);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReadBytes(class System.IO.BinaryReader reader, void* destination, int64 destinationSizeInBytes, int64 bytesToRead) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadBytes(System.IO.BinaryReader,System.Void*,System.Int64,System.Int64)" />
        <MemberSignature Language="F#" Value="static member ReadBytes : System.IO.BinaryReader * nativeptr&lt;unit&gt; * int64 * int64 -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadBytes (reader, destination, destinationSizeInBytes, bytesToRead)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
          <Parameter Name="destination" Type="System.Void*" />
          <Parameter Name="destinationSizeInBytes" Type="System.Int64" />
          <Parameter Name="bytesToRead" Type="System.Int64" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <param name="destination">To be added.</param>
          <param name="destinationSizeInBytes">To be added.</param>
          <param name="bytesToRead">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadBytes(System.IO.BinaryReader,System.Void*,System.Int64,System.Int64)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="ReadBytes">
        <MemberSignature Language="C#" Value="public static void ReadBytes (this System.IO.BinaryReader reader, void* destination, long destinationSizeInBytes, long bytesToRead, ref byte[] work);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReadBytes(class System.IO.BinaryReader reader, void* destination, int64 destinationSizeInBytes, int64 bytesToRead, unsigned int8[]&amp; work) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadBytes(System.IO.BinaryReader,System.Void*,System.Int64,System.Int64,System.Byte[]@)" />
        <MemberSignature Language="F#" Value="static member ReadBytes : System.IO.BinaryReader * nativeptr&lt;unit&gt; * int64 * int64 *  -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadBytes (reader, destination, destinationSizeInBytes, bytesToRead, work)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
          <Parameter Name="destination" Type="System.Void*" />
          <Parameter Name="destinationSizeInBytes" Type="System.Int64" />
          <Parameter Name="bytesToRead" Type="System.Int64" />
          <Parameter Name="work" Type="System.Byte[]" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <param name="destination">To be added.</param>
          <param name="destinationSizeInBytes">To be added.</param>
          <param name="bytesToRead">To be added.</param>
          <param name="work">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadBytes(System.IO.BinaryReader,System.Void*,System.Int64,System.Int64,System.Byte[]@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="ReadCharArray">
        <MemberSignature Language="C#" Value="public static char[] ReadCharArray (this System.IO.BinaryReader reader);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] ReadCharArray(class System.IO.BinaryReader reader) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadCharArray(System.IO.BinaryReader)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadCharArray (reader As BinaryReader) As Char()" />
        <MemberSignature Language="F#" Value="static member ReadCharArray : System.IO.BinaryReader -&gt; char[]" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadCharArray reader" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Char[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadCharArray(System.IO.BinaryReader)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="ReadCharArray">
        <MemberSignature Language="C#" Value="public static char[] ReadCharArray (this System.IO.BinaryReader reader, int size);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] ReadCharArray(class System.IO.BinaryReader reader, int32 size) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadCharArray(System.IO.BinaryReader,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadCharArray (reader As BinaryReader, size As Integer) As Char()" />
        <MemberSignature Language="F#" Value="static member ReadCharArray : System.IO.BinaryReader * int -&gt; char[]" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadCharArray (reader, size)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Char[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
          <Parameter Name="size" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <param name="size">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadCharArray(System.IO.BinaryReader,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="ReadDoubleArray">
        <MemberSignature Language="C#" Value="public static double[] ReadDoubleArray (this System.IO.BinaryReader reader);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64[] ReadDoubleArray(class System.IO.BinaryReader reader) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadDoubleArray(System.IO.BinaryReader)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadDoubleArray (reader As BinaryReader) As Double()" />
        <MemberSignature Language="F#" Value="static member ReadDoubleArray : System.IO.BinaryReader -&gt; double[]" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadDoubleArray reader" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Double[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadDoubleArray(System.IO.BinaryReader)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="ReadDoubleArray">
        <MemberSignature Language="C#" Value="public static double[] ReadDoubleArray (this System.IO.BinaryReader reader, int size);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64[] ReadDoubleArray(class System.IO.BinaryReader reader, int32 size) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadDoubleArray(System.IO.BinaryReader,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadDoubleArray (reader As BinaryReader, size As Integer) As Double()" />
        <MemberSignature Language="F#" Value="static member ReadDoubleArray : System.IO.BinaryReader * int -&gt; double[]" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadDoubleArray (reader, size)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Double[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
          <Parameter Name="size" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <param name="size">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadDoubleArray(System.IO.BinaryReader,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="ReadFloat">
        <MemberSignature Language="C#" Value="public static float ReadFloat (this System.IO.BinaryReader reader);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ReadFloat(class System.IO.BinaryReader reader) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadFloat(System.IO.BinaryReader)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadFloat (reader As BinaryReader) As Single" />
        <MemberSignature Language="F#" Value="static member ReadFloat : System.IO.BinaryReader -&gt; single" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadFloat reader" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Single</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadFloat(System.IO.BinaryReader)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="ReadFloatArray">
        <MemberSignature Language="C#" Value="public static float[] ReadFloatArray (this System.IO.BinaryReader reader);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32[] ReadFloatArray(class System.IO.BinaryReader reader) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadFloatArray(System.IO.BinaryReader)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadFloatArray (reader As BinaryReader) As Single()" />
        <MemberSignature Language="F#" Value="static member ReadFloatArray : System.IO.BinaryReader -&gt; single[]" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadFloatArray reader" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Single[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadFloatArray(System.IO.BinaryReader)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="ReadFloatArray">
        <MemberSignature Language="C#" Value="public static float[] ReadFloatArray (this System.IO.BinaryReader reader, int size);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32[] ReadFloatArray(class System.IO.BinaryReader reader, int32 size) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadFloatArray(System.IO.BinaryReader,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadFloatArray (reader As BinaryReader, size As Integer) As Single()" />
        <MemberSignature Language="F#" Value="static member ReadFloatArray : System.IO.BinaryReader * int -&gt; single[]" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadFloatArray (reader, size)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Single[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
          <Parameter Name="size" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <param name="size">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadFloatArray(System.IO.BinaryReader,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="ReadFloatArray">
        <MemberSignature Language="C#" Value="public static void ReadFloatArray (this System.IO.BinaryReader reader, float[] array, int start, int count);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReadFloatArray(class System.IO.BinaryReader reader, float32[] array, int32 start, int32 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadFloatArray(System.IO.BinaryReader,System.Single[],System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ReadFloatArray (reader As BinaryReader, array As Single(), start As Integer, count As Integer)" />
        <MemberSignature Language="F#" Value="static member ReadFloatArray : System.IO.BinaryReader * single[] * int * int -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadFloatArray (reader, array, start, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
          <Parameter Name="array" Type="System.Single[]" />
          <Parameter Name="start" Type="System.Int32" />
          <Parameter Name="count" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <param name="array">To be added.</param>
          <param name="start">To be added.</param>
          <param name="count">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadFloatArray(System.IO.BinaryReader,System.Single[],System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="ReadIntArray">
        <MemberSignature Language="C#" Value="public static int[] ReadIntArray (this System.IO.BinaryReader reader);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32[] ReadIntArray(class System.IO.BinaryReader reader) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadIntArray(System.IO.BinaryReader)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadIntArray (reader As BinaryReader) As Integer()" />
        <MemberSignature Language="F#" Value="static member ReadIntArray : System.IO.BinaryReader -&gt; int[]" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadIntArray reader" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadIntArray(System.IO.BinaryReader)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="ReadIntArray">
        <MemberSignature Language="C#" Value="public static int[] ReadIntArray (this System.IO.BinaryReader reader, int size);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32[] ReadIntArray(class System.IO.BinaryReader reader, int32 size) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadIntArray(System.IO.BinaryReader,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadIntArray (reader As BinaryReader, size As Integer) As Integer()" />
        <MemberSignature Language="F#" Value="static member ReadIntArray : System.IO.BinaryReader * int -&gt; int[]" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadIntArray (reader, size)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
          <Parameter Name="size" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <param name="size">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadIntArray(System.IO.BinaryReader,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="ReadLeb128Int">
        <MemberSignature Language="C#" Value="public static ulong ReadLeb128Int (this System.IO.BinaryReader reader);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ReadLeb128Int(class System.IO.BinaryReader reader) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadLeb128Int(System.IO.BinaryReader)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadLeb128Int (reader As BinaryReader) As ULong" />
        <MemberSignature Language="F#" Value="static member ReadLeb128Int : System.IO.BinaryReader -&gt; uint64" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadLeb128Int reader" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.UInt64</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <summary>
            Reads a LEB128 encoded unsigned integer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadLeb128Int(System.IO.BinaryReader)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="ReadLongArray">
        <MemberSignature Language="C#" Value="public static long[] ReadLongArray (this System.IO.BinaryReader reader);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64[] ReadLongArray(class System.IO.BinaryReader reader) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadLongArray(System.IO.BinaryReader)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadLongArray (reader As BinaryReader) As Long()" />
        <MemberSignature Language="F#" Value="static member ReadLongArray : System.IO.BinaryReader -&gt; int64[]" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadLongArray reader" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int64[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadLongArray(System.IO.BinaryReader)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="ReadLongArray">
        <MemberSignature Language="C#" Value="public static long[] ReadLongArray (this System.IO.BinaryReader reader, int size);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64[] ReadLongArray(class System.IO.BinaryReader reader, int32 size) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadLongArray(System.IO.BinaryReader,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadLongArray (reader As BinaryReader, size As Integer) As Long()" />
        <MemberSignature Language="F#" Value="static member ReadLongArray : System.IO.BinaryReader * int -&gt; int64[]" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadLongArray (reader, size)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int64[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
          <Parameter Name="size" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <param name="size">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadLongArray(System.IO.BinaryReader,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="ReadSingleArray">
        <MemberSignature Language="C#" Value="public static float[] ReadSingleArray (this System.IO.BinaryReader reader);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32[] ReadSingleArray(class System.IO.BinaryReader reader) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadSingleArray(System.IO.BinaryReader)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadSingleArray (reader As BinaryReader) As Single()" />
        <MemberSignature Language="F#" Value="static member ReadSingleArray : System.IO.BinaryReader -&gt; single[]" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadSingleArray reader" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Single[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadSingleArray(System.IO.BinaryReader)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="ReadSingleArray">
        <MemberSignature Language="C#" Value="public static float[] ReadSingleArray (this System.IO.BinaryReader reader, int size);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32[] ReadSingleArray(class System.IO.BinaryReader reader, int32 size) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadSingleArray(System.IO.BinaryReader,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadSingleArray (reader As BinaryReader, size As Integer) As Single()" />
        <MemberSignature Language="F#" Value="static member ReadSingleArray : System.IO.BinaryReader * int -&gt; single[]" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadSingleArray (reader, size)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Single[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
          <Parameter Name="size" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <param name="size">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadSingleArray(System.IO.BinaryReader,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="ReadUIntArray">
        <MemberSignature Language="C#" Value="public static uint[] ReadUIntArray (this System.IO.BinaryReader reader);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32[] ReadUIntArray(class System.IO.BinaryReader reader) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadUIntArray(System.IO.BinaryReader)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadUIntArray (reader As BinaryReader) As UInteger()" />
        <MemberSignature Language="F#" Value="static member ReadUIntArray : System.IO.BinaryReader -&gt; uint32[]" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadUIntArray reader" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.UInt32[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadUIntArray(System.IO.BinaryReader)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="ReadUIntArray">
        <MemberSignature Language="C#" Value="public static uint[] ReadUIntArray (this System.IO.BinaryReader reader, int size);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32[] ReadUIntArray(class System.IO.BinaryReader reader, int32 size) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadUIntArray(System.IO.BinaryReader,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReadUIntArray (reader As BinaryReader, size As Integer) As UInteger()" />
        <MemberSignature Language="F#" Value="static member ReadUIntArray : System.IO.BinaryReader * int -&gt; uint32[]" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadUIntArray (reader, size)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.UInt32[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
          <Parameter Name="size" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <param name="size">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.ReadUIntArray(System.IO.BinaryReader,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryReader" />
      </Targets>
      <Member MemberName="Seek">
        <MemberSignature Language="C#" Value="public static void Seek (this System.IO.BinaryReader reader, long fp);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Seek(class System.IO.BinaryReader reader, int64 fp) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.Seek(System.IO.BinaryReader,System.Int64)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Seek (reader As BinaryReader, fp As Long)" />
        <MemberSignature Language="F#" Value="static member Seek : System.IO.BinaryReader * int64 -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.Seek (reader, fp)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="reader" Type="System.IO.BinaryReader" RefType="this" />
          <Parameter Name="fp" Type="System.Int64" />
        </Parameters>
        <Docs>
          <param name="reader">To be added.</param>
          <param name="fp">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.Seek(System.IO.BinaryReader,System.Int64)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="Seek">
        <MemberSignature Language="C#" Value="public static void Seek (this System.IO.BinaryWriter writer, long fp);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Seek(class System.IO.BinaryWriter writer, int64 fp) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.Seek(System.IO.BinaryWriter,System.Int64)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Seek (writer As BinaryWriter, fp As Long)" />
        <MemberSignature Language="F#" Value="static member Seek : System.IO.BinaryWriter * int64 -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.Seek (writer, fp)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="fp" Type="System.Int64" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="fp">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.Seek(System.IO.BinaryWriter,System.Int64)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.String" />
      </Targets>
      <Member MemberName="StartsWithInvariantCulture">
        <MemberSignature Language="C#" Value="public static bool StartsWithInvariantCulture (this string str, string startsWith);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool StartsWithInvariantCulture(string str, string startsWith) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.StartsWithInvariantCulture(System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function StartsWithInvariantCulture (str As String, startsWith As String) As Boolean" />
        <MemberSignature Language="F#" Value="static member StartsWithInvariantCulture : string * string -&gt; bool" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.StartsWithInvariantCulture (str, startsWith)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="str" Type="System.String" RefType="this" />
          <Parameter Name="startsWith" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="str">To be added.</param>
          <param name="startsWith">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.StartsWithInvariantCulture(System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.String" />
      </Targets>
      <Member MemberName="StartsWithInvariantCultureIgnoreCase">
        <MemberSignature Language="C#" Value="public static bool StartsWithInvariantCultureIgnoreCase (this string str, string startsWith);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool StartsWithInvariantCultureIgnoreCase(string str, string startsWith) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.StartsWithInvariantCultureIgnoreCase(System.String,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function StartsWithInvariantCultureIgnoreCase (str As String, startsWith As String) As Boolean" />
        <MemberSignature Language="F#" Value="static member StartsWithInvariantCultureIgnoreCase : string * string -&gt; bool" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.StartsWithInvariantCultureIgnoreCase (str, startsWith)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="str" Type="System.String" RefType="this" />
          <Parameter Name="startsWith" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="str">To be added.</param>
          <param name="startsWith">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.StartsWithInvariantCultureIgnoreCase(System.String,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Int32" />
      </Targets>
      <Member MemberName="TryFindIndexSorted">
        <MemberSignature Language="C#" Value="public static bool TryFindIndexSorted (this int[] input, int min, int lim, int value, out int index);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryFindIndexSorted(int32[] input, int32 min, int32 lim, int32 value, [out] int32&amp; index) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.TryFindIndexSorted(System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TryFindIndexSorted (input As Integer(), min As Integer, lim As Integer, value As Integer, ByRef index As Integer) As Boolean" />
        <MemberSignature Language="F#" Value="static member TryFindIndexSorted : int[] * int * int * int *  -&gt; bool" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.TryFindIndexSorted (input, min, lim, value, index)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="System.Int32[]" RefType="this" />
          <Parameter Name="min" Type="System.Int32" />
          <Parameter Name="lim" Type="System.Int32" />
          <Parameter Name="value" Type="System.Int32" />
          <Parameter Name="index" Type="System.Int32" RefType="out" />
        </Parameters>
        <Docs>
          <param name="input">To be added.</param>
          <param name="min">To be added.</param>
          <param name="lim">To be added.</param>
          <param name="value">To be added.</param>
          <param name="index">To be added.</param>
          <summary>
            Akin to <c>FindIndexSorted</c>, except stores the found index in the output
            <c>index</c> parameter, and returns whether that index is a valid index
            pointing to a value equal to the input parameter <c>value</c>.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.TryFindIndexSorted(System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteBitArray">
        <MemberSignature Language="C#" Value="public static void WriteBitArray (this System.IO.BinaryWriter writer, System.Collections.BitArray arr);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteBitArray(class System.IO.BinaryWriter writer, class System.Collections.BitArray arr) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteBitArray(System.IO.BinaryWriter,System.Collections.BitArray)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteBitArray (writer As BinaryWriter, arr As BitArray)" />
        <MemberSignature Language="F#" Value="static member WriteBitArray : System.IO.BinaryWriter * System.Collections.BitArray -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteBitArray (writer, arr)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="arr" Type="System.Collections.BitArray" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="arr">To be added.</param>
          <summary>
            Writes a length prefixed array of packed bits.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteBitArray(System.IO.BinaryWriter,System.Collections.BitArray)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteBoolByte">
        <MemberSignature Language="C#" Value="public static void WriteBoolByte (this System.IO.BinaryWriter writer, bool x);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteBoolByte(class System.IO.BinaryWriter writer, bool x) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteBoolByte(System.IO.BinaryWriter,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteBoolByte (writer As BinaryWriter, x As Boolean)" />
        <MemberSignature Language="F#" Value="static member WriteBoolByte : System.IO.BinaryWriter * bool -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteBoolByte (writer, x)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="x" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="x">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteBoolByte(System.IO.BinaryWriter,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteBoolByteArray">
        <MemberSignature Language="C#" Value="public static void WriteBoolByteArray (this System.IO.BinaryWriter writer, bool[] values);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteBoolByteArray(class System.IO.BinaryWriter writer, bool[] values) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteBoolByteArray(System.IO.BinaryWriter,System.Boolean[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteBoolByteArray (writer As BinaryWriter, values As Boolean())" />
        <MemberSignature Language="F#" Value="static member WriteBoolByteArray : System.IO.BinaryWriter * bool[] -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteBoolByteArray (writer, values)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="values" Type="System.Boolean[]" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="values">To be added.</param>
          <summary>
            Writes a length prefixed array of bools as bytes with 0/1 values.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteBoolByteArray(System.IO.BinaryWriter,System.Boolean[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteBoolByteArray">
        <MemberSignature Language="C#" Value="public static void WriteBoolByteArray (this System.IO.BinaryWriter writer, bool[] values, int count);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteBoolByteArray(class System.IO.BinaryWriter writer, bool[] values, int32 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteBoolByteArray(System.IO.BinaryWriter,System.Boolean[],System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteBoolByteArray (writer As BinaryWriter, values As Boolean(), count As Integer)" />
        <MemberSignature Language="F#" Value="static member WriteBoolByteArray : System.IO.BinaryWriter * bool[] * int -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteBoolByteArray (writer, values, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="values" Type="System.Boolean[]" />
          <Parameter Name="count" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="values">To be added.</param>
          <param name="count">To be added.</param>
          <summary>
            Writes a length prefixed array of bools as bytes with 0/1 values.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteBoolByteArray(System.IO.BinaryWriter,System.Boolean[],System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteBoolBytesNoCount">
        <MemberSignature Language="C#" Value="public static void WriteBoolBytesNoCount (this System.IO.BinaryWriter writer, bool[] values, int count);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteBoolBytesNoCount(class System.IO.BinaryWriter writer, bool[] values, int32 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteBoolBytesNoCount(System.IO.BinaryWriter,System.Boolean[],System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteBoolBytesNoCount (writer As BinaryWriter, values As Boolean(), count As Integer)" />
        <MemberSignature Language="F#" Value="static member WriteBoolBytesNoCount : System.IO.BinaryWriter * bool[] * int -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteBoolBytesNoCount (writer, values, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="values" Type="System.Boolean[]" />
          <Parameter Name="count" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="values">To be added.</param>
          <param name="count">To be added.</param>
          <summary>
            Writes an array of bools as bytes with 0/1 values, without the length prefix.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteBoolBytesNoCount(System.IO.BinaryWriter,System.Boolean[],System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteByteArray">
        <MemberSignature Language="C#" Value="public static void WriteByteArray (this System.IO.BinaryWriter writer, byte[] values);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByteArray(class System.IO.BinaryWriter writer, unsigned int8[] values) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteByteArray(System.IO.BinaryWriter,System.Byte[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteByteArray (writer As BinaryWriter, values As Byte())" />
        <MemberSignature Language="F#" Value="static member WriteByteArray : System.IO.BinaryWriter * byte[] -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteByteArray (writer, values)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="values" Type="System.Byte[]" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="values">To be added.</param>
          <summary>
            Writes a length prefixed array of bytes.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteByteArray(System.IO.BinaryWriter,System.Byte[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteByteArray">
        <MemberSignature Language="C#" Value="public static void WriteByteArray (this System.IO.BinaryWriter writer, byte[] values, int count);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByteArray(class System.IO.BinaryWriter writer, unsigned int8[] values, int32 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteByteArray(System.IO.BinaryWriter,System.Byte[],System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteByteArray (writer As BinaryWriter, values As Byte(), count As Integer)" />
        <MemberSignature Language="F#" Value="static member WriteByteArray : System.IO.BinaryWriter * byte[] * int -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteByteArray (writer, values, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="values" Type="System.Byte[]" />
          <Parameter Name="count" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="values">To be added.</param>
          <param name="count">To be added.</param>
          <summary>
            Writes a length prefixed array of bytes.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteByteArray(System.IO.BinaryWriter,System.Byte[],System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteBytesNoCount">
        <MemberSignature Language="C#" Value="public static void WriteBytesNoCount (this System.IO.BinaryWriter writer, byte[] values, int count);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteBytesNoCount(class System.IO.BinaryWriter writer, unsigned int8[] values, int32 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteBytesNoCount(System.IO.BinaryWriter,System.Byte[],System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteBytesNoCount (writer As BinaryWriter, values As Byte(), count As Integer)" />
        <MemberSignature Language="F#" Value="static member WriteBytesNoCount : System.IO.BinaryWriter * byte[] * int -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteBytesNoCount (writer, values, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="values" Type="System.Byte[]" />
          <Parameter Name="count" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="values">To be added.</param>
          <param name="count">To be added.</param>
          <summary>
            Writes an array of bytes without the length prefix.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteBytesNoCount(System.IO.BinaryWriter,System.Byte[],System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteByteStream">
        <MemberSignature Language="C#" Value="public static long WriteByteStream (this System.IO.BinaryWriter writer, System.Collections.Generic.IEnumerable&lt;byte&gt; e);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 WriteByteStream(class System.IO.BinaryWriter writer, class System.Collections.Generic.IEnumerable`1&lt;unsigned int8&gt; e) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteByteStream(System.IO.BinaryWriter,System.Collections.Generic.IEnumerable{System.Byte})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WriteByteStream (writer As BinaryWriter, e As IEnumerable(Of Byte)) As Long" />
        <MemberSignature Language="F#" Value="static member WriteByteStream : System.IO.BinaryWriter * seq&lt;byte&gt; -&gt; int64" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteByteStream (writer, e)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int64</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="e" Type="System.Collections.Generic.IEnumerable&lt;System.Byte&gt;" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="e">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteByteStream(System.IO.BinaryWriter,System.Collections.Generic.IEnumerable{System.Byte})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteCharArray">
        <MemberSignature Language="C#" Value="public static void WriteCharArray (this System.IO.BinaryWriter writer, char[] values);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteCharArray(class System.IO.BinaryWriter writer, char[] values) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteCharArray(System.IO.BinaryWriter,System.Char[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteCharArray (writer As BinaryWriter, values As Char())" />
        <MemberSignature Language="F#" Value="static member WriteCharArray : System.IO.BinaryWriter * char[] -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteCharArray (writer, values)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="values" Type="System.Char[]" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="values">To be added.</param>
          <summary>
            Writes a length prefixed array of chars.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteCharArray(System.IO.BinaryWriter,System.Char[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteDoubleArray">
        <MemberSignature Language="C#" Value="public static void WriteDoubleArray (this System.IO.BinaryWriter writer, double[] values);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteDoubleArray(class System.IO.BinaryWriter writer, float64[] values) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteDoubleArray(System.IO.BinaryWriter,System.Double[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteDoubleArray (writer As BinaryWriter, values As Double())" />
        <MemberSignature Language="F#" Value="static member WriteDoubleArray : System.IO.BinaryWriter * double[] -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteDoubleArray (writer, values)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="values" Type="System.Double[]" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="values">To be added.</param>
          <summary>
            Writes a length prefixed array of doubles.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteDoubleArray(System.IO.BinaryWriter,System.Double[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteDoubleArray">
        <MemberSignature Language="C#" Value="public static void WriteDoubleArray (this System.IO.BinaryWriter writer, double[] values, int count);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteDoubleArray(class System.IO.BinaryWriter writer, float64[] values, int32 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteDoubleArray(System.IO.BinaryWriter,System.Double[],System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteDoubleArray (writer As BinaryWriter, values As Double(), count As Integer)" />
        <MemberSignature Language="F#" Value="static member WriteDoubleArray : System.IO.BinaryWriter * double[] * int -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteDoubleArray (writer, values, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="values" Type="System.Double[]" />
          <Parameter Name="count" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="values">To be added.</param>
          <param name="count">To be added.</param>
          <summary>
            Writes a length prefixed array of doubles.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteDoubleArray(System.IO.BinaryWriter,System.Double[],System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteDoublesNoCount">
        <MemberSignature Language="C#" Value="public static void WriteDoublesNoCount (this System.IO.BinaryWriter writer, double[] values, int count);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteDoublesNoCount(class System.IO.BinaryWriter writer, float64[] values, int32 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteDoublesNoCount(System.IO.BinaryWriter,System.Double[],System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteDoublesNoCount (writer As BinaryWriter, values As Double(), count As Integer)" />
        <MemberSignature Language="F#" Value="static member WriteDoublesNoCount : System.IO.BinaryWriter * double[] * int -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteDoublesNoCount (writer, values, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="values" Type="System.Double[]" />
          <Parameter Name="count" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="values">To be added.</param>
          <param name="count">To be added.</param>
          <summary>
            Writes an array of doubles without the length prefix.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteDoublesNoCount(System.IO.BinaryWriter,System.Double[],System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteDoubleStream">
        <MemberSignature Language="C#" Value="public static long WriteDoubleStream (this System.IO.BinaryWriter writer, System.Collections.Generic.IEnumerable&lt;double&gt; e);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 WriteDoubleStream(class System.IO.BinaryWriter writer, class System.Collections.Generic.IEnumerable`1&lt;float64&gt; e) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteDoubleStream(System.IO.BinaryWriter,System.Collections.Generic.IEnumerable{System.Double})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WriteDoubleStream (writer As BinaryWriter, e As IEnumerable(Of Double)) As Long" />
        <MemberSignature Language="F#" Value="static member WriteDoubleStream : System.IO.BinaryWriter * seq&lt;double&gt; -&gt; int64" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteDoubleStream (writer, e)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int64</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="e" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="e">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteDoubleStream(System.IO.BinaryWriter,System.Collections.Generic.IEnumerable{System.Double})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteFloatArray">
        <MemberSignature Language="C#" Value="public static void WriteFloatArray (this System.IO.BinaryWriter writer, System.Collections.Generic.IEnumerable&lt;float&gt; values, int count);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteFloatArray(class System.IO.BinaryWriter writer, class System.Collections.Generic.IEnumerable`1&lt;float32&gt; values, int32 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteFloatArray(System.IO.BinaryWriter,System.Collections.Generic.IEnumerable{System.Single},System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteFloatArray (writer As BinaryWriter, values As IEnumerable(Of Single), count As Integer)" />
        <MemberSignature Language="F#" Value="static member WriteFloatArray : System.IO.BinaryWriter * seq&lt;single&gt; * int -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteFloatArray (writer, values, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" />
          <Parameter Name="count" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="values">To be added.</param>
          <param name="count">To be added.</param>
          <summary>
            Writes a length prefixed array of Floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteFloatArray(System.IO.BinaryWriter,System.Collections.Generic.IEnumerable{System.Single},System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteFloatArray">
        <MemberSignature Language="C#" Value="public static void WriteFloatArray (this System.IO.BinaryWriter writer, float[] values);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteFloatArray(class System.IO.BinaryWriter writer, float32[] values) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteFloatArray(System.IO.BinaryWriter,System.Single[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteFloatArray (writer As BinaryWriter, values As Single())" />
        <MemberSignature Language="F#" Value="static member WriteFloatArray : System.IO.BinaryWriter * single[] -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteFloatArray (writer, values)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="values" Type="System.Single[]" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="values">To be added.</param>
          <summary>
            Writes a length prefixed array of Floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteFloatArray(System.IO.BinaryWriter,System.Single[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteFloatArray">
        <MemberSignature Language="C#" Value="public static void WriteFloatArray (this System.IO.BinaryWriter writer, float[] values, int count);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteFloatArray(class System.IO.BinaryWriter writer, float32[] values, int32 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteFloatArray(System.IO.BinaryWriter,System.Single[],System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteFloatArray (writer As BinaryWriter, values As Single(), count As Integer)" />
        <MemberSignature Language="F#" Value="static member WriteFloatArray : System.IO.BinaryWriter * single[] * int -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteFloatArray (writer, values, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="values" Type="System.Single[]" />
          <Parameter Name="count" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="values">To be added.</param>
          <param name="count">To be added.</param>
          <summary>
            Writes a length prefixed array of Floats.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteFloatArray(System.IO.BinaryWriter,System.Single[],System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteFloatArray">
        <MemberSignature Language="C#" Value="public static void WriteFloatArray (this System.IO.BinaryWriter writer, float[] values, int start, int count);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteFloatArray(class System.IO.BinaryWriter writer, float32[] values, int32 start, int32 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteFloatArray(System.IO.BinaryWriter,System.Single[],System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteFloatArray (writer As BinaryWriter, values As Single(), start As Integer, count As Integer)" />
        <MemberSignature Language="F#" Value="static member WriteFloatArray : System.IO.BinaryWriter * single[] * int * int -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteFloatArray (writer, values, start, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="values" Type="System.Single[]" />
          <Parameter Name="start" Type="System.Int32" />
          <Parameter Name="count" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="values">To be added.</param>
          <param name="start">To be added.</param>
          <param name="count">To be added.</param>
          <summary>
            Writes a specified number of floats starting at the specified index from an array.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteFloatArray(System.IO.BinaryWriter,System.Single[],System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteFloatsNoCount">
        <MemberSignature Language="C#" Value="public static void WriteFloatsNoCount (this System.IO.BinaryWriter writer, float[] values, int count);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteFloatsNoCount(class System.IO.BinaryWriter writer, float32[] values, int32 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteFloatsNoCount(System.IO.BinaryWriter,System.Single[],System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteFloatsNoCount (writer As BinaryWriter, values As Single(), count As Integer)" />
        <MemberSignature Language="F#" Value="static member WriteFloatsNoCount : System.IO.BinaryWriter * single[] * int -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteFloatsNoCount (writer, values, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="values" Type="System.Single[]" />
          <Parameter Name="count" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="values">To be added.</param>
          <param name="count">To be added.</param>
          <summary>
            Writes an array of Floats without the length prefix.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteFloatsNoCount(System.IO.BinaryWriter,System.Single[],System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteIntArray">
        <MemberSignature Language="C#" Value="public static void WriteIntArray (this System.IO.BinaryWriter writer, int[] values);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntArray(class System.IO.BinaryWriter writer, int32[] values) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteIntArray(System.IO.BinaryWriter,System.Int32[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteIntArray (writer As BinaryWriter, values As Integer())" />
        <MemberSignature Language="F#" Value="static member WriteIntArray : System.IO.BinaryWriter * int[] -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteIntArray (writer, values)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="values" Type="System.Int32[]" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="values">To be added.</param>
          <summary>
            Writes a length prefixed array of ints.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteIntArray(System.IO.BinaryWriter,System.Int32[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteIntArray">
        <MemberSignature Language="C#" Value="public static void WriteIntArray (this System.IO.BinaryWriter writer, int[] values, int count);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntArray(class System.IO.BinaryWriter writer, int32[] values, int32 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteIntArray(System.IO.BinaryWriter,System.Int32[],System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteIntArray (writer As BinaryWriter, values As Integer(), count As Integer)" />
        <MemberSignature Language="F#" Value="static member WriteIntArray : System.IO.BinaryWriter * int[] * int -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteIntArray (writer, values, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="values" Type="System.Int32[]" />
          <Parameter Name="count" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="values">To be added.</param>
          <param name="count">To be added.</param>
          <summary>
            Writes a length prefixed array of ints.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteIntArray(System.IO.BinaryWriter,System.Int32[],System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteIntsNoCount">
        <MemberSignature Language="C#" Value="public static void WriteIntsNoCount (this System.IO.BinaryWriter writer, int[] values, int count);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntsNoCount(class System.IO.BinaryWriter writer, int32[] values, int32 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteIntsNoCount(System.IO.BinaryWriter,System.Int32[],System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteIntsNoCount (writer As BinaryWriter, values As Integer(), count As Integer)" />
        <MemberSignature Language="F#" Value="static member WriteIntsNoCount : System.IO.BinaryWriter * int[] * int -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteIntsNoCount (writer, values, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="values" Type="System.Int32[]" />
          <Parameter Name="count" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="values">To be added.</param>
          <param name="count">To be added.</param>
          <summary>
            Writes an array of ints without the length prefix.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteIntsNoCount(System.IO.BinaryWriter,System.Int32[],System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteIntStream">
        <MemberSignature Language="C#" Value="public static long WriteIntStream (this System.IO.BinaryWriter writer, System.Collections.Generic.IEnumerable&lt;int&gt; e);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 WriteIntStream(class System.IO.BinaryWriter writer, class System.Collections.Generic.IEnumerable`1&lt;int32&gt; e) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteIntStream(System.IO.BinaryWriter,System.Collections.Generic.IEnumerable{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WriteIntStream (writer As BinaryWriter, e As IEnumerable(Of Integer)) As Long" />
        <MemberSignature Language="F#" Value="static member WriteIntStream : System.IO.BinaryWriter * seq&lt;int&gt; -&gt; int64" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteIntStream (writer, e)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int64</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="e" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="e">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteIntStream(System.IO.BinaryWriter,System.Collections.Generic.IEnumerable{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteLeb128Int">
        <MemberSignature Language="C#" Value="public static void WriteLeb128Int (this System.IO.BinaryWriter writer, ulong value);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLeb128Int(class System.IO.BinaryWriter writer, unsigned int64 value) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteLeb128Int(System.IO.BinaryWriter,System.UInt64)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteLeb128Int (writer As BinaryWriter, value As ULong)" />
        <MemberSignature Language="F#" Value="static member WriteLeb128Int : System.IO.BinaryWriter * uint64 -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteLeb128Int (writer, value)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="value" Type="System.UInt64" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="value">To be added.</param>
          <summary>
            Writes what Microsoft calls a UTF-7 encoded number in the binary reader and
            writer string methods. For non-negative integers this is equivalent to LEB128
            (see https://en.wikipedia.org/wiki/LEB128).
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteLeb128Int(System.IO.BinaryWriter,System.UInt64)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteLongStream">
        <MemberSignature Language="C#" Value="public static long WriteLongStream (this System.IO.BinaryWriter writer, System.Collections.Generic.IEnumerable&lt;long&gt; e);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 WriteLongStream(class System.IO.BinaryWriter writer, class System.Collections.Generic.IEnumerable`1&lt;int64&gt; e) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteLongStream(System.IO.BinaryWriter,System.Collections.Generic.IEnumerable{System.Int64})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WriteLongStream (writer As BinaryWriter, e As IEnumerable(Of Long)) As Long" />
        <MemberSignature Language="F#" Value="static member WriteLongStream : System.IO.BinaryWriter * seq&lt;int64&gt; -&gt; int64" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteLongStream (writer, e)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int64</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="e" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="e">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteLongStream(System.IO.BinaryWriter,System.Collections.Generic.IEnumerable{System.Int64})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteSByteStream">
        <MemberSignature Language="C#" Value="public static long WriteSByteStream (this System.IO.BinaryWriter writer, System.Collections.Generic.IEnumerable&lt;sbyte&gt; e);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 WriteSByteStream(class System.IO.BinaryWriter writer, class System.Collections.Generic.IEnumerable`1&lt;int8&gt; e) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteSByteStream(System.IO.BinaryWriter,System.Collections.Generic.IEnumerable{System.SByte})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WriteSByteStream (writer As BinaryWriter, e As IEnumerable(Of SByte)) As Long" />
        <MemberSignature Language="F#" Value="static member WriteSByteStream : System.IO.BinaryWriter * seq&lt;sbyte&gt; -&gt; int64" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteSByteStream (writer, e)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int64</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="e" Type="System.Collections.Generic.IEnumerable&lt;System.SByte&gt;" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="e">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteSByteStream(System.IO.BinaryWriter,System.Collections.Generic.IEnumerable{System.SByte})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteShortStream">
        <MemberSignature Language="C#" Value="public static long WriteShortStream (this System.IO.BinaryWriter writer, System.Collections.Generic.IEnumerable&lt;short&gt; e);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 WriteShortStream(class System.IO.BinaryWriter writer, class System.Collections.Generic.IEnumerable`1&lt;int16&gt; e) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteShortStream(System.IO.BinaryWriter,System.Collections.Generic.IEnumerable{System.Int16})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WriteShortStream (writer As BinaryWriter, e As IEnumerable(Of Short)) As Long" />
        <MemberSignature Language="F#" Value="static member WriteShortStream : System.IO.BinaryWriter * seq&lt;int16&gt; -&gt; int64" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteShortStream (writer, e)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int64</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="e" Type="System.Collections.Generic.IEnumerable&lt;System.Int16&gt;" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="e">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteShortStream(System.IO.BinaryWriter,System.Collections.Generic.IEnumerable{System.Int16})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteSingleArray">
        <MemberSignature Language="C#" Value="public static void WriteSingleArray (this System.IO.BinaryWriter writer, float[] values);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteSingleArray(class System.IO.BinaryWriter writer, float32[] values) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteSingleArray(System.IO.BinaryWriter,System.Single[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteSingleArray (writer As BinaryWriter, values As Single())" />
        <MemberSignature Language="F#" Value="static member WriteSingleArray : System.IO.BinaryWriter * single[] -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteSingleArray (writer, values)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="values" Type="System.Single[]" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="values">To be added.</param>
          <summary>
            Writes a length prefixed array of singles.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteSingleArray(System.IO.BinaryWriter,System.Single[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteSingleArray">
        <MemberSignature Language="C#" Value="public static void WriteSingleArray (this System.IO.BinaryWriter writer, float[] values, int count);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteSingleArray(class System.IO.BinaryWriter writer, float32[] values, int32 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteSingleArray(System.IO.BinaryWriter,System.Single[],System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteSingleArray (writer As BinaryWriter, values As Single(), count As Integer)" />
        <MemberSignature Language="F#" Value="static member WriteSingleArray : System.IO.BinaryWriter * single[] * int -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteSingleArray (writer, values, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="values" Type="System.Single[]" />
          <Parameter Name="count" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="values">To be added.</param>
          <param name="count">To be added.</param>
          <summary>
            Writes a length prefixed array of singles.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteSingleArray(System.IO.BinaryWriter,System.Single[],System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteSinglesNoCount">
        <MemberSignature Language="C#" Value="public static void WriteSinglesNoCount (this System.IO.BinaryWriter writer, float[] values, int count);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteSinglesNoCount(class System.IO.BinaryWriter writer, float32[] values, int32 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteSinglesNoCount(System.IO.BinaryWriter,System.Single[],System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteSinglesNoCount (writer As BinaryWriter, values As Single(), count As Integer)" />
        <MemberSignature Language="F#" Value="static member WriteSinglesNoCount : System.IO.BinaryWriter * single[] * int -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteSinglesNoCount (writer, values, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="values" Type="System.Single[]" />
          <Parameter Name="count" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="values">To be added.</param>
          <param name="count">To be added.</param>
          <summary>
            Writes an array of singles without the length prefix.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteSinglesNoCount(System.IO.BinaryWriter,System.Single[],System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteSingleStream">
        <MemberSignature Language="C#" Value="public static long WriteSingleStream (this System.IO.BinaryWriter writer, System.Collections.Generic.IEnumerable&lt;float&gt; e);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 WriteSingleStream(class System.IO.BinaryWriter writer, class System.Collections.Generic.IEnumerable`1&lt;float32&gt; e) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteSingleStream(System.IO.BinaryWriter,System.Collections.Generic.IEnumerable{System.Single})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WriteSingleStream (writer As BinaryWriter, e As IEnumerable(Of Single)) As Long" />
        <MemberSignature Language="F#" Value="static member WriteSingleStream : System.IO.BinaryWriter * seq&lt;single&gt; -&gt; int64" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteSingleStream (writer, e)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int64</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="e" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="e">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteSingleStream(System.IO.BinaryWriter,System.Collections.Generic.IEnumerable{System.Single})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteStringStream">
        <MemberSignature Language="C#" Value="public static long WriteStringStream (this System.IO.BinaryWriter writer, System.Collections.Generic.IEnumerable&lt;string&gt; e);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 WriteStringStream(class System.IO.BinaryWriter writer, class System.Collections.Generic.IEnumerable`1&lt;string&gt; e) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteStringStream(System.IO.BinaryWriter,System.Collections.Generic.IEnumerable{System.String})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WriteStringStream (writer As BinaryWriter, e As IEnumerable(Of String)) As Long" />
        <MemberSignature Language="F#" Value="static member WriteStringStream : System.IO.BinaryWriter * seq&lt;string&gt; -&gt; int64" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteStringStream (writer, e)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int64</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="e" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="e">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteStringStream(System.IO.BinaryWriter,System.Collections.Generic.IEnumerable{System.String})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteUIntArray">
        <MemberSignature Language="C#" Value="public static void WriteUIntArray (this System.IO.BinaryWriter writer, uint[] values);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUIntArray(class System.IO.BinaryWriter writer, unsigned int32[] values) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteUIntArray(System.IO.BinaryWriter,System.UInt32[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteUIntArray (writer As BinaryWriter, values As UInteger())" />
        <MemberSignature Language="F#" Value="static member WriteUIntArray : System.IO.BinaryWriter * uint32[] -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteUIntArray (writer, values)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="values" Type="System.UInt32[]" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="values">To be added.</param>
          <summary>
            Writes a length prefixed array of uints.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteUIntArray(System.IO.BinaryWriter,System.UInt32[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteUIntArray">
        <MemberSignature Language="C#" Value="public static void WriteUIntArray (this System.IO.BinaryWriter writer, uint[] values, int count);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUIntArray(class System.IO.BinaryWriter writer, unsigned int32[] values, int32 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteUIntArray(System.IO.BinaryWriter,System.UInt32[],System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteUIntArray (writer As BinaryWriter, values As UInteger(), count As Integer)" />
        <MemberSignature Language="F#" Value="static member WriteUIntArray : System.IO.BinaryWriter * uint32[] * int -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteUIntArray (writer, values, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="values" Type="System.UInt32[]" />
          <Parameter Name="count" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="values">To be added.</param>
          <param name="count">To be added.</param>
          <summary>
            Writes a length prefixed array of uints.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteUIntArray(System.IO.BinaryWriter,System.UInt32[],System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteUIntsNoCount">
        <MemberSignature Language="C#" Value="public static void WriteUIntsNoCount (this System.IO.BinaryWriter writer, uint[] values, int count);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUIntsNoCount(class System.IO.BinaryWriter writer, unsigned int32[] values, int32 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteUIntsNoCount(System.IO.BinaryWriter,System.UInt32[],System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub WriteUIntsNoCount (writer As BinaryWriter, values As UInteger(), count As Integer)" />
        <MemberSignature Language="F#" Value="static member WriteUIntsNoCount : System.IO.BinaryWriter * uint32[] * int -&gt; unit" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteUIntsNoCount (writer, values, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="values" Type="System.UInt32[]" />
          <Parameter Name="count" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="values">To be added.</param>
          <param name="count">To be added.</param>
          <summary>
            Writes an array of uints without the length prefix.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteUIntsNoCount(System.IO.BinaryWriter,System.UInt32[],System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteUIntStream">
        <MemberSignature Language="C#" Value="public static long WriteUIntStream (this System.IO.BinaryWriter writer, System.Collections.Generic.IEnumerable&lt;uint&gt; e);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 WriteUIntStream(class System.IO.BinaryWriter writer, class System.Collections.Generic.IEnumerable`1&lt;unsigned int32&gt; e) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteUIntStream(System.IO.BinaryWriter,System.Collections.Generic.IEnumerable{System.UInt32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WriteUIntStream (writer As BinaryWriter, e As IEnumerable(Of UInteger)) As Long" />
        <MemberSignature Language="F#" Value="static member WriteUIntStream : System.IO.BinaryWriter * seq&lt;uint32&gt; -&gt; int64" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteUIntStream (writer, e)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int64</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="e" Type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="e">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteUIntStream(System.IO.BinaryWriter,System.Collections.Generic.IEnumerable{System.UInt32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteULongStream">
        <MemberSignature Language="C#" Value="public static long WriteULongStream (this System.IO.BinaryWriter writer, System.Collections.Generic.IEnumerable&lt;long&gt; e);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 WriteULongStream(class System.IO.BinaryWriter writer, class System.Collections.Generic.IEnumerable`1&lt;int64&gt; e) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteULongStream(System.IO.BinaryWriter,System.Collections.Generic.IEnumerable{System.Int64})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WriteULongStream (writer As BinaryWriter, e As IEnumerable(Of Long)) As Long" />
        <MemberSignature Language="F#" Value="static member WriteULongStream : System.IO.BinaryWriter * seq&lt;int64&gt; -&gt; int64" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteULongStream (writer, e)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int64</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="e" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="e">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteULongStream(System.IO.BinaryWriter,System.Collections.Generic.IEnumerable{System.Int64})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.IO.BinaryWriter" />
      </Targets>
      <Member MemberName="WriteUShortStream">
        <MemberSignature Language="C#" Value="public static long WriteUShortStream (this System.IO.BinaryWriter writer, System.Collections.Generic.IEnumerable&lt;ushort&gt; e);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 WriteUShortStream(class System.IO.BinaryWriter writer, class System.Collections.Generic.IEnumerable`1&lt;unsigned int16&gt; e) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteUShortStream(System.IO.BinaryWriter,System.Collections.Generic.IEnumerable{System.UInt16})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WriteUShortStream (writer As BinaryWriter, e As IEnumerable(Of UShort)) As Long" />
        <MemberSignature Language="F#" Value="static member WriteUShortStream : System.IO.BinaryWriter * seq&lt;uint16&gt; -&gt; int64" Usage="Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteUShortStream (writer, e)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int64</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="writer" Type="System.IO.BinaryWriter" RefType="this" />
          <Parameter Name="e" Type="System.Collections.Generic.IEnumerable&lt;System.UInt16&gt;" />
        </Parameters>
        <Docs>
          <param name="writer">To be added.</param>
          <param name="e">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Internal.Utilities.Utils" Member="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.WriteUShortStream(System.IO.BinaryWriter,System.Collections.Generic.IEnumerable{System.UInt16})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Newtonsoft.Json.Linq.JObject" />
      </Targets>
      <Member MemberName="AddReturn">
        <MemberSignature Language="C#" Value="public static Newtonsoft.Json.Linq.JObject AddReturn (this Newtonsoft.Json.Linq.JObject toEdit, string name, Newtonsoft.Json.Linq.JToken value);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Newtonsoft.Json.Linq.JObject AddReturn(class Newtonsoft.Json.Linq.JObject toEdit, string name, class Newtonsoft.Json.Linq.JToken value) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Model.Pfa.PfaUtils.AddReturn(Newtonsoft.Json.Linq.JObject,System.String,Newtonsoft.Json.Linq.JToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AddReturn (toEdit As JObject, name As String, value As JToken) As JObject" />
        <MemberSignature Language="F#" Value="static member AddReturn : Newtonsoft.Json.Linq.JObject * string * Newtonsoft.Json.Linq.JToken -&gt; Newtonsoft.Json.Linq.JObject" Usage="Microsoft.ML.Runtime.Model.Pfa.PfaUtils.AddReturn (toEdit, name, value)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Newtonsoft.Json.Linq.JObject</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="toEdit" Type="Newtonsoft.Json.Linq.JObject" RefType="this" />
          <Parameter Name="name" Type="System.String" />
          <Parameter Name="value" Type="Newtonsoft.Json.Linq.JToken" />
        </Parameters>
        <Docs>
          <param name="toEdit">To be added.</param>
          <param name="name">To be added.</param>
          <param name="value">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Model.Pfa.PfaUtils" Member="M:Microsoft.ML.Runtime.Model.Pfa.PfaUtils.AddReturn(Newtonsoft.Json.Linq.JObject,System.String,Newtonsoft.Json.Linq.JToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Model.Pfa.PfaContext" />
      </Targets>
      <Member MemberName="EnsureAdd">
        <MemberSignature Language="C#" Value="public static string EnsureAdd (this Microsoft.ML.Runtime.Model.Pfa.PfaContext ctx, Newtonsoft.Json.Linq.JToken itemType);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EnsureAdd(class Microsoft.ML.Runtime.Model.Pfa.PfaContext ctx, class Newtonsoft.Json.Linq.JToken itemType) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Model.Pfa.PfaUtils.EnsureAdd(Microsoft.ML.Runtime.Model.Pfa.PfaContext,Newtonsoft.Json.Linq.JToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EnsureAdd (ctx As PfaContext, itemType As JToken) As String" />
        <MemberSignature Language="F#" Value="static member EnsureAdd : Microsoft.ML.Runtime.Model.Pfa.PfaContext * Newtonsoft.Json.Linq.JToken -&gt; string" Usage="Microsoft.ML.Runtime.Model.Pfa.PfaUtils.EnsureAdd (ctx, itemType)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.Model.Pfa.PfaContext" RefType="this" />
          <Parameter Name="itemType" Type="Newtonsoft.Json.Linq.JToken" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="itemType">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Model.Pfa.PfaUtils" Member="M:Microsoft.ML.Runtime.Model.Pfa.PfaUtils.EnsureAdd(Microsoft.ML.Runtime.Model.Pfa.PfaContext,Newtonsoft.Json.Linq.JToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Model.Pfa.PfaContext" />
      </Targets>
      <Member MemberName="EnsureCount">
        <MemberSignature Language="C#" Value="public static string EnsureCount (this Microsoft.ML.Runtime.Model.Pfa.PfaContext ctx, Newtonsoft.Json.Linq.JToken itemType);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EnsureCount(class Microsoft.ML.Runtime.Model.Pfa.PfaContext ctx, class Newtonsoft.Json.Linq.JToken itemType) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Model.Pfa.PfaUtils.EnsureCount(Microsoft.ML.Runtime.Model.Pfa.PfaContext,Newtonsoft.Json.Linq.JToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EnsureCount (ctx As PfaContext, itemType As JToken) As String" />
        <MemberSignature Language="F#" Value="static member EnsureCount : Microsoft.ML.Runtime.Model.Pfa.PfaContext * Newtonsoft.Json.Linq.JToken -&gt; string" Usage="Microsoft.ML.Runtime.Model.Pfa.PfaUtils.EnsureCount (ctx, itemType)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.Model.Pfa.PfaContext" RefType="this" />
          <Parameter Name="itemType" Type="Newtonsoft.Json.Linq.JToken" />
        </Parameters>
        <Docs>
          <param name="ctx">The context to check for the existence of this</param>
          <param name="itemType">The item type this will operate on</param>
          <summary>
            This ensures that there is a function formatted as "count_type" (e.g., "count_double"),
            that takes either a map or array and returns the number of items in that map or array.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Model.Pfa.PfaUtils" Member="M:Microsoft.ML.Runtime.Model.Pfa.PfaUtils.EnsureCount(Microsoft.ML.Runtime.Model.Pfa.PfaContext,Newtonsoft.Json.Linq.JToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Model.Pfa.PfaContext" />
      </Targets>
      <Member MemberName="EnsureDiv">
        <MemberSignature Language="C#" Value="public static string EnsureDiv (this Microsoft.ML.Runtime.Model.Pfa.PfaContext ctx, Newtonsoft.Json.Linq.JToken itemType);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EnsureDiv(class Microsoft.ML.Runtime.Model.Pfa.PfaContext ctx, class Newtonsoft.Json.Linq.JToken itemType) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Model.Pfa.PfaUtils.EnsureDiv(Microsoft.ML.Runtime.Model.Pfa.PfaContext,Newtonsoft.Json.Linq.JToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EnsureDiv (ctx As PfaContext, itemType As JToken) As String" />
        <MemberSignature Language="F#" Value="static member EnsureDiv : Microsoft.ML.Runtime.Model.Pfa.PfaContext * Newtonsoft.Json.Linq.JToken -&gt; string" Usage="Microsoft.ML.Runtime.Model.Pfa.PfaUtils.EnsureDiv (ctx, itemType)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.Model.Pfa.PfaContext" RefType="this" />
          <Parameter Name="itemType" Type="Newtonsoft.Json.Linq.JToken" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="itemType">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Model.Pfa.PfaUtils" Member="M:Microsoft.ML.Runtime.Model.Pfa.PfaUtils.EnsureDiv(Microsoft.ML.Runtime.Model.Pfa.PfaContext,Newtonsoft.Json.Linq.JToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Model.Pfa.PfaContext" />
      </Targets>
      <Member MemberName="EnsureHasChars">
        <MemberSignature Language="C#" Value="public static string EnsureHasChars (this Microsoft.ML.Runtime.Model.Pfa.PfaContext ctx);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EnsureHasChars(class Microsoft.ML.Runtime.Model.Pfa.PfaContext ctx) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Model.Pfa.PfaUtils.EnsureHasChars(Microsoft.ML.Runtime.Model.Pfa.PfaContext)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EnsureHasChars (ctx As PfaContext) As String" />
        <MemberSignature Language="F#" Value="static member EnsureHasChars : Microsoft.ML.Runtime.Model.Pfa.PfaContext -&gt; string" Usage="Microsoft.ML.Runtime.Model.Pfa.PfaUtils.EnsureHasChars ctx" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.Model.Pfa.PfaContext" RefType="this" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <summary>
            A string -&gt; bool function for determining whether a string has content.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Model.Pfa.PfaUtils" Member="M:Microsoft.ML.Runtime.Model.Pfa.PfaUtils.EnsureHasChars(Microsoft.ML.Runtime.Model.Pfa.PfaContext)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Model.Pfa.PfaContext" />
      </Targets>
      <Member MemberName="EnsureMul">
        <MemberSignature Language="C#" Value="public static string EnsureMul (this Microsoft.ML.Runtime.Model.Pfa.PfaContext ctx, Newtonsoft.Json.Linq.JToken itemType);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EnsureMul(class Microsoft.ML.Runtime.Model.Pfa.PfaContext ctx, class Newtonsoft.Json.Linq.JToken itemType) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Model.Pfa.PfaUtils.EnsureMul(Microsoft.ML.Runtime.Model.Pfa.PfaContext,Newtonsoft.Json.Linq.JToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EnsureMul (ctx As PfaContext, itemType As JToken) As String" />
        <MemberSignature Language="F#" Value="static member EnsureMul : Microsoft.ML.Runtime.Model.Pfa.PfaContext * Newtonsoft.Json.Linq.JToken -&gt; string" Usage="Microsoft.ML.Runtime.Model.Pfa.PfaUtils.EnsureMul (ctx, itemType)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.Model.Pfa.PfaContext" RefType="this" />
          <Parameter Name="itemType" Type="Newtonsoft.Json.Linq.JToken" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="itemType">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Model.Pfa.PfaUtils" Member="M:Microsoft.ML.Runtime.Model.Pfa.PfaUtils.EnsureMul(Microsoft.ML.Runtime.Model.Pfa.PfaContext,Newtonsoft.Json.Linq.JToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Model.Pfa.PfaContext" />
      </Targets>
      <Member MemberName="EnsureNewArray">
        <MemberSignature Language="C#" Value="public static string EnsureNewArray (this Microsoft.ML.Runtime.Model.Pfa.PfaContext ctx);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EnsureNewArray(class Microsoft.ML.Runtime.Model.Pfa.PfaContext ctx) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Model.Pfa.PfaUtils.EnsureNewArray(Microsoft.ML.Runtime.Model.Pfa.PfaContext)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EnsureNewArray (ctx As PfaContext) As String" />
        <MemberSignature Language="F#" Value="static member EnsureNewArray : Microsoft.ML.Runtime.Model.Pfa.PfaContext -&gt; string" Usage="Microsoft.ML.Runtime.Model.Pfa.PfaUtils.EnsureNewArray ctx" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.Model.Pfa.PfaContext" RefType="this" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Model.Pfa.PfaUtils" Member="M:Microsoft.ML.Runtime.Model.Pfa.PfaUtils.EnsureNewArray(Microsoft.ML.Runtime.Model.Pfa.PfaContext)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Model.Pfa.PfaContext" />
      </Targets>
      <Member MemberName="EnsureSub">
        <MemberSignature Language="C#" Value="public static string EnsureSub (this Microsoft.ML.Runtime.Model.Pfa.PfaContext ctx, Newtonsoft.Json.Linq.JToken itemType);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EnsureSub(class Microsoft.ML.Runtime.Model.Pfa.PfaContext ctx, class Newtonsoft.Json.Linq.JToken itemType) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Model.Pfa.PfaUtils.EnsureSub(Microsoft.ML.Runtime.Model.Pfa.PfaContext,Newtonsoft.Json.Linq.JToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EnsureSub (ctx As PfaContext, itemType As JToken) As String" />
        <MemberSignature Language="F#" Value="static member EnsureSub : Microsoft.ML.Runtime.Model.Pfa.PfaContext * Newtonsoft.Json.Linq.JToken -&gt; string" Usage="Microsoft.ML.Runtime.Model.Pfa.PfaUtils.EnsureSub (ctx, itemType)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.Runtime.Model.Pfa.PfaContext" RefType="this" />
          <Parameter Name="itemType" Type="Newtonsoft.Json.Linq.JToken" />
        </Parameters>
        <Docs>
          <param name="ctx">To be added.</param>
          <param name="itemType">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Model.Pfa.PfaUtils" Member="M:Microsoft.ML.Runtime.Model.Pfa.PfaUtils.EnsureSub(Microsoft.ML.Runtime.Model.Pfa.PfaContext,Newtonsoft.Json.Linq.JToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.IDataView" />
      </Targets>
      <Member MemberName="Cache">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.IDataView Cache (this Microsoft.ML.Runtime.Data.IDataView data);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.IDataView Cache(class Microsoft.ML.Runtime.Data.IDataView data) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.PipelineInference.InferenceUtils.Cache(Microsoft.ML.Runtime.Data.IDataView)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Cache (data As IDataView) As IDataView" />
        <MemberSignature Language="F#" Value="static member Cache : Microsoft.ML.Runtime.Data.IDataView -&gt; Microsoft.ML.Runtime.Data.IDataView" Usage="Microsoft.ML.Runtime.PipelineInference.InferenceUtils.Cache data" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.IDataView</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.Runtime.Data.IDataView" RefType="this" />
        </Parameters>
        <Docs>
          <param name="data">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.PipelineInference.InferenceUtils" Member="M:Microsoft.ML.Runtime.PipelineInference.InferenceUtils.Cache(Microsoft.ML.Runtime.Data.IDataView)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.IDataView" />
      </Targets>
      <Member MemberName="Take">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.IDataView Take (this Microsoft.ML.Runtime.Data.IDataView data, int count);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.IDataView Take(class Microsoft.ML.Runtime.Data.IDataView data, int32 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.PipelineInference.InferenceUtils.Take(Microsoft.ML.Runtime.Data.IDataView,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Take (data As IDataView, count As Integer) As IDataView" />
        <MemberSignature Language="F#" Value="static member Take : Microsoft.ML.Runtime.Data.IDataView * int -&gt; Microsoft.ML.Runtime.Data.IDataView" Usage="Microsoft.ML.Runtime.PipelineInference.InferenceUtils.Take (data, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.IDataView</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.Runtime.Data.IDataView" RefType="this" />
          <Parameter Name="count" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="data">To be added.</param>
          <param name="count">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.PipelineInference.InferenceUtils" Member="M:Microsoft.ML.Runtime.PipelineInference.InferenceUtils.Take(Microsoft.ML.Runtime.Data.IDataView,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.IChannelProvider" />
      </Targets>
      <Member MemberName="StartServerChannel">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.ServerChannel StartServerChannel (this Microsoft.ML.Runtime.IChannelProvider provider, string identifier);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.ServerChannel StartServerChannel(class Microsoft.ML.Runtime.IChannelProvider provider, string identifier) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.ServerChannelUtilities.StartServerChannel(Microsoft.ML.Runtime.IChannelProvider,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function StartServerChannel (provider As IChannelProvider, identifier As String) As ServerChannel" />
        <MemberSignature Language="F#" Value="static member StartServerChannel : Microsoft.ML.Runtime.IChannelProvider * string -&gt; Microsoft.ML.Runtime.ServerChannel" Usage="Microsoft.ML.Runtime.ServerChannelUtilities.StartServerChannel (provider, identifier)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.ServerChannel</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="provider" Type="Microsoft.ML.Runtime.IChannelProvider" RefType="this" />
          <Parameter Name="identifier" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="provider">The channel provider.</param>
          <param name="identifier">This is an identifier of the "type" of bundle that is being published,
            and should form a path with forward-slash '/' delimiters.</param>
          <summary>
            Convenience method for <see cref="M:Microsoft.ML.Runtime.ServerChannel.Start(Microsoft.ML.Runtime.IChannelProvider,System.String)" /> that looks more idiomatic to typical
            channel creation methods on <see cref="T:Microsoft.ML.Runtime.IChannelProvider" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.ServerChannelUtilities" Member="M:Microsoft.ML.Runtime.ServerChannelUtilities.StartServerChannel(Microsoft.ML.Runtime.IChannelProvider,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.ITrainer" />
      </Targets>
      <Member MemberName="Train">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.IPredictor Train (this Microsoft.ML.Runtime.ITrainer trainer, Microsoft.ML.Runtime.Data.RoleMappedData trainData);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.IPredictor Train(class Microsoft.ML.Runtime.ITrainer trainer, class Microsoft.ML.Runtime.Data.RoleMappedData trainData) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.TrainerExtensions.Train(Microsoft.ML.Runtime.ITrainer,Microsoft.ML.Runtime.Data.RoleMappedData)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Train (trainer As ITrainer, trainData As RoleMappedData) As IPredictor" />
        <MemberSignature Language="F#" Value="static member Train : Microsoft.ML.Runtime.ITrainer * Microsoft.ML.Runtime.Data.RoleMappedData -&gt; Microsoft.ML.Runtime.IPredictor" Usage="Microsoft.ML.Runtime.TrainerExtensions.Train (trainer, trainData)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.IPredictor</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="trainer" Type="Microsoft.ML.Runtime.ITrainer" RefType="this" />
          <Parameter Name="trainData" Type="Microsoft.ML.Runtime.Data.RoleMappedData" />
        </Parameters>
        <Docs>
          <param name="trainer">The trainer</param>
          <param name="trainData">The training data.</param>
          <summary>
            Convenience train extension for the case where one has only a training set with no auxiliary information.
            Equivalent to calling <see cref="M:Microsoft.ML.Runtime.ITrainer.Train(Microsoft.ML.Runtime.TrainContext)" />
            on a <see cref="T:Microsoft.ML.Runtime.TrainContext" /> constructed with <paramref name="trainData" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.TrainerExtensions" Member="M:Microsoft.ML.Runtime.TrainerExtensions.Train(Microsoft.ML.Runtime.ITrainer,Microsoft.ML.Runtime.Data.RoleMappedData)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.ITrainer`1" />
      </Targets>
      <Member MemberName="Train&lt;TPredictor&gt;">
        <MemberSignature Language="C#" Value="public static TPredictor Train&lt;TPredictor&gt; (this Microsoft.ML.Runtime.ITrainer&lt;TPredictor&gt; trainer, Microsoft.ML.Runtime.Data.RoleMappedData trainData) where TPredictor : Microsoft.ML.Runtime.IPredictor;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TPredictor Train&lt;(class Microsoft.ML.Runtime.IPredictor) TPredictor&gt;(class Microsoft.ML.Runtime.ITrainer`1&lt;!!TPredictor&gt; trainer, class Microsoft.ML.Runtime.Data.RoleMappedData trainData) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.TrainerExtensions.Train``1(Microsoft.ML.Runtime.ITrainer{``0},Microsoft.ML.Runtime.Data.RoleMappedData)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Train(Of TPredictor As IPredictor) (trainer As ITrainer(Of TPredictor), trainData As RoleMappedData) As TPredictor" />
        <MemberSignature Language="F#" Value="static member Train : Microsoft.ML.Runtime.ITrainer&lt;'Predictor (requires 'Predictor :&gt; Microsoft.ML.Runtime.IPredictor)&gt; * Microsoft.ML.Runtime.Data.RoleMappedData -&gt; 'Predictor (requires 'Predictor :&gt; Microsoft.ML.Runtime.IPredictor)" Usage="Microsoft.ML.Runtime.TrainerExtensions.Train (trainer, trainData)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TPredictor</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TPredictor">
            <Constraints>
              <InterfaceName>Microsoft.ML.Runtime.IPredictor</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="trainer" Type="Microsoft.ML.Runtime.ITrainer&lt;TPredictor&gt;" RefType="this" />
          <Parameter Name="trainData" Type="Microsoft.ML.Runtime.Data.RoleMappedData" />
        </Parameters>
        <Docs>
          <typeparam name="TPredictor">To be added.</typeparam>
          <param name="trainer">The trainer</param>
          <param name="trainData">The training data.</param>
          <summary>
            Convenience train extension for the case where one has only a training set with no auxiliary information.
            Equivalent to calling <see cref="M:Microsoft.ML.Runtime.ITrainer`1.Train(Microsoft.ML.Runtime.TrainContext)" />
            on a <see cref="T:Microsoft.ML.Runtime.TrainContext" /> constructed with <paramref name="trainData" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.TrainerExtensions" Member="M:Microsoft.ML.Runtime.TrainerExtensions.Train``1(Microsoft.ML.Runtime.ITrainer{``0},Microsoft.ML.Runtime.Data.RoleMappedData)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.RoleMappedData" />
      </Targets>
      <Member MemberName="CheckBinaryLabel">
        <MemberSignature Language="C#" Value="public static void CheckBinaryLabel (this Microsoft.ML.Runtime.Data.RoleMappedData data);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CheckBinaryLabel(class Microsoft.ML.Runtime.Data.RoleMappedData data) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Training.TrainerUtils.CheckBinaryLabel(Microsoft.ML.Runtime.Data.RoleMappedData)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CheckBinaryLabel (data As RoleMappedData)" />
        <MemberSignature Language="F#" Value="static member CheckBinaryLabel : Microsoft.ML.Runtime.Data.RoleMappedData -&gt; unit" Usage="Microsoft.ML.Runtime.Training.TrainerUtils.CheckBinaryLabel data" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.Runtime.Data.RoleMappedData" RefType="this" />
        </Parameters>
        <Docs>
          <param name="data">To be added.</param>
          <summary>
            Check for a standard binary classification label.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Training.TrainerUtils" Member="M:Microsoft.ML.Runtime.Training.TrainerUtils.CheckBinaryLabel(Microsoft.ML.Runtime.Data.RoleMappedData)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.RoleMappedData" />
      </Targets>
      <Member MemberName="CheckFeatureFloatVector">
        <MemberSignature Language="C#" Value="public static void CheckFeatureFloatVector (this Microsoft.ML.Runtime.Data.RoleMappedData data);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CheckFeatureFloatVector(class Microsoft.ML.Runtime.Data.RoleMappedData data) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Training.TrainerUtils.CheckFeatureFloatVector(Microsoft.ML.Runtime.Data.RoleMappedData)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CheckFeatureFloatVector (data As RoleMappedData)" />
        <MemberSignature Language="F#" Value="static member CheckFeatureFloatVector : Microsoft.ML.Runtime.Data.RoleMappedData -&gt; unit" Usage="Microsoft.ML.Runtime.Training.TrainerUtils.CheckFeatureFloatVector data" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.Runtime.Data.RoleMappedData" RefType="this" />
        </Parameters>
        <Docs>
          <param name="data">To be added.</param>
          <summary>
            Check for a standard (known-length vector of float) feature column.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Training.TrainerUtils" Member="M:Microsoft.ML.Runtime.Training.TrainerUtils.CheckFeatureFloatVector(Microsoft.ML.Runtime.Data.RoleMappedData)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.RoleMappedData" />
      </Targets>
      <Member MemberName="CheckFeatureFloatVector">
        <MemberSignature Language="C#" Value="public static void CheckFeatureFloatVector (this Microsoft.ML.Runtime.Data.RoleMappedData data, out int length);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CheckFeatureFloatVector(class Microsoft.ML.Runtime.Data.RoleMappedData data, [out] int32&amp; length) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Training.TrainerUtils.CheckFeatureFloatVector(Microsoft.ML.Runtime.Data.RoleMappedData,System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CheckFeatureFloatVector (data As RoleMappedData, ByRef length As Integer)" />
        <MemberSignature Language="F#" Value="static member CheckFeatureFloatVector : Microsoft.ML.Runtime.Data.RoleMappedData *  -&gt; unit" Usage="Microsoft.ML.Runtime.Training.TrainerUtils.CheckFeatureFloatVector (data, length)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.Runtime.Data.RoleMappedData" RefType="this" />
          <Parameter Name="length" Type="System.Int32" RefType="out" />
        </Parameters>
        <Docs>
          <param name="data">To be added.</param>
          <param name="length">To be added.</param>
          <summary>
            Check for a standard (known-length vector of float) feature column and determine its length.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Training.TrainerUtils" Member="M:Microsoft.ML.Runtime.Training.TrainerUtils.CheckFeatureFloatVector(Microsoft.ML.Runtime.Data.RoleMappedData,System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.RoleMappedData" />
      </Targets>
      <Member MemberName="CheckMultiClassLabel">
        <MemberSignature Language="C#" Value="public static void CheckMultiClassLabel (this Microsoft.ML.Runtime.Data.RoleMappedData data, out int count);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CheckMultiClassLabel(class Microsoft.ML.Runtime.Data.RoleMappedData data, [out] int32&amp; count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Training.TrainerUtils.CheckMultiClassLabel(Microsoft.ML.Runtime.Data.RoleMappedData,System.Int32@)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CheckMultiClassLabel (data As RoleMappedData, ByRef count As Integer)" />
        <MemberSignature Language="F#" Value="static member CheckMultiClassLabel : Microsoft.ML.Runtime.Data.RoleMappedData *  -&gt; unit" Usage="Microsoft.ML.Runtime.Training.TrainerUtils.CheckMultiClassLabel (data, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.Runtime.Data.RoleMappedData" RefType="this" />
          <Parameter Name="count" Type="System.Int32" RefType="out" />
        </Parameters>
        <Docs>
          <param name="data">To be added.</param>
          <param name="count">To be added.</param>
          <summary>
            Check for a standard multi-class label and determine its cardinality. If the column is a
            key type, it must have known cardinality. For other numeric types, this scans the data
            to determine the cardinality.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Training.TrainerUtils" Member="M:Microsoft.ML.Runtime.Training.TrainerUtils.CheckMultiClassLabel(Microsoft.ML.Runtime.Data.RoleMappedData,System.Int32@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.RoleMappedData" />
      </Targets>
      <Member MemberName="CheckMultiOutputRegressionLabel">
        <MemberSignature Language="C#" Value="public static void CheckMultiOutputRegressionLabel (this Microsoft.ML.Runtime.Data.RoleMappedData data);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CheckMultiOutputRegressionLabel(class Microsoft.ML.Runtime.Data.RoleMappedData data) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Training.TrainerUtils.CheckMultiOutputRegressionLabel(Microsoft.ML.Runtime.Data.RoleMappedData)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CheckMultiOutputRegressionLabel (data As RoleMappedData)" />
        <MemberSignature Language="F#" Value="static member CheckMultiOutputRegressionLabel : Microsoft.ML.Runtime.Data.RoleMappedData -&gt; unit" Usage="Microsoft.ML.Runtime.Training.TrainerUtils.CheckMultiOutputRegressionLabel data" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.Runtime.Data.RoleMappedData" RefType="this" />
        </Parameters>
        <Docs>
          <param name="data">To be added.</param>
          <summary>
            Check for a standard regression label.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Training.TrainerUtils" Member="M:Microsoft.ML.Runtime.Training.TrainerUtils.CheckMultiOutputRegressionLabel(Microsoft.ML.Runtime.Data.RoleMappedData)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.RoleMappedData" />
      </Targets>
      <Member MemberName="CheckOptFloatWeight">
        <MemberSignature Language="C#" Value="public static void CheckOptFloatWeight (this Microsoft.ML.Runtime.Data.RoleMappedData data);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CheckOptFloatWeight(class Microsoft.ML.Runtime.Data.RoleMappedData data) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Training.TrainerUtils.CheckOptFloatWeight(Microsoft.ML.Runtime.Data.RoleMappedData)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CheckOptFloatWeight (data As RoleMappedData)" />
        <MemberSignature Language="F#" Value="static member CheckOptFloatWeight : Microsoft.ML.Runtime.Data.RoleMappedData -&gt; unit" Usage="Microsoft.ML.Runtime.Training.TrainerUtils.CheckOptFloatWeight data" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.Runtime.Data.RoleMappedData" RefType="this" />
        </Parameters>
        <Docs>
          <param name="data">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Training.TrainerUtils" Member="M:Microsoft.ML.Runtime.Training.TrainerUtils.CheckOptFloatWeight(Microsoft.ML.Runtime.Data.RoleMappedData)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.RoleMappedData" />
      </Targets>
      <Member MemberName="CheckOptGroup">
        <MemberSignature Language="C#" Value="public static void CheckOptGroup (this Microsoft.ML.Runtime.Data.RoleMappedData data);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CheckOptGroup(class Microsoft.ML.Runtime.Data.RoleMappedData data) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Training.TrainerUtils.CheckOptGroup(Microsoft.ML.Runtime.Data.RoleMappedData)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CheckOptGroup (data As RoleMappedData)" />
        <MemberSignature Language="F#" Value="static member CheckOptGroup : Microsoft.ML.Runtime.Data.RoleMappedData -&gt; unit" Usage="Microsoft.ML.Runtime.Training.TrainerUtils.CheckOptGroup data" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.Runtime.Data.RoleMappedData" RefType="this" />
        </Parameters>
        <Docs>
          <param name="data">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Training.TrainerUtils" Member="M:Microsoft.ML.Runtime.Training.TrainerUtils.CheckOptGroup(Microsoft.ML.Runtime.Data.RoleMappedData)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.RoleMappedData" />
      </Targets>
      <Member MemberName="CheckRegressionLabel">
        <MemberSignature Language="C#" Value="public static void CheckRegressionLabel (this Microsoft.ML.Runtime.Data.RoleMappedData data);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CheckRegressionLabel(class Microsoft.ML.Runtime.Data.RoleMappedData data) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Training.TrainerUtils.CheckRegressionLabel(Microsoft.ML.Runtime.Data.RoleMappedData)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CheckRegressionLabel (data As RoleMappedData)" />
        <MemberSignature Language="F#" Value="static member CheckRegressionLabel : Microsoft.ML.Runtime.Data.RoleMappedData -&gt; unit" Usage="Microsoft.ML.Runtime.Training.TrainerUtils.CheckRegressionLabel data" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.Runtime.Data.RoleMappedData" RefType="this" />
        </Parameters>
        <Docs>
          <param name="data">To be added.</param>
          <summary>
            Check for a standard regression label.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Training.TrainerUtils" Member="M:Microsoft.ML.Runtime.Training.TrainerUtils.CheckRegressionLabel(Microsoft.ML.Runtime.Data.RoleMappedData)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.RoleMappedData" />
      </Targets>
      <Member MemberName="CreateRowCursor">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.IRowCursor CreateRowCursor (this Microsoft.ML.Runtime.Data.RoleMappedData data, Microsoft.ML.Runtime.Training.CursOpt opt, Microsoft.ML.Runtime.IRandom rand, System.Collections.Generic.IEnumerable&lt;int&gt; extraCols = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.IRowCursor CreateRowCursor(class Microsoft.ML.Runtime.Data.RoleMappedData data, valuetype Microsoft.ML.Runtime.Training.CursOpt opt, class Microsoft.ML.Runtime.IRandom rand, class System.Collections.Generic.IEnumerable`1&lt;int32&gt; extraCols) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Training.TrainerUtils.CreateRowCursor(Microsoft.ML.Runtime.Data.RoleMappedData,Microsoft.ML.Runtime.Training.CursOpt,Microsoft.ML.Runtime.IRandom,System.Collections.Generic.IEnumerable{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateRowCursor (data As RoleMappedData, opt As CursOpt, rand As IRandom, Optional extraCols As IEnumerable(Of Integer) = null) As IRowCursor" />
        <MemberSignature Language="F#" Value="static member CreateRowCursor : Microsoft.ML.Runtime.Data.RoleMappedData * Microsoft.ML.Runtime.Training.CursOpt * Microsoft.ML.Runtime.IRandom * seq&lt;int&gt; -&gt; Microsoft.ML.Runtime.Data.IRowCursor" Usage="Microsoft.ML.Runtime.Training.TrainerUtils.CreateRowCursor (data, opt, rand, extraCols)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.IRowCursor</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.Runtime.Data.RoleMappedData" RefType="this" />
          <Parameter Name="opt" Type="Microsoft.ML.Runtime.Training.CursOpt" />
          <Parameter Name="rand" Type="Microsoft.ML.Runtime.IRandom" />
          <Parameter Name="extraCols" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" />
        </Parameters>
        <Docs>
          <param name="data">To be added.</param>
          <param name="opt">To be added.</param>
          <param name="rand">To be added.</param>
          <param name="extraCols">To be added.</param>
          <summary>
            Create a row cursor for the RoleMappedData with the indicated standard columns active.
            This does not verify that the columns exist, but merely activates the ones that do exist.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Training.TrainerUtils" Member="M:Microsoft.ML.Runtime.Training.TrainerUtils.CreateRowCursor(Microsoft.ML.Runtime.Data.RoleMappedData,Microsoft.ML.Runtime.Training.CursOpt,Microsoft.ML.Runtime.IRandom,System.Collections.Generic.IEnumerable{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.RoleMappedData" />
      </Targets>
      <Member MemberName="CreateRowCursorSet">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.IRowCursor[] CreateRowCursorSet (this Microsoft.ML.Runtime.Data.RoleMappedData data, out Microsoft.ML.Runtime.Data.IRowCursorConsolidator consolidator, Microsoft.ML.Runtime.Training.CursOpt opt, int n, Microsoft.ML.Runtime.IRandom rand, System.Collections.Generic.IEnumerable&lt;int&gt; extraCols = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.IRowCursor[] CreateRowCursorSet(class Microsoft.ML.Runtime.Data.RoleMappedData data, [out] class Microsoft.ML.Runtime.Data.IRowCursorConsolidator&amp; consolidator, valuetype Microsoft.ML.Runtime.Training.CursOpt opt, int32 n, class Microsoft.ML.Runtime.IRandom rand, class System.Collections.Generic.IEnumerable`1&lt;int32&gt; extraCols) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Training.TrainerUtils.CreateRowCursorSet(Microsoft.ML.Runtime.Data.RoleMappedData,Microsoft.ML.Runtime.Data.IRowCursorConsolidator@,Microsoft.ML.Runtime.Training.CursOpt,System.Int32,Microsoft.ML.Runtime.IRandom,System.Collections.Generic.IEnumerable{System.Int32})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateRowCursorSet (data As RoleMappedData, ByRef consolidator As IRowCursorConsolidator, opt As CursOpt, n As Integer, rand As IRandom, Optional extraCols As IEnumerable(Of Integer) = null) As IRowCursor()" />
        <MemberSignature Language="F#" Value="static member CreateRowCursorSet : Microsoft.ML.Runtime.Data.RoleMappedData *  * Microsoft.ML.Runtime.Training.CursOpt * int * Microsoft.ML.Runtime.IRandom * seq&lt;int&gt; -&gt; Microsoft.ML.Runtime.Data.IRowCursor[]" Usage="Microsoft.ML.Runtime.Training.TrainerUtils.CreateRowCursorSet (data, consolidator, opt, n, rand, extraCols)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.IRowCursor[]</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.Runtime.Data.RoleMappedData" RefType="this" />
          <Parameter Name="consolidator" Type="Microsoft.ML.Runtime.Data.IRowCursorConsolidator" RefType="out" />
          <Parameter Name="opt" Type="Microsoft.ML.Runtime.Training.CursOpt" />
          <Parameter Name="n" Type="System.Int32" />
          <Parameter Name="rand" Type="Microsoft.ML.Runtime.IRandom" />
          <Parameter Name="extraCols" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" />
        </Parameters>
        <Docs>
          <param name="data">To be added.</param>
          <param name="consolidator">To be added.</param>
          <param name="opt">To be added.</param>
          <param name="n">To be added.</param>
          <param name="rand">To be added.</param>
          <param name="extraCols">To be added.</param>
          <summary>
            Create a row cursor set for the RoleMappedData with the indicated standard columns active.
            This does not verify that the columns exist, but merely activates the ones that do exist.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Training.TrainerUtils" Member="M:Microsoft.ML.Runtime.Training.TrainerUtils.CreateRowCursorSet(Microsoft.ML.Runtime.Data.RoleMappedData,Microsoft.ML.Runtime.Data.IRowCursorConsolidator@,Microsoft.ML.Runtime.Training.CursOpt,System.Int32,Microsoft.ML.Runtime.IRandom,System.Collections.Generic.IEnumerable{System.Int32})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.IRow" />
      </Targets>
      <Member MemberName="GetFeatureFloatVectorGetter">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.ValueGetter&lt;Microsoft.ML.Runtime.Data.VBuffer&lt;float&gt;&gt; GetFeatureFloatVectorGetter (this Microsoft.ML.Runtime.Data.IRow row, Microsoft.ML.Runtime.Data.RoleMappedData data);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.ValueGetter`1&lt;valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;float32&gt;&gt; GetFeatureFloatVectorGetter(class Microsoft.ML.Runtime.Data.IRow row, class Microsoft.ML.Runtime.Data.RoleMappedData data) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Training.TrainerUtils.GetFeatureFloatVectorGetter(Microsoft.ML.Runtime.Data.IRow,Microsoft.ML.Runtime.Data.RoleMappedData)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetFeatureFloatVectorGetter (row As IRow, data As RoleMappedData) As ValueGetter(Of VBuffer(Of Single))" />
        <MemberSignature Language="F#" Value="static member GetFeatureFloatVectorGetter : Microsoft.ML.Runtime.Data.IRow * Microsoft.ML.Runtime.Data.RoleMappedData -&gt; Microsoft.ML.Runtime.Data.ValueGetter&lt;Microsoft.ML.Runtime.Data.VBuffer&lt;single&gt;&gt;" Usage="Microsoft.ML.Runtime.Training.TrainerUtils.GetFeatureFloatVectorGetter (row, data)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.ValueGetter&lt;Microsoft.ML.Runtime.Data.VBuffer&lt;System.Single&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="row" Type="Microsoft.ML.Runtime.Data.IRow" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.Runtime.Data.RoleMappedData" />
        </Parameters>
        <Docs>
          <param name="row">To be added.</param>
          <param name="data">To be added.</param>
          <summary>
            Get the getter for the feature column, assuming it is a vector of float.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Training.TrainerUtils" Member="M:Microsoft.ML.Runtime.Training.TrainerUtils.GetFeatureFloatVectorGetter(Microsoft.ML.Runtime.Data.IRow,Microsoft.ML.Runtime.Data.RoleMappedData)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.IRow" />
      </Targets>
      <Member MemberName="GetFeatureFloatVectorGetter">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.ValueGetter&lt;Microsoft.ML.Runtime.Data.VBuffer&lt;float&gt;&gt; GetFeatureFloatVectorGetter (this Microsoft.ML.Runtime.Data.IRow row, Microsoft.ML.Runtime.Data.RoleMappedSchema schema);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.ValueGetter`1&lt;valuetype Microsoft.ML.Runtime.Data.VBuffer`1&lt;float32&gt;&gt; GetFeatureFloatVectorGetter(class Microsoft.ML.Runtime.Data.IRow row, class Microsoft.ML.Runtime.Data.RoleMappedSchema schema) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Training.TrainerUtils.GetFeatureFloatVectorGetter(Microsoft.ML.Runtime.Data.IRow,Microsoft.ML.Runtime.Data.RoleMappedSchema)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetFeatureFloatVectorGetter (row As IRow, schema As RoleMappedSchema) As ValueGetter(Of VBuffer(Of Single))" />
        <MemberSignature Language="F#" Value="static member GetFeatureFloatVectorGetter : Microsoft.ML.Runtime.Data.IRow * Microsoft.ML.Runtime.Data.RoleMappedSchema -&gt; Microsoft.ML.Runtime.Data.ValueGetter&lt;Microsoft.ML.Runtime.Data.VBuffer&lt;single&gt;&gt;" Usage="Microsoft.ML.Runtime.Training.TrainerUtils.GetFeatureFloatVectorGetter (row, schema)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.ValueGetter&lt;Microsoft.ML.Runtime.Data.VBuffer&lt;System.Single&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="row" Type="Microsoft.ML.Runtime.Data.IRow" RefType="this" />
          <Parameter Name="schema" Type="Microsoft.ML.Runtime.Data.RoleMappedSchema" />
        </Parameters>
        <Docs>
          <param name="row">To be added.</param>
          <param name="schema">To be added.</param>
          <summary>
            Get the getter for the feature column, assuming it is a vector of float.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Training.TrainerUtils" Member="M:Microsoft.ML.Runtime.Training.TrainerUtils.GetFeatureFloatVectorGetter(Microsoft.ML.Runtime.Data.IRow,Microsoft.ML.Runtime.Data.RoleMappedSchema)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.IRow" />
      </Targets>
      <Member MemberName="GetLabelFloatGetter">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.ValueGetter&lt;float&gt; GetLabelFloatGetter (this Microsoft.ML.Runtime.Data.IRow row, Microsoft.ML.Runtime.Data.RoleMappedData data);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.ValueGetter`1&lt;float32&gt; GetLabelFloatGetter(class Microsoft.ML.Runtime.Data.IRow row, class Microsoft.ML.Runtime.Data.RoleMappedData data) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Training.TrainerUtils.GetLabelFloatGetter(Microsoft.ML.Runtime.Data.IRow,Microsoft.ML.Runtime.Data.RoleMappedData)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetLabelFloatGetter (row As IRow, data As RoleMappedData) As ValueGetter(Of Single)" />
        <MemberSignature Language="F#" Value="static member GetLabelFloatGetter : Microsoft.ML.Runtime.Data.IRow * Microsoft.ML.Runtime.Data.RoleMappedData -&gt; Microsoft.ML.Runtime.Data.ValueGetter&lt;single&gt;" Usage="Microsoft.ML.Runtime.Training.TrainerUtils.GetLabelFloatGetter (row, data)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.ValueGetter&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="row" Type="Microsoft.ML.Runtime.Data.IRow" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.Runtime.Data.RoleMappedData" />
        </Parameters>
        <Docs>
          <param name="row">To be added.</param>
          <param name="data">To be added.</param>
          <summary>
            Get a getter for the label as a float. This assumes that the label column type
            has already been validated as appropriate for the kind of training being done.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Training.TrainerUtils" Member="M:Microsoft.ML.Runtime.Training.TrainerUtils.GetLabelFloatGetter(Microsoft.ML.Runtime.Data.IRow,Microsoft.ML.Runtime.Data.RoleMappedData)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.IRow" />
      </Targets>
      <Member MemberName="GetLabelFloatGetter">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.ValueGetter&lt;float&gt; GetLabelFloatGetter (this Microsoft.ML.Runtime.Data.IRow row, Microsoft.ML.Runtime.Data.RoleMappedSchema schema);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.ValueGetter`1&lt;float32&gt; GetLabelFloatGetter(class Microsoft.ML.Runtime.Data.IRow row, class Microsoft.ML.Runtime.Data.RoleMappedSchema schema) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Training.TrainerUtils.GetLabelFloatGetter(Microsoft.ML.Runtime.Data.IRow,Microsoft.ML.Runtime.Data.RoleMappedSchema)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetLabelFloatGetter (row As IRow, schema As RoleMappedSchema) As ValueGetter(Of Single)" />
        <MemberSignature Language="F#" Value="static member GetLabelFloatGetter : Microsoft.ML.Runtime.Data.IRow * Microsoft.ML.Runtime.Data.RoleMappedSchema -&gt; Microsoft.ML.Runtime.Data.ValueGetter&lt;single&gt;" Usage="Microsoft.ML.Runtime.Training.TrainerUtils.GetLabelFloatGetter (row, schema)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.ValueGetter&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="row" Type="Microsoft.ML.Runtime.Data.IRow" RefType="this" />
          <Parameter Name="schema" Type="Microsoft.ML.Runtime.Data.RoleMappedSchema" />
        </Parameters>
        <Docs>
          <param name="row">To be added.</param>
          <param name="schema">To be added.</param>
          <summary>
            Get a getter for the label as a float. This assumes that the label column type
            has already been validated as appropriate for the kind of training being done.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Training.TrainerUtils" Member="M:Microsoft.ML.Runtime.Training.TrainerUtils.GetLabelFloatGetter(Microsoft.ML.Runtime.Data.IRow,Microsoft.ML.Runtime.Data.RoleMappedSchema)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.IRow" />
      </Targets>
      <Member MemberName="GetOptGroupGetter">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.ValueGetter&lt;ulong&gt; GetOptGroupGetter (this Microsoft.ML.Runtime.Data.IRow row, Microsoft.ML.Runtime.Data.RoleMappedData data);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.ValueGetter`1&lt;unsigned int64&gt; GetOptGroupGetter(class Microsoft.ML.Runtime.Data.IRow row, class Microsoft.ML.Runtime.Data.RoleMappedData data) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Training.TrainerUtils.GetOptGroupGetter(Microsoft.ML.Runtime.Data.IRow,Microsoft.ML.Runtime.Data.RoleMappedData)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetOptGroupGetter (row As IRow, data As RoleMappedData) As ValueGetter(Of ULong)" />
        <MemberSignature Language="F#" Value="static member GetOptGroupGetter : Microsoft.ML.Runtime.Data.IRow * Microsoft.ML.Runtime.Data.RoleMappedData -&gt; Microsoft.ML.Runtime.Data.ValueGetter&lt;uint64&gt;" Usage="Microsoft.ML.Runtime.Training.TrainerUtils.GetOptGroupGetter (row, data)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.ValueGetter&lt;System.UInt64&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="row" Type="Microsoft.ML.Runtime.Data.IRow" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.Runtime.Data.RoleMappedData" />
        </Parameters>
        <Docs>
          <param name="row">To be added.</param>
          <param name="data">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Training.TrainerUtils" Member="M:Microsoft.ML.Runtime.Training.TrainerUtils.GetOptGroupGetter(Microsoft.ML.Runtime.Data.IRow,Microsoft.ML.Runtime.Data.RoleMappedData)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.IRow" />
      </Targets>
      <Member MemberName="GetOptGroupGetter">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.ValueGetter&lt;ulong&gt; GetOptGroupGetter (this Microsoft.ML.Runtime.Data.IRow row, Microsoft.ML.Runtime.Data.RoleMappedSchema schema);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.ValueGetter`1&lt;unsigned int64&gt; GetOptGroupGetter(class Microsoft.ML.Runtime.Data.IRow row, class Microsoft.ML.Runtime.Data.RoleMappedSchema schema) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Training.TrainerUtils.GetOptGroupGetter(Microsoft.ML.Runtime.Data.IRow,Microsoft.ML.Runtime.Data.RoleMappedSchema)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetOptGroupGetter (row As IRow, schema As RoleMappedSchema) As ValueGetter(Of ULong)" />
        <MemberSignature Language="F#" Value="static member GetOptGroupGetter : Microsoft.ML.Runtime.Data.IRow * Microsoft.ML.Runtime.Data.RoleMappedSchema -&gt; Microsoft.ML.Runtime.Data.ValueGetter&lt;uint64&gt;" Usage="Microsoft.ML.Runtime.Training.TrainerUtils.GetOptGroupGetter (row, schema)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.ValueGetter&lt;System.UInt64&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="row" Type="Microsoft.ML.Runtime.Data.IRow" RefType="this" />
          <Parameter Name="schema" Type="Microsoft.ML.Runtime.Data.RoleMappedSchema" />
        </Parameters>
        <Docs>
          <param name="row">To be added.</param>
          <param name="schema">To be added.</param>
          <summary>
            Get the getter for the group column, or null if there is no group column.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Training.TrainerUtils" Member="M:Microsoft.ML.Runtime.Training.TrainerUtils.GetOptGroupGetter(Microsoft.ML.Runtime.Data.IRow,Microsoft.ML.Runtime.Data.RoleMappedSchema)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.IRow" />
      </Targets>
      <Member MemberName="GetOptWeightFloatGetter">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.ValueGetter&lt;float&gt; GetOptWeightFloatGetter (this Microsoft.ML.Runtime.Data.IRow row, Microsoft.ML.Runtime.Data.RoleMappedData data);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.ValueGetter`1&lt;float32&gt; GetOptWeightFloatGetter(class Microsoft.ML.Runtime.Data.IRow row, class Microsoft.ML.Runtime.Data.RoleMappedData data) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Training.TrainerUtils.GetOptWeightFloatGetter(Microsoft.ML.Runtime.Data.IRow,Microsoft.ML.Runtime.Data.RoleMappedData)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetOptWeightFloatGetter (row As IRow, data As RoleMappedData) As ValueGetter(Of Single)" />
        <MemberSignature Language="F#" Value="static member GetOptWeightFloatGetter : Microsoft.ML.Runtime.Data.IRow * Microsoft.ML.Runtime.Data.RoleMappedData -&gt; Microsoft.ML.Runtime.Data.ValueGetter&lt;single&gt;" Usage="Microsoft.ML.Runtime.Training.TrainerUtils.GetOptWeightFloatGetter (row, data)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.ValueGetter&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="row" Type="Microsoft.ML.Runtime.Data.IRow" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.Runtime.Data.RoleMappedData" />
        </Parameters>
        <Docs>
          <param name="row">To be added.</param>
          <param name="data">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Training.TrainerUtils" Member="M:Microsoft.ML.Runtime.Training.TrainerUtils.GetOptWeightFloatGetter(Microsoft.ML.Runtime.Data.IRow,Microsoft.ML.Runtime.Data.RoleMappedData)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.IRow" />
      </Targets>
      <Member MemberName="GetOptWeightFloatGetter">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.Runtime.Data.ValueGetter&lt;float&gt; GetOptWeightFloatGetter (this Microsoft.ML.Runtime.Data.IRow row, Microsoft.ML.Runtime.Data.RoleMappedSchema schema);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.Runtime.Data.ValueGetter`1&lt;float32&gt; GetOptWeightFloatGetter(class Microsoft.ML.Runtime.Data.IRow row, class Microsoft.ML.Runtime.Data.RoleMappedSchema schema) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Training.TrainerUtils.GetOptWeightFloatGetter(Microsoft.ML.Runtime.Data.IRow,Microsoft.ML.Runtime.Data.RoleMappedSchema)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetOptWeightFloatGetter (row As IRow, schema As RoleMappedSchema) As ValueGetter(Of Single)" />
        <MemberSignature Language="F#" Value="static member GetOptWeightFloatGetter : Microsoft.ML.Runtime.Data.IRow * Microsoft.ML.Runtime.Data.RoleMappedSchema -&gt; Microsoft.ML.Runtime.Data.ValueGetter&lt;single&gt;" Usage="Microsoft.ML.Runtime.Training.TrainerUtils.GetOptWeightFloatGetter (row, schema)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.Runtime.Data.ValueGetter&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="row" Type="Microsoft.ML.Runtime.Data.IRow" RefType="this" />
          <Parameter Name="schema" Type="Microsoft.ML.Runtime.Data.RoleMappedSchema" />
        </Parameters>
        <Docs>
          <param name="row">To be added.</param>
          <param name="schema">To be added.</param>
          <summary>
            Get the getter for the weight column, or null if there is no weight column.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Runtime.Training.TrainerUtils" Member="M:Microsoft.ML.Runtime.Training.TrainerUtils.GetOptWeightFloatGetter(Microsoft.ML.Runtime.Data.IRow,Microsoft.ML.Runtime.Data.RoleMappedSchema)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="AveragedPerceptron">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; AveragedPerceptron (this Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers ctx, Microsoft.ML.Runtime.IClassificationLoss lossFunction, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, float learningRate = 1, bool decreaseLearningRate = false, float l2RegularizerWeight = 0, int numIterations = 1, Action&lt;Microsoft.ML.Runtime.Learners.LinearBinaryPredictor&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; AveragedPerceptron(class Microsoft.ML.BinaryClassificationContext/BinaryClassificationTrainers ctx, class Microsoft.ML.Runtime.IClassificationLoss lossFunction, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, float32 learningRate, bool decreaseLearningRate, float32 l2RegularizerWeight, int32 numIterations, class System.Action`1&lt;class Microsoft.ML.Runtime.Learners.LinearBinaryPredictor&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.BinaryClassificationTrainers.AveragedPerceptron(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.Runtime.IClassificationLoss,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Single,System.Boolean,System.Single,System.Int32,System.Action{Microsoft.ML.Runtime.Learners.LinearBinaryPredictor})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AveragedPerceptron (ctx As BinaryClassificationContext.BinaryClassificationTrainers, lossFunction As IClassificationLoss, label As Scalar(Of Boolean), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional learningRate As Single = 1, Optional decreaseLearningRate As Boolean = false, Optional l2RegularizerWeight As Single = 0, Optional numIterations As Integer = 1, Optional onFit As Action(Of LinearBinaryPredictor) = null) As ValueTuple(Of Scalar(Of Single), Scalar(Of Boolean))" />
        <MemberSignature Language="F#" Value="static member AveragedPerceptron : Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers * Microsoft.ML.Runtime.IClassificationLoss * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * single * bool * single * int * Action&lt;Microsoft.ML.Runtime.Learners.LinearBinaryPredictor&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.BinaryClassificationTrainers.AveragedPerceptron (ctx, lossFunction, label, features, weights, learningRate, decreaseLearningRate, l2RegularizerWeight, numIterations, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="lossFunction" Type="Microsoft.ML.Runtime.IClassificationLoss" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="learningRate" Type="System.Single" />
          <Parameter Name="decreaseLearningRate" Type="System.Boolean" />
          <Parameter Name="l2RegularizerWeight" Type="System.Single" />
          <Parameter Name="numIterations" Type="System.Int32" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Runtime.Learners.LinearBinaryPredictor&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The binary classification context trainer object.</param>
          <param name="lossFunction">The custom loss.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="learningRate">The learning Rate.</param>
          <param name="decreaseLearningRate">Decrease learning rate as iterations progress.</param>
          <param name="l2RegularizerWeight">L2 regularization weight.</param>
          <param name="numIterations">Number of training iterations through the data.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained, as well as the calibrator on top of that model. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear binary classification model trained with the AveragedPerceptron trainer, and a custom loss.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.BinaryClassificationTrainers" Member="M:Microsoft.ML.StaticPipe.BinaryClassificationTrainers.AveragedPerceptron(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.Runtime.IClassificationLoss,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Single,System.Boolean,System.Single,System.Int32,System.Action{Microsoft.ML.Runtime.Learners.LinearBinaryPredictor})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="LogisticRegressionBinaryClassifier">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; LogisticRegressionBinaryClassifier (this Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers ctx, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, float l1Weight = 1, float l2Weight = 1, float optimizationTolerance = 1E-07, int memorySize = 20, bool enoforceNoNegativity = false, Action&lt;Microsoft.ML.Runtime.Internal.Calibration.ParameterMixingCalibratedPredictor&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; LogisticRegressionBinaryClassifier(class Microsoft.ML.BinaryClassificationContext/BinaryClassificationTrainers ctx, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, float32 l1Weight, float32 l2Weight, float32 optimizationTolerance, int32 memorySize, bool enoforceNoNegativity, class System.Action`1&lt;class Microsoft.ML.Runtime.Internal.Calibration.ParameterMixingCalibratedPredictor&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.BinaryClassificationTrainers.LogisticRegressionBinaryClassifier(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Single,System.Single,System.Single,System.Int32,System.Boolean,System.Action{Microsoft.ML.Runtime.Internal.Calibration.ParameterMixingCalibratedPredictor})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LogisticRegressionBinaryClassifier (ctx As BinaryClassificationContext.BinaryClassificationTrainers, label As Scalar(Of Boolean), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional l1Weight As Single = 1, Optional l2Weight As Single = 1, Optional optimizationTolerance As Single = 1E-07, Optional memorySize As Integer = 20, Optional enoforceNoNegativity As Boolean = false, Optional onFit As Action(Of ParameterMixingCalibratedPredictor) = null) As ValueTuple(Of Scalar(Of Single), Scalar(Of Single), Scalar(Of Boolean))" />
        <MemberSignature Language="F#" Value="static member LogisticRegressionBinaryClassifier : Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * single * single * single * int * bool * Action&lt;Microsoft.ML.Runtime.Internal.Calibration.ParameterMixingCalibratedPredictor&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.StaticPipe.BinaryClassificationTrainers.LogisticRegressionBinaryClassifier (ctx, label, features, weights, l1Weight, l2Weight, optimizationTolerance, memorySize, enoforceNoNegativity, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "probability", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="l1Weight" Type="System.Single" />
          <Parameter Name="l2Weight" Type="System.Single" />
          <Parameter Name="optimizationTolerance" Type="System.Single" />
          <Parameter Name="memorySize" Type="System.Int32" />
          <Parameter Name="enoforceNoNegativity" Type="System.Boolean" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Runtime.Internal.Calibration.ParameterMixingCalibratedPredictor&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The binary classificaiton context trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="l1Weight">Weight of L1 regularization term.</param>
          <param name="l2Weight">Weight of L2 regularization term.</param>
          <param name="optimizationTolerance">Threshold for optimizer convergence.</param>
          <param name="memorySize">Memory size for <see cref="T:Microsoft.ML.Runtime.Learners.LogisticRegression" />. Lower=faster, less accurate.</param>
          <param name="enoforceNoNegativity">Enforce non-negative weights.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained.  Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
             Predict a target using a linear binary classification model trained with the <see cref="T:Microsoft.ML.Runtime.Learners.LogisticRegression" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.BinaryClassificationTrainers" Member="M:Microsoft.ML.StaticPipe.BinaryClassificationTrainers.LogisticRegressionBinaryClassifier(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Single,System.Single,System.Single,System.Int32,System.Boolean,System.Action{Microsoft.ML.Runtime.Internal.Calibration.ParameterMixingCalibratedPredictor})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.ClusteringContext.ClusteringTrainers" />
      </Targets>
      <Member MemberName="KMeans">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;float&gt;,Microsoft.ML.StaticPipe.Key&lt;uint&gt;&gt; KMeans (this Microsoft.ML.ClusteringContext.ClusteringTrainers ctx, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, int clustersCount = 5, Action&lt;Microsoft.ML.Runtime.KMeans.KMeansPlusPlusTrainer.Arguments&gt; advancedSettings = null, Action&lt;Microsoft.ML.Runtime.KMeans.KMeansPredictor&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Key`1&lt;unsigned int32&gt;&gt; KMeans(class Microsoft.ML.ClusteringContext/ClusteringTrainers ctx, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, int32 clustersCount, class System.Action`1&lt;class Microsoft.ML.Runtime.KMeans.KMeansPlusPlusTrainer/Arguments&gt; advancedSettings, class System.Action`1&lt;class Microsoft.ML.Runtime.KMeans.KMeansPredictor&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.ClusteringTrainers.KMeans(Microsoft.ML.ClusteringContext.ClusteringTrainers,Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Action{Microsoft.ML.Runtime.KMeans.KMeansPlusPlusTrainer.Arguments},System.Action{Microsoft.ML.Runtime.KMeans.KMeansPredictor})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function KMeans (ctx As ClusteringContext.ClusteringTrainers, features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional clustersCount As Integer = 5, Optional advancedSettings As Action(Of KMeansPlusPlusTrainer.Arguments) = null, Optional onFit As Action(Of KMeansPredictor) = null) As ValueTuple(Of Vector(Of Single), Key(Of UInteger))" />
        <MemberSignature Language="F#" Value="static member KMeans : Microsoft.ML.ClusteringContext.ClusteringTrainers * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * int * Action&lt;Microsoft.ML.Runtime.KMeans.KMeansPlusPlusTrainer.Arguments&gt; * Action&lt;Microsoft.ML.Runtime.KMeans.KMeansPredictor&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;single&gt;, Microsoft.ML.StaticPipe.Key&lt;uint32&gt;&gt;" Usage="Microsoft.ML.StaticPipe.ClusteringTrainers.KMeans (ctx, features, weights, clustersCount, advancedSettings, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Key&lt;System.UInt32&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.ClusteringContext+ClusteringTrainers" RefType="this" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="clustersCount" Type="System.Int32" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Runtime.KMeans.KMeansPlusPlusTrainer+Arguments&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Runtime.KMeans.KMeansPredictor&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The regression context trainer object.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="clustersCount">The number of clusters to use for KMeans.</param>
          <param name="advancedSettings">Algorithm advanced settings.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained.  Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
            KMeans <see cref="T:Microsoft.ML.ClusteringContext" /> extension method.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.ClusteringTrainers" Member="M:Microsoft.ML.StaticPipe.ClusteringTrainers.KMeans(Microsoft.ML.ClusteringContext.ClusteringTrainers,Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Action{Microsoft.ML.Runtime.KMeans.KMeansPlusPlusTrainer.Arguments},System.Action{Microsoft.ML.Runtime.KMeans.KMeansPredictor})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.DataView`1" />
      </Targets>
      <Member MemberName="GetColumn&lt;TItem,TShape&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TItem&gt; GetColumn&lt;TItem,TShape&gt; (this Microsoft.ML.StaticPipe.DataView&lt;TShape&gt; data, Func&lt;TShape,Microsoft.ML.StaticPipe.Scalar&lt;TItem&gt;&gt; column);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TItem&gt; GetColumn&lt;TItem, TShape&gt;(class Microsoft.ML.StaticPipe.DataView`1&lt;!!TShape&gt; data, class System.Func`2&lt;!!TShape, class Microsoft.ML.StaticPipe.Scalar`1&lt;!!TItem&gt;&gt; column) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn``2(Microsoft.ML.StaticPipe.DataView{``1},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetColumn(Of TItem, TShape) (data As DataView(Of TShape), column As Func(Of TShape, Scalar(Of TItem))) As IEnumerable(Of TItem)" />
        <MemberSignature Language="F#" Value="static member GetColumn : Microsoft.ML.StaticPipe.DataView&lt;'Shape&gt; * Func&lt;'Shape, Microsoft.ML.StaticPipe.Scalar&lt;'Item&gt;&gt; -&gt; seq&lt;'Item&gt;" Usage="Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn (data, column)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;TItem&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TItem" />
          <TypeParameter Name="TShape" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;TShape&gt;" RefType="this" />
          <Parameter Name="column" Type="System.Func&lt;TShape,Microsoft.ML.StaticPipe.Scalar&lt;TItem&gt;&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TItem">To be added.</typeparam>
          <typeparam name="TShape">To be added.</typeparam>
          <param name="data">To be added.</param>
          <param name="column">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.DataViewExtensions" Member="M:Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn``2(Microsoft.ML.StaticPipe.DataView{``1},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.DataView`1" />
      </Targets>
      <Member MemberName="GetColumn&lt;TItem,TShape&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TItem[]&gt; GetColumn&lt;TItem,TShape&gt; (this Microsoft.ML.StaticPipe.DataView&lt;TShape&gt; data, Func&lt;TShape,Microsoft.ML.StaticPipe.VarVector&lt;TItem&gt;&gt; column);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TItem[]&gt; GetColumn&lt;TItem, TShape&gt;(class Microsoft.ML.StaticPipe.DataView`1&lt;!!TShape&gt; data, class System.Func`2&lt;!!TShape, class Microsoft.ML.StaticPipe.VarVector`1&lt;!!TItem&gt;&gt; column) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn``2(Microsoft.ML.StaticPipe.DataView{``1},System.Func{``1,Microsoft.ML.StaticPipe.VarVector{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetColumn(Of TItem, TShape) (data As DataView(Of TShape), column As Func(Of TShape, VarVector(Of TItem))) As IEnumerable(Of TItem())" />
        <MemberSignature Language="F#" Value="static member GetColumn : Microsoft.ML.StaticPipe.DataView&lt;'Shape&gt; * Func&lt;'Shape, Microsoft.ML.StaticPipe.VarVector&lt;'Item&gt;&gt; -&gt; seq&lt;'Item[]&gt;" Usage="Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn (data, column)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;TItem[]&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TItem" />
          <TypeParameter Name="TShape" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;TShape&gt;" RefType="this" />
          <Parameter Name="column" Type="System.Func&lt;TShape,Microsoft.ML.StaticPipe.VarVector&lt;TItem&gt;&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TItem">To be added.</typeparam>
          <typeparam name="TShape">To be added.</typeparam>
          <param name="data">To be added.</param>
          <param name="column">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.DataViewExtensions" Member="M:Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn``2(Microsoft.ML.StaticPipe.DataView{``1},System.Func{``1,Microsoft.ML.StaticPipe.VarVector{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.DataView`1" />
      </Targets>
      <Member MemberName="GetColumn&lt;TItem,TShape&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TItem[]&gt; GetColumn&lt;TItem,TShape&gt; (this Microsoft.ML.StaticPipe.DataView&lt;TShape&gt; data, Func&lt;TShape,Microsoft.ML.StaticPipe.Vector&lt;TItem&gt;&gt; column);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TItem[]&gt; GetColumn&lt;TItem, TShape&gt;(class Microsoft.ML.StaticPipe.DataView`1&lt;!!TShape&gt; data, class System.Func`2&lt;!!TShape, class Microsoft.ML.StaticPipe.Vector`1&lt;!!TItem&gt;&gt; column) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn``2(Microsoft.ML.StaticPipe.DataView{``1},System.Func{``1,Microsoft.ML.StaticPipe.Vector{``0}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetColumn(Of TItem, TShape) (data As DataView(Of TShape), column As Func(Of TShape, Vector(Of TItem))) As IEnumerable(Of TItem())" />
        <MemberSignature Language="F#" Value="static member GetColumn : Microsoft.ML.StaticPipe.DataView&lt;'Shape&gt; * Func&lt;'Shape, Microsoft.ML.StaticPipe.Vector&lt;'Item&gt;&gt; -&gt; seq&lt;'Item[]&gt;" Usage="Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn (data, column)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;TItem[]&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TItem" />
          <TypeParameter Name="TShape" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;TShape&gt;" RefType="this" />
          <Parameter Name="column" Type="System.Func&lt;TShape,Microsoft.ML.StaticPipe.Vector&lt;TItem&gt;&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TItem">To be added.</typeparam>
          <typeparam name="TShape">To be added.</typeparam>
          <param name="data">To be added.</param>
          <param name="column">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.DataViewExtensions" Member="M:Microsoft.ML.StaticPipe.DataViewExtensions.GetColumn``2(Microsoft.ML.StaticPipe.DataView{``1},System.Func{``1,Microsoft.ML.StaticPipe.Vector{``0}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="MultiClassLogisticRegression&lt;TVal&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;float&gt;,Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt;&gt; MultiClassLogisticRegression&lt;TVal&gt; (this Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers ctx, Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, float l1Weight = 1, float l2Weight = 1, float optimizationTolerance = 1E-07, int memorySize = 20, bool enoforceNoNegativity = false, Action&lt;Microsoft.ML.Runtime.Learners.MulticlassLogisticRegressionPredictor&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt;&gt; MultiClassLogisticRegression&lt;TVal&gt;(class Microsoft.ML.MulticlassClassificationContext/MulticlassClassificationTrainers ctx, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, float32 l1Weight, float32 l2Weight, float32 optimizationTolerance, int32 memorySize, bool enoforceNoNegativity, class System.Action`1&lt;class Microsoft.ML.Runtime.Learners.MulticlassLogisticRegressionPredictor&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.MultiClassClassificationTrainers.MultiClassLogisticRegression``1(Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Single,System.Single,System.Single,System.Int32,System.Boolean,System.Action{Microsoft.ML.Runtime.Learners.MulticlassLogisticRegressionPredictor})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function MultiClassLogisticRegression(Of TVal) (ctx As MulticlassClassificationContext.MulticlassClassificationTrainers, label As Key(Of UInteger, TVal), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional l1Weight As Single = 1, Optional l2Weight As Single = 1, Optional optimizationTolerance As Single = 1E-07, Optional memorySize As Integer = 20, Optional enoforceNoNegativity As Boolean = false, Optional onFit As Action(Of MulticlassLogisticRegressionPredictor) = null) As ValueTuple(Of Vector(Of Single), Key(Of UInteger, TVal))" />
        <MemberSignature Language="F#" Value="static member MultiClassLogisticRegression : Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers * Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * single * single * single * int * bool * Action&lt;Microsoft.ML.Runtime.Learners.MulticlassLogisticRegressionPredictor&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;single&gt;, Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt;&gt;" Usage="Microsoft.ML.StaticPipe.MultiClassClassificationTrainers.MultiClassLogisticRegression (ctx, label, features, weights, l1Weight, l2Weight, optimizationTolerance, memorySize, enoforceNoNegativity, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TVal" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.MulticlassClassificationContext+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="l1Weight" Type="System.Single" />
          <Parameter Name="l2Weight" Type="System.Single" />
          <Parameter Name="optimizationTolerance" Type="System.Single" />
          <Parameter Name="memorySize" Type="System.Int32" />
          <Parameter Name="enoforceNoNegativity" Type="System.Boolean" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Runtime.Learners.MulticlassLogisticRegressionPredictor&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TVal">To be added.</typeparam>
          <param name="ctx">The multiclass classification context trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="l1Weight">Weight of L1 regularization term.</param>
          <param name="l2Weight">Weight of L2 regularization term.</param>
          <param name="optimizationTolerance">Threshold for optimizer convergence.</param>
          <param name="memorySize">Memory size for <see cref="T:Microsoft.ML.Runtime.Learners.LogisticRegression" />. Lower=faster, less accurate.</param>
          <param name="enoforceNoNegativity">Enforce non-negative weights.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear multiclass classification model trained with the <see cref="T:Microsoft.ML.Runtime.Learners.MulticlassLogisticRegression" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.MultiClassClassificationTrainers" Member="M:Microsoft.ML.StaticPipe.MultiClassClassificationTrainers.MultiClassLogisticRegression``1(Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Single,System.Single,System.Single,System.Int32,System.Boolean,System.Action{Microsoft.ML.Runtime.Learners.MulticlassLogisticRegressionPredictor})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionContext.RegressionTrainers" />
      </Targets>
      <Member MemberName="OnlineGradientDescent">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; OnlineGradientDescent (this Microsoft.ML.RegressionContext.RegressionTrainers ctx, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, Microsoft.ML.Runtime.IRegressionLoss lossFunction = null, float learningRate = 0.1, bool decreaseLearningRate = true, float l2RegularizerWeight = 0, int numIterations = 1, Action&lt;Microsoft.ML.Runtime.Learners.LinearRegressionPredictor&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; OnlineGradientDescent(class Microsoft.ML.RegressionContext/RegressionTrainers ctx, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, class Microsoft.ML.Runtime.IRegressionLoss lossFunction, float32 learningRate, bool decreaseLearningRate, float32 l2RegularizerWeight, int32 numIterations, class System.Action`1&lt;class Microsoft.ML.Runtime.Learners.LinearRegressionPredictor&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.RegressionTrainers.OnlineGradientDescent(Microsoft.ML.RegressionContext.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Runtime.IRegressionLoss,System.Single,System.Boolean,System.Single,System.Int32,System.Action{Microsoft.ML.Runtime.Learners.LinearRegressionPredictor})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OnlineGradientDescent (ctx As RegressionContext.RegressionTrainers, label As Scalar(Of Single), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional lossFunction As IRegressionLoss = null, Optional learningRate As Single = 0.1, Optional decreaseLearningRate As Boolean = true, Optional l2RegularizerWeight As Single = 0, Optional numIterations As Integer = 1, Optional onFit As Action(Of LinearRegressionPredictor) = null) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member OnlineGradientDescent : Microsoft.ML.RegressionContext.RegressionTrainers * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.Runtime.IRegressionLoss * single * bool * single * int * Action&lt;Microsoft.ML.Runtime.Learners.LinearRegressionPredictor&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.RegressionTrainers.OnlineGradientDescent (ctx, label, features, weights, lossFunction, learningRate, decreaseLearningRate, l2RegularizerWeight, numIterations, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RegressionContext+RegressionTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="lossFunction" Type="Microsoft.ML.Runtime.IRegressionLoss" />
          <Parameter Name="learningRate" Type="System.Single" />
          <Parameter Name="decreaseLearningRate" Type="System.Boolean" />
          <Parameter Name="l2RegularizerWeight" Type="System.Single" />
          <Parameter Name="numIterations" Type="System.Int32" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Runtime.Learners.LinearRegressionPredictor&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The regression context trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="lossFunction">The custom loss. Defaults to <see cref="T:Microsoft.ML.Runtime.SquaredLoss" /> if not provided.</param>
          <param name="learningRate">The learning Rate.</param>
          <param name="decreaseLearningRate">Decrease learning rate as iterations progress.</param>
          <param name="l2RegularizerWeight">L2 regularization weight.</param>
          <param name="numIterations">Number of training iterations through the data.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained, as well as the calibrator on top of that model. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear regression model trained with the <see cref="T:Microsoft.ML.Runtime.Learners.OnlineGradientDescentTrainer" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.RegressionTrainers" Member="M:Microsoft.ML.StaticPipe.RegressionTrainers.OnlineGradientDescent(Microsoft.ML.RegressionContext.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Runtime.IRegressionLoss,System.Single,System.Boolean,System.Single,System.Int32,System.Action{Microsoft.ML.Runtime.Learners.LinearRegressionPredictor})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionContext.RegressionTrainers" />
      </Targets>
      <Member MemberName="PoissonRegression">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; PoissonRegression (this Microsoft.ML.RegressionContext.RegressionTrainers ctx, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, float l1Weight = 1, float l2Weight = 1, float optimizationTolerance = 1E-07, int memorySize = 20, bool enoforceNoNegativity = false, Action&lt;Microsoft.ML.Runtime.Learners.PoissonRegressionPredictor&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; PoissonRegression(class Microsoft.ML.RegressionContext/RegressionTrainers ctx, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, float32 l1Weight, float32 l2Weight, float32 optimizationTolerance, int32 memorySize, bool enoforceNoNegativity, class System.Action`1&lt;class Microsoft.ML.Runtime.Learners.PoissonRegressionPredictor&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.RegressionTrainers.PoissonRegression(Microsoft.ML.RegressionContext.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Single,System.Single,System.Single,System.Int32,System.Boolean,System.Action{Microsoft.ML.Runtime.Learners.PoissonRegressionPredictor})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function PoissonRegression (ctx As RegressionContext.RegressionTrainers, label As Scalar(Of Single), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional l1Weight As Single = 1, Optional l2Weight As Single = 1, Optional optimizationTolerance As Single = 1E-07, Optional memorySize As Integer = 20, Optional enoforceNoNegativity As Boolean = false, Optional onFit As Action(Of PoissonRegressionPredictor) = null) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member PoissonRegression : Microsoft.ML.RegressionContext.RegressionTrainers * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * single * single * single * int * bool * Action&lt;Microsoft.ML.Runtime.Learners.PoissonRegressionPredictor&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.StaticPipe.RegressionTrainers.PoissonRegression (ctx, label, features, weights, l1Weight, l2Weight, optimizationTolerance, memorySize, enoforceNoNegativity, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RegressionContext+RegressionTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="l1Weight" Type="System.Single" />
          <Parameter Name="l2Weight" Type="System.Single" />
          <Parameter Name="optimizationTolerance" Type="System.Single" />
          <Parameter Name="memorySize" Type="System.Int32" />
          <Parameter Name="enoforceNoNegativity" Type="System.Boolean" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Runtime.Learners.PoissonRegressionPredictor&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The regression context trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="l1Weight">Weight of L1 regularization term.</param>
          <param name="l2Weight">Weight of L2 regularization term.</param>
          <param name="optimizationTolerance">Threshold for optimizer convergence.</param>
          <param name="memorySize">Memory size for <see cref="T:Microsoft.ML.Runtime.Learners.LogisticRegression" />. Lower=faster, less accurate.</param>
          <param name="enoforceNoNegativity">Enforce non-negative weights.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained.  Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear regression model trained with the <see cref="T:Microsoft.ML.Runtime.Learners.LogisticRegression" /> trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.RegressionTrainers" Member="M:Microsoft.ML.StaticPipe.RegressionTrainers.PoissonRegression(Microsoft.ML.RegressionContext.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Single,System.Single,System.Single,System.Int32,System.Boolean,System.Action{Microsoft.ML.Runtime.Learners.PoissonRegressionPredictor})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Runtime.Data.IDataView" />
      </Targets>
      <Member MemberName="AssertStatic&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.DataView&lt;T&gt; AssertStatic&lt;T&gt; (this Microsoft.ML.Runtime.Data.IDataView view, Microsoft.ML.Runtime.IHostEnvironment env, Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,T&gt; outputDecl);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt; AssertStatic&lt;T&gt;(class Microsoft.ML.Runtime.Data.IDataView view, class Microsoft.ML.Runtime.IHostEnvironment env, class System.Func`2&lt;class Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, !!T&gt; outputDecl) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``1(Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AssertStatic(Of T) (view As IDataView, env As IHostEnvironment, outputDecl As Func(Of SchemaAssertionContext, T)) As DataView(Of T)" />
        <MemberSignature Language="F#" Value="static member AssertStatic : Microsoft.ML.Runtime.Data.IDataView * Microsoft.ML.Runtime.IHostEnvironment * Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, 'T&gt; -&gt; Microsoft.ML.StaticPipe.DataView&lt;'T&gt;" Usage="Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic (view, env, outputDecl)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.DataView&lt;T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T">
            <Attributes>
              <Attribute>
                <AttributeName>Microsoft.ML.StaticPipe.IsShape</AttributeName>
              </Attribute>
            </Attributes>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="view" Type="Microsoft.ML.Runtime.Data.IDataView" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
          <Parameter Name="outputDecl" Type="System.Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,T&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="T">The type representing the view's schema shape</typeparam>
          <param name="view">The view to assert the static schema on</param>
          <param name="env">The host environment to keep in the statically typed variant</param>
          <param name="outputDecl">The delegate through which we declare the schema, which ought to
            use the input <see cref="T:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext" /> to declare a <see cref="T:System.ValueTuple" />
            of the <see cref="T:Microsoft.ML.StaticPipe.PipelineColumn" /> indices, properly named</param>
          <summary>
            Asserts that a given data view has the indicated schema. If this method returns without
            throwing then the view has been validated to have columns with the indicated names and types.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.StaticPipeExtensions" Member="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``1(Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.IDataReader`1" />
      </Targets>
      <Member MemberName="AssertStatic&lt;TIn,T&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.DataReader&lt;TIn,T&gt; AssertStatic&lt;TIn,T&gt; (this Microsoft.ML.Core.Data.IDataReader&lt;TIn&gt; reader, Microsoft.ML.Runtime.IHostEnvironment env, Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,T&gt; outputDecl);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.DataReader`2&lt;!!TIn, !!T&gt; AssertStatic&lt;TIn, T&gt;(class Microsoft.ML.Core.Data.IDataReader`1&lt;!!TIn&gt; reader, class Microsoft.ML.Runtime.IHostEnvironment env, class System.Func`2&lt;class Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, !!T&gt; outputDecl) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``2(Microsoft.ML.Core.Data.IDataReader{``0},Microsoft.ML.Runtime.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AssertStatic(Of TIn, T) (reader As IDataReader(Of TIn), env As IHostEnvironment, outputDecl As Func(Of SchemaAssertionContext, T)) As DataReader(Of TIn, T)" />
        <MemberSignature Language="F#" Value="static member AssertStatic : Microsoft.ML.Core.Data.IDataReader&lt;'In&gt; * Microsoft.ML.Runtime.IHostEnvironment * Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, 'T&gt; -&gt; Microsoft.ML.StaticPipe.DataReader&lt;'In, 'T&gt;" Usage="Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic (reader, env, outputDecl)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.DataReader&lt;TIn,T&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TIn" />
          <TypeParameter Name="T">
            <Attributes>
              <Attribute>
                <AttributeName>Microsoft.ML.StaticPipe.IsShape</AttributeName>
              </Attribute>
            </Attributes>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="reader" Type="Microsoft.ML.Core.Data.IDataReader&lt;TIn&gt;" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
          <Parameter Name="outputDecl" Type="System.Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,T&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TIn">To be added.</typeparam>
          <typeparam name="T">To be added.</typeparam>
          <param name="reader">To be added.</param>
          <param name="env">To be added.</param>
          <param name="outputDecl">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.StaticPipeExtensions" Member="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``2(Microsoft.ML.Core.Data.IDataReader{``0},Microsoft.ML.Runtime.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.ITransformer" />
      </Targets>
      <Member MemberName="AssertStatic&lt;TIn,TOut,TTrans&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Transformer&lt;TIn,TOut,TTrans&gt; AssertStatic&lt;TIn,TOut,TTrans&gt; (this TTrans transformer, Microsoft.ML.Runtime.IHostEnvironment env, Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,TIn&gt; inputDecl, Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,TOut&gt; outputDecl) where TTrans : class, Microsoft.ML.Core.Data.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Transformer`3&lt;!!TIn, !!TOut, !!TTrans&gt; AssertStatic&lt;TIn, TOut, class (class Microsoft.ML.Core.Data.ITransformer) TTrans&gt;(!!TTrans transformer, class Microsoft.ML.Runtime.IHostEnvironment env, class System.Func`2&lt;class Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, !!TIn&gt; inputDecl, class System.Func`2&lt;class Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, !!TOut&gt; outputDecl) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``3(``2,Microsoft.ML.Runtime.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``0},System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AssertStatic(Of TIn, TOut, TTrans) (transformer As TTrans, env As IHostEnvironment, inputDecl As Func(Of SchemaAssertionContext, TIn), outputDecl As Func(Of SchemaAssertionContext, TOut)) As Transformer(Of TIn, TOut, TTrans)" />
        <MemberSignature Language="F#" Value="static member AssertStatic : 'rans * Microsoft.ML.Runtime.IHostEnvironment * Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, 'In&gt; * Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, 'Out&gt; -&gt; Microsoft.ML.StaticPipe.Transformer&lt;'In, 'Out, 'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)" Usage="Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic (transformer, env, inputDecl, outputDecl)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Transformer&lt;TIn,TOut,TTrans&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TIn">
            <Attributes>
              <Attribute>
                <AttributeName>Microsoft.ML.StaticPipe.IsShape</AttributeName>
              </Attribute>
            </Attributes>
          </TypeParameter>
          <TypeParameter Name="TOut">
            <Attributes>
              <Attribute>
                <AttributeName>Microsoft.ML.StaticPipe.IsShape</AttributeName>
              </Attribute>
            </Attributes>
          </TypeParameter>
          <TypeParameter Name="TTrans">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="transformer" Type="TTrans" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
          <Parameter Name="inputDecl" Type="System.Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,TIn&gt;" />
          <Parameter Name="outputDecl" Type="System.Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,TOut&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TIn">To be added.</typeparam>
          <typeparam name="TOut">To be added.</typeparam>
          <typeparam name="TTrans">To be added.</typeparam>
          <param name="transformer">To be added.</param>
          <param name="env">To be added.</param>
          <param name="inputDecl">To be added.</param>
          <param name="outputDecl">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.StaticPipeExtensions" Member="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``3(``2,Microsoft.ML.Runtime.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``0},System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.IDataReaderEstimator`2" />
      </Targets>
      <Member MemberName="AssertStatic&lt;TIn,T,TReader&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.DataReaderEstimator&lt;TIn,T,TReader&gt; AssertStatic&lt;TIn,T,TReader&gt; (this Microsoft.ML.Core.Data.IDataReaderEstimator&lt;TIn,TReader&gt; readerEstimator, Microsoft.ML.Runtime.IHostEnvironment env, Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,T&gt; outputDecl) where TReader : class, Microsoft.ML.Core.Data.IDataReader&lt;TIn&gt;;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.DataReaderEstimator`3&lt;!!TIn, !!T, !!TReader&gt; AssertStatic&lt;TIn, T, class (class Microsoft.ML.Core.Data.IDataReader`1&lt;!!TIn&gt;) TReader&gt;(class Microsoft.ML.Core.Data.IDataReaderEstimator`2&lt;!!TIn, !!TReader&gt; readerEstimator, class Microsoft.ML.Runtime.IHostEnvironment env, class System.Func`2&lt;class Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, !!T&gt; outputDecl) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``3(Microsoft.ML.Core.Data.IDataReaderEstimator{``0,``2},Microsoft.ML.Runtime.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AssertStatic(Of TIn, T, TReader) (readerEstimator As IDataReaderEstimator(Of TIn, TReader), env As IHostEnvironment, outputDecl As Func(Of SchemaAssertionContext, T)) As DataReaderEstimator(Of TIn, T, TReader)" />
        <MemberSignature Language="F#" Value="static member AssertStatic : Microsoft.ML.Core.Data.IDataReaderEstimator&lt;'In, 'Reader (requires 'Reader : null and 'Reader :&gt; Microsoft.ML.Core.Data.IDataReader&lt;'In&gt;)&gt; * Microsoft.ML.Runtime.IHostEnvironment * Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, 'T&gt; -&gt; Microsoft.ML.StaticPipe.DataReaderEstimator&lt;'In, 'T, 'Reader (requires 'Reader : null and 'Reader :&gt; Microsoft.ML.Core.Data.IDataReader&lt;'In&gt;)&gt; (requires 'Reader : null and 'Reader :&gt; Microsoft.ML.Core.Data.IDataReader&lt;'In&gt;)" Usage="Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic (readerEstimator, env, outputDecl)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.DataReaderEstimator&lt;TIn,T,TReader&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TIn" />
          <TypeParameter Name="T">
            <Attributes>
              <Attribute>
                <AttributeName>Microsoft.ML.StaticPipe.IsShape</AttributeName>
              </Attribute>
            </Attributes>
          </TypeParameter>
          <TypeParameter Name="TReader">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.IDataReader&lt;TIn&gt;</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="readerEstimator" Type="Microsoft.ML.Core.Data.IDataReaderEstimator&lt;TIn,TReader&gt;" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
          <Parameter Name="outputDecl" Type="System.Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,T&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TIn">To be added.</typeparam>
          <typeparam name="T">To be added.</typeparam>
          <typeparam name="TReader">To be added.</typeparam>
          <param name="readerEstimator">To be added.</param>
          <param name="env">To be added.</param>
          <param name="outputDecl">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.StaticPipeExtensions" Member="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``3(Microsoft.ML.Core.Data.IDataReaderEstimator{``0,``2},Microsoft.ML.Runtime.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.Core.Data.IEstimator`1" />
      </Targets>
      <Member MemberName="AssertStatic&lt;TIn,TOut,TTrans&gt;">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Estimator&lt;TIn,TOut,TTrans&gt; AssertStatic&lt;TIn,TOut,TTrans&gt; (this Microsoft.ML.Core.Data.IEstimator&lt;TTrans&gt; estimator, Microsoft.ML.Runtime.IHostEnvironment env, Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,TIn&gt; inputDecl, Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,TOut&gt; outputDecl) where TTrans : class, Microsoft.ML.Core.Data.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Estimator`3&lt;!!TIn, !!TOut, !!TTrans&gt; AssertStatic&lt;TIn, TOut, class (class Microsoft.ML.Core.Data.ITransformer) TTrans&gt;(class Microsoft.ML.Core.Data.IEstimator`1&lt;!!TTrans&gt; estimator, class Microsoft.ML.Runtime.IHostEnvironment env, class System.Func`2&lt;class Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, !!TIn&gt; inputDecl, class System.Func`2&lt;class Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, !!TOut&gt; outputDecl) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``3(Microsoft.ML.Core.Data.IEstimator{``2},Microsoft.ML.Runtime.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``0},System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``1})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AssertStatic(Of TIn, TOut, TTrans) (estimator As IEstimator(Of TTrans), env As IHostEnvironment, inputDecl As Func(Of SchemaAssertionContext, TIn), outputDecl As Func(Of SchemaAssertionContext, TOut)) As Estimator(Of TIn, TOut, TTrans)" />
        <MemberSignature Language="F#" Value="static member AssertStatic : Microsoft.ML.Core.Data.IEstimator&lt;'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; * Microsoft.ML.Runtime.IHostEnvironment * Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, 'In&gt; * Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext, 'Out&gt; -&gt; Microsoft.ML.StaticPipe.Estimator&lt;'In, 'Out, 'rans (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; (requires 'rans : null and 'rans :&gt; Microsoft.ML.Core.Data.ITransformer)" Usage="Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic (estimator, env, inputDecl, outputDecl)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Estimator&lt;TIn,TOut,TTrans&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TIn">
            <Attributes>
              <Attribute>
                <AttributeName>Microsoft.ML.StaticPipe.IsShape</AttributeName>
              </Attribute>
            </Attributes>
          </TypeParameter>
          <TypeParameter Name="TOut">
            <Attributes>
              <Attribute>
                <AttributeName>Microsoft.ML.StaticPipe.IsShape</AttributeName>
              </Attribute>
            </Attributes>
          </TypeParameter>
          <TypeParameter Name="TTrans">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="estimator" Type="Microsoft.ML.Core.Data.IEstimator&lt;TTrans&gt;" RefType="this" />
          <Parameter Name="env" Type="Microsoft.ML.Runtime.IHostEnvironment" />
          <Parameter Name="inputDecl" Type="System.Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,TIn&gt;" />
          <Parameter Name="outputDecl" Type="System.Func&lt;Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,TOut&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TIn">To be added.</typeparam>
          <typeparam name="TOut">To be added.</typeparam>
          <typeparam name="TTrans">To be added.</typeparam>
          <param name="estimator">To be added.</param>
          <param name="env">To be added.</param>
          <param name="inputDecl">To be added.</param>
          <param name="outputDecl">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.StaticPipe.StaticPipeExtensions" Member="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``3(Microsoft.ML.Core.Data.IEstimator{``2},Microsoft.ML.Runtime.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``0},System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``1})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="FieldAwareFactorizationMachine">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; FieldAwareFactorizationMachine (this Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers ctx, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt;[] features, float learningRate = 0.1, int numIterations = 5, int numLatentDimensions = 20, Action&lt;Microsoft.ML.Runtime.FactorizationMachine.FieldAwareFactorizationMachineTrainer.Arguments&gt; advancedSettings = null, Action&lt;Microsoft.ML.Runtime.FactorizationMachine.FieldAwareFactorizationMachinePredictor&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; FieldAwareFactorizationMachine(class Microsoft.ML.BinaryClassificationContext/BinaryClassificationTrainers ctx, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;[] features, float32 learningRate, int32 numIterations, int32 numLatentDimensions, class System.Action`1&lt;class Microsoft.ML.Runtime.FactorizationMachine.FieldAwareFactorizationMachineTrainer/Arguments&gt; advancedSettings, class System.Action`1&lt;class Microsoft.ML.Runtime.FactorizationMachine.FieldAwareFactorizationMachinePredictor&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FactorizationMachineStatic.FieldAwareFactorizationMachine(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single}[],System.Single,System.Int32,System.Int32,System.Action{Microsoft.ML.Runtime.FactorizationMachine.FieldAwareFactorizationMachineTrainer.Arguments},System.Action{Microsoft.ML.Runtime.FactorizationMachine.FieldAwareFactorizationMachinePredictor})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FieldAwareFactorizationMachine (ctx As BinaryClassificationContext.BinaryClassificationTrainers, label As Scalar(Of Boolean), features As Vector(Of Single)(), Optional learningRate As Single = 0.1, Optional numIterations As Integer = 5, Optional numLatentDimensions As Integer = 20, Optional advancedSettings As Action(Of FieldAwareFactorizationMachineTrainer.Arguments) = null, Optional onFit As Action(Of FieldAwareFactorizationMachinePredictor) = null) As ValueTuple(Of Scalar(Of Single), Scalar(Of Boolean))" />
        <MemberSignature Language="F#" Value="static member FieldAwareFactorizationMachine : Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt;[] * single * int * int * Action&lt;Microsoft.ML.Runtime.FactorizationMachine.FieldAwareFactorizationMachineTrainer.Arguments&gt; * Action&lt;Microsoft.ML.Runtime.FactorizationMachine.FieldAwareFactorizationMachinePredictor&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.Trainers.FactorizationMachineStatic.FieldAwareFactorizationMachine (ctx, label, features, learningRate, numIterations, numLatentDimensions, advancedSettings, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;[]" />
          <Parameter Name="learningRate" Type="System.Single" />
          <Parameter Name="numIterations" Type="System.Int32" />
          <Parameter Name="numLatentDimensions" Type="System.Int32" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Runtime.FactorizationMachine.FieldAwareFactorizationMachineTrainer+Arguments&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Runtime.FactorizationMachine.FieldAwareFactorizationMachinePredictor&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The binary classifier context trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="learningRate">Initial learning rate.</param>
          <param name="numIterations">Number of training iterations.</param>
          <param name="numLatentDimensions">Latent space dimensions.</param>
          <param name="advancedSettings">A delegate to set more settings.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the model that was trained.  Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
            Predict a target using a field-aware factorization machine.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FactorizationMachineStatic" Member="M:Microsoft.ML.Trainers.FactorizationMachineStatic.FieldAwareFactorizationMachine(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single}[],System.Single,System.Int32,System.Int32,System.Action{Microsoft.ML.Runtime.FactorizationMachine.FieldAwareFactorizationMachineTrainer.Arguments},System.Action{Microsoft.ML.Runtime.FactorizationMachine.FieldAwareFactorizationMachinePredictor})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="FastTree">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; FastTree (this Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers ctx, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, int numLeaves = 20, int numTrees = 100, int minDocumentsInLeafs = 10, double learningRate = 0.2, Action&lt;Microsoft.ML.Runtime.FastTree.FastTreeBinaryClassificationTrainer.Arguments&gt; advancedSettings = null, Action&lt;Microsoft.ML.Runtime.Internal.Internallearn.IPredictorWithFeatureWeights&lt;float&gt;&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; FastTree(class Microsoft.ML.BinaryClassificationContext/BinaryClassificationTrainers ctx, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, int32 numLeaves, int32 numTrees, int32 minDocumentsInLeafs, float64 learningRate, class System.Action`1&lt;class Microsoft.ML.Runtime.FastTree.FastTreeBinaryClassificationTrainer/Arguments&gt; advancedSettings, class System.Action`1&lt;class Microsoft.ML.Runtime.Internal.Internallearn.IPredictorWithFeatureWeights`1&lt;float32&gt;&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTreeStatic.FastTree(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Runtime.FastTree.FastTreeBinaryClassificationTrainer.Arguments},System.Action{Microsoft.ML.Runtime.Internal.Internallearn.IPredictorWithFeatureWeights{System.Single}})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FastTree (ctx As BinaryClassificationContext.BinaryClassificationTrainers, label As Scalar(Of Boolean), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional numLeaves As Integer = 20, Optional numTrees As Integer = 100, Optional minDocumentsInLeafs As Integer = 10, Optional learningRate As Double = 0.2, Optional advancedSettings As Action(Of FastTreeBinaryClassificationTrainer.Arguments) = null, Optional onFit As Action(Of IPredictorWithFeatureWeights(Of Single)) = null) As ValueTuple(Of Scalar(Of Single), Scalar(Of Single), Scalar(Of Boolean))" />
        <MemberSignature Language="F#" Value="static member FastTree : Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * int * int * int * double * Action&lt;Microsoft.ML.Runtime.FastTree.FastTreeBinaryClassificationTrainer.Arguments&gt; * Action&lt;Microsoft.ML.Runtime.Internal.Internallearn.IPredictorWithFeatureWeights&lt;single&gt;&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.Trainers.FastTreeStatic.FastTree (ctx, label, features, weights, numLeaves, numTrees, minDocumentsInLeafs, learningRate, advancedSettings, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "probability", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="numLeaves" Type="System.Int32" />
          <Parameter Name="numTrees" Type="System.Int32" />
          <Parameter Name="minDocumentsInLeafs" Type="System.Int32" />
          <Parameter Name="learningRate" Type="System.Double" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Runtime.FastTree.FastTreeBinaryClassificationTrainer+Arguments&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Runtime.Internal.Internallearn.IPredictorWithFeatureWeights&lt;System.Single&gt;&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The <see cref="T:Microsoft.ML.BinaryClassificationContext" />.</param>
          <param name="label">The label column.</param>
          <param name="features">The features colum.</param>
          <param name="weights">The weights column.</param>
          <param name="numLeaves">The number of leaves to use.</param>
          <param name="numTrees">Total number of decision trees to create in the ensemble.</param>
          <param name="minDocumentsInLeafs">The minimal number of documents allowed in a leaf of the tree, out of the subsampled data.</param>
          <param name="learningRate">The learning rate.</param>
          <param name="advancedSettings">Algorithm advanced settings.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained. Note that this action cannot change the result in any way;
            it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            FastTree <see cref="T:Microsoft.ML.BinaryClassificationContext" /> extension method.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTreeStatic" Member="M:Microsoft.ML.Trainers.FastTreeStatic.FastTree(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Runtime.FastTree.FastTreeBinaryClassificationTrainer.Arguments},System.Action{Microsoft.ML.Runtime.Internal.Internallearn.IPredictorWithFeatureWeights{System.Single}})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionContext.RegressionTrainers" />
      </Targets>
      <Member MemberName="FastTree">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; FastTree (this Microsoft.ML.RegressionContext.RegressionTrainers ctx, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, int numLeaves = 20, int numTrees = 100, int minDocumentsInLeafs = 10, double learningRate = 0.2, Action&lt;Microsoft.ML.Runtime.FastTree.FastTreeRegressionTrainer.Arguments&gt; advancedSettings = null, Action&lt;Microsoft.ML.Runtime.FastTree.FastTreeRegressionPredictor&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; FastTree(class Microsoft.ML.RegressionContext/RegressionTrainers ctx, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, int32 numLeaves, int32 numTrees, int32 minDocumentsInLeafs, float64 learningRate, class System.Action`1&lt;class Microsoft.ML.Runtime.FastTree.FastTreeRegressionTrainer/Arguments&gt; advancedSettings, class System.Action`1&lt;class Microsoft.ML.Runtime.FastTree.FastTreeRegressionPredictor&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.FastTreeStatic.FastTree(Microsoft.ML.RegressionContext.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Runtime.FastTree.FastTreeRegressionTrainer.Arguments},System.Action{Microsoft.ML.Runtime.FastTree.FastTreeRegressionPredictor})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FastTree (ctx As RegressionContext.RegressionTrainers, label As Scalar(Of Single), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional numLeaves As Integer = 20, Optional numTrees As Integer = 100, Optional minDocumentsInLeafs As Integer = 10, Optional learningRate As Double = 0.2, Optional advancedSettings As Action(Of FastTreeRegressionTrainer.Arguments) = null, Optional onFit As Action(Of FastTreeRegressionPredictor) = null) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member FastTree : Microsoft.ML.RegressionContext.RegressionTrainers * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * int * int * int * double * Action&lt;Microsoft.ML.Runtime.FastTree.FastTreeRegressionTrainer.Arguments&gt; * Action&lt;Microsoft.ML.Runtime.FastTree.FastTreeRegressionPredictor&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.Trainers.FastTreeStatic.FastTree (ctx, label, features, weights, numLeaves, numTrees, minDocumentsInLeafs, learningRate, advancedSettings, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RegressionContext+RegressionTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="numLeaves" Type="System.Int32" />
          <Parameter Name="numTrees" Type="System.Int32" />
          <Parameter Name="minDocumentsInLeafs" Type="System.Int32" />
          <Parameter Name="learningRate" Type="System.Double" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Runtime.FastTree.FastTreeRegressionTrainer+Arguments&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Runtime.FastTree.FastTreeRegressionPredictor&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The <see cref="T:Microsoft.ML.RegressionContext" />.</param>
          <param name="label">The label column.</param>
          <param name="features">The features colum.</param>
          <param name="weights">The weights column.</param>
          <param name="numLeaves">The number of leaves to use.</param>
          <param name="numTrees">Total number of decision trees to create in the ensemble.</param>
          <param name="minDocumentsInLeafs">The minimal number of documents allowed in a leaf of a regression tree, out of the subsampled data.</param>
          <param name="learningRate">The learning rate.</param>
          <param name="advancedSettings">Algorithm advanced settings.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained. Note that this action cannot change the result in any way;
            it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            FastTree <see cref="T:Microsoft.ML.RegressionContext" /> extension method.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.FastTreeStatic" Member="M:Microsoft.ML.Trainers.FastTreeStatic.FastTree(Microsoft.ML.RegressionContext.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32,System.Int32,System.Double,System.Action{Microsoft.ML.Runtime.FastTree.FastTreeRegressionTrainer.Arguments},System.Action{Microsoft.ML.Runtime.FastTree.FastTreeRegressionPredictor})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="Sdca">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; Sdca (this Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers ctx, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.Runtime.ISupportSdcaClassificationLoss loss, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, Nullable&lt;float&gt; l2Const = null, Nullable&lt;float&gt; l1Threshold = null, Nullable&lt;int&gt; maxIterations = null, Action&lt;Microsoft.ML.Runtime.Learners.LinearBinaryPredictor&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; Sdca(class Microsoft.ML.BinaryClassificationContext/BinaryClassificationTrainers ctx, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.Runtime.ISupportSdcaClassificationLoss loss, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, valuetype System.Nullable`1&lt;float32&gt; l2Const, valuetype System.Nullable`1&lt;float32&gt; l1Threshold, valuetype System.Nullable`1&lt;int32&gt; maxIterations, class System.Action`1&lt;class Microsoft.ML.Runtime.Learners.LinearBinaryPredictor&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.SdcaStatic.Sdca(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.Runtime.ISupportSdcaClassificationLoss,Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Runtime.Learners.LinearBinaryPredictor})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sdca (ctx As BinaryClassificationContext.BinaryClassificationTrainers, label As Scalar(Of Boolean), features As Vector(Of Single), loss As ISupportSdcaClassificationLoss, Optional weights As Scalar(Of Single) = null, Optional l2Const As Nullable(Of Single) = null, Optional l1Threshold As Nullable(Of Single) = null, Optional maxIterations As Nullable(Of Integer) = null, Optional onFit As Action(Of LinearBinaryPredictor) = null) As ValueTuple(Of Scalar(Of Single), Scalar(Of Boolean))" />
        <MemberSignature Language="F#" Value="static member Sdca : Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.Runtime.ISupportSdcaClassificationLoss * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;int&gt; * Action&lt;Microsoft.ML.Runtime.Learners.LinearBinaryPredictor&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.Trainers.SdcaStatic.Sdca (ctx, label, features, loss, weights, l2Const, l1Threshold, maxIterations, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="loss" Type="Microsoft.ML.Runtime.ISupportSdcaClassificationLoss" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="l2Const" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="l1Threshold" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="maxIterations" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Runtime.Learners.LinearBinaryPredictor&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The binary classification context trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="loss">The custom loss.</param>
          <param name="weights">The optional example weights.</param>
          <param name="l2Const">The L2 regularization hyperparameter.</param>
          <param name="l1Threshold">The L1 regularization hyperparameter. Higher values will tend to lead to more sparse model.</param>
          <param name="maxIterations">The maximum number of passes to perform over the data.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained, as well as the calibrator on top of that model. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear binary classification model trained with the SDCA trainer, and a custom loss.
            Note that because we cannot be sure that all loss functions will produce naturally calibrated outputs, setting
            a custom loss function will not produce a calibrated probability column.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.SdcaStatic" Member="M:Microsoft.ML.Trainers.SdcaStatic.Sdca(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.Runtime.ISupportSdcaClassificationLoss,Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Runtime.Learners.LinearBinaryPredictor})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers" />
      </Targets>
      <Member MemberName="Sdca">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; Sdca (this Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers ctx, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, Nullable&lt;float&gt; l2Const = null, Nullable&lt;float&gt; l1Threshold = null, Nullable&lt;int&gt; maxIterations = null, Action&lt;Microsoft.ML.Runtime.Learners.LinearBinaryPredictor,Microsoft.ML.Runtime.Internal.Calibration.ParameterMixingCalibratedPredictor&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; Sdca(class Microsoft.ML.BinaryClassificationContext/BinaryClassificationTrainers ctx, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, valuetype System.Nullable`1&lt;float32&gt; l2Const, valuetype System.Nullable`1&lt;float32&gt; l1Threshold, valuetype System.Nullable`1&lt;int32&gt; maxIterations, class System.Action`2&lt;class Microsoft.ML.Runtime.Learners.LinearBinaryPredictor, class Microsoft.ML.Runtime.Internal.Calibration.ParameterMixingCalibratedPredictor&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.SdcaStatic.Sdca(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Runtime.Learners.LinearBinaryPredictor,Microsoft.ML.Runtime.Internal.Calibration.ParameterMixingCalibratedPredictor})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sdca (ctx As BinaryClassificationContext.BinaryClassificationTrainers, label As Scalar(Of Boolean), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional l2Const As Nullable(Of Single) = null, Optional l1Threshold As Nullable(Of Single) = null, Optional maxIterations As Nullable(Of Integer) = null, Optional onFit As Action(Of LinearBinaryPredictor, ParameterMixingCalibratedPredictor) = null) As ValueTuple(Of Scalar(Of Single), Scalar(Of Single), Scalar(Of Boolean))" />
        <MemberSignature Language="F#" Value="static member Sdca : Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;int&gt; * Action&lt;Microsoft.ML.Runtime.Learners.LinearBinaryPredictor, Microsoft.ML.Runtime.Internal.Calibration.ParameterMixingCalibratedPredictor&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt;" Usage="Microsoft.ML.Trainers.SdcaStatic.Sdca (ctx, label, features, weights, l2Const, l1Threshold, maxIterations, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "probability", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.BinaryClassificationContext+BinaryClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="l2Const" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="l1Threshold" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="maxIterations" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Runtime.Learners.LinearBinaryPredictor,Microsoft.ML.Runtime.Internal.Calibration.ParameterMixingCalibratedPredictor&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The binary classification context trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="l2Const">The L2 regularization hyperparameter.</param>
          <param name="l1Threshold">The L1 regularization hyperparameter. Higher values will tend to lead to more sparse model.</param>
          <param name="maxIterations">The maximum number of passes to perform over the data.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained, as well as the calibrator on top of that model. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear binary classification model trained with the SDCA trainer, and log-loss.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.SdcaStatic" Member="M:Microsoft.ML.Trainers.SdcaStatic.Sdca(Microsoft.ML.BinaryClassificationContext.BinaryClassificationTrainers,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Runtime.Learners.LinearBinaryPredictor,Microsoft.ML.Runtime.Internal.Calibration.ParameterMixingCalibratedPredictor})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionContext.RegressionTrainers" />
      </Targets>
      <Member MemberName="Sdca">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;float&gt; Sdca (this Microsoft.ML.RegressionContext.RegressionTrainers ctx, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, Nullable&lt;float&gt; l2Const = null, Nullable&lt;float&gt; l1Threshold = null, Nullable&lt;int&gt; maxIterations = null, Microsoft.ML.Runtime.ISupportSdcaRegressionLoss loss = null, Action&lt;Microsoft.ML.Runtime.Learners.LinearRegressionPredictor&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; Sdca(class Microsoft.ML.RegressionContext/RegressionTrainers ctx, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, valuetype System.Nullable`1&lt;float32&gt; l2Const, valuetype System.Nullable`1&lt;float32&gt; l1Threshold, valuetype System.Nullable`1&lt;int32&gt; maxIterations, class Microsoft.ML.Runtime.ISupportSdcaRegressionLoss loss, class System.Action`1&lt;class Microsoft.ML.Runtime.Learners.LinearRegressionPredictor&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.SdcaStatic.Sdca(Microsoft.ML.RegressionContext.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},Microsoft.ML.Runtime.ISupportSdcaRegressionLoss,System.Action{Microsoft.ML.Runtime.Learners.LinearRegressionPredictor})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sdca (ctx As RegressionContext.RegressionTrainers, label As Scalar(Of Single), features As Vector(Of Single), Optional weights As Scalar(Of Single) = null, Optional l2Const As Nullable(Of Single) = null, Optional l1Threshold As Nullable(Of Single) = null, Optional maxIterations As Nullable(Of Integer) = null, Optional loss As ISupportSdcaRegressionLoss = null, Optional onFit As Action(Of LinearRegressionPredictor) = null) As Scalar(Of Single)" />
        <MemberSignature Language="F#" Value="static member Sdca : Microsoft.ML.RegressionContext.RegressionTrainers * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;int&gt; * Microsoft.ML.Runtime.ISupportSdcaRegressionLoss * Action&lt;Microsoft.ML.Runtime.Learners.LinearRegressionPredictor&gt; -&gt; Microsoft.ML.StaticPipe.Scalar&lt;single&gt;" Usage="Microsoft.ML.Trainers.SdcaStatic.Sdca (ctx, label, features, weights, l2Const, l1Threshold, maxIterations, loss, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.RegressionContext+RegressionTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="l2Const" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="l1Threshold" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="maxIterations" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="loss" Type="Microsoft.ML.Runtime.ISupportSdcaRegressionLoss" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Runtime.Learners.LinearRegressionPredictor&gt;" />
        </Parameters>
        <Docs>
          <param name="ctx">The regression context trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="weights">The optional example weights.</param>
          <param name="l2Const">The L2 regularization hyperparameter.</param>
          <param name="l1Threshold">The L1 regularization hyperparameter. Higher values will tend to lead to more sparse model.</param>
          <param name="maxIterations">The maximum number of passes to perform over the data.</param>
          <param name="loss">The custom loss, if unspecified will be <see cref="T:Microsoft.ML.Runtime.SquaredLossSDCARegressionLossFunction" />.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained.  Note that this action cannot change the result in any way; it is only a way for the caller to
            be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear regression model trained with the SDCA trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.SdcaStatic" Member="M:Microsoft.ML.Trainers.SdcaStatic.Sdca(Microsoft.ML.RegressionContext.RegressionTrainers,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},Microsoft.ML.Runtime.ISupportSdcaRegressionLoss,System.Action{Microsoft.ML.Runtime.Learners.LinearRegressionPredictor})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers" />
      </Targets>
      <Member MemberName="Sdca&lt;TVal&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;float&gt;,Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt;&gt; Sdca&lt;TVal&gt; (this Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers ctx, Microsoft.ML.StaticPipe.Key&lt;uint,TVal&gt; label, Microsoft.ML.StaticPipe.Vector&lt;float&gt; features, Microsoft.ML.Runtime.ISupportSdcaClassificationLoss loss = null, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; weights = null, Nullable&lt;float&gt; l2Const = null, Nullable&lt;float&gt; l1Threshold = null, Nullable&lt;int&gt; maxIterations = null, Action&lt;Microsoft.ML.Runtime.Learners.MulticlassLogisticRegressionPredictor&gt; onFit = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt;, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt;&gt; Sdca&lt;TVal&gt;(class Microsoft.ML.MulticlassClassificationContext/MulticlassClassificationTrainers ctx, class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, !!TVal&gt; label, class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; features, class Microsoft.ML.Runtime.ISupportSdcaClassificationLoss loss, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; weights, valuetype System.Nullable`1&lt;float32&gt; l2Const, valuetype System.Nullable`1&lt;float32&gt; l1Threshold, valuetype System.Nullable`1&lt;int32&gt; maxIterations, class System.Action`1&lt;class Microsoft.ML.Runtime.Learners.MulticlassLogisticRegressionPredictor&gt; onFit) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Trainers.SdcaStatic.Sdca``1(Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.Runtime.ISupportSdcaClassificationLoss,Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Runtime.Learners.MulticlassLogisticRegressionPredictor})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sdca(Of TVal) (ctx As MulticlassClassificationContext.MulticlassClassificationTrainers, label As Key(Of UInteger, TVal), features As Vector(Of Single), Optional loss As ISupportSdcaClassificationLoss = null, Optional weights As Scalar(Of Single) = null, Optional l2Const As Nullable(Of Single) = null, Optional l1Threshold As Nullable(Of Single) = null, Optional maxIterations As Nullable(Of Integer) = null, Optional onFit As Action(Of MulticlassLogisticRegressionPredictor) = null) As ValueTuple(Of Vector(Of Single), Key(Of UInteger, TVal))" />
        <MemberSignature Language="F#" Value="static member Sdca : Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers * Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt; * Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.Runtime.ISupportSdcaClassificationLoss * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;single&gt; * Nullable&lt;int&gt; * Action&lt;Microsoft.ML.Runtime.Learners.MulticlassLogisticRegressionPredictor&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;single&gt;, Microsoft.ML.StaticPipe.Key&lt;uint32, 'Val&gt;&gt;" Usage="Microsoft.ML.Trainers.SdcaStatic.Sdca (ctx, label, features, loss, weights, l2Const, l1Threshold, maxIterations, onFit)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;,Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "score", "predictedLabel" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TVal" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="ctx" Type="Microsoft.ML.MulticlassClassificationContext+MulticlassClassificationTrainers" RefType="this" />
          <Parameter Name="label" Type="Microsoft.ML.StaticPipe.Key&lt;System.UInt32,TVal&gt;" />
          <Parameter Name="features" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" />
          <Parameter Name="loss" Type="Microsoft.ML.Runtime.ISupportSdcaClassificationLoss" />
          <Parameter Name="weights" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="l2Const" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="l1Threshold" Type="System.Nullable&lt;System.Single&gt;" />
          <Parameter Name="maxIterations" Type="System.Nullable&lt;System.Int32&gt;" />
          <Parameter Name="onFit" Type="System.Action&lt;Microsoft.ML.Runtime.Learners.MulticlassLogisticRegressionPredictor&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TVal">To be added.</typeparam>
          <param name="ctx">The multiclass classification context trainer object.</param>
          <param name="label">The label, or dependent variable.</param>
          <param name="features">The features, or independent variables.</param>
          <param name="loss">The custom loss.</param>
          <param name="weights">The optional example weights.</param>
          <param name="l2Const">The L2 regularization hyperparameter.</param>
          <param name="l1Threshold">The L1 regularization hyperparameter. Higher values will tend to lead to more sparse model.</param>
          <param name="maxIterations">The maximum number of passes to perform over the data.</param>
          <param name="onFit">A delegate that is called every time the
            <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Fit(Microsoft.ML.StaticPipe.DataView{`0})" /> method is called on the
            <see cref="T:Microsoft.ML.StaticPipe.Estimator`3" /> instance created out of this. This delegate will receive
            the linear model that was trained. Note that this action cannot change the
            result in any way; it is only a way for the caller to be informed about what was learnt.</param>
          <summary>
            Predict a target using a linear multiclass classification model trained with the SDCA trainer.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Trainers.SdcaStatic" Member="M:Microsoft.ML.Trainers.SdcaStatic.Sdca``1(Microsoft.ML.MulticlassClassificationContext.MulticlassClassificationTrainers,Microsoft.ML.StaticPipe.Key{System.UInt32,``0},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.Runtime.ISupportSdcaClassificationLoss,Microsoft.ML.StaticPipe.Scalar{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int32},System.Action{Microsoft.ML.Runtime.Learners.MulticlassLogisticRegressionPredictor})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext" />
      </Targets>
      <Member MemberName="CrossValidate&lt;TInShape,TOutShape,TTransformer&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator.CalibratedResult,Microsoft.ML.StaticPipe.Transformer&lt;TInShape,TOutShape,TTransformer&gt;,Microsoft.ML.StaticPipe.DataView&lt;TOutShape&gt;&gt;[] CrossValidate&lt;TInShape,TOutShape,TTransformer&gt; (this Microsoft.ML.BinaryClassificationContext context, Microsoft.ML.StaticPipe.DataView&lt;TInShape&gt; data, Microsoft.ML.StaticPipe.Estimator&lt;TInShape,TOutShape,TTransformer&gt; estimator, Func&lt;TOutShape,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; label, int numFolds = 5, Func&lt;TInShape,Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn = null) where TTransformer : class, Microsoft.ML.Core.Data.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator/CalibratedResult, class Microsoft.ML.StaticPipe.Transformer`3&lt;!!TInShape, !!TOutShape, !!TTransformer&gt;, class Microsoft.ML.StaticPipe.DataView`1&lt;!!TOutShape&gt;&gt;[] CrossValidate&lt;TInShape, TOutShape, class (class Microsoft.ML.Core.Data.ITransformer) TTransformer&gt;(class Microsoft.ML.BinaryClassificationContext context, class Microsoft.ML.StaticPipe.DataView`1&lt;!!TInShape&gt; data, class Microsoft.ML.StaticPipe.Estimator`3&lt;!!TInShape, !!TOutShape, !!TTransformer&gt; estimator, class System.Func`2&lt;!!TOutShape, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; label, int32 numFolds, class System.Func`2&lt;!!TInShape, class Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TrainingStaticExtensions.CrossValidate``3(Microsoft.ML.BinaryClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CrossValidate(Of TInShape, TOutShape, TTransformer) (context As BinaryClassificationContext, data As DataView(Of TInShape), estimator As Estimator(Of TInShape, TOutShape, TTransformer), label As Func(Of TOutShape, Scalar(Of Boolean)), Optional numFolds As Integer = 5, Optional stratificationColumn As Func(Of TInShape, PipelineColumn) = null) As ValueTuple(Of BinaryClassifierEvaluator.CalibratedResult, Transformer(Of TInShape, TOutShape, TTransformer), DataView(Of TOutShape))()" />
        <MemberSignature Language="F#" Value="static member CrossValidate : Microsoft.ML.BinaryClassificationContext * Microsoft.ML.StaticPipe.DataView&lt;'InShape&gt; * Microsoft.ML.StaticPipe.Estimator&lt;'InShape, 'OutShape, 'ransformer (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; * Func&lt;'OutShape, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; * int * Func&lt;'InShape, Microsoft.ML.StaticPipe.PipelineColumn&gt; -&gt; ValueTuple&lt;Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator.CalibratedResult, Microsoft.ML.StaticPipe.Transformer&lt;'InShape, 'OutShape, 'ransformer&gt;, Microsoft.ML.StaticPipe.DataView&lt;'OutShape&gt;&gt;[] (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.Core.Data.ITransformer)" Usage="Microsoft.ML.TrainingStaticExtensions.CrossValidate (context, data, estimator, label, numFolds, stratificationColumn)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator+CalibratedResult,Microsoft.ML.StaticPipe.Transformer&lt;TInShape,TOutShape,TTransformer&gt;,Microsoft.ML.StaticPipe.DataView&lt;TOutShape&gt;&gt;[]</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "metrics", "model", "scoredTestData" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TInShape" />
          <TypeParameter Name="TOutShape" />
          <TypeParameter Name="TTransformer">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="context" Type="Microsoft.ML.BinaryClassificationContext" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;TInShape&gt;" />
          <Parameter Name="estimator" Type="Microsoft.ML.StaticPipe.Estimator&lt;TInShape,TOutShape,TTransformer&gt;" />
          <Parameter Name="label" Type="System.Func&lt;TOutShape,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;" />
          <Parameter Name="numFolds" Type="System.Int32" />
          <Parameter Name="stratificationColumn" Type="System.Func&lt;TInShape,Microsoft.ML.StaticPipe.PipelineColumn&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TInShape">The input schema shape.</typeparam>
          <typeparam name="TOutShape">The output schema shape.</typeparam>
          <typeparam name="TTransformer">The type of the trained model.</typeparam>
          <param name="context">The training context.</param>
          <param name="data">The data to run cross-validation on.</param>
          <param name="estimator">The estimator to fit.</param>
          <param name="label">The label column (for evaluation).</param>
          <param name="numFolds">Number of cross-validation folds.</param>
          <param name="stratificationColumn">Optional stratification column.</param>
          <summary>
            Run cross-validation over <paramref name="numFolds" /> folds of <paramref name="data" />, by fitting <paramref name="estimator" />,
            and respecting <paramref name="stratificationColumn" /> if provided.
            Then evaluate each sub-model against <paramref name="label" /> and return metrics.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TrainingStaticExtensions" Member="M:Microsoft.ML.TrainingStaticExtensions.CrossValidate``3(Microsoft.ML.BinaryClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.MulticlassClassificationContext" />
      </Targets>
      <Member MemberName="CrossValidate&lt;TInShape,TOutShape,TTransformer&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.Runtime.Data.MultiClassClassifierEvaluator.Result,Microsoft.ML.StaticPipe.Transformer&lt;TInShape,TOutShape,TTransformer&gt;,Microsoft.ML.StaticPipe.DataView&lt;TOutShape&gt;&gt;[] CrossValidate&lt;TInShape,TOutShape,TTransformer&gt; (this Microsoft.ML.MulticlassClassificationContext context, Microsoft.ML.StaticPipe.DataView&lt;TInShape&gt; data, Microsoft.ML.StaticPipe.Estimator&lt;TInShape,TOutShape,TTransformer&gt; estimator, Func&lt;TOutShape,Microsoft.ML.StaticPipe.Key&lt;uint&gt;&gt; label, int numFolds = 5, Func&lt;TInShape,Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn = null) where TTransformer : class, Microsoft.ML.Core.Data.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.Runtime.Data.MultiClassClassifierEvaluator/Result, class Microsoft.ML.StaticPipe.Transformer`3&lt;!!TInShape, !!TOutShape, !!TTransformer&gt;, class Microsoft.ML.StaticPipe.DataView`1&lt;!!TOutShape&gt;&gt;[] CrossValidate&lt;TInShape, TOutShape, class (class Microsoft.ML.Core.Data.ITransformer) TTransformer&gt;(class Microsoft.ML.MulticlassClassificationContext context, class Microsoft.ML.StaticPipe.DataView`1&lt;!!TInShape&gt; data, class Microsoft.ML.StaticPipe.Estimator`3&lt;!!TInShape, !!TOutShape, !!TTransformer&gt; estimator, class System.Func`2&lt;!!TOutShape, class Microsoft.ML.StaticPipe.Key`1&lt;unsigned int32&gt;&gt; label, int32 numFolds, class System.Func`2&lt;!!TInShape, class Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TrainingStaticExtensions.CrossValidate``3(Microsoft.ML.MulticlassClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Key{System.UInt32}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CrossValidate(Of TInShape, TOutShape, TTransformer) (context As MulticlassClassificationContext, data As DataView(Of TInShape), estimator As Estimator(Of TInShape, TOutShape, TTransformer), label As Func(Of TOutShape, Key(Of UInteger)), Optional numFolds As Integer = 5, Optional stratificationColumn As Func(Of TInShape, PipelineColumn) = null) As ValueTuple(Of MultiClassClassifierEvaluator.Result, Transformer(Of TInShape, TOutShape, TTransformer), DataView(Of TOutShape))()" />
        <MemberSignature Language="F#" Value="static member CrossValidate : Microsoft.ML.MulticlassClassificationContext * Microsoft.ML.StaticPipe.DataView&lt;'InShape&gt; * Microsoft.ML.StaticPipe.Estimator&lt;'InShape, 'OutShape, 'ransformer (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; * Func&lt;'OutShape, Microsoft.ML.StaticPipe.Key&lt;uint32&gt;&gt; * int * Func&lt;'InShape, Microsoft.ML.StaticPipe.PipelineColumn&gt; -&gt; ValueTuple&lt;Microsoft.ML.Runtime.Data.MultiClassClassifierEvaluator.Result, Microsoft.ML.StaticPipe.Transformer&lt;'InShape, 'OutShape, 'ransformer&gt;, Microsoft.ML.StaticPipe.DataView&lt;'OutShape&gt;&gt;[] (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.Core.Data.ITransformer)" Usage="Microsoft.ML.TrainingStaticExtensions.CrossValidate (context, data, estimator, label, numFolds, stratificationColumn)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.Runtime.Data.MultiClassClassifierEvaluator+Result,Microsoft.ML.StaticPipe.Transformer&lt;TInShape,TOutShape,TTransformer&gt;,Microsoft.ML.StaticPipe.DataView&lt;TOutShape&gt;&gt;[]</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "metrics", "model", "scoredTestData" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TInShape" />
          <TypeParameter Name="TOutShape" />
          <TypeParameter Name="TTransformer">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="context" Type="Microsoft.ML.MulticlassClassificationContext" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;TInShape&gt;" />
          <Parameter Name="estimator" Type="Microsoft.ML.StaticPipe.Estimator&lt;TInShape,TOutShape,TTransformer&gt;" />
          <Parameter Name="label" Type="System.Func&lt;TOutShape,Microsoft.ML.StaticPipe.Key&lt;System.UInt32&gt;&gt;" />
          <Parameter Name="numFolds" Type="System.Int32" />
          <Parameter Name="stratificationColumn" Type="System.Func&lt;TInShape,Microsoft.ML.StaticPipe.PipelineColumn&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TInShape">The input schema shape.</typeparam>
          <typeparam name="TOutShape">The output schema shape.</typeparam>
          <typeparam name="TTransformer">The type of the trained model.</typeparam>
          <param name="context">The training context.</param>
          <param name="data">The data to run cross-validation on.</param>
          <param name="estimator">The estimator to fit.</param>
          <param name="label">The label column (for evaluation).</param>
          <param name="numFolds">Number of cross-validation folds.</param>
          <param name="stratificationColumn">Optional stratification column.</param>
          <summary>
            Run cross-validation over <paramref name="numFolds" /> folds of <paramref name="data" />, by fitting <paramref name="estimator" />,
            and respecting <paramref name="stratificationColumn" /> if provided.
            Then evaluate each sub-model against <paramref name="label" /> and return metrics.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TrainingStaticExtensions" Member="M:Microsoft.ML.TrainingStaticExtensions.CrossValidate``3(Microsoft.ML.MulticlassClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Key{System.UInt32}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.RegressionContext" />
      </Targets>
      <Member MemberName="CrossValidate&lt;TInShape,TOutShape,TTransformer&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.Runtime.Data.RegressionEvaluator.Result,Microsoft.ML.StaticPipe.Transformer&lt;TInShape,TOutShape,TTransformer&gt;,Microsoft.ML.StaticPipe.DataView&lt;TOutShape&gt;&gt;[] CrossValidate&lt;TInShape,TOutShape,TTransformer&gt; (this Microsoft.ML.RegressionContext context, Microsoft.ML.StaticPipe.DataView&lt;TInShape&gt; data, Microsoft.ML.StaticPipe.Estimator&lt;TInShape,TOutShape,TTransformer&gt; estimator, Func&lt;TOutShape,Microsoft.ML.StaticPipe.Scalar&lt;float&gt;&gt; label, int numFolds = 5, Func&lt;TInShape,Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn = null) where TTransformer : class, Microsoft.ML.Core.Data.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.Runtime.Data.RegressionEvaluator/Result, class Microsoft.ML.StaticPipe.Transformer`3&lt;!!TInShape, !!TOutShape, !!TTransformer&gt;, class Microsoft.ML.StaticPipe.DataView`1&lt;!!TOutShape&gt;&gt;[] CrossValidate&lt;TInShape, TOutShape, class (class Microsoft.ML.Core.Data.ITransformer) TTransformer&gt;(class Microsoft.ML.RegressionContext context, class Microsoft.ML.StaticPipe.DataView`1&lt;!!TInShape&gt; data, class Microsoft.ML.StaticPipe.Estimator`3&lt;!!TInShape, !!TOutShape, !!TTransformer&gt; estimator, class System.Func`2&lt;!!TOutShape, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt;&gt; label, int32 numFolds, class System.Func`2&lt;!!TInShape, class Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TrainingStaticExtensions.CrossValidate``3(Microsoft.ML.RegressionContext,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{System.Single}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CrossValidate(Of TInShape, TOutShape, TTransformer) (context As RegressionContext, data As DataView(Of TInShape), estimator As Estimator(Of TInShape, TOutShape, TTransformer), label As Func(Of TOutShape, Scalar(Of Single)), Optional numFolds As Integer = 5, Optional stratificationColumn As Func(Of TInShape, PipelineColumn) = null) As ValueTuple(Of RegressionEvaluator.Result, Transformer(Of TInShape, TOutShape, TTransformer), DataView(Of TOutShape))()" />
        <MemberSignature Language="F#" Value="static member CrossValidate : Microsoft.ML.RegressionContext * Microsoft.ML.StaticPipe.DataView&lt;'InShape&gt; * Microsoft.ML.StaticPipe.Estimator&lt;'InShape, 'OutShape, 'ransformer (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; * Func&lt;'OutShape, Microsoft.ML.StaticPipe.Scalar&lt;single&gt;&gt; * int * Func&lt;'InShape, Microsoft.ML.StaticPipe.PipelineColumn&gt; -&gt; ValueTuple&lt;Microsoft.ML.Runtime.Data.RegressionEvaluator.Result, Microsoft.ML.StaticPipe.Transformer&lt;'InShape, 'OutShape, 'ransformer&gt;, Microsoft.ML.StaticPipe.DataView&lt;'OutShape&gt;&gt;[] (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.Core.Data.ITransformer)" Usage="Microsoft.ML.TrainingStaticExtensions.CrossValidate (context, data, estimator, label, numFolds, stratificationColumn)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.Runtime.Data.RegressionEvaluator+Result,Microsoft.ML.StaticPipe.Transformer&lt;TInShape,TOutShape,TTransformer&gt;,Microsoft.ML.StaticPipe.DataView&lt;TOutShape&gt;&gt;[]</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "metrics", "model", "scoredTestData" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TInShape" />
          <TypeParameter Name="TOutShape" />
          <TypeParameter Name="TTransformer">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="context" Type="Microsoft.ML.RegressionContext" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;TInShape&gt;" />
          <Parameter Name="estimator" Type="Microsoft.ML.StaticPipe.Estimator&lt;TInShape,TOutShape,TTransformer&gt;" />
          <Parameter Name="label" Type="System.Func&lt;TOutShape,Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;&gt;" />
          <Parameter Name="numFolds" Type="System.Int32" />
          <Parameter Name="stratificationColumn" Type="System.Func&lt;TInShape,Microsoft.ML.StaticPipe.PipelineColumn&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TInShape">The input schema shape.</typeparam>
          <typeparam name="TOutShape">The output schema shape.</typeparam>
          <typeparam name="TTransformer">The type of the trained model.</typeparam>
          <param name="context">The training context.</param>
          <param name="data">The data to run cross-validation on.</param>
          <param name="estimator">The estimator to fit.</param>
          <param name="label">The label column (for evaluation).</param>
          <param name="numFolds">Number of cross-validation folds.</param>
          <param name="stratificationColumn">Optional stratification column.</param>
          <summary>
            Run cross-validation over <paramref name="numFolds" /> folds of <paramref name="data" />, by fitting <paramref name="estimator" />,
            and respecting <paramref name="stratificationColumn" /> if provided.
            Then evaluate each sub-model against <paramref name="label" /> and return metrics.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TrainingStaticExtensions" Member="M:Microsoft.ML.TrainingStaticExtensions.CrossValidate``3(Microsoft.ML.RegressionContext,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{System.Single}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.BinaryClassificationContext" />
      </Targets>
      <Member MemberName="CrossValidateNonCalibrated&lt;TInShape,TOutShape,TTransformer&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator.Result,Microsoft.ML.StaticPipe.Transformer&lt;TInShape,TOutShape,TTransformer&gt;,Microsoft.ML.StaticPipe.DataView&lt;TOutShape&gt;&gt;[] CrossValidateNonCalibrated&lt;TInShape,TOutShape,TTransformer&gt; (this Microsoft.ML.BinaryClassificationContext context, Microsoft.ML.StaticPipe.DataView&lt;TInShape&gt; data, Microsoft.ML.StaticPipe.Estimator&lt;TInShape,TOutShape,TTransformer&gt; estimator, Func&lt;TOutShape,Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; label, int numFolds = 5, Func&lt;TInShape,Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn = null) where TTransformer : class, Microsoft.ML.Core.Data.ITransformer;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`3&lt;class Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator/Result, class Microsoft.ML.StaticPipe.Transformer`3&lt;!!TInShape, !!TOutShape, !!TTransformer&gt;, class Microsoft.ML.StaticPipe.DataView`1&lt;!!TOutShape&gt;&gt;[] CrossValidateNonCalibrated&lt;TInShape, TOutShape, class (class Microsoft.ML.Core.Data.ITransformer) TTransformer&gt;(class Microsoft.ML.BinaryClassificationContext context, class Microsoft.ML.StaticPipe.DataView`1&lt;!!TInShape&gt; data, class Microsoft.ML.StaticPipe.Estimator`3&lt;!!TInShape, !!TOutShape, !!TTransformer&gt; estimator, class System.Func`2&lt;!!TOutShape, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt;&gt; label, int32 numFolds, class System.Func`2&lt;!!TInShape, class Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TrainingStaticExtensions.CrossValidateNonCalibrated``3(Microsoft.ML.BinaryClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CrossValidateNonCalibrated(Of TInShape, TOutShape, TTransformer) (context As BinaryClassificationContext, data As DataView(Of TInShape), estimator As Estimator(Of TInShape, TOutShape, TTransformer), label As Func(Of TOutShape, Scalar(Of Boolean)), Optional numFolds As Integer = 5, Optional stratificationColumn As Func(Of TInShape, PipelineColumn) = null) As ValueTuple(Of BinaryClassifierEvaluator.Result, Transformer(Of TInShape, TOutShape, TTransformer), DataView(Of TOutShape))()" />
        <MemberSignature Language="F#" Value="static member CrossValidateNonCalibrated : Microsoft.ML.BinaryClassificationContext * Microsoft.ML.StaticPipe.DataView&lt;'InShape&gt; * Microsoft.ML.StaticPipe.Estimator&lt;'InShape, 'OutShape, 'ransformer (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.Core.Data.ITransformer)&gt; * Func&lt;'OutShape, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt;&gt; * int * Func&lt;'InShape, Microsoft.ML.StaticPipe.PipelineColumn&gt; -&gt; ValueTuple&lt;Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator.Result, Microsoft.ML.StaticPipe.Transformer&lt;'InShape, 'OutShape, 'ransformer&gt;, Microsoft.ML.StaticPipe.DataView&lt;'OutShape&gt;&gt;[] (requires 'ransformer : null and 'ransformer :&gt; Microsoft.ML.Core.Data.ITransformer)" Usage="Microsoft.ML.TrainingStaticExtensions.CrossValidateNonCalibrated (context, data, estimator, label, numFolds, stratificationColumn)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator+Result,Microsoft.ML.StaticPipe.Transformer&lt;TInShape,TOutShape,TTransformer&gt;,Microsoft.ML.StaticPipe.DataView&lt;TOutShape&gt;&gt;[]</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "metrics", "model", "scoredTestData" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TInShape" />
          <TypeParameter Name="TOutShape" />
          <TypeParameter Name="TTransformer">
            <Constraints>
              <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
              <InterfaceName>Microsoft.ML.Core.Data.ITransformer</InterfaceName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="context" Type="Microsoft.ML.BinaryClassificationContext" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;TInShape&gt;" />
          <Parameter Name="estimator" Type="Microsoft.ML.StaticPipe.Estimator&lt;TInShape,TOutShape,TTransformer&gt;" />
          <Parameter Name="label" Type="System.Func&lt;TOutShape,Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;&gt;" />
          <Parameter Name="numFolds" Type="System.Int32" />
          <Parameter Name="stratificationColumn" Type="System.Func&lt;TInShape,Microsoft.ML.StaticPipe.PipelineColumn&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TInShape">The input schema shape.</typeparam>
          <typeparam name="TOutShape">The output schema shape.</typeparam>
          <typeparam name="TTransformer">The type of the trained model.</typeparam>
          <param name="context">The training context.</param>
          <param name="data">The data to run cross-validation on.</param>
          <param name="estimator">The estimator to fit.</param>
          <param name="label">The label column (for evaluation).</param>
          <param name="numFolds">Number of cross-validation folds.</param>
          <param name="stratificationColumn">Optional stratification column.</param>
          <summary>
            Run cross-validation over <paramref name="numFolds" /> folds of <paramref name="data" />, by fitting <paramref name="estimator" />,
            and respecting <paramref name="stratificationColumn" /> if provided.
            Then evaluate each sub-model against <paramref name="label" /> and return metrics.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TrainingStaticExtensions" Member="M:Microsoft.ML.TrainingStaticExtensions.CrossValidateNonCalibrated``3(Microsoft.ML.BinaryClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.TrainContextBase" />
      </Targets>
      <Member MemberName="TrainTestSplit&lt;T&gt;">
        <MemberSignature Language="C#" Value="public static ValueTuple&lt;Microsoft.ML.StaticPipe.DataView&lt;T&gt;,Microsoft.ML.StaticPipe.DataView&lt;T&gt;&gt; TrainTestSplit&lt;T&gt; (this Microsoft.ML.TrainContextBase context, Microsoft.ML.StaticPipe.DataView&lt;T&gt; data, double testFraction = 0.1, Func&lt;T,Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt;, class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt;&gt; TrainTestSplit&lt;T&gt;(class Microsoft.ML.TrainContextBase context, class Microsoft.ML.StaticPipe.DataView`1&lt;!!T&gt; data, float64 testFraction, class System.Func`2&lt;!!T, class Microsoft.ML.StaticPipe.PipelineColumn&gt; stratificationColumn) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.TrainingStaticExtensions.TrainTestSplit``1(Microsoft.ML.TrainContextBase,Microsoft.ML.StaticPipe.DataView{``0},System.Double,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrainTestSplit(Of T) (context As TrainContextBase, data As DataView(Of T), Optional testFraction As Double = 0.1, Optional stratificationColumn As Func(Of T, PipelineColumn) = null) As ValueTuple(Of DataView(Of T), DataView(Of T))" />
        <MemberSignature Language="F#" Value="static member TrainTestSplit : Microsoft.ML.TrainContextBase * Microsoft.ML.StaticPipe.DataView&lt;'T&gt; * double * Func&lt;'T, Microsoft.ML.StaticPipe.PipelineColumn&gt; -&gt; ValueTuple&lt;Microsoft.ML.StaticPipe.DataView&lt;'T&gt;, Microsoft.ML.StaticPipe.DataView&lt;'T&gt;&gt;" Usage="Microsoft.ML.TrainingStaticExtensions.TrainTestSplit (context, data, testFraction, stratificationColumn)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.ValueTuple&lt;Microsoft.ML.StaticPipe.DataView&lt;T&gt;,Microsoft.ML.StaticPipe.DataView&lt;T&gt;&gt;</ReturnType>
          <Attributes>
            <Attribute>
              <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "trainSet", "testSet" })</AttributeName>
            </Attribute>
          </Attributes>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="T" />
        </TypeParameters>
        <Parameters>
          <Parameter Name="context" Type="Microsoft.ML.TrainContextBase" RefType="this" />
          <Parameter Name="data" Type="Microsoft.ML.StaticPipe.DataView&lt;T&gt;" />
          <Parameter Name="testFraction" Type="System.Double" />
          <Parameter Name="stratificationColumn" Type="System.Func&lt;T,Microsoft.ML.StaticPipe.PipelineColumn&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="T">The tuple describing the data schema.</typeparam>
          <param name="context">The training context.</param>
          <param name="data">The dataset to split.</param>
          <param name="testFraction">The fraction of data to go into the test set.</param>
          <param name="stratificationColumn">Optional selector for the stratification column.</param>
          <summary>
            Split the dataset into the train set and test set according to the given fraction.
            Respects the <paramref name="stratificationColumn" /> if provided.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.TrainingStaticExtensions" Member="M:Microsoft.ML.TrainingStaticExtensions.TrainTestSplit``1(Microsoft.ML.TrainContextBase,Microsoft.ML.StaticPipe.DataView{``0},System.Double,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnCount">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;double&gt; SelectFeaturesBasedOnCount (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, long count = 1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; SelectFeaturesBasedOnCount(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, int64 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.CountFeatureSelectorExtensions.SelectFeaturesBasedOnCount(Microsoft.ML.StaticPipe.Vector{System.Double},System.Int64)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnCount (input As Vector(Of Double), Optional count As Long = 1) As Vector(Of Double)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnCount : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * int64 -&gt; Microsoft.ML.StaticPipe.Vector&lt;double&gt;" Usage="Microsoft.ML.Transforms.CountFeatureSelectorExtensions.SelectFeaturesBasedOnCount (input, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="count" Type="System.Int64" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="count">If the count of non-default values for a slot is greater than or equal to this threshold, the slot is preserved.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.CountFeatureSelectorExtensions" Member="M:Microsoft.ML.Transforms.CountFeatureSelectorExtensions.SelectFeaturesBasedOnCount(Microsoft.ML.StaticPipe.Vector{System.Double},System.Int64)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnCount">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; SelectFeaturesBasedOnCount (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, long count = 1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; SelectFeaturesBasedOnCount(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, int64 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.CountFeatureSelectorExtensions.SelectFeaturesBasedOnCount(Microsoft.ML.StaticPipe.Vector{System.Single},System.Int64)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnCount (input As Vector(Of Single), Optional count As Long = 1) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnCount : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * int64 -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Transforms.CountFeatureSelectorExtensions.SelectFeaturesBasedOnCount (input, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="count" Type="System.Int64" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="count">If the count of non-default values for a slot is greater than or equal to this threshold, the slot is preserved.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.CountFeatureSelectorExtensions" Member="M:Microsoft.ML.Transforms.CountFeatureSelectorExtensions.SelectFeaturesBasedOnCount(Microsoft.ML.StaticPipe.Vector{System.Single},System.Int64)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnCount">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;string&gt; SelectFeaturesBasedOnCount (this Microsoft.ML.StaticPipe.Vector&lt;string&gt; input, long count = 1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;string&gt; SelectFeaturesBasedOnCount(class Microsoft.ML.StaticPipe.Vector`1&lt;string&gt; input, int64 count) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.CountFeatureSelectorExtensions.SelectFeaturesBasedOnCount(Microsoft.ML.StaticPipe.Vector{System.String},System.Int64)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnCount (input As Vector(Of String), Optional count As Long = 1) As Vector(Of String)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnCount : Microsoft.ML.StaticPipe.Vector&lt;string&gt; * int64 -&gt; Microsoft.ML.StaticPipe.Vector&lt;string&gt;" Usage="Microsoft.ML.Transforms.CountFeatureSelectorExtensions.SelectFeaturesBasedOnCount (input, count)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.String&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.String&gt;" RefType="this" />
          <Parameter Name="count" Type="System.Int64" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="count">If the count of non-default values for a slot is greater than or equal to this threshold, the slot is preserved.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.CountFeatureSelectorExtensions" Member="M:Microsoft.ML.Transforms.CountFeatureSelectorExtensions.SelectFeaturesBasedOnCount(Microsoft.ML.StaticPipe.Vector{System.String},System.Int64)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="GlobalContrastNormalize">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; GlobalContrastNormalize (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, bool subMean = true, bool useStdDev = false, float scale = 1);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; GlobalContrastNormalize(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, bool subMean, bool useStdDev, float32 scale) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.GcNormalizerExtensions.GlobalContrastNormalize(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Boolean,System.Single)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GlobalContrastNormalize (input As Vector(Of Single), Optional subMean As Boolean = true, Optional useStdDev As Boolean = false, Optional scale As Single = 1) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member GlobalContrastNormalize : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * bool * bool * single -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Transforms.GcNormalizerExtensions.GlobalContrastNormalize (input, subMean, useStdDev, scale)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="subMean" Type="System.Boolean" />
          <Parameter Name="useStdDev" Type="System.Boolean" />
          <Parameter Name="scale" Type="System.Single" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="subMean">Subtract mean from each value before normalizing.</param>
          <param name="useStdDev">Normalize by standard deviation rather than L2 norm.</param>
          <param name="scale">Scale features by this value.</param>
          <summary>
            <para>Performs a global contrast normalization on input values:</para>
            <para>Y = (s * X - M) / D</para>
            <para>where s is a scale, M is mean and D is either the L2 norm or standard deviation.</para>
          </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.GcNormalizerExtensions" Member="M:Microsoft.ML.Transforms.GcNormalizerExtensions.GlobalContrastNormalize(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Boolean,System.Single)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="LpNormalize">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; LpNormalize (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, Microsoft.ML.Runtime.Data.LpNormNormalizerTransform.NormalizerKind normKind = Microsoft.ML.Runtime.Data.LpNormNormalizerTransform+NormalizerKind.L2Norm, bool subMean = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; LpNormalize(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, valuetype Microsoft.ML.Runtime.Data.LpNormNormalizerTransform/NormalizerKind normKind, bool subMean) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.LpNormNormalizerExtensions.LpNormalize(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.Runtime.Data.LpNormNormalizerTransform.NormalizerKind,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LpNormalize (input As Vector(Of Single), Optional normKind As LpNormNormalizerTransform.NormalizerKind = Microsoft.ML.Runtime.Data.LpNormNormalizerTransform+NormalizerKind.L2Norm, Optional subMean As Boolean = false) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member LpNormalize : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.Runtime.Data.LpNormNormalizerTransform.NormalizerKind * bool -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Transforms.LpNormNormalizerExtensions.LpNormalize (input, normKind, subMean)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="normKind" Type="Microsoft.ML.Runtime.Data.LpNormNormalizerTransform+NormalizerKind" />
          <Parameter Name="subMean" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="normKind">Type of norm to use to normalize each sample.</param>
          <param name="subMean">Subtract mean from each value before normalizing.</param>
          <summary>
         The LpNormalizer transforms, normalizes vectors (rows) individually by rescaling them to unit norm (L2, L1 or LInf). 
         <para>Performs the following operation on a vector X:</para><para>Y = (X - M) / D</para><para>where M is mean and D is either L2 norm, L1 norm or LInf norm.</para></summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.LpNormNormalizerExtensions" Member="M:Microsoft.ML.Transforms.LpNormNormalizerExtensions.LpNormalize(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.Runtime.Data.LpNormNormalizerTransform.NormalizerKind,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnMutualInformation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;bool&gt; SelectFeaturesBasedOnMutualInformation (this Microsoft.ML.StaticPipe.Vector&lt;bool&gt; input, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; labelColumn, int slotsInOutput = 1000, int numBins = 256);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;bool&gt; SelectFeaturesBasedOnMutualInformation(class Microsoft.ML.StaticPipe.Vector`1&lt;bool&gt; input, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; labelColumn, int32 slotsInOutput, int32 numBins) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.MutualInformationFeatureSelectorExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Boolean},Microsoft.ML.StaticPipe.Scalar{System.Boolean},System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnMutualInformation (input As Vector(Of Boolean), labelColumn As Scalar(Of Boolean), Optional slotsInOutput As Integer = 1000, Optional numBins As Integer = 256) As Vector(Of Boolean)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnMutualInformation : Microsoft.ML.StaticPipe.Vector&lt;bool&gt; * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * int * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;bool&gt;" Usage="Microsoft.ML.Transforms.MutualInformationFeatureSelectorExtensions.SelectFeaturesBasedOnMutualInformation (input, labelColumn, slotsInOutput, numBins)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Boolean&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Boolean&gt;" RefType="this" />
          <Parameter Name="labelColumn" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="slotsInOutput" Type="System.Int32" />
          <Parameter Name="numBins" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="labelColumn">Column to use for labels.</param>
          <param name="slotsInOutput">The maximum number of slots to preserve in output.</param>
          <param name="numBins">Max number of bins for float/double columns, power of 2 recommended.</param>
          <summary>
        Selects the top k slots across all specified columns ordered by their mutual information with the label column.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.MutualInformationFeatureSelectorExtensions" Member="M:Microsoft.ML.Transforms.MutualInformationFeatureSelectorExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Boolean},Microsoft.ML.StaticPipe.Scalar{System.Boolean},System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnMutualInformation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;bool&gt; SelectFeaturesBasedOnMutualInformation (this Microsoft.ML.StaticPipe.Vector&lt;bool&gt; input, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; labelColumn, int slotsInOutput = 1000, int numBins = 256);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;bool&gt; SelectFeaturesBasedOnMutualInformation(class Microsoft.ML.StaticPipe.Vector`1&lt;bool&gt; input, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; labelColumn, int32 slotsInOutput, int32 numBins) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.MutualInformationFeatureSelectorExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Boolean},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnMutualInformation (input As Vector(Of Boolean), labelColumn As Scalar(Of Single), Optional slotsInOutput As Integer = 1000, Optional numBins As Integer = 256) As Vector(Of Boolean)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnMutualInformation : Microsoft.ML.StaticPipe.Vector&lt;bool&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * int * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;bool&gt;" Usage="Microsoft.ML.Transforms.MutualInformationFeatureSelectorExtensions.SelectFeaturesBasedOnMutualInformation (input, labelColumn, slotsInOutput, numBins)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Boolean&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Boolean&gt;" RefType="this" />
          <Parameter Name="labelColumn" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="slotsInOutput" Type="System.Int32" />
          <Parameter Name="numBins" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="labelColumn">Column to use for labels.</param>
          <param name="slotsInOutput">The maximum number of slots to preserve in output.</param>
          <param name="numBins">Max number of bins for float/double columns, power of 2 recommended.</param>
          <summary>
        Selects the top k slots across all specified columns ordered by their mutual information with the label column.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.MutualInformationFeatureSelectorExtensions" Member="M:Microsoft.ML.Transforms.MutualInformationFeatureSelectorExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Boolean},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnMutualInformation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;double&gt; SelectFeaturesBasedOnMutualInformation (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; labelColumn, int slotsInOutput = 1000, int numBins = 256);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; SelectFeaturesBasedOnMutualInformation(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; labelColumn, int32 slotsInOutput, int32 numBins) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.MutualInformationFeatureSelectorExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Double},Microsoft.ML.StaticPipe.Scalar{System.Boolean},System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnMutualInformation (input As Vector(Of Double), labelColumn As Scalar(Of Boolean), Optional slotsInOutput As Integer = 1000, Optional numBins As Integer = 256) As Vector(Of Double)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnMutualInformation : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * int * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;double&gt;" Usage="Microsoft.ML.Transforms.MutualInformationFeatureSelectorExtensions.SelectFeaturesBasedOnMutualInformation (input, labelColumn, slotsInOutput, numBins)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="labelColumn" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="slotsInOutput" Type="System.Int32" />
          <Parameter Name="numBins" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="labelColumn">Column to use for labels.</param>
          <param name="slotsInOutput">The maximum number of slots to preserve in output.</param>
          <param name="numBins">Max number of bins for float/double columns, power of 2 recommended.</param>
          <summary>
        Selects the top k slots across all specified columns ordered by their mutual information with the label column.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.MutualInformationFeatureSelectorExtensions" Member="M:Microsoft.ML.Transforms.MutualInformationFeatureSelectorExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Double},Microsoft.ML.StaticPipe.Scalar{System.Boolean},System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnMutualInformation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;double&gt; SelectFeaturesBasedOnMutualInformation (this Microsoft.ML.StaticPipe.Vector&lt;double&gt; input, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; labelColumn, int slotsInOutput = 1000, int numBins = 256);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; SelectFeaturesBasedOnMutualInformation(class Microsoft.ML.StaticPipe.Vector`1&lt;float64&gt; input, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; labelColumn, int32 slotsInOutput, int32 numBins) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.MutualInformationFeatureSelectorExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Double},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnMutualInformation (input As Vector(Of Double), labelColumn As Scalar(Of Single), Optional slotsInOutput As Integer = 1000, Optional numBins As Integer = 256) As Vector(Of Double)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnMutualInformation : Microsoft.ML.StaticPipe.Vector&lt;double&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * int * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;double&gt;" Usage="Microsoft.ML.Transforms.MutualInformationFeatureSelectorExtensions.SelectFeaturesBasedOnMutualInformation (input, labelColumn, slotsInOutput, numBins)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Double&gt;" RefType="this" />
          <Parameter Name="labelColumn" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="slotsInOutput" Type="System.Int32" />
          <Parameter Name="numBins" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="labelColumn">Column to use for labels.</param>
          <param name="slotsInOutput">The maximum number of slots to preserve in output.</param>
          <param name="numBins">Max number of bins for float/double columns, power of 2 recommended.</param>
          <summary>
        Selects the top k slots across all specified columns ordered by their mutual information with the label column.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.MutualInformationFeatureSelectorExtensions" Member="M:Microsoft.ML.Transforms.MutualInformationFeatureSelectorExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Double},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnMutualInformation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; SelectFeaturesBasedOnMutualInformation (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; labelColumn, int slotsInOutput = 1000, int numBins = 256);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; SelectFeaturesBasedOnMutualInformation(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, class Microsoft.ML.StaticPipe.Scalar`1&lt;bool&gt; labelColumn, int32 slotsInOutput, int32 numBins) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.MutualInformationFeatureSelectorExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Boolean},System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnMutualInformation (input As Vector(Of Single), labelColumn As Scalar(Of Boolean), Optional slotsInOutput As Integer = 1000, Optional numBins As Integer = 256) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnMutualInformation : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;bool&gt; * int * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Transforms.MutualInformationFeatureSelectorExtensions.SelectFeaturesBasedOnMutualInformation (input, labelColumn, slotsInOutput, numBins)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="labelColumn" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Boolean&gt;" />
          <Parameter Name="slotsInOutput" Type="System.Int32" />
          <Parameter Name="numBins" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="labelColumn">Column to use for labels.</param>
          <param name="slotsInOutput">The maximum number of slots to preserve in output.</param>
          <param name="numBins">Max number of bins for float/double columns, power of 2 recommended.</param>
          <summary>
        Selects the top k slots across all specified columns ordered by their mutual information with the label column.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.MutualInformationFeatureSelectorExtensions" Member="M:Microsoft.ML.Transforms.MutualInformationFeatureSelectorExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Boolean},System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="SelectFeaturesBasedOnMutualInformation">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; SelectFeaturesBasedOnMutualInformation (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, Microsoft.ML.StaticPipe.Scalar&lt;float&gt; labelColumn, int slotsInOutput = 1000, int numBins = 256);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; SelectFeaturesBasedOnMutualInformation(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, class Microsoft.ML.StaticPipe.Scalar`1&lt;float32&gt; labelColumn, int32 slotsInOutput, int32 numBins) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.MutualInformationFeatureSelectorExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectFeaturesBasedOnMutualInformation (input As Vector(Of Single), labelColumn As Scalar(Of Single), Optional slotsInOutput As Integer = 1000, Optional numBins As Integer = 256) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member SelectFeaturesBasedOnMutualInformation : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * Microsoft.ML.StaticPipe.Scalar&lt;single&gt; * int * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Transforms.MutualInformationFeatureSelectorExtensions.SelectFeaturesBasedOnMutualInformation (input, labelColumn, slotsInOutput, numBins)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="labelColumn" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.Single&gt;" />
          <Parameter Name="slotsInOutput" Type="System.Int32" />
          <Parameter Name="numBins" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="labelColumn">Column to use for labels.</param>
          <param name="slotsInOutput">The maximum number of slots to preserve in output.</param>
          <param name="numBins">Max number of bins for float/double columns, power of 2 recommended.</param>
          <summary>
        Selects the top k slots across all specified columns ordered by their mutual information with the label column.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.MutualInformationFeatureSelectorExtensions" Member="M:Microsoft.ML.Transforms.MutualInformationFeatureSelectorExtensions.SelectFeaturesBasedOnMutualInformation(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Int32,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ApplyTensorFlowGraph">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ApplyTensorFlowGraph (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, string modelFile);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ApplyTensorFlowGraph(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, string modelFile) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.TensorFlowStaticExtensions.ApplyTensorFlowGraph(Microsoft.ML.StaticPipe.Vector{System.Single},System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ApplyTensorFlowGraph (input As Vector(Of Single), modelFile As String) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ApplyTensorFlowGraph : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * string -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Transforms.TensorFlowStaticExtensions.ApplyTensorFlowGraph (input, modelFile)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="modelFile" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="input">To be added.</param>
          <param name="modelFile">To be added.</param>
          <summary>
            Run a TensorFlow model on the input column and extract one output column.
            The inputs and outputs are matched to TensorFlow graph nodes by name.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.TensorFlowStaticExtensions" Member="M:Microsoft.ML.Transforms.TensorFlowStaticExtensions.ApplyTensorFlowGraph(Microsoft.ML.StaticPipe.Vector{System.Single},System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="TokenizeIntoCharacters">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;ushort,string&gt;&gt; TokenizeIntoCharacters (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, bool useMarkerCharacters = true);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int16, string&gt;&gt; TokenizeIntoCharacters(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, bool useMarkerCharacters) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.Text.CharacterTokenizerExtensions.TokenizeIntoCharacters(Microsoft.ML.StaticPipe.Scalar{System.String},System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TokenizeIntoCharacters (input As Scalar(Of String), Optional useMarkerCharacters As Boolean = true) As VarVector(Of Key(Of UShort, String))" />
        <MemberSignature Language="F#" Value="static member TokenizeIntoCharacters : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * bool -&gt; Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint16, string&gt;&gt;" Usage="Microsoft.ML.Transforms.Text.CharacterTokenizerExtensions.TokenizeIntoCharacters (input, useMarkerCharacters)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt16,System.String&gt;&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="useMarkerCharacters" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="useMarkerCharacters">Whether to use marker characters to separate words.</param>
          <summary>
            Tokenize incoming text into a sequence of characters.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.Text.CharacterTokenizerExtensions" Member="M:Microsoft.ML.Transforms.Text.CharacterTokenizerExtensions.TokenizeIntoCharacters(Microsoft.ML.StaticPipe.Scalar{System.String},System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ToLdaTopicVector">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToLdaTopicVector (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, int numTopic = 100, Action&lt;Microsoft.ML.Runtime.TextAnalytics.LdaTransform.Arguments&gt; advancedSettings = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToLdaTopicVector(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, int32 numTopic, class System.Action`1&lt;class Microsoft.ML.Runtime.TextAnalytics.LdaTransform/Arguments&gt; advancedSettings) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.Text.LdaEstimatorExtensions.ToLdaTopicVector(Microsoft.ML.StaticPipe.Vector{System.Single},System.Int32,System.Action{Microsoft.ML.Runtime.TextAnalytics.LdaTransform.Arguments})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLdaTopicVector (input As Vector(Of Single), Optional numTopic As Integer = 100, Optional advancedSettings As Action(Of LdaTransform.Arguments) = null) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToLdaTopicVector : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * int * Action&lt;Microsoft.ML.Runtime.TextAnalytics.LdaTransform.Arguments&gt; -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Transforms.Text.LdaEstimatorExtensions.ToLdaTopicVector (input, numTopic, advancedSettings)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="numTopic" Type="System.Int32" />
          <Parameter Name="advancedSettings" Type="System.Action&lt;Microsoft.ML.Runtime.TextAnalytics.LdaTransform+Arguments&gt;" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="numTopic">The number of topics in the LDA.</param>
          <param name="advancedSettings">A delegate to apply all the advanced arguments to the algorithm.</param>
          <summary>
        The LDA transform implements LightLDA, a state-of-the-art implementation of Latent Dirichlet Allocation.
      </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.Text.LdaEstimatorExtensions" Member="M:Microsoft.ML.Transforms.Text.LdaEstimatorExtensions.ToLdaTopicVector(Microsoft.ML.StaticPipe.Vector{System.Single},System.Int32,System.Action{Microsoft.ML.Runtime.TextAnalytics.LdaTransform.Arguments})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToNgrams">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToNgrams (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,string&gt;&gt; input, int ngramLength = 1, int skipLength = 0, bool allLengths = true, int maxNumTerms = 10000000, Microsoft.ML.Runtime.Data.NgramTransform.WeightingCriteria weighting = Microsoft.ML.Runtime.Data.NgramTransform+WeightingCriteria.Tf);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToNgrams(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, string&gt;&gt; input, int32 ngramLength, int32 skipLength, bool allLengths, int32 maxNumTerms, valuetype Microsoft.ML.Runtime.Data.NgramTransform/WeightingCriteria weighting) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.Text.NgramEstimatorExtensions.ToNgrams(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{System.UInt32,System.String}},System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Runtime.Data.NgramTransform.WeightingCriteria)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToNgrams (input As VarVector(Of Key(Of UInteger, String)), Optional ngramLength As Integer = 1, Optional skipLength As Integer = 0, Optional allLengths As Boolean = true, Optional maxNumTerms As Integer = 10000000, Optional weighting As NgramTransform.WeightingCriteria = Microsoft.ML.Runtime.Data.NgramTransform+WeightingCriteria.Tf) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToNgrams : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, string&gt;&gt; * int * int * bool * int * Microsoft.ML.Runtime.Data.NgramTransform.WeightingCriteria -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Transforms.Text.NgramEstimatorExtensions.ToNgrams (input, ngramLength, skipLength, allLengths, maxNumTerms, weighting)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.String&gt;&gt;" RefType="this" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="allLengths" Type="System.Boolean" />
          <Parameter Name="maxNumTerms" Type="System.Int32" />
          <Parameter Name="weighting" Type="Microsoft.ML.Runtime.Data.NgramTransform+WeightingCriteria" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="allLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="maxNumTerms">Maximum number of ngrams to store in the dictionary.</param>
          <param name="weighting">Statistical measure used to evaluate how important a word is to a document in a corpus.</param>
          <summary>
             Produces a bag of counts of ngrams (sequences of consecutive words ) in a given tokenized text.
             It does so by building a dictionary of ngrams and using the id in the dictionary as the index in the bag.
            
             /// <see cref="M:Microsoft.ML.Transforms.Text.NgramEstimatorExtensions.ToNgrams(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{System.UInt32,System.String}},System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Runtime.Data.NgramTransform.WeightingCriteria)" /> is different from <see cref="M:Microsoft.ML.Transforms.Text.WordBagEstimatorExtensions.ToBagofWords(Microsoft.ML.StaticPipe.Scalar{System.String},System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Runtime.Data.NgramTransform.WeightingCriteria)" />
             in a way that <see cref="M:Microsoft.ML.Transforms.Text.NgramEstimatorExtensions.ToNgrams(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{System.UInt32,System.String}},System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Runtime.Data.NgramTransform.WeightingCriteria)" /> takes tokenized text as input while <see cref="M:Microsoft.ML.Transforms.Text.WordBagEstimatorExtensions.ToBagofWords(Microsoft.ML.StaticPipe.Scalar{System.String},System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Runtime.Data.NgramTransform.WeightingCriteria)" /> tokenizes text internally.
             </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.Text.NgramEstimatorExtensions" Member="M:Microsoft.ML.Transforms.Text.NgramEstimatorExtensions.ToNgrams(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{System.UInt32,System.String}},System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Runtime.Data.NgramTransform.WeightingCriteria)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="ToNgramsHash">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToNgramsHash (this Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint,string&gt;&gt; input, int hashBits = 16, int ngramLength = 2, int skipLength = 0, bool allLengths = true, uint seed = 314489979, bool ordered = true, int invertHash = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToNgramsHash(class Microsoft.ML.StaticPipe.VarVector`1&lt;class Microsoft.ML.StaticPipe.Key`2&lt;unsigned int32, string&gt;&gt; input, int32 hashBits, int32 ngramLength, int32 skipLength, bool allLengths, unsigned int32 seed, bool ordered, int32 invertHash) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.Text.NgramHashEstimatorExtensions.ToNgramsHash(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{System.UInt32,System.String}},System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToNgramsHash (input As VarVector(Of Key(Of UInteger, String)), Optional hashBits As Integer = 16, Optional ngramLength As Integer = 2, Optional skipLength As Integer = 0, Optional allLengths As Boolean = true, Optional seed As UInteger = 314489979, Optional ordered As Boolean = true, Optional invertHash As Integer = 0) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToNgramsHash : Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;uint32, string&gt;&gt; * int * int * int * bool * uint32 * bool * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Transforms.Text.NgramHashEstimatorExtensions.ToNgramsHash (input, hashBits, ngramLength, skipLength, allLengths, seed, ordered, invertHash)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;Microsoft.ML.StaticPipe.Key&lt;System.UInt32,System.String&gt;&gt;" RefType="this" />
          <Parameter Name="hashBits" Type="System.Int32" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="allLengths" Type="System.Boolean" />
          <Parameter Name="seed" Type="System.UInt32" />
          <Parameter Name="ordered" Type="System.Boolean" />
          <Parameter Name="invertHash" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="hashBits">Number of bits to hash into. Must be between 1 and 30, inclusive.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="allLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="seed">Hashing seed.</param>
          <param name="ordered">Whether the position of each source column should be included in the hash (when there are multiple source columns).</param>
          <param name="invertHash">Limit the number of keys used to generate the slot name to this many. 0 means no invert hashing, -1 means no limit.</param>
          <summary>
             Produces a bag of counts of ngrams (sequences of consecutive words of length 1-n) in a given tokenized text.
             It does so by hashing each ngram and using the hash value as the index in the bag.
            
             <see cref="M:Microsoft.ML.Transforms.Text.NgramHashEstimatorExtensions.ToNgramsHash(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{System.UInt32,System.String}},System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" /> is different from <see cref="M:Microsoft.ML.Transforms.Text.WordHashBagEstimatorExtensions.ToBagofHashedWords(Microsoft.ML.StaticPipe.Scalar{System.String},System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
             in a way that <see cref="M:Microsoft.ML.Transforms.Text.NgramHashEstimatorExtensions.ToNgramsHash(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{System.UInt32,System.String}},System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" /> takes tokenized text as input while <see cref="M:Microsoft.ML.Transforms.Text.WordHashBagEstimatorExtensions.ToBagofHashedWords(Microsoft.ML.StaticPipe.Scalar{System.String},System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" /> tokenizes text internally.
             </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.Text.NgramHashEstimatorExtensions" Member="M:Microsoft.ML.Transforms.Text.NgramHashEstimatorExtensions.ToNgramsHash(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{System.UInt32,System.String}},System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.VarVector`1" />
      </Targets>
      <Member MemberName="RemoveStopwords">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;string&gt; RemoveStopwords (this Microsoft.ML.StaticPipe.VarVector&lt;string&gt; input, Microsoft.ML.Runtime.TextAnalytics.StopWordsRemoverTransform.Language language = Microsoft.ML.Runtime.TextAnalytics.StopWordsRemoverTransform+Language.English);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;string&gt; RemoveStopwords(class Microsoft.ML.StaticPipe.VarVector`1&lt;string&gt; input, valuetype Microsoft.ML.Runtime.TextAnalytics.StopWordsRemoverTransform/Language language) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.Text.StopwordRemoverExtensions.RemoveStopwords(Microsoft.ML.StaticPipe.VarVector{System.String},Microsoft.ML.Runtime.TextAnalytics.StopWordsRemoverTransform.Language)" />
        <MemberSignature Language="F#" Value="static member RemoveStopwords : Microsoft.ML.StaticPipe.VarVector&lt;string&gt; * Microsoft.ML.Runtime.TextAnalytics.StopWordsRemoverTransform.Language -&gt; Microsoft.ML.StaticPipe.VarVector&lt;string&gt;" Usage="Microsoft.ML.Transforms.Text.StopwordRemoverExtensions.RemoveStopwords (input, language)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.String&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.VarVector&lt;System.String&gt;" RefType="this" />
          <Parameter Name="language" Type="Microsoft.ML.Runtime.TextAnalytics.StopWordsRemoverTransform+Language" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="language">Langauge of the input text.</param>
          <summary>
            Remove stop words from incoming text.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.Text.StopwordRemoverExtensions" Member="M:Microsoft.ML.Transforms.Text.StopwordRemoverExtensions.RemoveStopwords(Microsoft.ML.StaticPipe.VarVector{System.String},Microsoft.ML.Runtime.TextAnalytics.StopWordsRemoverTransform.Language)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="NormalizeText">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Scalar&lt;string&gt; NormalizeText (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, Microsoft.ML.Runtime.TextAnalytics.TextNormalizerTransform.CaseNormalizationMode textCase = Microsoft.ML.Runtime.TextAnalytics.TextNormalizerTransform+CaseNormalizationMode.Lower, bool keepDiacritics = false, bool keepPunctuations = true, bool keepNumbers = true);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; NormalizeText(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, valuetype Microsoft.ML.Runtime.TextAnalytics.TextNormalizerTransform/CaseNormalizationMode textCase, bool keepDiacritics, bool keepPunctuations, bool keepNumbers) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.Text.TextNormalizerExtensions.NormalizeText(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.Runtime.TextAnalytics.TextNormalizerTransform.CaseNormalizationMode,System.Boolean,System.Boolean,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeText (input As Scalar(Of String), Optional textCase As TextNormalizerTransform.CaseNormalizationMode = Microsoft.ML.Runtime.TextAnalytics.TextNormalizerTransform+CaseNormalizationMode.Lower, Optional keepDiacritics As Boolean = false, Optional keepPunctuations As Boolean = true, Optional keepNumbers As Boolean = true) As Scalar(Of String)" />
        <MemberSignature Language="F#" Value="static member NormalizeText : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * Microsoft.ML.Runtime.TextAnalytics.TextNormalizerTransform.CaseNormalizationMode * bool * bool * bool -&gt; Microsoft.ML.StaticPipe.Scalar&lt;string&gt;" Usage="Microsoft.ML.Transforms.Text.TextNormalizerExtensions.NormalizeText (input, textCase, keepDiacritics, keepPunctuations, keepNumbers)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="textCase" Type="Microsoft.ML.Runtime.TextAnalytics.TextNormalizerTransform+CaseNormalizationMode" />
          <Parameter Name="keepDiacritics" Type="System.Boolean" />
          <Parameter Name="keepPunctuations" Type="System.Boolean" />
          <Parameter Name="keepNumbers" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="textCase">Casing text using the rules of the invariant culture.</param>
          <param name="keepDiacritics">Whether to keep diacritical marks or remove them.</param>
          <param name="keepPunctuations">Whether to keep punctuation marks or remove them.</param>
          <param name="keepNumbers">Whether to keep numbers or remove them.</param>
          <summary>
            Normalizes input text by changing case, removing diacritical marks, punctuation marks and/or numbers.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.Text.TextNormalizerExtensions" Member="M:Microsoft.ML.Transforms.Text.TextNormalizerExtensions.NormalizeText(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.Runtime.TextAnalytics.TextNormalizerTransform.CaseNormalizationMode,System.Boolean,System.Boolean,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToBagofWords">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBagofWords (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, int ngramLength = 1, int skipLength = 0, bool allLengths = true, int maxNumTerms = 10000000, Microsoft.ML.Runtime.Data.NgramTransform.WeightingCriteria weighting = Microsoft.ML.Runtime.Data.NgramTransform+WeightingCriteria.Tf);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBagofWords(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, int32 ngramLength, int32 skipLength, bool allLengths, int32 maxNumTerms, valuetype Microsoft.ML.Runtime.Data.NgramTransform/WeightingCriteria weighting) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.Text.WordBagEstimatorExtensions.ToBagofWords(Microsoft.ML.StaticPipe.Scalar{System.String},System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Runtime.Data.NgramTransform.WeightingCriteria)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBagofWords (input As Scalar(Of String), Optional ngramLength As Integer = 1, Optional skipLength As Integer = 0, Optional allLengths As Boolean = true, Optional maxNumTerms As Integer = 10000000, Optional weighting As NgramTransform.WeightingCriteria = Microsoft.ML.Runtime.Data.NgramTransform+WeightingCriteria.Tf) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBagofWords : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * int * int * bool * int * Microsoft.ML.Runtime.Data.NgramTransform.WeightingCriteria -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Transforms.Text.WordBagEstimatorExtensions.ToBagofWords (input, ngramLength, skipLength, allLengths, maxNumTerms, weighting)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="allLengths" Type="System.Boolean" />
          <Parameter Name="maxNumTerms" Type="System.Int32" />
          <Parameter Name="weighting" Type="Microsoft.ML.Runtime.Data.NgramTransform+WeightingCriteria" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="allLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="maxNumTerms">Maximum number of ngrams to store in the dictionary.</param>
          <param name="weighting">Statistical measure used to evaluate how important a word is to a document in a corpus.</param>
          <summary>
            Produces a bag of counts of ngrams (sequences of consecutive words ) in a given text.
            It does so by building a dictionary of ngrams and using the id in the dictionary as the index in the bag.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.Text.WordBagEstimatorExtensions" Member="M:Microsoft.ML.Transforms.Text.WordBagEstimatorExtensions.ToBagofWords(Microsoft.ML.StaticPipe.Scalar{System.String},System.Int32,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Runtime.Data.NgramTransform.WeightingCriteria)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="ToBagofHashedWords">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ToBagofHashedWords (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, int hashBits = 16, int ngramLength = 1, int skipLength = 0, bool allLengths = true, uint seed = 314489979, bool ordered = true, int invertHash = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ToBagofHashedWords(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, int32 hashBits, int32 ngramLength, int32 skipLength, bool allLengths, unsigned int32 seed, bool ordered, int32 invertHash) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.Text.WordHashBagEstimatorExtensions.ToBagofHashedWords(Microsoft.ML.StaticPipe.Scalar{System.String},System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToBagofHashedWords (input As Scalar(Of String), Optional hashBits As Integer = 16, Optional ngramLength As Integer = 1, Optional skipLength As Integer = 0, Optional allLengths As Boolean = true, Optional seed As UInteger = 314489979, Optional ordered As Boolean = true, Optional invertHash As Integer = 0) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ToBagofHashedWords : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * int * int * int * bool * uint32 * bool * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Transforms.Text.WordHashBagEstimatorExtensions.ToBagofHashedWords (input, hashBits, ngramLength, skipLength, allLengths, seed, ordered, invertHash)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="hashBits" Type="System.Int32" />
          <Parameter Name="ngramLength" Type="System.Int32" />
          <Parameter Name="skipLength" Type="System.Int32" />
          <Parameter Name="allLengths" Type="System.Boolean" />
          <Parameter Name="seed" Type="System.UInt32" />
          <Parameter Name="ordered" Type="System.Boolean" />
          <Parameter Name="invertHash" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="hashBits">Number of bits to hash into. Must be between 1 and 30, inclusive.</param>
          <param name="ngramLength">Ngram length.</param>
          <param name="skipLength">Maximum number of tokens to skip when constructing an ngram.</param>
          <param name="allLengths">Whether to include all ngram lengths up to <paramref name="ngramLength" /> or only <paramref name="ngramLength" />.</param>
          <param name="seed">Hashing seed.</param>
          <param name="ordered">Whether the position of each source column should be included in the hash (when there are multiple source columns).</param>
          <param name="invertHash">Limit the number of keys used to generate the slot name to this many. 0 means no invert hashing, -1 means no limit.</param>
          <summary>
            Produces a bag of counts of ngrams (sequences of consecutive words of length 1-n) in a given text.
            It does so by hashing each ngram and using the hash value as the index in the bag.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.Text.WordHashBagEstimatorExtensions" Member="M:Microsoft.ML.Transforms.Text.WordHashBagEstimatorExtensions.ToBagofHashedWords(Microsoft.ML.StaticPipe.Scalar{System.String},System.Int32,System.Int32,System.Int32,System.Boolean,System.UInt32,System.Boolean,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Scalar`1" />
      </Targets>
      <Member MemberName="TokenizeText">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.VarVector&lt;string&gt; TokenizeText (this Microsoft.ML.StaticPipe.Scalar&lt;string&gt; input, string separators = &quot;space&quot;);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.VarVector`1&lt;string&gt; TokenizeText(class Microsoft.ML.StaticPipe.Scalar`1&lt;string&gt; input, string separators) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.Text.WordTokenizerExtensions.TokenizeText(Microsoft.ML.StaticPipe.Scalar{System.String},System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TokenizeText (input As Scalar(Of String), Optional separators As String = &quot;space&quot;) As VarVector(Of String)" />
        <MemberSignature Language="F#" Value="static member TokenizeText : Microsoft.ML.StaticPipe.Scalar&lt;string&gt; * string -&gt; Microsoft.ML.StaticPipe.VarVector&lt;string&gt;" Usage="Microsoft.ML.Transforms.Text.WordTokenizerExtensions.TokenizeText (input, separators)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.VarVector&lt;System.String&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Scalar&lt;System.String&gt;" RefType="this" />
          <Parameter Name="separators" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="separators">The separators to use (comma separated).</param>
          <summary>
            Tokenize incoming text using <paramref name="separators" /> and output the tokens.
            </summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.Text.WordTokenizerExtensions" Member="M:Microsoft.ML.Transforms.Text.WordTokenizerExtensions.TokenizeText(Microsoft.ML.StaticPipe.Scalar{System.String},System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="PcaWhitening">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; PcaWhitening (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, float eps = 1E-05, int maxRows = 100000, bool saveInverse = false, int pcaNum = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; PcaWhitening(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, float32 eps, int32 maxRows, bool saveInverse, int32 pcaNum) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.WhiteningExtensions.PcaWhitening(Microsoft.ML.StaticPipe.Vector{System.Single},System.Single,System.Int32,System.Boolean,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function PcaWhitening (input As Vector(Of Single), Optional eps As Single = 1E-05, Optional maxRows As Integer = 100000, Optional saveInverse As Boolean = false, Optional pcaNum As Integer = 0) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member PcaWhitening : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * single * int * bool * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Transforms.WhiteningExtensions.PcaWhitening (input, eps, maxRows, saveInverse, pcaNum)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="eps" Type="System.Single" />
          <Parameter Name="maxRows" Type="System.Int32" />
          <Parameter Name="saveInverse" Type="System.Boolean" />
          <Parameter Name="pcaNum" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="eps">Scaling regularizer.</param>
          <param name="maxRows">Max number of rows.</param>
          <param name="saveInverse">Whether to save inverse (recovery) matrix.</param>
          <param name="pcaNum">PCA components to retain.</param>
          <summary>
        Implements PCA (Principal Component Analysis) and ZCA (Zero phase Component Analysis) whitening.
        The whitening process consists of 2 steps:
            1. Decorrelation of the input data. Input data is assumed to have zero mean.
            2. Rescale decorrelated features to have unit variance.
        That is, PCA whitening is essentially just a PCA + rescale.
        ZCA whitening tries to make resulting data to look more like input data by rotating it back to the
        original input space.
        More information: <a href="http://ufldl.stanford.edu/wiki/index.php/Whitening">http://ufldl.stanford.edu/wiki/index.php/Whitening</a></summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.WhiteningExtensions" Member="M:Microsoft.ML.Transforms.WhiteningExtensions.PcaWhitening(Microsoft.ML.StaticPipe.Vector{System.Single},System.Single,System.Int32,System.Boolean,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.ML.StaticPipe.Vector`1" />
      </Targets>
      <Member MemberName="ZcaWhitening">
        <MemberSignature Language="C#" Value="public static Microsoft.ML.StaticPipe.Vector&lt;float&gt; ZcaWhitening (this Microsoft.ML.StaticPipe.Vector&lt;float&gt; input, float eps = 1E-05, int maxRows = 100000, bool saveInverse = false, int pcaNum = 0);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; ZcaWhitening(class Microsoft.ML.StaticPipe.Vector`1&lt;float32&gt; input, float32 eps, int32 maxRows, bool saveInverse, int32 pcaNum) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.ML.Transforms.WhiteningExtensions.ZcaWhitening(Microsoft.ML.StaticPipe.Vector{System.Single},System.Single,System.Int32,System.Boolean,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ZcaWhitening (input As Vector(Of Single), Optional eps As Single = 1E-05, Optional maxRows As Integer = 100000, Optional saveInverse As Boolean = false, Optional pcaNum As Integer = 0) As Vector(Of Single)" />
        <MemberSignature Language="F#" Value="static member ZcaWhitening : Microsoft.ML.StaticPipe.Vector&lt;single&gt; * single * int * bool * int -&gt; Microsoft.ML.StaticPipe.Vector&lt;single&gt;" Usage="Microsoft.ML.Transforms.WhiteningExtensions.ZcaWhitening (input, eps, maxRows, saveInverse, pcaNum)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="input" Type="Microsoft.ML.StaticPipe.Vector&lt;System.Single&gt;" RefType="this" />
          <Parameter Name="eps" Type="System.Single" />
          <Parameter Name="maxRows" Type="System.Int32" />
          <Parameter Name="saveInverse" Type="System.Boolean" />
          <Parameter Name="pcaNum" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="input">The column to apply to.</param>
          <param name="eps">Scaling regularizer.</param>
          <param name="maxRows">Max number of rows.</param>
          <param name="saveInverse">Whether to save inverse (recovery) matrix.</param>
          <param name="pcaNum">PCA components to retain.</param>
          <summary>
        Implements PCA (Principal Component Analysis) and ZCA (Zero phase Component Analysis) whitening.
        The whitening process consists of 2 steps:
            1. Decorrelation of the input data. Input data is assumed to have zero mean.
            2. Rescale decorrelated features to have unit variance.
        That is, PCA whitening is essentially just a PCA + rescale.
        ZCA whitening tries to make resulting data to look more like input data by rotating it back to the
        original input space.
        More information: <a href="http://ufldl.stanford.edu/wiki/index.php/Whitening">http://ufldl.stanford.edu/wiki/index.php/Whitening</a></summary>
        </Docs>
        <Link Type="Microsoft.ML.Transforms.WhiteningExtensions" Member="M:Microsoft.ML.Transforms.WhiteningExtensions.ZcaWhitening(Microsoft.ML.StaticPipe.Vector{System.Single},System.Single,System.Int32,System.Boolean,System.Int32)" />
      </Member>
    </ExtensionMethod>
  </ExtensionMethods>
</Overview>
