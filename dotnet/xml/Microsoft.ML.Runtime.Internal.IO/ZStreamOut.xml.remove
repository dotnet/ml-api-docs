<Type Name="ZStreamOut" FullName="Microsoft.ML.Runtime.Internal.IO.ZStreamOut">
  <TypeSignature Language="C#" Value="public class ZStreamOut" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ZStreamOut extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.ML.Runtime.Internal.IO.ZStreamOut" />
  <TypeSignature Language="VB.NET" Value="Public Class ZStreamOut" />
  <TypeSignature Language="F#" Value="type ZStreamOut = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.ML.InternalStreams</AssemblyName>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
            Class to create output Streams given file paths.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AllowLibraryFallback">
      <MemberSignature Language="C#" Value="public static bool AllowLibraryFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowLibraryFallback" />
      <MemberSignature Language="DocId" Value="P:Microsoft.ML.Runtime.Internal.IO.ZStreamOut.AllowLibraryFallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property AllowLibraryFallback As Boolean" />
      <MemberSignature Language="F#" Value="member this.AllowLibraryFallback : bool with get, set" Usage="Microsoft.ML.Runtime.Internal.IO.ZStreamOut.AllowLibraryFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.InternalStreams</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Get whether to allow fallback to the compression library if executables
            are not found in the path. false by default. Using the fallback may result in
            slower performance and larger files. This setting is shared with ZStreamIn,
            ZStreamOut, ZStreamReader, and ZStreamWriter.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BreakChunksAtLines">
      <MemberSignature Language="C#" Value="public static bool BreakChunksAtLines { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool BreakChunksAtLines" />
      <MemberSignature Language="DocId" Value="P:Microsoft.ML.Runtime.Internal.IO.ZStreamOut.BreakChunksAtLines" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BreakChunksAtLines As Boolean" />
      <MemberSignature Language="F#" Value="member this.BreakChunksAtLines : bool with get, set" Usage="Microsoft.ML.Runtime.Internal.IO.ZStreamOut.BreakChunksAtLines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.InternalStreams</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Get or set whether to break at line boundaries when using chunked streams.
            False by default.
            </summary>
        <value>To be added.</value>
        <remarks>
            This will not necessarily have any effect. Most streams have no concept of chunks.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompressionArchiveExtensions">
      <MemberSignature Language="C#" Value="public static string[] CompressionArchiveExtensions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string[] CompressionArchiveExtensions" />
      <MemberSignature Language="DocId" Value="P:Microsoft.ML.Runtime.Internal.IO.ZStreamOut.CompressionArchiveExtensions" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompressionArchiveExtensions As String()" />
      <MemberSignature Language="F#" Value="member this.CompressionArchiveExtensions : string[]" Usage="Microsoft.ML.Runtime.Internal.IO.ZStreamOut.CompressionArchiveExtensions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.InternalStreams</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the set of extensions (such as ".7z") that are accepted for multi-file
            archive compression.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompressionExtensions">
      <MemberSignature Language="C#" Value="public static string[] CompressionExtensions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string[] CompressionExtensions" />
      <MemberSignature Language="DocId" Value="P:Microsoft.ML.Runtime.Internal.IO.ZStreamOut.CompressionExtensions" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompressionExtensions As String()" />
      <MemberSignature Language="F#" Value="member this.CompressionExtensions : string[]" Usage="Microsoft.ML.Runtime.Internal.IO.ZStreamOut.CompressionExtensions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.InternalStreams</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the set of extensions (such as ".gz") that are accepted for compression.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompressionLevel">
      <MemberSignature Language="C#" Value="public static int CompressionLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CompressionLevel" />
      <MemberSignature Language="DocId" Value="P:Microsoft.ML.Runtime.Internal.IO.ZStreamOut.CompressionLevel" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CompressionLevel As Integer" />
      <MemberSignature Language="F#" Value="member this.CompressionLevel : int with get, set" Usage="Microsoft.ML.Runtime.Internal.IO.ZStreamOut.CompressionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.InternalStreams</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Get or set the compression level (0 - 9) used for compressed streams.
            </summary>
        <value>To be added.</value>
        <remarks>
          <p>
            The default is 1, which is the worst (but fastest) compression.
            Setting a higher level can significantly improve the compression ratio,
            especially for tighter compression methods (such as 7z), but the time
            needed will increase.
            </p>
          <p>
            If file size is a problem, raising this value can help.
            </p>
          <p>
            A setting of 0 represents storing without compression for methods that
            support this.
            </p>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultLowFragmentation">
      <MemberSignature Language="C#" Value="public static bool DefaultLowFragmentation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool DefaultLowFragmentation" />
      <MemberSignature Language="DocId" Value="P:Microsoft.ML.Runtime.Internal.IO.ZStreamOut.DefaultLowFragmentation" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultLowFragmentation As Boolean" />
      <MemberSignature Language="F#" Value="member this.DefaultLowFragmentation : bool with get, set" Usage="Microsoft.ML.Runtime.Internal.IO.ZStreamOut.DefaultLowFragmentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.InternalStreams</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Get or set whether the Open method should use a LowFragmentationStream for files.
            true, by default.
            </summary>
        <value>To be added.</value>
        <remarks>
            The <see cref="T:Microsoft.ML.Runtime.Internal.IO.LowFragmentationStream" /> has strong advantages, increasing write
            speed and decreasing fragmentation.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Stream Open (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream Open(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.IO.ZStreamOut.Open(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (fileName As String) As Stream" />
      <MemberSignature Language="F#" Value="static member Open : string -&gt; System.IO.Stream" Usage="Microsoft.ML.Runtime.Internal.IO.ZStreamOut.Open fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.InternalStreams</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Stream Open (string fileName, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream Open(string fileName, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.IO.ZStreamOut.Open(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (fileName As String, append As Boolean) As Stream" />
      <MemberSignature Language="F#" Value="static member Open : string * bool -&gt; System.IO.Stream" Usage="Microsoft.ML.Runtime.Internal.IO.ZStreamOut.Open (fileName, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.InternalStreams</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">To be added.</param>
        <param name="append">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Stream Open (string fileName, bool append, bool breakChunksAtLines);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream Open(string fileName, bool append, bool breakChunksAtLines) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.IO.ZStreamOut.Open(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (fileName As String, append As Boolean, breakChunksAtLines As Boolean) As Stream" />
      <MemberSignature Language="F#" Value="static member Open : string * bool * bool -&gt; System.IO.Stream" Usage="Microsoft.ML.Runtime.Internal.IO.ZStreamOut.Open (fileName, append, breakChunksAtLines)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.InternalStreams</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="breakChunksAtLines" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">To be added.</param>
        <param name="append">To be added.</param>
        <param name="breakChunksAtLines">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Stream Open (string fileName, bool append, out string pathFull);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream Open(string fileName, bool append, [out] string&amp; pathFull) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.IO.ZStreamOut.Open(System.String,System.Boolean,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (fileName As String, append As Boolean, ByRef pathFull As String) As Stream" />
      <MemberSignature Language="F#" Value="static member Open : string * bool *  -&gt; System.IO.Stream" Usage="Microsoft.ML.Runtime.Internal.IO.ZStreamOut.Open (fileName, append, pathFull)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.InternalStreams</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="pathFull" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="fileName">To be added.</param>
        <param name="append">To be added.</param>
        <param name="pathFull">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Stream Open (string fileName, bool append, bool breakChunksAtLines, out string pathFull);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream Open(string fileName, bool append, bool breakChunksAtLines, [out] string&amp; pathFull) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.IO.ZStreamOut.Open(System.String,System.Boolean,System.Boolean,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (fileName As String, append As Boolean, breakChunksAtLines As Boolean, ByRef pathFull As String) As Stream" />
      <MemberSignature Language="F#" Value="static member Open : string * bool * bool *  -&gt; System.IO.Stream" Usage="Microsoft.ML.Runtime.Internal.IO.ZStreamOut.Open (fileName, append, breakChunksAtLines, pathFull)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.InternalStreams</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="breakChunksAtLines" Type="System.Boolean" />
        <Parameter Name="pathFull" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="fileName">To be added.</param>
        <param name="append">To be added.</param>
        <param name="breakChunksAtLines">To be added.</param>
        <param name="pathFull">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenUnbuffered">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenUnbuffered (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenUnbuffered(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.IO.ZStreamOut.OpenUnbuffered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenUnbuffered (fileName As String) As Stream" />
      <MemberSignature Language="F#" Value="static member OpenUnbuffered : string -&gt; System.IO.Stream" Usage="Microsoft.ML.Runtime.Internal.IO.ZStreamOut.OpenUnbuffered fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.InternalStreams</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">file to write to</param>
        <summary>
            Open the given file (unbuffered, if possible).
            </summary>
        <returns>A Stream for the file</returns>
        <remarks>
          <para>
            Unbuffered I/O can give better performance, especially on fast RAID arrays.
            It does not use the system file cache. However, for writing, this currently
            has no effect.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenUnbuffered">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenUnbuffered (string fileName, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenUnbuffered(string fileName, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.IO.ZStreamOut.OpenUnbuffered(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenUnbuffered (fileName As String, append As Boolean) As Stream" />
      <MemberSignature Language="F#" Value="static member OpenUnbuffered : string * bool -&gt; System.IO.Stream" Usage="Microsoft.ML.Runtime.Internal.IO.ZStreamOut.OpenUnbuffered (fileName, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.InternalStreams</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">file to write to</param>
        <param name="append">if true, append; if false, overwrite</param>
        <summary>
            Open the given file (unbuffered, if possible).
            </summary>
        <returns>A Stream for the file</returns>
        <remarks>
          <para>
            Unbuffered I/O can give better performance, especially on fast RAID arrays.
            It does not use the system file cache. However, for writing, this currently
            has no effect.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenUnbuffered">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenUnbuffered (string fileName, bool append, bool breakChunksAtLines);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenUnbuffered(string fileName, bool append, bool breakChunksAtLines) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.ML.Runtime.Internal.IO.ZStreamOut.OpenUnbuffered(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenUnbuffered (fileName As String, append As Boolean, breakChunksAtLines As Boolean) As Stream" />
      <MemberSignature Language="F#" Value="static member OpenUnbuffered : string * bool * bool -&gt; System.IO.Stream" Usage="Microsoft.ML.Runtime.Internal.IO.ZStreamOut.OpenUnbuffered (fileName, append, breakChunksAtLines)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.InternalStreams</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="breakChunksAtLines" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">file to write to</param>
        <param name="append">if true, append; if false, overwrite</param>
        <param name="breakChunksAtLines">if true, break at line boundaries when using chunked streams</param>
        <summary>
            Open the given file (unbuffered, if possible).
            </summary>
        <returns>A Stream for the file</returns>
        <remarks>
          <para>
            Unbuffered I/O can give better performance, especially on fast RAID arrays.
            It does not use the system file cache. However, for writing, this currently
            has no effect.
            </para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
