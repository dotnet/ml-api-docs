<Type Name="NodeProto" FullName="LotusIR.NodeProto">
  <TypeSignature Language="C#" Value="public sealed class NodeProto : Google.Protobuf.IDeepCloneable&lt;LotusIR.NodeProto&gt;, Google.Protobuf.IMessage&lt;LotusIR.NodeProto&gt;, IEquatable&lt;LotusIR.NodeProto&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit NodeProto extends System.Object implements class Google.Protobuf.IDeepCloneable`1&lt;class LotusIR.NodeProto&gt;, class Google.Protobuf.IMessage, class Google.Protobuf.IMessage`1&lt;class LotusIR.NodeProto&gt;, class System.IEquatable`1&lt;class LotusIR.NodeProto&gt;" />
  <TypeSignature Language="DocId" Value="T:LotusIR.NodeProto" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class NodeProto&#xA;Implements IDeepCloneable(Of NodeProto), IEquatable(Of NodeProto), IMessage(Of NodeProto)" />
  <TypeSignature Language="F#" Value="type NodeProto = class&#xA;    interface IMessage&lt;NodeProto&gt;&#xA;    interface IMessage&#xA;    interface IEquatable&lt;NodeProto&gt;&#xA;    interface IDeepCloneable&lt;NodeProto&gt;" />
  <TypeSignature Language="C++ CLI" Value="public ref class NodeProto sealed : Google::Protobuf::IDeepCloneable&lt;LotusIR::NodeProto ^&gt;, Google::Protobuf::IMessage&lt;LotusIR::NodeProto ^&gt;, IEquatable&lt;LotusIR::NodeProto ^&gt;" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Google.Protobuf.IDeepCloneable&lt;LotusIR.NodeProto&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Google.Protobuf.IMessage&lt;LotusIR.NodeProto&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;LotusIR.NodeProto&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
             Defines a node in a computation graph. Each graph node is either an
             operator or a function call. A node that is similar to the notion of "layer"
             or "operator" in many deep learning frameworks. For example, it can be a
             node of type "Conv" that takes in an image, a filter tensor and a bias
             tensor, and produces the convolved output.
            
             NOTE: Control flow is defined by two built-in operators:
            
             Cond(p, true_input, false_input) takes three inputs, where p is a
             boolean scalar tensor, true_input is the list of inputs to the true
             branch of cond, and false_input is the list of inputs to the false
             branch of cond. The true and false branches are defined as 
             functions that takes true_input and false_input as inputs respectively.
             The two functions must have the same number of outputs, and each
             corresponding output must have the same types, and have compatible
             shapes.
            
             While(vars, consts) takes two inputs, where vars are the initial
             values of the loop variables and consts are the values of constants
             used inside the loop. The loop condition and loop body are defined
             as functions. The functions take both vars and consts as inputs.
             The loop condition function returns a boolean scalar tensor. The
             loop body function has the form: body(vars, consts) = new_vars,
             where new_vars are the new values of the loop variables after one
             iteration so must match vars in terms of types and shapes.
             </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NodeProto ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:LotusIR.NodeProto.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NodeProto();" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; NodeProto();" />
      <MemberSignature Language="C++ WINRT" Value=" NodeProto();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NodeProto (LotusIR.NodeProto other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class LotusIR.NodeProto other) cil managed" />
      <MemberSignature Language="DocId" Value="M:LotusIR.NodeProto.#ctor(LotusIR.NodeProto)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (other As NodeProto)" />
      <MemberSignature Language="F#" Value="new LotusIR.NodeProto : LotusIR.NodeProto -&gt; LotusIR.NodeProto" Usage="new LotusIR.NodeProto other" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NodeProto(LotusIR::NodeProto ^ other);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="other" Type="LotusIR.NodeProto" />
      </Parameters>
      <Docs>
        <param name="other">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Attribute">
      <MemberSignature Language="C#" Value="public Google.Protobuf.Collections.RepeatedField&lt;LotusIR.AttributeProto&gt; Attribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Google.Protobuf.Collections.RepeatedField`1&lt;class LotusIR.AttributeProto&gt; Attribute" />
      <MemberSignature Language="DocId" Value="P:LotusIR.NodeProto.Attribute" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attribute As RepeatedField(Of AttributeProto)" />
      <MemberSignature Language="F#" Value="member this.Attribute : Google.Protobuf.Collections.RepeatedField&lt;LotusIR.AttributeProto&gt;" Usage="LotusIR.NodeProto.Attribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Google::Protobuf::Collections::RepeatedField&lt;LotusIR::AttributeProto ^&gt; ^ Attribute { Google::Protobuf::Collections::RepeatedField&lt;LotusIR::AttributeProto ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Google.Protobuf.Collections.RepeatedField&lt;LotusIR.AttributeProto&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Additional named attributes.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AttributeFieldNumber">
      <MemberSignature Language="C#" Value="public const int AttributeFieldNumber = 5;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 AttributeFieldNumber = (5)" />
      <MemberSignature Language="DocId" Value="F:LotusIR.NodeProto.AttributeFieldNumber" />
      <MemberSignature Language="VB.NET" Value="Public Const AttributeFieldNumber As Integer  = 5" />
      <MemberSignature Language="F#" Value="val mutable AttributeFieldNumber : int" Usage="LotusIR.NodeProto.AttributeFieldNumber" />
      <MemberSignature Language="C++ CLI" Value="public: int AttributeFieldNumber = 5;" />
      <MemberSignature Language="C++ WINRT" Value="int AttributeFieldNumber = 5;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>5</MemberValue>
      <Docs>
        <summary>Field number for the "attribute" field.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CalculateSize">
      <MemberSignature Language="C#" Value="public int CalculateSize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CalculateSize() cil managed" />
      <MemberSignature Language="DocId" Value="M:LotusIR.NodeProto.CalculateSize" />
      <MemberSignature Language="VB.NET" Value="Public Function CalculateSize () As Integer" />
      <MemberSignature Language="F#" Value="abstract member CalculateSize : unit -&gt; int&#xA;override this.CalculateSize : unit -&gt; int" Usage="nodeProto.CalculateSize " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CalculateSize();" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; int CalculateSize();" />
      <MemberSignature Language="C++ WINRT" Value="int CalculateSize();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Google.Protobuf.IMessage.CalculateSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public LotusIR.NodeProto Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class LotusIR.NodeProto Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:LotusIR.NodeProto.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As NodeProto" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; LotusIR.NodeProto&#xA;override this.Clone : unit -&gt; LotusIR.NodeProto" Usage="nodeProto.Clone " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual LotusIR::NodeProto ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Google.Protobuf.IDeepCloneable`1.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>LotusIR.NodeProto</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ControlInput">
      <MemberSignature Language="C#" Value="public Google.Protobuf.Collections.RepeatedField&lt;string&gt; ControlInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Google.Protobuf.Collections.RepeatedField`1&lt;string&gt; ControlInput" />
      <MemberSignature Language="DocId" Value="P:LotusIR.NodeProto.ControlInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ControlInput As RepeatedField(Of String)" />
      <MemberSignature Language="F#" Value="member this.ControlInput : Google.Protobuf.Collections.RepeatedField&lt;string&gt;" Usage="LotusIR.NodeProto.ControlInput" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Google::Protobuf::Collections::RepeatedField&lt;System::String ^&gt; ^ ControlInput { Google::Protobuf::Collections::RepeatedField&lt;System::String ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Google.Protobuf.Collections.RepeatedField&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Specify a list of named nodes that must be executed before this node.
            Framework may use this to give users the ability to impose additional
            execution orders for the operations.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ControlInputFieldNumber">
      <MemberSignature Language="C#" Value="public const int ControlInputFieldNumber = 51;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 ControlInputFieldNumber = (51)" />
      <MemberSignature Language="DocId" Value="F:LotusIR.NodeProto.ControlInputFieldNumber" />
      <MemberSignature Language="VB.NET" Value="Public Const ControlInputFieldNumber As Integer  = 51" />
      <MemberSignature Language="F#" Value="val mutable ControlInputFieldNumber : int" Usage="LotusIR.NodeProto.ControlInputFieldNumber" />
      <MemberSignature Language="C++ CLI" Value="public: int ControlInputFieldNumber = 51;" />
      <MemberSignature Language="C++ WINRT" Value="int ControlInputFieldNumber = 51;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>51</MemberValue>
      <Docs>
        <summary>Field number for the "control_input" field.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Descriptor">
      <MemberSignature Language="C#" Value="public static Google.Protobuf.Reflection.MessageDescriptor Descriptor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Google.Protobuf.Reflection.MessageDescriptor Descriptor" />
      <MemberSignature Language="DocId" Value="P:LotusIR.NodeProto.Descriptor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Descriptor As MessageDescriptor" />
      <MemberSignature Language="F#" Value="member this.Descriptor : Google.Protobuf.Reflection.MessageDescriptor" Usage="LotusIR.NodeProto.Descriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Google::Protobuf::Reflection::MessageDescriptor ^ Descriptor { Google::Protobuf::Reflection::MessageDescriptor ^ get(); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; static property Google::Protobuf::Reflection::MessageDescriptor ^ Descriptor { Google::Protobuf::Reflection::MessageDescriptor ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Google.Protobuf.IMessage.Descriptor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Google.Protobuf.Reflection.MessageDescriptor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DocString">
      <MemberSignature Language="C#" Value="public string DocString { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DocString" />
      <MemberSignature Language="DocId" Value="P:LotusIR.NodeProto.DocString" />
      <MemberSignature Language="VB.NET" Value="Public Property DocString As String" />
      <MemberSignature Language="F#" Value="member this.DocString : string with get, set" Usage="LotusIR.NodeProto.DocString" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DocString { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; property Platform::String ^ DocString { Platform::String ^ get(); void set(Platform::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            An  human-readable documentation for this node in the graph.
            This text MAY contain Markdown markup that conforms to http://commonmark.org/. 
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DocStringFieldNumber">
      <MemberSignature Language="C#" Value="public const int DocStringFieldNumber = 6;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 DocStringFieldNumber = (6)" />
      <MemberSignature Language="DocId" Value="F:LotusIR.NodeProto.DocStringFieldNumber" />
      <MemberSignature Language="VB.NET" Value="Public Const DocStringFieldNumber As Integer  = 6" />
      <MemberSignature Language="F#" Value="val mutable DocStringFieldNumber : int" Usage="LotusIR.NodeProto.DocStringFieldNumber" />
      <MemberSignature Language="C++ CLI" Value="public: int DocStringFieldNumber = 6;" />
      <MemberSignature Language="C++ WINRT" Value="int DocStringFieldNumber = 6;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>6</MemberValue>
      <Docs>
        <summary>Field number for the "doc_string" field.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (LotusIR.NodeProto other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class LotusIR.NodeProto other) cil managed" />
      <MemberSignature Language="DocId" Value="M:LotusIR.NodeProto.Equals(LotusIR.NodeProto)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As NodeProto) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : LotusIR.NodeProto -&gt; bool" Usage="nodeProto.Equals other" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(LotusIR::NodeProto ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="LotusIR.NodeProto" />
      </Parameters>
      <Docs>
        <param name="other">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object other) cil managed" />
      <MemberSignature Language="DocId" Value="M:LotusIR.NodeProto.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (other As Object) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="nodeProto.Equals other" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ other);" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; override bool Equals(Platform::Object ^ other);" />
      <MemberSignature Language="C++ WINRT" Value=" override bool Equals(winrt::Windows::Foundation::IInspectable const &amp; other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="other">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:LotusIR.NodeProto.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="nodeProto.GetHashCode " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="C++ WINRT" Value=" override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Google.Protobuf.IMessage.Descriptor">
      <MemberSignature Language="C#" Value="Google.Protobuf.Reflection.MessageDescriptor Google.Protobuf.IMessage.Descriptor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Google.Protobuf.Reflection.MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor" />
      <MemberSignature Language="DocId" Value="P:LotusIR.NodeProto.pb::Google#Protobuf#IMessage#Descriptor" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Descriptor As MessageDescriptor Implements IMessage.Descriptor" />
      <MemberSignature Language="F#" Usage="LotusIR.NodeProto.pb::Google.Protobuf.IMessage.Descriptor" />
      <MemberSignature Language="C++ CLI" Value="property Google::Protobuf::Reflection::MessageDescriptor ^ Google.Protobuf.IMessage.Descriptor { Google::Protobuf::Reflection::MessageDescriptor ^ get(); };" />
      <MemberSignature Language="C++ CX" Value="property Google::Protobuf::Reflection::MessageDescriptor ^ Google.Protobuf.IMessage.Descriptor { Google::Protobuf::Reflection::MessageDescriptor ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Google.Protobuf.IMessage.Descriptor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Google.Protobuf.Reflection.MessageDescriptor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public Google.Protobuf.Collections.RepeatedField&lt;string&gt; Input { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Google.Protobuf.Collections.RepeatedField`1&lt;string&gt; Input" />
      <MemberSignature Language="DocId" Value="P:LotusIR.NodeProto.Input" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Input As RepeatedField(Of String)" />
      <MemberSignature Language="F#" Value="member this.Input : Google.Protobuf.Collections.RepeatedField&lt;string&gt;" Usage="LotusIR.NodeProto.Input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Google::Protobuf::Collections::RepeatedField&lt;System::String ^&gt; ^ Input { Google::Protobuf::Collections::RepeatedField&lt;System::String ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Google.Protobuf.Collections.RepeatedField&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The named inputs of the node.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InputArgCount">
      <MemberSignature Language="C#" Value="public Google.Protobuf.Collections.RepeatedField&lt;int&gt; InputArgCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Google.Protobuf.Collections.RepeatedField`1&lt;int32&gt; InputArgCount" />
      <MemberSignature Language="DocId" Value="P:LotusIR.NodeProto.InputArgCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputArgCount As RepeatedField(Of Integer)" />
      <MemberSignature Language="F#" Value="member this.InputArgCount : Google.Protobuf.Collections.RepeatedField&lt;int&gt;" Usage="LotusIR.NodeProto.InputArgCount" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Google::Protobuf::Collections::RepeatedField&lt;int&gt; ^ InputArgCount { Google::Protobuf::Collections::RepeatedField&lt;int&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Google.Protobuf.Collections.RepeatedField&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             The number of inputs for each argument of the operator/function.
             A formal parameter of the op may take a variable number of inputs
             that is only known when this node is constructed.
            BUG:13806939,dbox: I'm assuming that this field is like input_arg_info in that
                      a zero element/missing array implies that one needs to crawl
                      the graph to figure out the input counts, yes? Confirm and I'll
                      make clear.  Otherwise, we need to require it to be present
                      and accurate.
             </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InputArgCountFieldNumber">
      <MemberSignature Language="C#" Value="public const int InputArgCountFieldNumber = 50;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 InputArgCountFieldNumber = (50)" />
      <MemberSignature Language="DocId" Value="F:LotusIR.NodeProto.InputArgCountFieldNumber" />
      <MemberSignature Language="VB.NET" Value="Public Const InputArgCountFieldNumber As Integer  = 50" />
      <MemberSignature Language="F#" Value="val mutable InputArgCountFieldNumber : int" Usage="LotusIR.NodeProto.InputArgCountFieldNumber" />
      <MemberSignature Language="C++ CLI" Value="public: int InputArgCountFieldNumber = 50;" />
      <MemberSignature Language="C++ WINRT" Value="int InputArgCountFieldNumber = 50;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>50</MemberValue>
      <Docs>
        <summary>Field number for the "input_arg_count" field.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InputFieldNumber">
      <MemberSignature Language="C#" Value="public const int InputFieldNumber = 1;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 InputFieldNumber = (1)" />
      <MemberSignature Language="DocId" Value="F:LotusIR.NodeProto.InputFieldNumber" />
      <MemberSignature Language="VB.NET" Value="Public Const InputFieldNumber As Integer  = 1" />
      <MemberSignature Language="F#" Value="val mutable InputFieldNumber : int" Usage="LotusIR.NodeProto.InputFieldNumber" />
      <MemberSignature Language="C++ CLI" Value="public: int InputFieldNumber = 1;" />
      <MemberSignature Language="C++ WINRT" Value="int InputFieldNumber = 1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary>Field number for the "input" field.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeFrom">
      <MemberSignature Language="C#" Value="public void MergeFrom (Google.Protobuf.CodedInputStream input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MergeFrom(class Google.Protobuf.CodedInputStream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:LotusIR.NodeProto.MergeFrom(Google.Protobuf.CodedInputStream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MergeFrom (input As CodedInputStream)" />
      <MemberSignature Language="F#" Value="abstract member MergeFrom : Google.Protobuf.CodedInputStream -&gt; unit&#xA;override this.MergeFrom : Google.Protobuf.CodedInputStream -&gt; unit" Usage="nodeProto.MergeFrom input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MergeFrom(Google::Protobuf::CodedInputStream ^ input);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Google.Protobuf.IMessage.MergeFrom(Google.Protobuf.CodedInputStream)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="Google.Protobuf.CodedInputStream" />
      </Parameters>
      <Docs>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeFrom">
      <MemberSignature Language="C#" Value="public void MergeFrom (LotusIR.NodeProto other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MergeFrom(class LotusIR.NodeProto other) cil managed" />
      <MemberSignature Language="DocId" Value="M:LotusIR.NodeProto.MergeFrom(LotusIR.NodeProto)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MergeFrom (other As NodeProto)" />
      <MemberSignature Language="F#" Value="abstract member MergeFrom : LotusIR.NodeProto -&gt; unit&#xA;override this.MergeFrom : LotusIR.NodeProto -&gt; unit" Usage="nodeProto.MergeFrom other" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MergeFrom(LotusIR::NodeProto ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Google.Protobuf.IMessage`1.MergeFrom(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="LotusIR.NodeProto" />
      </Parameters>
      <Docs>
        <param name="other">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:LotusIR.NodeProto.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="LotusIR.NodeProto.Name" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; property Platform::String ^ Name { Platform::String ^ get(); void set(Platform::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The name of this node.
            This field is  and used to uniquely identify nodes in the graph.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NameFieldNumber">
      <MemberSignature Language="C#" Value="public const int NameFieldNumber = 3;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 NameFieldNumber = (3)" />
      <MemberSignature Language="DocId" Value="F:LotusIR.NodeProto.NameFieldNumber" />
      <MemberSignature Language="VB.NET" Value="Public Const NameFieldNumber As Integer  = 3" />
      <MemberSignature Language="F#" Value="val mutable NameFieldNumber : int" Usage="LotusIR.NodeProto.NameFieldNumber" />
      <MemberSignature Language="C++ CLI" Value="public: int NameFieldNumber = 3;" />
      <MemberSignature Language="C++ WINRT" Value="int NameFieldNumber = 3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>3</MemberValue>
      <Docs>
        <summary>Field number for the "name" field.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OpType">
      <MemberSignature Language="C#" Value="public string OpType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OpType" />
      <MemberSignature Language="DocId" Value="P:LotusIR.NodeProto.OpType" />
      <MemberSignature Language="VB.NET" Value="Public Property OpType As String" />
      <MemberSignature Language="F#" Value="member this.OpType : string with get, set" Usage="LotusIR.NodeProto.OpType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OpType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; property Platform::String ^ OpType { Platform::String ^ get(); void set(Platform::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The name of the operator/function called by the node.
            This field MUST be present for this version of the IR.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OpTypeFieldNumber">
      <MemberSignature Language="C#" Value="public const int OpTypeFieldNumber = 4;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 OpTypeFieldNumber = (4)" />
      <MemberSignature Language="DocId" Value="F:LotusIR.NodeProto.OpTypeFieldNumber" />
      <MemberSignature Language="VB.NET" Value="Public Const OpTypeFieldNumber As Integer  = 4" />
      <MemberSignature Language="F#" Value="val mutable OpTypeFieldNumber : int" Usage="LotusIR.NodeProto.OpTypeFieldNumber" />
      <MemberSignature Language="C++ CLI" Value="public: int OpTypeFieldNumber = 4;" />
      <MemberSignature Language="C++ WINRT" Value="int OpTypeFieldNumber = 4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>4</MemberValue>
      <Docs>
        <summary>Field number for the "op_type" field.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Output">
      <MemberSignature Language="C#" Value="public Google.Protobuf.Collections.RepeatedField&lt;string&gt; Output { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Google.Protobuf.Collections.RepeatedField`1&lt;string&gt; Output" />
      <MemberSignature Language="DocId" Value="P:LotusIR.NodeProto.Output" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Output As RepeatedField(Of String)" />
      <MemberSignature Language="F#" Value="member this.Output : Google.Protobuf.Collections.RepeatedField&lt;string&gt;" Usage="LotusIR.NodeProto.Output" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Google::Protobuf::Collections::RepeatedField&lt;System::String ^&gt; ^ Output { Google::Protobuf::Collections::RepeatedField&lt;System::String ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Google.Protobuf.Collections.RepeatedField&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The named outputs of the node.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputFieldNumber">
      <MemberSignature Language="C#" Value="public const int OutputFieldNumber = 2;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 OutputFieldNumber = (2)" />
      <MemberSignature Language="DocId" Value="F:LotusIR.NodeProto.OutputFieldNumber" />
      <MemberSignature Language="VB.NET" Value="Public Const OutputFieldNumber As Integer  = 2" />
      <MemberSignature Language="F#" Value="val mutable OutputFieldNumber : int" Usage="LotusIR.NodeProto.OutputFieldNumber" />
      <MemberSignature Language="C++ CLI" Value="public: int OutputFieldNumber = 2;" />
      <MemberSignature Language="C++ WINRT" Value="int OutputFieldNumber = 2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Field number for the "output" field.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parser">
      <MemberSignature Language="C#" Value="public static Google.Protobuf.MessageParser&lt;LotusIR.NodeProto&gt; Parser { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Google.Protobuf.MessageParser`1&lt;class LotusIR.NodeProto&gt; Parser" />
      <MemberSignature Language="DocId" Value="P:LotusIR.NodeProto.Parser" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Parser As MessageParser(Of NodeProto)" />
      <MemberSignature Language="F#" Value="member this.Parser : Google.Protobuf.MessageParser&lt;LotusIR.NodeProto&gt;" Usage="LotusIR.NodeProto.Parser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Google::Protobuf::MessageParser&lt;LotusIR::NodeProto ^&gt; ^ Parser { Google::Protobuf::MessageParser&lt;LotusIR::NodeProto ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Google.Protobuf.MessageParser&lt;LotusIR.NodeProto&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:LotusIR.NodeProto.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="nodeProto.ToString " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; override Platform::String ^ ToString();" />
      <MemberSignature Language="C++ WINRT" Value=" override std::wstring ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public void WriteTo (Google.Protobuf.CodedOutputStream output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteTo(class Google.Protobuf.CodedOutputStream output) cil managed" />
      <MemberSignature Language="DocId" Value="M:LotusIR.NodeProto.WriteTo(Google.Protobuf.CodedOutputStream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteTo (output As CodedOutputStream)" />
      <MemberSignature Language="F#" Value="abstract member WriteTo : Google.Protobuf.CodedOutputStream -&gt; unit&#xA;override this.WriteTo : Google.Protobuf.CodedOutputStream -&gt; unit" Usage="nodeProto.WriteTo output" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteTo(Google::Protobuf::CodedOutputStream ^ output);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Google.Protobuf.IMessage.WriteTo(Google.Protobuf.CodedOutputStream)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.ML.UniversalModelFormat</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="output" Type="Google.Protobuf.CodedOutputStream" />
      </Parameters>
      <Docs>
        <param name="output">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>